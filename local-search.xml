<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>02-运行Docker容器</title>
    <link href="/2025/03/03/09_%E9%9F%A9%E5%85%88%E8%B6%85K8S/01-Docker%E5%9F%BA%E7%A1%80/02-%E8%BF%90%E8%A1%8CDocker%E5%AE%B9%E5%99%A8/"/>
    <url>/2025/03/03/09_%E9%9F%A9%E5%85%88%E8%B6%85K8S/01-Docker%E5%9F%BA%E7%A1%80/02-%E8%BF%90%E8%A1%8CDocker%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Docker容器操作"><a href="#一、Docker容器操作" class="headerlink" title="一、Docker容器操作"></a>一、Docker容器操作</h1><h2 id="1-1-交互式容器"><a href="#1-1-交互式容器" class="headerlink" title="1.1 交互式容器"></a>1.1 交互式容器</h2><p>1、创建交互式Docker容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 以交互式方式运行容器，并进入容器docker run  --name&#x3D;hello -it centos &#x2F;bin&#x2F;bash</code></pre></div></figure><p><img src="/./../../../img/image-20250303151500931.png" alt="image-20250303151500931"></p><p>2、查看正在运行的容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker ps</code></pre></div></figure><p><img src="/./../../../img/image-20250303151630396.png" alt="image-20250303151630396"></p><p>3、以守护进程方式运行容器</p><blockquote><p>在1.1中创建的hello容器比较脆弱，只要exit退出，容器也会停止，需要设置守护进程让容器一直运行。</p></blockquote><p>以后台守护进程方式运行容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --name&#x3D;hello -td centos &#x2F;bin&#x2F;bash</code></pre></div></figure><p>交互式进入容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it hello &#x2F;bin&#x2F;bash</code></pre></div></figure><h2 id="1-2-查找容器"><a href="#1-2-查找容器" class="headerlink" title="1.2 查找容器"></a>1.2 查找容器</h2><p>查看容器（包括已经停止删除的容器）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker ps -a</code></pre></div></figure><h2 id="1-3-停止-启动容器"><a href="#1-3-停止-启动容器" class="headerlink" title="1.3 停止&#x2F;启动容器"></a>1.3 停止&#x2F;启动容器</h2><p>1、停止容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker stop 【容器名 或者 容器ID】# 实践docker stop hello# 或者docker stop 926b</code></pre></div></figure><p>2、启动容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker stop 【容器名 或者 容器ID】# 实践docker start hello# 或者docker start 926b</code></pre></div></figure><h2 id="1-4-删除容器"><a href="#1-4-删除容器" class="headerlink" title="1.4 删除容器"></a>1.4 删除容器</h2><p>删除hello(926b)容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 正常删除docker rm 926b# 强制删除docker rm 926b --force</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>超哥K8S</category>
      
      <category>（一）Docker容器基础入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Docker基础</title>
    <link href="/2025/03/03/09_%E9%9F%A9%E5%85%88%E8%B6%85K8S/01-Docker%E5%9F%BA%E7%A1%80/01-Dokcer%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2025/03/03/09_%E9%9F%A9%E5%85%88%E8%B6%85K8S/01-Docker%E5%9F%BA%E7%A1%80/01-Dokcer%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Docker介绍"><a href="#一、Docker介绍" class="headerlink" title="一、Docker介绍"></a>一、Docker介绍</h1><h2 id="1-1-Docker现状"><a href="#1-1-Docker现状" class="headerlink" title="1.1 Docker现状"></a>1.1 Docker现状</h2><p>​K8S已废弃docker，改用containerd（更轻量级的容器运行时），还有一个Podman。</p><p>​但必须学习docker，学完之后使用containerd可以很快上手。</p><h2 id="1-2-Docker的优缺点"><a href="#1-2-Docker的优缺点" class="headerlink" title="1.2 Docker的优缺点"></a>1.2 Docker的优缺点</h2><p>优点：</p><ul><li><p>快：性能快、管理操作快</p></li><li><p>敏捷：像虚拟机一样敏捷，但更便宜</p></li><li><p>灵活：将应用和系统容器化，不需要额外的操作性系统</p></li><li><p>轻量：一台服务器上可以部署100~1000个Container容器</p></li><li><p>便宜：开源、免费</p><ul><li>docker-ce：社区版</li><li>docker-ee：商业版</li></ul></li></ul><p>缺点：</p><ul><li><p>所有容器共用linux内核资源，资源能否实现最大限度的利用，因此安全上存在漏洞。</p></li><li><p>物理机内核出问题，所有容器都会受影响。</p></li></ul><h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><h2 id="2-1-虚拟机初始化"><a href="#2-1-虚拟机初始化" class="headerlink" title="2.1 虚拟机初始化"></a>2.1 虚拟机初始化</h2><p>1、虚拟机配置：</p><table><thead><tr><th>名称</th><th>配置</th><th>IP</th><th>操作系统</th></tr></thead><tbody><tr><td>Master1</td><td>2核2G、硬盘100G、NAT网络</td><td>192.168.40.180</td><td>CentOS 7.7</td></tr></tbody></table><p>2、服务器系统初始化操作</p><ul><li>设置主机名</li><li>关闭firewalld</li><li>关闭iptables</li><li>关闭selinux</li></ul><p>3、开启时间同步服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install ntp ntpdate -yntpdate cn.pool.ntp.org# 写到计划任务中，每一小时同步一次crontab -e*&#x2F;1 * * * * &#x2F;sbin&#x2F;ntpdate cn.pool.ntp.org &amp;&gt;&#x2F;dev&#x2F;nullsystemctl restart crond</code></pre></div></figure><p>4、安装常用软件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y wget net-tools nfs-utils lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel vim ncurses-devel autoconf automake zlib-devel python-devel epel-release openssh-server socat ipvsadm conntrack yum-utils</code></pre></div></figure><h2 id="2-2-安装Docker"><a href="#2-2-安装Docker" class="headerlink" title="2.2 安装Docker"></a>2.2 安装Docker</h2><blockquote><p>安装Docker-ce版本</p></blockquote><p>1、配置docker-ce国内的yum源（阿里云）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum-config-manager --add-repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</code></pre></div></figure><p>2、安装docker依赖包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y device-mapper-persistent-data lvm2</code></pre></div></figure><p>3、安装docker-ce</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install docker-ce -y</code></pre></div></figure><p>4、启动docker服务器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start docker &amp;&amp; systemctl enable docker</code></pre></div></figure><p>5、查看docker版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker verison[root@master1 ~]#docker versionClient: Version:           18.09.9 API version:       1.39 Go version:        go1.11.13...</code></pre></div></figure><h2 id="2-3-开启包转发功能"><a href="#2-3-开启包转发功能" class="headerlink" title="2.3 开启包转发功能"></a>2.3 开启包转发功能</h2><p>1、br_netfilter模块用于将桥接流量转发至iptables链，需要开启转发。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 开启模块modprobe br_netfilter# 验证是否已加载[root@master1 &#x2F;etc&#x2F;sysctl.d]#lsmod | grep br_netfilterbr_netfilter           22256  0 bridge                151336  1 br_netfilter</code></pre></div></figure><p>2、创建配置文件，修改内核参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建配置文件cat &gt; &#x2F;etc&#x2F;sysctl.d&#x2F;docker.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables &#x3D; 1net.bridge.bridge-nf-call-iptables &#x3D; 1net.ipv4.ip_forward &#x3D; 1EOF# 执行命令，使内核参数生效sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;docker.conf</code></pre></div></figure><p>3、自动加载模块</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 编辑配置文件[root@master1 ~]#cat &#x2F;etc&#x2F;rc.sysint #!&#x2F;bin&#x2F;bashfor file in &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;*.modules; do[ -x $file ] &amp;&amp; $filedone# 添加模块自动加载的文件[root@master1 ~]#cat &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;br_netfilter.modulesmodprobe br_netfilter# 添加可执行权限chmod 755 &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;br_netfilter.modules</code></pre></div></figure><p>重启docker生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctlrestart docker</code></pre></div></figure><h2 id="2-4-配置镜像加速"><a href="#2-4-配置镜像加速" class="headerlink" title="2.4 配置镜像加速"></a>2.4 配置镜像加速</h2><p>在OS中通过配置文件配置镜像加速</p><blockquote><p>镜像加速器多写几个，不然容易超时拉取失败</p><p>Error response from daemon: Get “<a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,    &quot;https:&#x2F;&#x2F;docker.imgdb.de&quot;,    &quot;https:&#x2F;&#x2F;docker-0.unsee.tech&quot;,    &quot;https:&#x2F;&#x2F;docker.hlmirror.com&quot;,    &quot;https:&#x2F;&#x2F;docker.1ms.run&quot;,    &quot;https:&#x2F;&#x2F;func.ink&quot;,    &quot;https:&#x2F;&#x2F;lispy.org&quot;,    &quot;https:&#x2F;&#x2F;docker.xiaogenban1993.com&quot;  ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div></figure><h1 id="三、docker镜像操作"><a href="#三、docker镜像操作" class="headerlink" title="三、docker镜像操作"></a>三、docker镜像操作</h1><p>1、搜索镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 搜索centos镜像docker search centos</code></pre></div></figure><p>2、下载镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 默认拉取latest版本（最新的镜像）docker pull centos</code></pre></div></figure><p>3、查看下载的镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@master1 &#x2F;etc&#x2F;docker]#docker imagesREPOSITORY                                                        TAG                 IMAGE ID            CREATED             SIZEcentos                                                            latest              5d0da3dc9764        3 years ago         231MB</code></pre></div></figure><p>4、镜像打包成离线包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker save -o centos-20250303.tar.gz centos# 实践[root@master1 &#x2F;tmp]#docker save -o centos-20250303.tar.gz centos[root@master1 &#x2F;tmp]#ls | grep centoscentos-20250303.tar.gz</code></pre></div></figure><p>5、导入离线包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker load -i centos-20250303.tar.gz</code></pre></div></figure><p>6、删除镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker rmi 5d0d --force</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>超哥K8S</category>
      
      <category>（一）Docker容器基础入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu22.04显卡直通虚拟机</title>
    <link href="/2025/02/25/06_%E6%9D%82%E8%AE%B0/Ubuntu22.04%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A/"/>
    <url>/2025/02/25/06_%E6%9D%82%E8%AE%B0/Ubuntu22.04%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="一、实现的效果"><a href="#一、实现的效果" class="headerlink" title="一、实现的效果"></a>一、实现的效果</h1><p>​服务器共8张卡，6张留给物理机用，2张直通给虚拟机用</p><h1 id="二、部署步骤"><a href="#二、部署步骤" class="headerlink" title="二、部署步骤"></a>二、部署步骤</h1><p>1、服务器在BIOS开启虚拟化，并确认OS支持vfio模块</p><blockquote><p>Ubuntu22.04 5.15.0-131-generic内核的vfio模块内建在内核中，lsmod是找不到的</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:~# cat &#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;modules.builtin | grep vfiokernel&#x2F;drivers&#x2F;vfio&#x2F;vfio.kokernel&#x2F;drivers&#x2F;vfio&#x2F;vfio_virqfd.kokernel&#x2F;drivers&#x2F;vfio&#x2F;vfio_iommu_type1.kokernel&#x2F;drivers&#x2F;vfio&#x2F;pci&#x2F;vfio-pci-core.kokernel&#x2F;drivers&#x2F;vfio&#x2F;pci&#x2F;vfio-pci.ko# lsmod 找不到，害我苦苦排查了好久(base) root@k8s-master1:~# lsmod | grep vfio(base) root@k8s-master1:~# </code></pre></div></figure><p>2、服务器修改grub文件，开启iommu</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 编辑&#x2F;etc&#x2F;default&#x2F;grub文件...GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;quiet splash intel_iommu&#x3D;on&quot;# 修改这一条...</code></pre></div></figure><p>使grub生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:~# update-grubSourcing file &#96;&#x2F;etc&#x2F;default&#x2F;grub&#39;Sourcing file &#96;&#x2F;etc&#x2F;default&#x2F;grub.d&#x2F;init-select.cfg&#39;Generating grub configuration file ...Found linux image: &#x2F;boot&#x2F;vmlinuz-5.15.0-131-genericFound initrd image: &#x2F;boot&#x2F;initrd.img-5.15.0-131-genericFound linux image: &#x2F;boot&#x2F;vmlinuz-5.15.0-130-genericFound initrd image: &#x2F;boot&#x2F;initrd.img-5.15.0-130-genericWarning: os-prober will not be executed to detect other bootable partitions.Systems on them will not be added to the GRUB boot configuration.Check GRUB_DISABLE_OS_PROBER documentation entry.done</code></pre></div></figure><p>然后重启服务器，重启之后可以用命令检查ioomu是否开启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:~# dmesg | grep -i &quot;iommu en&quot; -A 3[    2.640510] DMAR: IOMMU enabled</code></pre></div></figure><p>3、配置模块加载顺序，让nvidia驱动在vfio之后加载</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:~# cat &#x2F;etc&#x2F;modprobe.d&#x2F;nvidia.conf softdep snd_hda_intel pre: vfio-pcisoftdep nouveau pre: vfio-pcisoftdep nvidia pre: vfio-pcisoftdep nvidia* pre: vfio-pci</code></pre></div></figure><p>4、确定需要直通的两张显卡ID</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:&#x2F;nvme&#x2F;system_images# lspci -nnk | grep -i nvidia -A 3...... # 最后两张显卡的IDb1:00.0 VGA compatible controller [0300]: NVIDIA Corporation Device [10de:2684] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: nvidiaKernel modules: nvidiafb, nouveau, nvidia_drm, nvidiab1:00.1 Audio device [0403]: NVIDIA Corporation Device [10de:22ba] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: snd_hda_intelKernel modules: snd_hda_intelb2:00.0 VGA compatible controller [0300]: NVIDIA Corporation Device [10de:2684] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: nvidiaKernel modules: nvidiafb, nouveau, nvidia_drm, nvidiab2:00.1 Audio device [0403]: NVIDIA Corporation Device [10de:22ba] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: snd_hda_intelKernel modules: snd_hda_intel</code></pre></div></figure><p>其中的<code>b1:00.0</code>和<code>b1:00.1</code>这种就是其中一张显卡和它对应声卡的ID</p><p>5、配置直通</p><p>编辑配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;initramfs-tools&#x2F;scripts&#x2F;init-top&#x2F;vfio.sh</code></pre></div></figure><p>内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shecho &quot;vfio-pci&quot; &gt; &#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices&#x2F;0000:b1:00.0&#x2F;driver_overrideecho &quot;vfio-pci&quot; &gt; &#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices&#x2F;0000:b1:00.1&#x2F;driver_overrideecho &quot;vfio-pci&quot; &gt; &#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices&#x2F;0000:b2:00.0&#x2F;driver_overrideecho &quot;vfio-pci&quot; &gt; &#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices&#x2F;0000:b2:00.1&#x2F;driver_overrideexit 0</code></pre></div></figure><p>使文件生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先执行脚本bash &#x2F;etc&#x2F;initramfs-tools&#x2F;scripts&#x2F;init-top&#x2F;vfio.sh# 再执行命令update-initramfs -u</code></pre></div></figure><p>查看内容确认修改成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:~# cat &#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices&#x2F;0000:b2:00.1&#x2F;driver_overridevfio-pci</code></pre></div></figure><p>重启生效，可见到配置过的两张卡在nvidia-smi中已经看不到了</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:~# nvidia-smi Tue Feb 25 17:32:37 2025       +-----------------------------------------------------------------------------------------+| NVIDIA-SMI 550.54.14              Driver Version: 550.54.14      CUDA Version: 12.4     ||-----------------------------------------+------------------------+----------------------+| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage&#x2F;Cap |           Memory-Usage | GPU-Util  Compute M. ||                                         |                        |               MIG M. ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||   0  NVIDIA GeForce RTX 4090        Off |   00000000:17:00.0 Off |                  Off ||  0%   24C    P8             11W &#x2F;  450W |   20876MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+|   1  NVIDIA GeForce RTX 4090        Off |   00000000:18:00.0 Off |                  Off ||  0%   22C    P8              9W &#x2F;  450W |       4MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+|   2  NVIDIA GeForce RTX 4090        Off |   00000000:31:00.0 Off |                  Off ||  0%   23C    P8             11W &#x2F;  450W |    2991MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+|   3  NVIDIA GeForce RTX 4090        Off |   00000000:32:00.0 Off |                  Off ||  0%   34C    P2             56W &#x2F;  450W |    1155MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+|   4  NVIDIA GeForce RTX 4090        Off |   00000000:98:00.0 Off |                  Off ||  0%   23C    P8              9W &#x2F;  450W |       4MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+|   5  NVIDIA GeForce RTX 4090        Off |   00000000:99:00.0 Off |                  Off ||  0%   24C    P8             11W &#x2F;  450W |       4MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+....</code></pre></div></figure><p>5、重新绑定驱动</p><blockquote><p>原来被nvidia驱动的两张显卡，绑定到vfio-pci后，并不会被直接接管，成为无驱动状态，需要手动重新绑定驱动。</p></blockquote><p>绑定：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">driverctl set-override 0000:b1:00.0 vfio-pcidriverctl set-override 0000:b1:00.1 vfio-pcidriverctl set-override 0000:b2:00.0 vfio-pcidriverctl set-override 0000:b2:00.1 vfio-pci</code></pre></div></figure><p>解绑</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">driverctl unset-override 0000:b1:00.0 vfio-pcidriverctl unset-override 0000:b1:00.1 vfio-pcidriverctl unset-override 0000:b2:00.0 vfio-pcidriverctl unset-override 0000:b2:00.1 vfio-pci</code></pre></div></figure><p>6、重新绑定后，可以查到这四个ID设备已经被<code>vfio-pci</code>接管</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) root@k8s-master1:~# lspci -nnk | grep -i nvidia -A 3...b1:00.0 VGA compatible controller [0300]: NVIDIA Corporation Device [10de:2684] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: vfio-pciKernel modules: nvidiafb, nouveau, nvidia_drm, nvidiab1:00.1 Audio device [0403]: NVIDIA Corporation Device [10de:22ba] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: vfio-pciKernel modules: snd_hda_intelb2:00.0 VGA compatible controller [0300]: NVIDIA Corporation Device [10de:2684] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: vfio-pciKernel modules: nvidiafb, nouveau, nvidia_drm, nvidiab2:00.1 Audio device [0403]: NVIDIA Corporation Device [10de:22ba] (rev a1)Subsystem: NVIDIA Corporation Device [10de:16f3]Kernel driver in use: vfio-pciKernel modules: snd_hda_intelc9:00.0 System peripheral [0880]: Intel Corporation Device [8086:09a2] (rev 04)</code></pre></div></figure><p>7、虚拟机中配置直通显卡</p><p>创建虚拟机时，勾选<code>Customize configuration before install</code></p><p><img src="/../../img/image-20250225174200403.png" alt="image-20250225174200403"></p><p>把这四张英伟达设备添加进去</p><p><img src="/./../../img/image-20250225175256936.png" alt="image-20250225175256936"></p><p>在虚拟机查看显卡设备是否正常加载</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@seuvm01:~&#x2F;getinfo# lspci ....05:00.0 VGA compatible controller: NVIDIA Corporation AD102 [GeForce RTX 4090] (rev a1)06:00.0 Audio device: NVIDIA Corporation AD102 High Definition Audio Controller (rev a1)07:00.0 VGA compatible controller: NVIDIA Corporation AD102 [GeForce RTX 4090] (rev a1)08:00.0 Audio device: NVIDIA Corporation AD102 High Definition Audio Controller (rev a1)....</code></pre></div></figure><p>正常安装Nvidia显卡驱动即可使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@seuvm01:~&#x2F;getinfo# nvidia-smiThu Feb 27 16:45:47 2025       +-----------------------------------------------------------------------------------------+| NVIDIA-SMI 550.54.14              Driver Version: 550.54.14      CUDA Version: 12.4     ||-----------------------------------------+------------------------+----------------------+| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage&#x2F;Cap |           Memory-Usage | GPU-Util  Compute M. ||                                         |                        |               MIG M. ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||   0  NVIDIA GeForce RTX 4090        On  |   00000000:05:00.0 Off |                  Off ||  0%   30C    P8             25W &#x2F;  450W |       0MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+|   1  NVIDIA GeForce RTX 4090        On  |   00000000:07:00.0 Off |                  Off ||  0%   32C    P8             30W &#x2F;  450W |       0MiB &#x2F;  24564MiB |      0%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------+                                                                                         +-----------------------------------------------------------------------------------------+| Processes:                                                                              ||  GPU   GI   CI        PID   Type   Process name                              GPU Memory ||        ID   ID                                                               Usage      ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||  No running processes found                                                             |+-----------------------------------------------------------------------------------------+</code></pre></div></figure><h1 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h1><p><a href="https://www.heiko-sieger.info/blacklisting-graphics-driver/">https://www.heiko-sieger.info/blacklisting-graphics-driver/</a></p><h1 id="番外：virt-manager虚拟机配置桥接模式"><a href="#番外：virt-manager虚拟机配置桥接模式" class="headerlink" title="番外：virt-manager虚拟机配置桥接模式"></a>番外：virt-manager虚拟机配置桥接模式</h1><p>1、宿主机：修改ubuntu22.04的网络配置文件，添加桥接网卡gsbr0</p><blockquote><p>注意：桥接网卡gsbr0是接到物理网卡eno1上的，只需要配置gsbr0的IP地址</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># vim &#x2F;etc&#x2F;netplan&#x2F;00-installer-config.yamlnetwork:  ethernets:    eno1:      dhcp4: no    eno2:      dhcp4: true    ens118f0np0:      dhcp4: true    ens118f1np1:      dhcp4: true  bridges:    gsbr0:      interfaces: [eno1]      dhcp4: no      routes:        - to: default          via: 15.1.10.254      addresses: [15.1.10.202&#x2F;24]      nameservers:        addresses: [223.5.5.5,8.8.8.8]  version: 2</code></pre></div></figure><p>查看验证配置成功：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使配置生效netplan apply# 查看IP(base) root@k8s-master1:~# ip add | grep 15.1.10    inet 15.1.10.202&#x2F;24 brd 15.1.10.255 scope global gsbr0</code></pre></div></figure><p>2、虚拟机：配置IP地址，跟桥接网口同网段</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@seuvm01:~&#x2F;getinfo# cat &#x2F;etc&#x2F;netplan&#x2F;00-installer-config.yaml network:  ethernets:    enp1s0:      dhcp4: no      addresses: [15.1.10.231&#x2F;24]      gateway4: 15.1.10.254      nameservers:        addresses: [223.5.5.5,8.8.8.8]  version: 2</code></pre></div></figure><p>3、验证虚拟机网络，配置成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 网络配置文件生效netplan apply# 查看IProot@seuvm01:~&#x2F;getinfo# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1&#x2F;8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1&#x2F;128 scope host noprefixroute        valid_lft forever preferred_lft forever2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link&#x2F;ether 52:54:00:15:ae:00 brd ff:ff:ff:ff:ff:ff    inet 15.1.10.231&#x2F;24 brd 15.1.10.255 scope global enp1s0       valid_lft forever preferred_lft forever    inet6 fe80::5054:ff:fe15:ae00&#x2F;64 scope link        valid_lft forever preferred_lft forever</code></pre></div></figure><h1 id="番外：JumpServer恢复锁定30分钟"><a href="#番外：JumpServer恢复锁定30分钟" class="headerlink" title="番外：JumpServer恢复锁定30分钟"></a>番外：JumpServer恢复锁定30分钟</h1><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@r250-1:&#x2F;opt# docker exec -it jms_core &#x2F;bin&#x2F;bashroot@jms_core:&#x2F;opt&#x2F;jumpserver# root@jms_core:&#x2F;opt&#x2F;jumpserver# root@jms_core:&#x2F;opt&#x2F;jumpserver# lsCODE_OF_CONDUCT.md  Dockerfile     Dockerfile-ee  README.md     SECURITY.md  config.yml      data  entrypoint.sh  poetry.lock   readmes tmp  utilsCONTRIBUTING.md     Dockerfile-base  LICENSE    README.zh-CN.md  apps  config_example.yml  docs  jms   pyproject.toml  requirements  uiroot@jms_core:&#x2F;opt&#x2F;jumpserver# python manage.py shellpython: can&#39;t open file &#39;&#x2F;opt&#x2F;jumpserver&#x2F;manage.py&#39;: [Errno 2] No such file or directoryroot@jms_core:&#x2F;opt&#x2F;jumpserver# lsCODE_OF_CONDUCT.md  Dockerfile     Dockerfile-ee  README.md     SECURITY.md  config.yml      data  entrypoint.sh  poetry.lock   readmes tmp  utilsCONTRIBUTING.md     Dockerfile-base  LICENSE    README.zh-CN.md  apps  config_example.yml  docs  jms   pyproject.toml  requirements  uiroot@jms_core:&#x2F;opt&#x2F;jumpserver# cd apps&#x2F;root@jms_core:&#x2F;opt&#x2F;jumpserver&#x2F;apps# ls__init__.py  __pycache__  accounts  acls  assets  audits  authentication  common  i18njumpserver  labels  libs  manage.py  notifications  ops  orgs  perms  rbac  settings  static  templates  terminal  tickets  usersroot@jms_core:&#x2F;opt&#x2F;jumpserver&#x2F;apps# python manage.py shellPython 3.11.11 (main, Jan 14 2025, 02:24:43) [GCC 10.2.1 20210110] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.(InteractiveConsole)&gt;&gt;&gt; from django.core.cache import cache&gt;&gt;&gt; cache.delete_pattern(&#39;_LOGIN_BLOCK_*&#39;)3&gt;&gt;&gt; cache.delete_pattern(&#39;_LOGIN_LIMIT_*&#39;)5&gt;&gt;&gt; </code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hmailserver配置邮件中继转发</title>
    <link href="/2025/01/17/06_%E6%9D%82%E8%AE%B0/hmailserver%E9%82%AE%E4%BB%B6%E8%BD%AC%E5%8F%91/"/>
    <url>/2025/01/17/06_%E6%9D%82%E8%AE%B0/hmailserver%E9%82%AE%E4%BB%B6%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="hmailserver配置邮件中继转发"><a href="#hmailserver配置邮件中继转发" class="headerlink" title="hmailserver配置邮件中继转发"></a>hmailserver配置邮件中继转发</h1><h1 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h1><p>在内网服务器BMC管理网段不能联网的情况下，配置邮件中继转发，将BMC告警邮件转发到QQ邮箱中。</p><p><font color=green><strong>内网Server</strong></font> —-25端口—-&gt; <font color=green><strong>PC1</strong></font> —–587端口 + 验证—–&gt; <font color=green><strong>QQ邮箱</strong></font></p><p><img src="/../../img/image-20250117094940903.png" alt="image-20250117094940903"></p><h1 id="二、hmailserver配置"><a href="#二、hmailserver配置" class="headerlink" title="二、hmailserver配置"></a>二、hmailserver配置</h1><blockquote><p>在PC1 - windows系统配置</p></blockquote><p>1、下载并安装hmailserver</p><p>链接：<a href="https://www.hmailserver.com/">https://www.hmailserver.com/</a></p><p>2、打开软件，使用安装时创建的密码登录</p><p><img src="/./../../img/image-20250117095311930.png" alt="image-20250117095311930"></p><p>3、配置SMTP转发：将QQ邮箱的SMTP服务信息填进去。</p><p>其中的密码要使用QQ邮箱的安全密码，而不是账号登录密码，端口使用587。</p><p>Settings - Protocols - SMTP - Delivery of e-mail</p><p><img src="/./../../img/image-20250117095440895.png" alt="image-20250117095440895"></p><p>4、配置SMTP协议的路由</p><p>Settings - Protocols - SMTP - Routes 点击 Add 添加一条路由</p><p><img src="/./../../img/image-20250117095646085.png" alt="image-20250117095646085"></p><p>新建的路由设置如下，其中Domian(*)代表转发内网过来的任意IP地址</p><p><img src="/./../../img/image-20250117095716649.png" alt="image-20250117095716649"></p><p>再切换到”Delivery“标签，切记此处也要设置认证方式和认证密码！！</p><p><img src="/./../../img/image-20250117101043743.png" alt="image-20250117101043743"></p><p>5、设置IP范围</p><p>Settings - Advanced - IP Ranges 添加一条规则”内网服务器“</p><p><img src="/./../../img/image-20250117095918257.png" alt="image-20250117095918257"></p><p>规则设置如下，用于指定内网服务器IP</p><p><img src="/./../../img/image-20250117095939691.png" alt="image-20250117095939691"></p><h1 id="三、服务器BMC配置"><a href="#三、服务器BMC配置" class="headerlink" title="三、服务器BMC配置"></a>三、服务器BMC配置</h1><p>1、配置SMTP发送邮件告警，内网服务器BMC与PC的hmailserver通过25端口通信，因此不需要设置验证</p><p><img src="/./../../img/image-20250117100417624.png" alt="image-20250117100417624"></p><p>2、配置完测试邮件是否能发送成功</p><p><img src="/./../../img/image-20250117100611319.png" alt="image-20250117100611319"></p><h1 id="四、遇到的问题"><a href="#四、遇到的问题" class="headerlink" title="四、遇到的问题"></a>四、遇到的问题</h1><p>问题一：SENT: 530 SMTP authentication is required</p><p>处理方案：是因为没有设置SMTP验证引起，按照2.3和2.4配置SMTP认证即可</p><p>问题二：RECEIVED: 503 Error: need EHLO and AUTH first !</p><p>处理方案：同样是认证方式配置有误，按照2.3和2.4配置SMTP认证即可</p><p>问题三：501 Mail from address must be same as authorization user</p><p>处理方案：发件人和收件人得保持一致，在3.1配置服务器BMC的邮件告警时，发件人要设置成和收件人一致的邮箱地址。</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>昇腾910B显卡满载功耗测试</title>
    <link href="/2024/11/07/02_%E6%B5%8B%E8%AF%95/09-%E6%98%87%E8%85%BE910B%E6%BB%A1%E8%BD%BD%E5%8A%9F%E8%80%97%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/11/07/02_%E6%B5%8B%E8%AF%95/09-%E6%98%87%E8%85%BE910B%E6%BB%A1%E8%BD%BD%E5%8A%9F%E8%80%97%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="昇腾910B显卡满载功耗测试"><a href="#昇腾910B显卡满载功耗测试" class="headerlink" title="昇腾910B显卡满载功耗测试"></a>昇腾910B显卡满载功耗测试</h1><p>一、安装测试工具</p><blockquote><p>参考链接：<a href="https://www.hiascend.com/document/detail/zh/mindx-dl/60rc2/toolbox/ascenddmi/toolboxug_0004.html">https://www.hiascend.com/document/detail/zh/mindx-dl/60rc2/toolbox/ascenddmi/toolboxug_0004.html</a></p></blockquote><p>下载Toolbox的deb安装包</p><p>链接：<a href="https://www.hiascend.com/developer/download/community/result?module=dl+cann">https://www.hiascend.com/developer/download/community/result?module=dl%2Bcann</a></p><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">dpkg -i .&#x2F;Ascend-mindx-toolbox_6.0.RC2.2_linux-aarch64.deb</code></pre></div></figure><p>执行环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;usr&#x2F;local&#x2F;Ascend&#x2F;toolbox&#x2F;set_env.sh</code></pre></div></figure><p>测试是否安装成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@user:~&#x2F;Ascend-test# ascend-dmi --versionascend-dmi version: 6.0.RC2.2</code></pre></div></figure><p>二、压力测试</p><p>执行设置开发者套件的环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># toolboxsource &#x2F;usr&#x2F;local&#x2F;Ascend&#x2F;toolbox&#x2F;set_env.sh# 开发者套件source &#x2F;usr&#x2F;local&#x2F;Ascend&#x2F;ascend-toolkit&#x2F;set_env.sh# nnrt软件包source &#x2F;usr&#x2F;local&#x2F;Ascend&#x2F;nnrt&#x2F;set_env.sh# nnae软件包source &#x2F;usr&#x2F;local&#x2F;Ascend&#x2F;nnae&#x2F;set_env.sh</code></pre></div></figure><p>执行功耗压测</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 以执行时间为60s，信息的打印间隔信息为5s，屏幕的输出模式为清除历史记录为例ascend-dmi -p --dur 60 --it 5 --pm refresh</code></pre></div></figure><p>正常输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|| Type                  | NPU Count                                |+-----------------------+------------------+-----------------------+| Device ID             | Health           | Temperature   Voltage || Chip Name             | AI Core Usage    | Power                 ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|| Ascend 910 B3         | 8                                        |+-----------------------+------------------+-----------------------+| 0                     | OK               | 71C           0.76V   || Ascend 910B3          | 100%             | 364.5W                |+-----------------------+------------------+-----------------------+| 1                     | OK               | 71C           0.79V   || Ascend 910B3          | 100%             | 363.8W                |+-----------------------+------------------+-----------------------+| 2                     | OK               | 72C           0.79V   || Ascend 910B3          | 100%             | 364.6W                |+-----------------------+------------------+-----------------------+| 3                     | OK               | 74C           0.79V   || Ascend 910B3          | 100%             | 364.3W                |+-----------------------+------------------+-----------------------+| 4                     | OK               | 78C           0.77V   || Ascend 910B3          | 100%             | 364.2W                |+-----------------------+------------------+-----------------------+| 5                     | OK               | 79C           0.78V   || Ascend 910B3          | 100%             | 364.4W                |+-----------------------+------------------+-----------------------+| 6                     | OK               | 78C           0.76V   || Ascend 910B3          | 100%             | 364.5W                |+-----------------------+------------------+-----------------------+| 7                     | OK               | 77C           0.76V   || Ascend 910B3          | 100%             | 364.5W                ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GPU服务器硬件拓扑和集群组网</title>
    <link href="/2024/11/02/06_%E6%9D%82%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDGPU%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/11/02/06_%E6%9D%82%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDGPU%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="GPU服务器硬件拓扑和集群组网"><a href="#GPU服务器硬件拓扑和集群组网" class="headerlink" title="GPU服务器硬件拓扑和集群组网"></a>GPU服务器硬件拓扑和集群组网</h1><blockquote><p>转载自：<a href="http://arthurchiao.art/blog/gpu-advanced-notes-1-zh/#11-pcie-%E4%BA%A4%E6%8D%A2%E8%8A%AF%E7%89%87">http://arthurchiao.art/blog/gpu-advanced-notes-1-zh/#11-pcie-%E4%BA%A4%E6%8D%A2%E8%8A%AF%E7%89%87</a></p><p>感谢原作者的分享！在此基础上改动为个人版本。</p></blockquote><h1 id="1-术语与基础"><a href="#1-术语与基础" class="headerlink" title="1 术语与基础"></a>1 术语与基础</h1><p>大模型训练一般都是用单机 8 卡 GPU 主机组成集群，机型包括 <code>8*&#123;A100,A800,H100,H800&#125;</code> 。 下面一台典型 8*A100 GPU 的主机内硬件拓扑：</p><p><img src="/../../img/image-20241012131712609.png" alt="典型 8 卡 A100 主机硬件拓扑"></p><p>需要重点理解的组成部件包括：</p><ul><li>PCIE交换芯片</li><li>NVSwitch</li><li>NVLink Switch</li><li>HBM</li></ul><p>本节将基于这张图来介绍一些概念和术语，有基础的可直接跳过。</p><h2 id="1-1-PCIe-交换芯片"><a href="#1-1-PCIe-交换芯片" class="headerlink" title="1.1 PCIe 交换芯片"></a>1.1 PCIe 交换芯片</h2><p>用于连接CPU、内存、存储（NVME）、GPU、网卡等<strong>支持 PICe 的设备</strong>，实现互联互通。</p><p>PCIe 目前有 5 代产品，最新的是 **<code>Gen5</code>**。</p><h2 id="1-2-NVLink技术"><a href="#1-2-NVLink技术" class="headerlink" title="1.2 NVLink技术"></a>1.2 NVLink技术</h2><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><p>Wikipedia 上 <a href="https://en.wikipedia.org/wiki/NVLink">NVLink</a> 上的定义：</p><blockquote><p>NVLink is a wire-based serial multi-lane near-range communications link developed by Nvidia. Unlike PCI Express, a device can consist of multiple NVLinks, and devices use mesh networking to communicate instead of a central hub. The protocol was first announced in March 2014 and uses a proprietary high-speed signaling interconnect (NVHS).</p></blockquote><p>简单总结：同主机内多个GPU之间的一种高速互联方式，由NVSwitch连接同一主机内的多个GPU而构成。</p><ol><li>是一种短距离<strong>通信链路</strong>，能保证包的成功传输，提高性能，用于替代 PCIe；</li><li>支持多 lane，链路带宽随 lane 数量线性增长；</li><li>同一台 node 内的 GPU 通过 NVLink 以 <strong>full-mesh</strong> 方式（类似 spine-leaf）互联；</li><li>是NVIDIA的专利技术。</li></ol><h3 id="2）NVLink技术演进"><a href="#2）NVLink技术演进" class="headerlink" title="2）NVLink技术演进"></a>2）NVLink技术演进</h3><p>从2016年的第1代开始，到2022年已升级到第4 代。</p><p>图示为版本差异：主要区别是单条 NVLink 链路的 <strong>lane 数量</strong>以及每个 <strong>lane 的带宽</strong>（图中给的都是双向带宽）等：</p><p><img src="/./../../img/image-20241012132051768.png" alt="NVLink 演进。Image from: HotChips 2022 [1]"></p><h3 id="3）NVLink总带宽的计算方式"><a href="#3）NVLink总带宽的计算方式" class="headerlink" title="3）NVLink总带宽的计算方式"></a>3）NVLink总带宽的计算方式</h3><ul><li>A100的双向带宽是600GB&#x2F;s，单向带宽是300GB&#x2F;s</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># A100双向带宽的计算公式# 一台8卡的A100服务器里总共有6个NVSwitch，每个NVSwitch中有两条lane，每条lane的速度是50GB&#x2F;s,2 lanes&#x2F;NVSwitch * 6 NVSwitch * 50GB&#x2F;s&#x2F;lane &#x3D; 600GB&#x2F;s</code></pre></div></figure><ul><li>A800 被阉割了 4 条 lane，所以是双向带宽是400GB&#x2F;s，单向带宽是200GB&#x2F;s</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">8 lane * 50GB&#x2F;s&#x2F;lane &#x3D; 400GB&#x2F;s</code></pre></div></figure><h3 id="4）监控NVLink带宽的方法"><a href="#4）监控NVLink带宽的方法" class="headerlink" title="4）监控NVLink带宽的方法"></a>4）监控NVLink带宽的方法</h3><p>基于 DCGM 可以采集到实时 NVLink 带宽</p><p><img src="/./../../img/image-20241012132200770.png" alt="Metrics from dcgm-exporter [5]"></p><h2 id="1-3-NVSwitch芯片"><a href="#1-3-NVSwitch芯片" class="headerlink" title="1.3 NVSwitch芯片"></a>1.3 NVSwitch芯片</h2><p>NVSwitch 是 NVIDIA 的一款<strong>交换芯片</strong>，封装在 GPU模组（module）上，用于<strong>连接同一主机内GPU。</strong></p><p>如下图所示，为浪潮机器的真机图，左侧的8 个nvdia盒子就是 8 片 A100 GPU，而右侧的 6 块超厚散热片下面就是 NVSwitch 芯片。</p><p><img src="/./../../img/image-20241012132323761.png" alt="Inspur NF5488A5 NVIDIA HGX A100 8 GPU Assembly Side View. Image source: [2]"></p><h2 id="1-4-NVLink-Switch"><a href="#1-4-NVLink-Switch" class="headerlink" title="1.4 NVLink Switch"></a>1.4 NVLink Switch</h2><blockquote><p>请注意，别和NVSwitch弄混淆了！</p></blockquote><p>2022 年，NVIDIA 把NVSwitch芯片拿出来，做成了交换机，叫 NVLink Switch， 用来<strong>跨主机连接 GPU 设备</strong>。</p><p><img src="/./../../img/image-20241012154412755.png" alt="image-20241012154412755"></p><h2 id="1-5-HBM"><a href="#1-5-HBM" class="headerlink" title="1.5 HBM"></a>1.5 HBM</h2><h3 id="1）什么是HBM？"><a href="#1）什么是HBM？" class="headerlink" title="1）什么是HBM？"></a>1）什么是HBM？</h3><blockquote><p>美光副总裁暨计算与网络事业部计算产品事业群总经理Praveen Vaidyanathan指出，芯片性能表现与存储器的频宽和容量成正相关，随着大语言模型（LLM）参数量增加，也需要更高频宽存储器，AI处理器才能顺利运行。</p></blockquote><p>GDDR类型（传统）：（Graphics Double Data Rate）</p><ul><li>在传统显卡中，GPU的显存采用GDDR类型，以平铺的方式封装在 GPU 周围，通过<strong>较长的总线</strong>与GPU相连。（单层设计，绕远路）</li><li>GDDR6 的单芯片带宽通常在 14-18 Gbps 左右</li><li>功耗高，单芯片容量小，需要更高的频率来提高带宽，而且总线也长，需要更多能耗来驱动</li></ul><p>HBM类型（新技术）：（High Bandwidth Memory）</p><ul><li>可简单理解为多个DRAM透过先进封装堆叠起来，并且通过硅中介层（interposer）<strong>与 GPU 直接连接</strong>，减少了总线的长度和复杂性传输速度快，储存空间也更大。（多层设计，直连）</li><li>HBM2 的带宽可以达到 256-512 GB&#x2F;s 或更高。</li><li>HBM 的能效更高，它的总线更宽，但工作频率较低，且通过堆叠设计缩短了显存和 GPU 之间的距离。这种设计显著降低了功耗。</li></ul><p>HBM 的市场目前被 SK 海力士和三星等韩国公司垄断。</p><p><img src="/./../../img/image-20241012160300087.png" alt="image-20241012160300087"></p><blockquote><p>现在 CPU 也有用 HBM 的了，比如 <a href="https://www.intel.com/content/www/us/en/products/details/processors/xeon/max-series.html">Intel Xeon CPU Max Series</a> 就自带了 64GB HBM2e。</p></blockquote><h3 id="2）HDM技术演进："><a href="#2）HDM技术演进：" class="headerlink" title="2）HDM技术演进："></a>2）HDM技术演进：</h3><blockquote><p>From wikipedia <a href="https://en.wikipedia.org/wiki/High_Bandwidth_Memory">HBM</a></p></blockquote><p>HBM已有5代：</p><table><thead><tr><th align="left">版本</th><th align="left">Bandwidth</th><th align="left">Year</th><th>GPU</th></tr></thead><tbody><tr><td align="left">HBM</td><td align="left">128GB&#x2F;s&#x2F;package</td><td align="left"></td><td></td></tr><tr><td align="left">HBM2</td><td align="left">256GB&#x2F;s&#x2F;package</td><td align="left">2016</td><td>V100</td></tr><tr><td align="left">HBM2e</td><td align="left">~450GB&#x2F;s</td><td align="left">2018</td><td><code>A100, ~2TB/s</code>; 华为 <code>Ascend 910B</code></td></tr><tr><td align="left">HBM3</td><td align="left">600GB&#x2F;s&#x2F;site</td><td align="left">2020</td><td>H100, 3.35TB&#x2F;s</td></tr><tr><td align="left">HBM3e</td><td align="left">~1TB&#x2F;s</td><td align="left">2023</td><td><code>H200</code>, <a href="https://www.nvidia.com/en-us/data-center/h200/">4.8TB&#x2F;s</a></td></tr></tbody></table><p><img src="/./../../img/image-20241012132627792.png" alt="使用了 HBM 的近几代高端 NVIDIA GPU 显存带宽（双向），纵坐标是 TB/s。Image source: [3]"></p><ul><li>AMD MI300X 采用 192GB HBM3 方案，带宽 **<code>5.2TB/s</code>**；</li><li>HBM3e 是 HBM3 的增强版，速度从 6.4GT&#x2F;s 到 8GT&#x2F;s。</li></ul><h2 id="1-6-带宽单位"><a href="#1-6-带宽单位" class="headerlink" title="1.6 带宽单位"></a>1.6 带宽单位</h2><p>大规模 GPU 训练的性能与数据传输速度有直接关系。这里面涉及到很多链路，比如 PCIe 带宽、内存带宽、NVLink 带宽、HBM 带宽、网络带宽等等。</p><ul><li>网络习惯用 <strong><code>bits/second (b/s)</code></strong> 表示之外，并且一般说的都是<strong>单向</strong>（TX&#x2F;RX）；</li><li>其他模块带宽基本用 <code>byte/sedond (B/s)</code> 或 <code>transactions/second (T/s)</code> 表示，并且一般都是<strong>双向总带宽</strong>。</li></ul><p>比较带宽时注意区分和转换。</p><h1 id="2-典型8卡A100-A800主机构成"><a href="#2-典型8卡A100-A800主机构成" class="headerlink" title="2 典型8卡A100&#x2F;A800主机构成"></a>2 典型8卡A100&#x2F;A800主机构成</h1><h2 id="2-1-主要部件"><a href="#2-1-主要部件" class="headerlink" title="2.1 主要部件"></a>2.1 主要部件</h2><ul><li>2 片 CPU（以及两边的内存[DRAM]，NUMA）</li><li>2 张网卡（用于连接存储、带内管理等）</li><li>4 个 PCIe Gen4 Switch 芯片（用于CPU与显卡连接）</li><li>6 个 NVSwitch 芯片（用于连接主机内的8块GPU）</li><li>8 个 GPU</li><li>8 个 GPU 专属网卡（GPU卡 - PCIE总线 - Infiniband网卡）</li></ul><p>可参考下图构成：</p><p><img src="/./../../img/NVIDIA-DGX-A100-Block-Diagram.png" alt="NVIDIA DGX A100 主机（官方 8 卡机器）硬件拓扑"></p><h3 id="1）存储网卡"><a href="#1）存储网卡" class="headerlink" title="1）存储网卡"></a>1）存储网卡</h3><p>通过 PCIe 直连 CPU，用途：</p><ol><li>从分布式存储读写数据，例如读训练数据，写checkpoint等。</li><li>正常的 node 管理，ssh，监控采集等等。</li></ol><p>官方推荐用 BF3 DPU。但其实只要带宽达标，用什么都行。组网经济点的话用 RoCE，追求最好的性能用 IB。</p><h3 id="2）NVSwitch-删除"><a href="#2）NVSwitch-删除" class="headerlink" title="2）NVSwitch(删除)"></a>2）NVSwitch(删除)</h3><p>8 个 GPU 通过 6 个 NVSwitch 芯片 full-mesh 连接，这个 full-mesh 也叫 **<code>NVSwitch fabric</code>**； </p><p>full-mesh 里面的<strong>每根线的带宽是 n * bw-per-nvlink-lane</strong>，比如：</p><p>A100 用的 NVLink3，每条lane的带宽是50GB&#x2F;s</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">所以 full-mesh 里的每条线就是 12*50GB&#x2F;s&#x3D;600GB&#x2F;s，注意这个是双向带宽，单向只有 300GB&#x2F;s。</code></pre></div></figure><p>A800 是阉割版，12 lane 变成 8 lane</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">所以每条线 8*50GB&#x2F;s&#x3D;400GB&#x2F;s，单向 200GB&#x2F;s。</code></pre></div></figure><h3 id="3）查看拓扑"><a href="#3）查看拓扑" class="headerlink" title="3）查看拓扑"></a>3）查看拓扑</h3><p>使用<code>nvidia-smi topo</code>命令可以查看部件连接拓扑：</p><p>下面是一台 8*A800 机器上 <strong><code>nvidia-smi</code></strong> 显示的实际拓扑（网卡两两做了 bond，NIC 0~3 都是 bond）：</p><p><img src="/./../../img/image-20241012133420998.png" alt="image-20241012133420998"></p><ul><li><p>GPU 之间（左上角区域）：都是 **<code>NV8</code>**，表示 <strong>8 条 NVLink</strong> 连接；</p></li><li><p>NIC 之间：</p><ul><li>在同一片 CPU 上：**<code>NODE</code><strong>，表示</strong>不需要跨 NUMA，但需要跨 PCIe 交换芯片**；</li><li>不在同一片 CPU 上：**<code>SYS</code><strong>，表示</strong>需要跨 NUMA**；</li></ul></li><li><p>GPU 和 NIC 之间：</p><ul><li>在同一片 CPU 上，且在同一个 PCIe Switch 芯片下面：**<code>PXB</code><strong>，表示</strong>只需要跨 PCIe 交换芯片**；</li><li>在同一片 CPU 上，且不在同一个 PCIe Switch 芯片下面：**<code>NODE</code><strong>，表示</strong>需要跨 PCIe 交换芯片和 PCIe Host Bridge**；</li><li>不在同一片 CPU 上：**<code>SYS</code><strong>，表示</strong>需要跨 NUMA、PCIe 交换芯片，距离最远**；</li></ul></li></ul><h2 id="2-2-GPU-训练集群组网"><a href="#2-2-GPU-训练集群组网" class="headerlink" title="2.2 GPU 训练集群组网"></a>2.2 GPU 训练集群组网</h2><p>计算节点互联的网络架构：主要连接<strong>计算网络</strong>和<strong>存储网络</strong></p><p><img src="/./../../img/a100-idc-network.png" alt="a100-idc-network"></p><h3 id="1）计算网络"><a href="#1）计算网络" class="headerlink" title="1）计算网络"></a>1）计算网络</h3><p>GPU 网卡直连到叶层交换机（leaf），leaf 通过 full-mesh（点对点直连）的方式连接到脊层交换机（spine），形成跨主机 GPU 计算网络。</p><ul><li><p>这个网络的目的是 GPU 与其他计算节点的 GPU交换数据；</p></li><li><p>服务器内部的GPU和存储网卡通过PCIe 交换芯片连接</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">  GPU &lt;--&gt; PCIe Switch &lt;--&gt; 存储网卡### 2）存储网络直连 CPU 的两张网卡，连接到另一张网络里，主要作用是读写数据，以及 SSH 管理等等。### 3）RDMA概念在了解RDMA之前，需要先了解DMA（全称为Direct Memory Access，即直接内存访问。意思是外设对内存的读写过程可以不用CPU参与而直接进行）没有DMA的时候，外部设备读写内存需要绕道CPU走一圈。假设I&#x2F;O设备为一个普通网卡，为了从内存拿到需要发送的数据，然后组装数据包发送到物理链路上，网卡需要通过总线告知CPU自己的数据请求。然后CPU将会把内存缓冲区中的数据复制到自己内部的寄存器中，再复制到I&#x2F;O设备的存储空间中。如果数据量比较大，那么很长一段时间内CPU都会忙于搬移数据，而无法投入到其他工作中去。![image-20241012170122410](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012170122410.png)CPU的最主要工作是计算，而不是进行数据复制，这种工作属于白白浪费了它的计算能力。为了给CPU“减负”，让它投入到更有意义的工作中去，后来人们设计了DMA机制：![image-20241012170404114](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012170404114.png)可以看到总线上又挂了一个DMA控制器，它是专门用来读写内存的设备。有了它以后，当我们的网卡想要从内存中拷贝数据时，除了一些必要的控制命令外，整个数据复制过程都是由DMA控制器完成的。过程跟CPU复制是一样的，只不过这次是把内存中的数据通过总线复制到DMA控制器内部的寄存器中，再复制到I&#x2F;O设备的存储空间中。CPU除了关注一下这个过程的开始和结束以外，其他时间可以去做其他事情。DMA控制器一般是和I&#x2F;O设备在一起的，也就是说一块网卡中既有负责数据收发的模块，也有DMA模块。好了，现在可以来学习RDMA了。RDMA（Remote Direct Memory Access，远程直接内存访问）是一种高速网络互联技术，该技术主要设计目的是减少在数据传输过程中收发端的处理延迟以及资源消耗。RDMA技术使计算机能够直接访问远程计算机的内存，在内存层面进行数据传输而无需CPU频繁介入，从而显著增强网络通信性能。传统网卡的通信方式：传统网络中，&quot;服务器1给服务器2发消息&quot;实际上做的是“把&quot;服务器1内存中的一段数据，通过网络链路搬移到&quot;服务器2的内存中”，而这一过程无论是发端还是收段，都需要CPU的指挥和控制，包括网卡的控制，中断的处理，报文的封装和解析等等。![image-20241012171059302](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012171059302.png)使用RDMA网卡的通信方式：同样是把本端内存中的一段数据，复制到对端内存中，在使用了RDMA技术时，两端的CPU几乎不用参与数据传输过程（只参与控制面）。本端的网卡直接从内存的用户空间DMA拷贝数据到内部存储空间，然后硬件进行各层报文的组装后，通过物理链路发送到对端网卡。对端的RDMA网卡收到数据后，剥离各层报文头和校验码，通过DMA将数据直接拷贝到用户空间内存中。![image-20241012171217209](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012171217209.png)### 3）RoCE vs. InfiniBand不管是计算网络还是存储网络，都需要RDMA技术才能实现 AI 所需的高性能。RDMA**技术**的实现目前有**两种协议**选择：- RoCEv2：公有云卖的 8 卡 GPU 主机基本都是这种网络；在性能达标的前提下，（相对）便宜；- InfiniBand (IB)：同等网卡带宽下，性能比 RoCEv2 好 20% 以上，但是价格贵一倍。## 2.3 数据链路带宽瓶颈分析![单机 8 卡 A100 GPU 主机带宽瓶颈分析](.&#x2F;..&#x2F;..&#x2F;img&#x2F;8x-a100-bw-limits.png)几个关键链路带宽都标在图上了，1、同主机 GPU 之间：走 NVLink，双向 600GB&#x2F;s，单向 **&#96;300GB&#x2F;s&#96;**；2、同主机 GPU 和自己的网卡之间：走 PICe Gen4 Switch 芯片，双向 64GB&#x2F;s，单向 **&#96;32GB&#x2F;s&#96;**；3、跨主机 GPU 之间：需要通过网卡收发数据，这个就看网卡带宽了，- &#96;100Gbps&#x3D;12.5GB&#x2F;s&#96;： 远低于PCIe Gen4 的单向带宽，所以跨机通信相比主机内通信性能要下降很多。- &#96;200Gbps&#x3D;&#x3D;25GB&#x2F;s&#96;：已经**接近** PCIe Gen4 的单向带宽（推荐）。- &#96;400Gbps&#x3D;&#x3D;50GB&#x2F;s&#96;：已经**超过** PCIe Gen4 的单向带宽。因此在这种机型里，用 400Gbps 网卡作用不大，400Gbps 需要 PCIe Gen5 性能才能发挥出来。# 3 典型8卡H100&#x2F;H800主机构成H系列的GPU按照主板规格（Board Form Factor）分为两种类型：- PCIe Gen5- SXM-5：性能更高一些## 3.1 H100 芯片 layout下面是一片 H100 GPU 芯片的内部结构：![单片H100GPU内部逻辑布局](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012134446643.png)- 台积电4nm工艺- 采用第四代NVlink技术，最下面的绿色条是18条lane；NVLINK的双向总带宽900GB&#x2F;s（18 * 50）- 中间蓝色的是 L2 cache；- 左右两侧是 **&#96;HBM&#96;** 芯片，即显存；## 3.2 主机内硬件拓扑跟 A100 8 卡机结构大致类似，区别：1. NVSwitch 芯片从 6 个减少到了 4 个；真机图如下，![A100-8卡真机图](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012134550723.png)2.与 CPU 的互联从 PCIe Gen4 x16 升级到 **&#96;PCIe Gen5 x16&#96;**，双向带宽 **&#96;128GB&#x2F;s&#96;**；![image-20241012134613017](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012134613017.png)## 3.3 组网与 A100 也类似，只是标配改成了 **&#96;400Gbps&#96;** 的 CX7 网卡， 否则网络带宽与 PCIe Switch 和 NVLink&#x2F;NVSwitch 之间的差距更大了。# 4 典型 &#96;4*L40S&#x2F;8*L40S&#96; 主机L40S 是今年（2023）即将上市的新一代“性价比款”多功能 GPU，**对标 A100**。 除了不适合训练基座大模型之外（后面会看到为什么），官方的宣传里它几乎什么都能干。 ~~价格的话，目前第三方服务器厂商给到的口头报价都是 A100 的 8 折左右~~。## 4.1 L40S vs A100 配置及特点对比L40S 最大的特点之一是 **time-to-market 时间短**，也就是从订货到拿到货周期比 A100&#x2F;A800&#x2F;H800 快很多。 这里面技术和非技术原因都有，比如：- ~~不存在被美国禁售的功能~~（根据 2023.10 的新规定，已经禁售了），比如 **FP64 和 NVLink 都干掉了**；- 使用 **&#96;GDDR6&#96;** 显存，不依赖 HBM 产能（及先进封装）；价格便宜也有几方面原因，后面会详细介绍：1. 大头可能来自 GPU 本身价格降低：因为去掉了一些模块和功能，或者用便宜的产品替代；2. 整机成本也有节省：例如去掉了一层 PCIe Gen4 Swtich；不过相比于 4x&#x2F;8x GPU，整机的其他部分都可以说送的了；## 4.2 L40S 与 A100 性能对比下面是一个官方标称性能对比：![L40S与A100性能对比](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012134804131.png)具体场景的性能对比网上也有很多官方资料，这里就不列举了。简单来，- 性能 1.2x ~ 2x（看具体场景）。- 功耗：两台 L40S 和单台 A100 差不多需要注意，**L40S 主机官方推荐的是单机 4 卡而不是 8 卡**（后面会介绍为什么）， 所以对比一般是用 &#96;两台 4*L40S&#96; vs &#96;单台 8*A100&#96;。另外，很多场景的性能提升有个 **大前提**：网络需要是 200Gbps RoCE 或 IB 网络，接下来介绍为什么。## 4.3 L40S 攒机### 推荐架构：&#96;2-2-4&#96;相比于 A100 的 **&#96;2-2-4-6-8-8&#96;** 架构， 官方推荐的 L40S GPU 主机是 2-2-4 架构，一台机器物理拓扑如下：![单机4卡L40S GPU](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012135201064.png)最明显的变化是**去掉了 CPU 和 GPU 之间的 PCIe Switch 芯片**， 网卡和 GPU 都是直连 CPU 上自带的 PCIe Gen4 x16（64GB&#x2F;s），- 2 片 CPU（NUMA）- 2 张双口 CX7 网卡（每张网卡 **&#96;2\*200Gbps&#96;**）- 4 片 L40S GPU- 另外，存储网卡只配 1 张（双口），直连在任意一片 CPU 上这样**每片 GPU 平均 200Gbps 网络带宽**。### 不推荐架构：&#96;2-2-8&#96;![单机 8 卡 L40S GPU 主机拓扑，来自 NVIDIA L40S 官方推介材料](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012135239994.png)如图，跟单机 4 卡相比，单机 8 卡需要引入两片 PCIe Gen5 Switch 芯片：- 说是现在**PCIe Gen5 Switch 单片价格 1w 刀**（不知真假），一台机器需要 2 片；价格不划算；- PCIe switch 只有一家在生产，产能受限，周期很长；- 平摊到每片 GPU 的网络带宽减半；## 4.4 组网官方建议 4 卡机型，搭配 200Gbps RoCE&#x2F;IB 组网。## 4.5 数据链路带宽瓶颈分析![单机 4 卡 L40S GPU 主机带宽瓶颈分析](.&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20241012135328084.png)以同 CPU 下面的两种 L40S 为例，这里面有两条链路可选：1. 直接通过 CPU 处理：&#96;GPU0 &lt;--PCIe--&gt; CPU &lt;--PCIe--&gt; GPU1&#96;   - PCIe Gen4 x16 双向 64GB&#x2F;s，单向 **&#96;32GB&#x2F;s&#96;**；   - **CPU 处理瓶颈？TODO**2. 完全绕过 CPU 处理，**通过网卡去外面绕一圈再回来**：&#96;GPU0 &lt;--PCIe--&gt; NIC &lt;-- RoCe&#x2F;IB Switch --&gt; NIC &lt;--PCIe--&gt; GPU1&#96;   - PCIe Gen4 x16 双向 64GB&#x2F;s，单向 **&#96;32GB&#x2F;s&#96;**；   - 平均每个 GPU 一个单向 200Gbps 网口，单向折算 **&#96;25GB&#x2F;s&#96;**；   - **需要 NCCL 支持**，官方说新版本 NCCL 正在针对 L40S 适配，默认行为就是去外面绕一圈回来；第二种方式看着长了很多，但官方说其实比方式一还要快很多（这里还每太搞懂，CPU 那里是怎么处理的？）—— **前提是网卡和交换机配到位**：200Gbps RoCE&#x2F;IB 网络。在这种网络架构下（网络带宽充足），- **任何两片 GPU 的通信带宽和延迟都是一样的**，是否在一台机器内或一片 CPU 下面并不重要，集群可以**横向扩展**（scaling up，compared with scaling in）；- GPU 机器成本降低；但其实对于那些对网络带宽要求没那么高的业务来说，是**把 NVLINK 的成本转嫁给了网络**，这时候必须要组建 200Gbps 网络，否则发挥不出 L40S 多卡训练的性能。如果是方式二，同主机内 GPU 卡间的带宽瓶颈在网卡速度。即使网络是推荐的 2*CX7 配置，- L40S： 200Gbps（网卡单向线速）- A100： 300GB&#x2F;s（NVLINK3 单向） &#x3D;&#x3D; **&#96;12x&#96;**200Gbps- A800： 200GB&#x2F;s（NVLINK3 单向） &#x3D;&#x3D; **&#96;8x&#96;**200Gbps可以看到，**L40S 卡间带宽还是比 A100 NVLINK 慢了 12 倍**， 比 A800 NVLink 慢了 8 倍，所以**不适合数据密集交互的基础大模型训练**。## 4.6 测试注意事项如上，即便只测试单机 4 卡 L40S 机器，也需要搭配 200Gbps 交换机，否则卡间性能发挥不出来。# 5 典型 &#96;8*H20&#96; GPU 服务器（2024 更新）H20 是 2023 年发布，2024 年正式开始交付的 GPU。面向中国大陆市场，填补 A800&#x2F;L40S 等等被禁之后的产品空缺。## 5.1 显存：**&#96;8\*96GB&#96;**</code></pre></div></figure></li></ul><p>$ nvidia-smi<br>+—————————————————————————————+<br>| NVIDIA-SMI 535.161.03             Driver Version: 535.161.03   CUDA Version: 12.2     |<br>|—————————————–+———————-+———————-+<br>| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp   Perf          Pwr:Usage&#x2F;Cap |         Memory-Usage | GPU-Util  Compute M. |<br>|                                         |                      |               MIG M. |<br>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|<br>|   0  NVIDIA H20                     On  | 00000000:04:00.0 Off |                    0 |<br>| N&#x2F;A   24C    P0              72W &#x2F; 500W |      0MiB &#x2F; 97871MiB |      0%      Default |<br>|                                         |                      |             Disabled |<br>+—————————————–+———————-+———————-+<br>|   1  NVIDIA H20                     On  | 00000000:23:00.0 Off |                    0 |<br>| N&#x2F;A   24C    P0              71W &#x2F; 500W |      0MiB &#x2F; 97871MiB |      0%      Default |<br>|                                         |                      |             Disabled |<br>+—————————————–+———————-+———————-+<br>…<br>+—————————————–+———————-+———————-+<br>|   7  NVIDIA H20                     On  | 00000000:E4:00.0 Off |                    0 |<br>| N&#x2F;A   24C    P0              72W &#x2F; 500W |      0MiB &#x2F; 97871MiB |      0%      Default |<br>|                                         |                      |             Disabled |<br>+—————————————–+———————-+———————-+</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">GPU 最大功耗 &#96;8*500W&#96;。## 5.2 卡间互联：NVLINK &#96;x18 lanes &#x3D; 900GB&#x2F;s&#96;</code></pre></div></figure><p>$ nvidia-smi topo -m<br>        GPU0    GPU1    GPU2    GPU3    GPU4    GPU5    GPU6    GPU7    NIC0    NIC1    CPU Affinity    NUMA Affinity   GPU NUMA ID<br>GPU0     X      NV18    NV18    NV18    NV18    NV18    NV18    NV18    SYS     SYS     0-95,192-287    0               N&#x2F;A<br>GPU1    NV18     X      NV18    NV18    NV18    NV18    NV18    NV18    SYS     SYS     0-95,192-287    0               N&#x2F;A<br>GPU2    NV18    NV18     X      NV18    NV18    NV18    NV18    NV18    SYS     SYS     0-95,192-287    0               N&#x2F;A<br>GPU3    NV18    NV18    NV18     X      NV18    NV18    NV18    NV18    SYS     SYS     0-95,192-287    0               N&#x2F;A<br>GPU4    NV18    NV18    NV18    NV18     X      NV18    NV18    NV18    NODE    NODE    96-191,288-383  1               N&#x2F;A<br>GPU5    NV18    NV18    NV18    NV18    NV18     X      NV18    NV18    NODE    NODE    96-191,288-383  1               N&#x2F;A<br>GPU6    NV18    NV18    NV18    NV18    NV18    NV18     X      NV18    PHB     PHB     96-191,288-383  1               N&#x2F;A<br>GPU7    NV18    NV18    NV18    NV18    NV18    NV18    NV18     X      NODE    NODE    96-191,288-383  1               N&#x2F;A<br>NIC0    SYS     SYS     SYS     SYS     NODE    NODE    PHB     NODE     X      PIX<br>NIC1    SYS     SYS     SYS     SYS     NODE    NODE    PHB     NODE    PIX      X</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">可以看到双向 **&#96;18 lanes \* 50GB&#x2F;s&#x2F;lane&#x3D; 900GB&#x2F;s&#96;**（单向 450GB&#x2F;s）。 作为对比，&#96;8*A800&#96; NVLINK 是 8 lanes，见前面章节。## 5.3 网络这个看各服务器厂商怎么配了。下面是国内某家的 PCIe 和网卡信息：</code></pre></div></figure><p>$ lspci<br>00:00.0 Host bridge: Advanced Micro Devices, Inc. [AMD] Device 14a4 (rev 01)<br>c0:00.2 IOMMU: Advanced Micro Devices, Inc. [AMD] Device 149e (rev 01)<br>c0:01.1 PCI bridge: Advanced Micro Devices, Inc. [AMD] Device 14ab (rev 01)<br>c1:00.0 PCI bridge: Broadcom &#x2F; LSI PEX890xx PCIe Gen 5 Switch (rev b0)           # &lt;– PCIe Gen5<br>c2:00.0 PCI bridge: Broadcom &#x2F; LSI PEX890xx PCIe Gen 5 Switch (rev b0)<br>c3:00.0 3D controller: NVIDIA Corporation Device 2329 (rev a1)<br>c6:00.0 Ethernet controller: Mellanox Technologies MT2894 Family [ConnectX-6 Lx] # &lt;– Mellanox CX6<br>c6:00.1 Ethernet controller: Mellanox Technologies MT2894 Family [ConnectX-6 Lx]<br>…</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">RDMA：</code></pre></div></figure><p>$ ibstat<br>CA ‘mlx5_0’<br>        CA type: MT4127<br>        Number of ports: 1<br>        Port 1:<br>                State: Down<br>                Physical state: Disabled<br>                Rate: 40<br>                Base lid: 0<br>                LMC: 0<br>                SM lid: 0<br>                Capability mask: 0x00010000<br>                Link layer: Ethernet<br>CA ‘mlx5_1’<br>        CA type: MT4127<br>        Number of ports: 1<br>        Port 1:<br>                State: Down<br>                Physical state: Disabled<br>                Rate: 40<br>                Base lid: 0<br>                LMC: 0<br>                SM lid: 0<br>                Capability mask: 0x00010000<br>                Link layer: Ethernet</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">## 5.4 训练性能：`8*H20 vs 8*A800`单机 8 卡训练性能（实测数据，但大家用的模型、框架、数据集等可能各不相同，因此这里的结果仅供参考）：| GPU Node (NVLINK interconnect) | Throughput            || :----------------------------- | :-------------------- || 8*A800-80GB                    | **`~30`** samples/sec || **`8\*H20-96GB`**              | **`~21`** samples/sec |相比 A800，H20 纸面算力阉割了一半左右 [6]，但在 NVLINK/cache 等地方补了一下，所以实际性能（只）下降了 1/3。# 参考资料1. [NVLink-Network Switch - NVIDIA’s Switch Chip for High Communication-Bandwidth SuperPODs](https://hc34.hotchips.org/), Hot Chips 20222. [ChatGPT Hardware a Look at 8x NVIDIA A100 Powering the Tool](https://www.servethehome.com/chatgpt-hardware-a-look-at-8x-nvidia-a100-systems-powering-the-tool-openai-microsoft-azure-supermicro-inspur-asus-dell-gigabyte/), 20233. [NVIDIA Hopper Architecture In-Depth](https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/), nvidia.com, 20224. [DGX A100 review: Throughput and Hardware Summary](https://www.microway.com/hpc-tech-tips/dgx-a100-review-throughput-and-hardware-summary/), 20205. [Understanding NVIDIA GPU Performance: Utilization vs. Saturation](http://arthurchiao.art/blog/understanding-gpu-performance/), 20236. [GPU Performance (Data Sheets) Quick Reference (2023)](http://arthurchiao.art/blog/gpu-data-sheets/)</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-智算中心的建设成本</title>
    <link href="/2024/10/17/01_%E8%BF%90%E7%BB%B4/06-%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83/01-%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BB%BA%E8%AE%BE%E6%88%90%E6%9C%AC/"/>
    <url>/2024/10/17/01_%E8%BF%90%E7%BB%B4/06-%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83/01-%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BB%BA%E8%AE%BE%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：公众号：IT技术分享-老张</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>智算中心的建设成本大家都比较清楚了，以H100千卡集群为例，整体预算要3个多亿，其中<strong>H100整机的八卡整机</strong>占比最高，目前市场价<strong>一台约240w</strong>，仅128台H100就要3个亿，还有配套的IB或者Roce网络也需要2-3千万，以及存储系统（并行文件存储）、安全配套设备以及运维运营平台等费用也需要1千万左右，如果涉及液冷方案还需增加1千万左右，所以<strong>H100千卡的预算通常会在3.5-4亿区间</strong>，除了建设成本，运营成本也非常重要，到底有哪些方面组成呢？</p><p><strong>一、运营成本组成1-设备的折旧</strong></p><p>我们知道这类重资产的H100整机是有使用寿命年限的，以算力租赁维度，通常规划5年的回本周期，也就是5年内产生的收益要大于等于设备本身的价值才不至于亏损，举例来说，一台240w，折算到5年的60个月里，折旧的成本每台每月就是4万，当然也有客户会计算5年后的设备残值，按照采购价10-20%作为收益的组成（这个要看未来几年新品迭代的速度，以及对训练算力机的需求）。</p><p><strong>二、运营成本组成2-机房日常运营投入</strong></p><p>这个属于常规运营成本，设备要运行就必须有配套的机房环境，比如IDC的机柜的租金、水电相关的能源功耗成本、散热成本、液冷改造成本等等；</p><p>目前<strong>H100整机一台就10.2Kw</strong>，传统的IDC机房单机柜供电往往都是4-8kw，往往需要对传统数据中心机房的<strong>供电系统进行改造</strong>，液冷也是如此，如果需要液冷方案还要配套液冷的系统。</p><p><strong>三、运营成本组成3-人员的成本</strong></p><p>人员成本在IDC服务业（奥飞数据统计）约占业务成本的3%，占IDC服务收入的比例约2%；但是智算中心我认为要略高于此，因为新设备、新方案、新业务对相应人员的要求也更高了，这部分预计占业务成本的3-4%。</p><p><strong>四、运营成本组成4-其他隐形成本</strong></p><p>1、H100这类特殊机型的维修不及时带来的损失也较大，不同的采购渠道获得的售后时效也不同，维修期间的租赁收益是零，带来的损失也算运营成本的一部分。</p><p>2、市场宣传推广、目前智算中心市场的租赁业务竞争激励，需要投入市场营销费用，这个也算是运营过程中的成本。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（六）智算中心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-一文搞懂H100H200，B100B200，B200GB200，HGXDGX的区别和参数</title>
    <link href="/2024/10/17/01_%E8%BF%90%E7%BB%B4/06-%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83/02-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82H100H200%EF%BC%8CB100B200%EF%BC%8CB200GB200%EF%BC%8CHGXDGX%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8F%82%E6%95%B0/"/>
    <url>/2024/10/17/01_%E8%BF%90%E7%BB%B4/06-%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83/02-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82H100H200%EF%BC%8CB100B200%EF%BC%8CB200GB200%EF%BC%8CHGXDGX%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载至公众号：IT技术分享-老张</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近英伟达GPU热点一直很高，尤其是对H200，B200的讨论，当然也包括GB200，DGX及HGX等，我简单汇总了以下几个问题，我们今天展开聊聊！</p><ul><li>1、你清楚H200比H100升级了什么吗？B200与B100的区别呢？</li><li>2、B200和GB200名字看着很像，有何区别与联系呢？</li><li>3、我们常见到HGX和DGX，他们是什么产品以及两者间的区别和联系？</li><li>4、HGX H200\B200，DGX H100\B200的官方参数情况</li></ul><h1 id="一、英伟达H200和H100的变化"><a href="#一、英伟达H200和H100的变化" class="headerlink" title="一、英伟达H200和H100的变化"></a>一、英伟达H200和H100的变化</h1><p>作为H100的升级款产品，H200相信大家的关注度挺高，其实从整体参数方面H200只升级了GPU显存相关内容，GPU单卡从80G HBM3升级到了141G HBM3e（显存容量和类型有变化），同时显存带宽从3.35TB&#x2F;s提升至4.8TB&#x2F;s，整体参数对比如下：</p><p><img src="/./../../../img/image-20241017133750456.png" alt="H100对比H200"></p><h1 id="二、英伟达B200和B100的区别"><a href="#二、英伟达B200和B100的区别" class="headerlink" title="二、英伟达B200和B100的区别"></a>二、英伟达B200和B100的区别</h1><p>B200和B100都是基于英伟达最新一代Blackwell架构的数据中心GPU，英伟达目前的市场策略是以B200为主，从整体参数上，两者除了显存的规格一致，其他的不同精度的算力、功率有所不同，具体可以见下图，供参考，可以看到B100的TDP是700W，有传言说是为了兼容现有H100的服务器平台（机头）做的设计，但是从综合性能上B200更优，比如FP16算力是H100的2倍以上，同时TDP也提升到了单卡1000W，所以B200的服务器平台需重新设计，与H100的不兼容了。</p><p><img src="/./../../../img/image-20241017133929287.png" alt="GB、B系列显卡对比"></p><h1 id="三、B200和GB200，HGX和DGX的区别"><a href="#三、B200和GB200，HGX和DGX的区别" class="headerlink" title="三、B200和GB200，HGX和DGX的区别"></a>三、B200和GB200，HGX和DGX的区别</h1><p>1、认识B200和GB200</p><p>从名字上看GB200和B200很容易弄混，尤其是新手朋友，便于大家理解我专门找了2张图，最左侧老黄手持就是B200，是标准的英伟达基于Blackwell架构的GPU芯片，而GB200是芯片的“组合”，如中间图所示，是通过一个板子将2颗B200加上一颗Grace CPU（72核心的ARM架构处理器）组合而成，我们一般GPU服务器上是没法用的，定位是专用的“产品”，是英伟达为了搭建NVL72这类GPU“方案级产品”做的设计，如右图所示它是NVL72的算力节点，包括2个GB200。</p><p><img src="/./../../../img/image-20241017134100861.png" alt="image-20241017134100861"></p><p>2、认识HGX和DGX</p><p>很多做英伟达GPU生意的朋友肯定都知道HGX，就是我们所说的“模组”，一套HGX 100模组价格高达200w+，如下图所示，HGX产品的核心是8块GPU，通过底板进行整合，同时也集成了NVLink技术和NVLink SW的芯片。这个“大家伙”是英伟达设计的，是H100 SXM GPU直接提供给服务器的厂商的“最小形态”，当然它是无法独立工作的，因为他就是一个“逻辑的大GPU”必须要和服务器平台（机头）组合才能形成一台完整的GPU服务器。</p><p><img src="/./../../../img/image-20241017134151513.png" alt="image-20241017134151513"></p><p>DGX是英伟达品牌的GPU服务器，如下图所示，除了包括最核心的HGX模组外，配套了服务器该有的机箱、主板、电源、CPU、内存、硬盘、网卡等部件。它和我们平时看到的各大服务器厂商推出的基于HGX模组的GPU服务器并无本质区别，英伟达推出DGX 整机和其他服务器厂商形成了竞争关系（又是供应商，又是对手，比较尴尬），一是DGX价格偏高，二是为了避免和服务器厂商的市场冲突，除特定客户外，一般很少见到有主动采购DGX产品的。</p><p><img src="/./../../../img/image-20241017134239527.png" alt="image-20241017134239527"></p><h1 id="四、HGX-H100和H200的参数情况"><a href="#四、HGX-H100和H200的参数情况" class="headerlink" title="四、HGX H100和H200的参数情况"></a>四、HGX H100和H200的参数情况</h1><p>以下图片截自英伟达的官方彩页，文章最后我会提供资料获取的方式。</p><p>1、HGX H100、HGX H200的参数及对比情况</p><p><img src="/./../../../img/image-20241017134305642.png" alt="image-20241017134305642"></p><p>2、英伟达DGX H100的参数情况</p><p><img src="/./../../../img/image-20241017134316469.png" alt="image-20241017134316469"></p><p>3、英伟达DGX B200的参数情况</p><p><img src="/./../../../img/image-20241017134412918.png" alt="image-20241017134412918"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（六）智算中心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mellanox网卡安装驱动</title>
    <link href="/2024/09/09/06_%E6%9D%82%E8%AE%B0/Mellanox%E7%BD%91%E5%8D%A1%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8/"/>
    <url>/2024/09/09/06_%E6%9D%82%E8%AE%B0/Mellanox%E7%BD%91%E5%8D%A1%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Mellanox网卡安装驱动"><a href="#Mellanox网卡安装驱动" class="headerlink" title="Mellanox网卡安装驱动"></a>Mellanox网卡安装驱动</h1><p>文档作用：</p><p>​在旧版本操作系统中（如Cenos7.4），部分网卡不能识别出来，需要手动安装驱动。</p><h1 id="一、查看网卡"><a href="#一、查看网卡" class="headerlink" title="一、查看网卡"></a>一、查看网卡</h1><p>BMC界面查看安装了7张网卡，共13个网口</p><p><img src="/../../img/image-20240905162633122.png" alt="image-20240905162633122"></p><p>在系统中使用lspci也可以看到13个网口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# lspci | grep Mellanox04:00.0 Ethernet controller: Mellanox Technologies MT27800 Family [ConnectX-5]04:00.1 Ethernet controller: Mellanox Technologies MT27800 Family [ConnectX-5]08:00.0 Ethernet controller: Mellanox Technologies MT27710 Family [ConnectX-4 Lx]08:00.1 Ethernet controller: Mellanox Technologies MT27710 Family [ConnectX-4 Lx]2d:00.0 Ethernet controller: Mellanox Technologies MT27800 Family [ConnectX-5]5b:00.0 Ethernet controller: Mellanox Technologies MT288415b:00.1 Ethernet controller: Mellanox Technologies MT288415c:00.0 Ethernet controller: Mellanox Technologies MT288415c:00.1 Ethernet controller: Mellanox Technologies MT2884196:00.0 Ethernet controller: Mellanox Technologies MT2884196:00.1 Ethernet controller: Mellanox Technologies MT2884197:00.0 Ethernet controller: Mellanox Technologies MT2884197:00.1 Ethernet controller: Mellanox Technologies MT28841</code></pre></div></figure><p>但是使用命令查看网口，只可以看到5个ens网口，有8个没有，需要手动安装驱动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 12: ens19f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 10003: ens19f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 10004: ens21f0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 10005: ens21f1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 10006: ens12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 10007: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN qlen 10008: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN qlen </code></pre></div></figure><h1 id="二、安装驱动"><a href="#二、安装驱动" class="headerlink" title="二、安装驱动"></a>二、安装驱动</h1><h2 id="2-1-下载驱动"><a href="#2-1-下载驱动" class="headerlink" title="2.1 下载驱动"></a>2.1 下载驱动</h2><p>驱动下载地址：</p><blockquote><p><a href="https://developer.nvidia.com/networking/ethernet-software">https://developer.nvidia.com/networking/ethernet-software</a></p></blockquote><p>EN版本只包含网卡驱动，OFED版本既有驱动还有部分配套软件，建议下载OFED版本。</p><p><img src="/../../img/image-20240905163247783.png" alt="image-20240905163247783"></p><p>然后选择对应的系统和架构，下载安装包</p><p><img src="/../../img/image-20240905163325019.png" alt="image-20240905163325019"></p><p>查看操作系统版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# cat &#x2F;etc&#x2F;redhat-release CentOS Linux release 7.4.1708 (Core) </code></pre></div></figure><h2 id="2-2-安装驱动-EN"><a href="#2-2-安装驱动-EN" class="headerlink" title="2.2 安装驱动-EN"></a>2.2 安装驱动-EN</h2><p>1、解压安装包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost Downloads]# lsmlnx-en-23.10-3.2.2.0-rhel7.4-x86_64.tgz[root@localhost Downloads]# tar -vxf mlnx-en-23.10-3.2.2.0-rhel7.4-x86_64.tgz </code></pre></div></figure><p>2、进入目录，执行安装程序</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost Downloads]# cd mlnx-en-23.10-3.2.2.0-rhel7.4-x86_64&#x2F;[root@localhost mlnx-en-23.10-3.2.2.0-rhel7.4-x86_64]# lscommon_installers.pl  common.pl  create_mlnx_ofed_installers.pl  distro  install  is_kmp_compat.sh  LICENSE  mlnx_add_kernel_support.sh  RPM-GPG-KEY-Mellanox  RPMS  RPMS_ETH  src  uninstall.sh[root@localhost mlnx-en-23.10-3.2.2.0-rhel7.4-x86_64]# .&#x2F;install Logs dir: &#x2F;tmp&#x2F;mlnx-en.55110.logsGeneral log file: &#x2F;tmp&#x2F;mlnx-en.55110.logs&#x2F;general.logVerifying KMP rpms compatibility with target kernel...This program will install the mlnx-en package on your machine.Note that all other Mellanox, OEM, OFED, RDMA or Distribution IB packages will be removed.Those packages are removed due to conflicts with mlnx-en, do not reinstall them.# 这里输入y即可Do you want to continue?[y&#x2F;N]:y</code></pre></div></figure><p>3、等安装完，需要执行提示命令，重新加载新驱动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;init.d&#x2F;mlnx-en.d restart</code></pre></div></figure><p>注意，重新加载驱动后，网卡名会变化，对应的网卡配置文件也要修改才行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如，ens19f0变为ens19f0np09: ens19f0np0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</code></pre></div></figure><p>4、重新查看网卡数量，可以看到变为13个，恢复正常。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">9: ens19f0np0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 100010: ens19f1np1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 100011: ens21f0np0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100012: ens21f1np1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100013: ens12np0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 100014: ens13f0np0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100015: ens13f1np1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100016: ens14f0np0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100017: ens14f1np1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100018: ens15f0np0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100019: ens15f1np1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100020: ens16f0np0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 100021: ens16f1np1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN qlen 1000</code></pre></div></figure><h2 id="2-2-安装驱动-OFED"><a href="#2-2-安装驱动-OFED" class="headerlink" title="2.2 安装驱动-OFED"></a>2.2 安装驱动-OFED</h2><p>解压后执行安装程序</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# tar -vxf MLNX_OFED_LINUX-23.10-3.2.2.0-rhel7.4-x86_64[root@localhost ~]# cd MLNX_OFED_LINUX-23.10-3.2.2.0-rhel7.4-x86_64&#x2F; [root@localhost MLNX_OFED_LINUX-23.10-3.2.2.0-rhel7.4-x86_64]# .&#x2F;mlnxofedinstall</code></pre></div></figure><p>如果缺少依赖，按提示安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">General log file: &#x2F;tmp&#x2F;MLNX_OFED_LINUX.74618.logs&#x2F;general.logError: One or more required packages for installing MLNX_OFED_LINUX are missing.Please install the missing packages using your Linux distribution Package Management tool.Run:yum install tcl tk</code></pre></div></figure><p>然后继续安装，输入y即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost MLNX_OFED_LINUX-23.10-3.2.2.0-rhel7.4-x86_64]# .&#x2F;mlnxofedinstall Logs dir: &#x2F;tmp&#x2F;MLNX_OFED_LINUX.75823.logsGeneral log file: &#x2F;tmp&#x2F;MLNX_OFED_LINUX.75823.logs&#x2F;general.logVerifying KMP rpms compatibility with target kernel...This program will install the MLNX_OFED_LINUX package on your machine.Note that all other Mellanox, OEM, OFED, RDMA or Distribution IB packages will be removed.Those packages are removed due to conflicts with MLNX_OFED_LINUX, do not reinstall them.Do you want to continue?[y&#x2F;N]:y</code></pre></div></figure><p>安装完也一样重新加载驱动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Log File: &#x2F;tmp&#x2F;Fpnr9q8X6mReal log file: &#x2F;tmp&#x2F;MLNX_OFED_LINUX.75823.logs&#x2F;fw_update.logFailed to update Firmware.See &#x2F;tmp&#x2F;MLNX_OFED_LINUX.75823.logs&#x2F;fw_update.logTo load the new driver, run:&#x2F;etc&#x2F;init.d&#x2F;openibd restart</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day79-LVS与JumpServer</title>
    <link href="/2024/08/21/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day79-LVS%E4%B8%8EJumpServer/"/>
    <url>/2024/08/21/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day79-LVS%E4%B8%8EJumpServer/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li>LVS负载均衡</li><li>OpenVPN加密通信隧道</li><li>JumpServer跳板机</li></ul><h1 id="一、负载均衡介绍"><a href="#一、负载均衡介绍" class="headerlink" title="一、负载均衡介绍"></a>一、负载均衡介绍</h1><h2 id="1-1-常见负载均衡对比"><a href="#1-1-常见负载均衡对比" class="headerlink" title="1.1 常见负载均衡对比"></a>1.1 常见负载均衡对比</h2><table><thead><tr><th>常见负载均衡对比</th><th>优势</th><th>缺点</th></tr></thead><tbody><tr><td>硬件：如F5负载均衡</td><td>性能好、购买有技术支持</td><td>价格昂贵，且一次需要购买2台凑成1对。</td></tr><tr><td>LVS</td><td>工作在4层，效率极其高</td><td>需要部署维护(运维成本较高)</td></tr><tr><td>Nginx&#x2F;Tengine&#x2F;Openresty(lua)</td><td>使用简单，支持4层(1.9版本后支持)和7层负载均衡、反向代理、缓存、流量镜像(mirror)</td><td>处理数据为 “代理模式”，即替用户去查找，找到后发送给用户。在并发较大(1w以 上)时会卡</td></tr><tr><td>Haproxy</td><td>相对复杂 支持4层和7层 反向代理 动态加载配置文件.</td><td>处理数据为“代理模式”，并发较大(1w以上，但比nginx多) 时会卡</td></tr><tr><td>云服务：如clb(slb)</td><td>支持4层和7层</td><td>只能支持url或者域名的转发</td></tr><tr><td>ALB</td><td>支持更多的7层的转发功能 ，如基于用户请求头 http_user_agent、用户语言、 镜像流量(申请,深圳)</td><td>只支持7层负载均衡</td></tr></tbody></table><p>四层负载均衡和七层负载均衡的对比：</p><ul><li>四层负载均衡：在传输层，负载均衡最多到端口级别</li><li>七层负载均衡，在应用层，URL、URI 转发、HTTP HTTPS</li></ul><h2 id="1-2-反向代理和负载均衡的区别"><a href="#1-2-反向代理和负载均衡的区别" class="headerlink" title="1.2 反向代理和负载均衡的区别"></a>1.2 反向代理和负载均衡的区别</h2><p>反向代理：Nginx &#x2F; Haproxy做<strong>代理</strong>，代替用户找，找到后发给用户</p><p>负载均衡：VS对数据进行<strong>转发</strong></p><p><img src="/../../../img/image-20240816142138132.png" alt="image-20240816142138132"></p><h2 id="1-3-ARP地址解析"><a href="#1-3-ARP地址解析" class="headerlink" title="1.3 ARP地址解析"></a>1.3 ARP地址解析</h2><p>DNS域名解析：域名 解析成 IP</p><p>ARP地址解析：IP 解析成  Mac地址</p><p><img src="/../../../img/image-20240816144825521.png" alt="image-20240816144825521"></p><h3 id="1-3-1-ARP欺骗"><a href="#1-3-1-ARP欺骗" class="headerlink" title="1.3.1 ARP欺骗"></a>1.3.1 ARP欺骗</h3><p><img src="/../../../img/image-20240816145003736.png" alt="image-20240816145003736"></p><h1 id="二、LVS快速上手"><a href="#二、LVS快速上手" class="headerlink" title="二、LVS快速上手"></a>二、LVS快速上手</h1><h2 id="2-1-LVS概述"><a href="#2-1-LVS概述" class="headerlink" title="2.1 LVS概述"></a>2.1 LVS概述</h2><p>LVS的工作模式：</p><ul><li>DR 模式</li><li>NAT 模式</li><li>TUN隧道模式</li><li>FLL NAT 完全NAT模式</li></ul><p>关键词：</p><table><thead><tr><th>名称</th><th>单词</th><th>含义</th></tr></thead><tbody><tr><td>CIP</td><td>client ip</td><td>客户端ip地址</td></tr><tr><td>VIP</td><td>Virtual ip</td><td>虚拟ip</td></tr><tr><td>DIP</td><td>director ip</td><td>负载均衡本身的ip</td></tr><tr><td>RS服务器</td><td>real server</td><td>真实服务器 处理用户请求.</td></tr><tr><td>RIP</td><td>Real erver IP</td><td>real server ip 真实服务器的ip地址</td></tr></tbody></table><p><img src="/../../../img/image-20240816151056982.png" alt="image-20240816151056982"></p><h2 id="2-2-LVS-DR模式上手"><a href="#2-2-LVS-DR模式上手" class="headerlink" title="2.2 LVS-DR模式上手"></a>2.2 LVS-DR模式上手</h2><h3 id="2-2-1-环境准备"><a href="#2-2-1-环境准备" class="headerlink" title="2.2.1 环境准备"></a>2.2.1 环境准备</h3><table><thead><tr><th>主机</th><th>作用</th><th>真实ip</th><th>虚拟IP（vip）</th></tr></thead><tbody><tr><td>lb01</td><td>LVS主服务器</td><td>10.0.0.5</td><td>10.0.0.3</td></tr><tr><td>web01</td><td>nginx-01</td><td>10.0.0.7</td><td>数据转向10.0.0.3</td></tr><tr><td>web02</td><td>nginx-02</td><td>10.0.0.8</td><td>数据转向10.0.0.3</td></tr></tbody></table><h3 id="2-2-2-前提处理"><a href="#2-2-2-前提处理" class="headerlink" title="2.2.2 前提处理"></a>2.2.2 前提处理</h3><p>1、web01和web02准备站点</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 站点文件 [root@web01 &#x2F;server&#x2F;code&#x2F;lvs]#cat index.html lvs web01[root@web02 ~]#cat &#x2F;server&#x2F;code&#x2F;lvs&#x2F;index.html lvs web02# Nginx虚拟主机，web01&#x2F;02相同[root@web02 ~]#cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;lvs.test.cn.conf server &#123;  listen 80;  server_name lvs.test.cn;  root &#x2F;server&#x2F;code&#x2F;lvs;  location &#x2F; &#123;    index index.html;  &#125;&#125;# 重启服务,设置HOSTS，并测试[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]#curl -H Host:lvs.test.cn 10.0.0.7lvs web01[root@web02 ~]#curl -H Host:lvs.test.cn 10.0.0.8lvs web02</code></pre></div></figure><p>2、lb01和lb02关闭不需要的服务，安装LVS</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 关闭keepalived和nginx，防止影响负载均衡[root@lb01 ~]#systemctl stop keepalived nginx[root@lb01 ~]#systemctl disable keepalived nginx# 安装LVS[root@lb01 ~]#yum install -y ipvsadm# 检查模块是否已加载[root@lb01 ~]#lsmod | grep ip_vsip_vs                 145458  0 nf_conntrack          139264  1 ip_vslibcrc32c              12644  3 xfs,ip_vs,nf_conntrack</code></pre></div></figure><h3 id="2-2-3-DR模式配置流程"><a href="#2-2-3-DR模式配置流程" class="headerlink" title="2.2.3 DR模式配置流程"></a>2.2.3 DR模式配置流程</h3><h4 id="2-2-3-1-LVS服务器配置"><a href="#2-2-3-1-LVS服务器配置" class="headerlink" title="2.2.3.1 LVS服务器配置"></a>2.2.3.1 LVS服务器配置</h4><p>1、手动添加VIP，后面是由Keepalived生成（需先把网卡名改成eth0）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]#ifconfig eth0:0 10.0.0.3 netmask 255.255.255.0</code></pre></div></figure><p>永久保存</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts]#cat ifcfg-eth0:0DEVICE&#x3D;eth0:0IPADDR&#x3D;10.0.0.3NETMASK&#x3D;255.255.255.0ONBOOT&#x3D;yesNAME&#x3D;eth0:0</code></pre></div></figure><p>2、添加规则 (类似于nginx的upstream)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipvsadm -A -t 10.0.0.3:80 -s wrr#-A --add-service 创建池塘#-t --tcp-service tcp协议# 10.0.0.3:80 组名称# -s scheduler 轮询算法 wrr weight 加权轮询 rrlc wlc# -p persistent 会话保持时间（时间别设置太长，不然测试xiao&#39;guo）</code></pre></div></figure><p>3、添加规则（类似于向upstream中添加server）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipvsadm -a -t 10.0.0.3:80 -r 10.0.0.7:80 -g -w 1ipvsadm -a -t 10.0.0.3:80 -r 10.0.0.8:80 -g -w 2# -a 添加 rs服务器# -t tcp协议# -r 指定rs服务器ip# -g --gatewaying dr模式 默认的# -w 权重</code></pre></div></figure><blockquote><p>类似于使用Nginx配置负载均衡</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;upstream web_pools &#123;server 10.0.0.7:80;server 10.0.0.8:80;&gt;&#125;&gt;server &#123;location &#x2F; &#123;proxy_pass http:&#x2F;&#x2F;web_pools;&#125; &gt;&#125;</code></pre></div></figure></blockquote><p>4、查看LVS规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]#ipvsadm# 或者[root@lb01 ~]#ipvsadm -ln</code></pre></div></figure><h4 id="2-2-3-2-后端web服务器配置"><a href="#2-2-3-2-后端web服务器配置" class="headerlink" title="2.2.3.2 后端web服务器配置"></a>2.2.3.2 后端web服务器配置</h4><p>1、lo网卡绑定</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]#ifconfig lo:1 10.0.0.3 netmask 255.255.255.255  </code></pre></div></figure><p>永久保存</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-lo:1DEVICE&#x3D;lo:1IPADDR&#x3D;10.0.0.3NETMASK&#x3D;255.255.255.255ONBOOT&#x3D;yesNAME&#x3D;loopback</code></pre></div></figure><p>重启网络并查看</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl restart network[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]#ip a s lo1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1&#x2F;8 scope host lo       valid_lft forever preferred_lft forever    inet 10.0.0.3&#x2F;32 brd 10.0.0.3 scope global lo:1       valid_lft forever preferred_lft forever    inet6 ::1&#x2F;128 scope host        valid_lft forever preferred_lft forever</code></pre></div></figure><p>2、抑制ARP解析</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt;&gt;&#x2F;etc&#x2F;sysctl.conf&lt;&lt;EOFnet.ipv4.conf.all.arp_ignore &#x3D; 1net.ipv4.conf.all.arp_announce &#x3D; 2net.ipv4.conf.lo.arp_ignore &#x3D; 1net.ipv4.conf.lo.arp_announce &#x3D; 2EOF# 查看[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]#sysctl -pnet.ipv4.conf.all.arp_ignore &#x3D; 1net.ipv4.conf.all.arp_announce &#x3D; 2net.ipv4.conf.lo.arp_ignore &#x3D; 1net.ipv4.conf.lo.arp_announce &#x3D; 2</code></pre></div></figure><h4 id="2-2-3-3-测试"><a href="#2-2-3-3-测试" class="headerlink" title="2.2.3.3 测试"></a>2.2.3.3 测试</h4><p>多次访问<a href="http://10.0.0.3:80，应该指向不同的web服务端">http://10.0.0.3:80，应该指向不同的web服务端</a></p><p><img src="/../../../img/image-20240820151554150.png" alt="image-20240820151554150"></p><h3 id="2-2-4-LVS规则的备份和恢复"><a href="#2-2-4-LVS规则的备份和恢复" class="headerlink" title="2.2.4 LVS规则的备份和恢复"></a>2.2.4 LVS规则的备份和恢复</h3><p>1、保存配置和还原</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 导出配置ipvsadm-save -n &gt;&#x2F;root&#x2F;ipvs.txt# 还原配置ipvsadm-restore &lt;&#x2F;root&#x2F;ipvs.txt</code></pre></div></figure><p>2、清空LVS规则，记得清空前备份</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]#ipvsadm -C</code></pre></div></figure><h2 id="2-3-LVS与keepalived结合"><a href="#2-3-LVS与keepalived结合" class="headerlink" title="2.3 LVS与keepalived结合"></a>2.3 LVS与keepalived结合</h2><h3 id="2-3-1-环境准备"><a href="#2-3-1-环境准备" class="headerlink" title="2.3.1 环境准备"></a>2.3.1 环境准备</h3><table><thead><tr><th>主机</th><th>作用</th><th>真实ip</th><th>虚拟IP（vip）</th></tr></thead><tbody><tr><td>lb01</td><td>LVS主服务器</td><td>10.0.0.5</td><td>10.0.0.3</td></tr><tr><td>lb01</td><td>LVS备服务器</td><td>10.0.0.6</td><td>10.0.0.3</td></tr><tr><td>web01</td><td>nginx-01</td><td>10.0.0.7</td><td>数据转向10.0.0.3</td></tr><tr><td>web02</td><td>nginx-02</td><td>10.0.0.8</td><td>数据转向10.0.0.3</td></tr></tbody></table><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">                              |             +----------------+-----------------+             |                                  |10.0.0.5     |----       VIP:10.0.0.3       ----|     10.0.0.6     +-------+--------+                +--------+-------+     |     DS1       |                |       DS2      |     | LVS+Keepalived |                | LVS+Keepalived |     +-------+--------+                +--------+-------+             |                |             +----------------+-----------------+                              |  +------------+              |               +------------+  |     RS1    |10.0.0.7      |       10.0.0.8|     RS2    |  | Web Server +--------------+---------------+ Web Server |  +------------+                              +------------+</code></pre></div></figure><h3 id="2-3-2-DS服务器配置"><a href="#2-3-2-DS服务器配置" class="headerlink" title="2.3.2 DS服务器配置"></a>2.3.2 DS服务器配置</h3><h4 id="1）DS1配置LVS-Keepalived"><a href="#1）DS1配置LVS-Keepalived" class="headerlink" title="1）DS1配置LVS+Keepalived"></a>1）DS1配置LVS+Keepalived</h4><blockquote><p>配置前，先清空LVS的规则和eth0:0接口，因为keepalived会自动创建</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf! Configuration File for keepalivedglobal_defs &#123;  router_id LVS_DEVEL&#125;vrrp_instance VI_1 &#123;    state MASTER            # 两个 DS，一个为 MASTER 一个为 BACKUP    interface eth0        # 当前 IP 对应的网络接口，通过 ifconfig 查询    virtual_router_id 62    # 虚拟路由 ID(0-255)，在一个 VRRP 实例中主备服务器 ID 必须一样    priority 200            # 优先级值设定：MASTER 要比 BACKUP 的值大    advert_int 1            # 通告时间间隔：单位秒，主备要一致    authentication &#123;        # 认证机制，主从节点保持一致即可        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        10.0.0.3       # VIP，可配置多个    &#125;&#125;# LB 配置virtual_server 10.0.0.3 80  &#123;    delay_loop 3                    # 设置健康状态检查时间    lb_algo rr                      # 调度算法，这里用了 rr 轮询算法    lb_kind DR                      # 这里测试用了 Direct Route 模式    persistence_timeout 50          # 持久连接超时时间    protocol TCP    real_server 10.0.0.7 80 &#123;        weight 1        TCP_CHECK &#123;            connect_timeout 10　　　            retry 3　　　　　　      # 旧版本为 nb_get_retry             delay_before_retry 3　　　            connect_port 80        &#125;    &#125;    real_server 10.0.0.8 80 &#123;        weight 1        TCP_CHECK &#123;            connect_timeout 10            retry 3            delay_before_retry 3            connect_port 80        &#125;    &#125;&#125;</code></pre></div></figure><h4 id="2）DS2配置LVS-Keepalived"><a href="#2）DS2配置LVS-Keepalived" class="headerlink" title="2）DS2配置LVS+Keepalived"></a>2）DS2配置LVS+Keepalived</h4><p>把配置文件中的<code>MASTER</code>改为<code>BACKUP</code>即可</p><h3 id="2-3-3-RS服务器配置"><a href="#2-3-3-RS服务器配置" class="headerlink" title="2.3.3 RS服务器配置"></a>2.3.3 RS服务器配置</h3><p>两台服务器参考<code>2.2.3.2</code>章节配置即可</p><h3 id="2-3-4-测试"><a href="#2-3-4-测试" class="headerlink" title="2.3.4 测试"></a>2.3.4 测试</h3><h4 id="1）-keepalived的主备切换"><a href="#1）-keepalived的主备切换" class="headerlink" title="1） keepalived的主备切换"></a>1） keepalived的主备切换</h4><p>启动服务后，默认lb01是主，并且有生成10.0.0.3的网络接口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts]#systemctl status keepalived.service ● keepalived.service - LVS and VRRP High Availability Monitor...Aug 20 16:43:06 lb01 Keepalived_vrrp[5888]: Sending gratuitous ARP on eth0 for 10.0.0.3Aug 20 16:43:11 lb01 Keepalived_vrrp[5888]: VRRP_Instance(VI_1) Sending&#x2F;queueing gratuitous ARPs on eth0 for 10.0.0.3...</code></pre></div></figure><p>lb02为备，不生成10.0.0.3网络接口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb02 ~]#systemctl status keepalived.service ● keepalived.service - LVS and VRRP High Availability Monitor...Aug 20 16:43:06 lb02 Keepalived_vrrp[5049]: VRRP_Instance(VI_1) Entering BACKUP STATE...</code></pre></div></figure><p>关闭lb01的keepalived服务，手动造成故障</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts]#systemctl stop keepalived.service </code></pre></div></figure><p>lb02切换为主，验证成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb02 ~]#systemctl status keepalived.service ● keepalived.service - LVS and VRRP High Availability Monitor...Aug 20 16:55:14 lb02 Keepalived_vrrp[5162]: VRRP_Instance(VI_1) Transition to MASTER STATEAug 20 16:55:15 lb02 Keepalived_vrrp[5162]: Sending gratuitous ARP on eth0 for 10.0.0.3Aug 20 16:55:15 lb02 Keepalived_vrrp[5162]: VRRP_Instance(VI_1) Sending&#x2F;queueing gratuitous ARPs on eth0 for 10.0.0.3Aug 20 16:55:15 lb02 Keepalived_vrrp[5162]: Sending gratuitous ARP on eth0 for 10.0.0.3</code></pre></div></figure><h4 id="2）-LVS的负载均衡测试"><a href="#2）-LVS的负载均衡测试" class="headerlink" title="2） LVS的负载均衡测试"></a>2） LVS的负载均衡测试</h4><p>访问<a href="http://10.0.0.3:80，可见访问web01和web02循环。">http://10.0.0.3:80，可见访问web01和web02循环。</a></p><p>查看LVS规则流量信息，确保两条路都有流量，验证成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts]#ipvsadm -ln --statsIP Virtual Server version 1.2.1 (size&#x3D;4096)Prot LocalAddress:Port               Conns   InPkts  OutPkts  InBytes OutBytes  -&gt; RemoteAddress:PortTCP  10.0.0.3:80                         8      132        0    34840        0  -&gt; 10.0.0.7:80                         4       90        0    24476        0  -&gt; 10.0.0.8:80                         4       42        0    10364        0</code></pre></div></figure><h1 id="二、加密隧道服务"><a href="#二、加密隧道服务" class="headerlink" title="二、加密隧道服务"></a>二、加密隧道服务</h1><h2 id="2-1-应用场景"><a href="#2-1-应用场景" class="headerlink" title="2.1 应用场景"></a>2.1 应用场景</h2><p>两点之间如何传输数据最安全？</p><ul><li>方案1：铺设专线，成本高昂</li><li>方案2：使用硬件3层路由、硬件VPN设备（如深信服VPN）</li><li>方案3：使用公有云等商业产品，通过网络传输</li><li>方案4：使用开源软件搭建VPN（如OpenVPN）</li></ul><p>加密隧道服务即是其中的方案4，OpenVPN有如下应用场景：</p><ul><li>运营：通过OpenVPN实现网站安全登录（后台地址，设置为只能通过VPN登录）</li><li>开发：通过OpenVPN实现开发与测试人员连接网站，进行开发测试</li><li>运维：通过OpenVPN连接内网服务器进行管理</li></ul><h2 id="2-2-OpenVPN原理图"><a href="#2-2-OpenVPN原理图" class="headerlink" title="2.2 OpenVPN原理图"></a>2.2 OpenVPN原理图</h2><p><img src="/../../../img/image-20240821133723790.png" alt="image-20240821133723790"></p><h2 id="2-3-OpenVPN快速上手"><a href="#2-3-OpenVPN快速上手" class="headerlink" title="2.3 OpenVPN快速上手"></a>2.3 OpenVPN快速上手</h2><h3 id="2-3-1-环境准备-1"><a href="#2-3-1-环境准备-1" class="headerlink" title="2.3.1 环境准备"></a>2.3.1 环境准备</h3><table><thead><tr><th>主机</th><th>ip</th><th>作用</th></tr></thead><tbody><tr><td>m01</td><td>10.0.0.61  &#x2F; 172.16.1.61</td><td>openvpn server服务端</td></tr><tr><td>db01</td><td>10.0.0.51 &#x2F; 172.16.1.51</td><td>内网服务器</td></tr><tr><td>windows 笔记本</td><td>192.168.1.103</td><td>openvpn客户端</td></tr></tbody></table><h3 id="2-3-2-服务端创建证书"><a href="#2-3-2-服务端创建证书" class="headerlink" title="2.3.2 服务端创建证书"></a>2.3.2 服务端创建证书</h3><h4 id="1）安装工具"><a href="#1）安装工具" class="headerlink" title="1）安装工具"></a>1）安装工具</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装[root@mn01 ~]#yum install -y openvpn easy-rsa</code></pre></div></figure><h4 id="2）创建CA证书"><a href="#2）创建CA证书" class="headerlink" title="2）创建CA证书"></a>2）创建CA证书</h4><p>修改vars文件，配置证书参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 充当权威机构,修改vars文件mkdir -p &#x2F;opt&#x2F;easy-rsacp -a &#x2F;usr&#x2F;share&#x2F;easy-rsa&#x2F;3.0.8&#x2F;* &#x2F;opt&#x2F;easy-rsa&#x2F;cp &#x2F;usr&#x2F;share&#x2F;doc&#x2F;easy-rsa-3.0.8&#x2F;vars.example &#x2F;opt&#x2F;easy-rsa&#x2F;varscat &gt;&#x2F;opt&#x2F;easy-rsa&#x2F;vars&lt;&lt;&#39;EOF&#39;if [ -z &quot;$EASYRSA_CALLER&quot; ]; thenecho &quot;You appear to be sourcing an Easy-RSA &#39;vars&#39; file.&quot; &gt;&amp;2echo &quot;This is no longer necessary and is disallowed. See the section called&quot; &gt;&amp;2echo &quot;&#39;How to use this file&#39; near the top comments for more details.&quot; &gt;&amp;2return 1fiset_var EASYRSA_DN &quot;cn_only&quot;set_var EASYRSA_REQ_COUNTRY &quot;CN&quot;set_var EASYRSA_REQ_PROVINCE &quot;Beijing&quot;set_var EASYRSA_REQ_CITY &quot;Beijing&quot;set_var EASYRSA_REQ_ORG &quot;oldboylinux&quot;set_var EASYRSA_REQ_EMAIL &quot;oldboy@qq.com&quot;set_var EASYRSA_NS_SUPPORT &quot;yes&quot;EOF</code></pre></div></figure><p>初始化</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#.&#x2F;easyrsa init-pki# 初始化完成，显示可以创建CA证书Note: using Easy-RSA configuration from: &#x2F;opt&#x2F;easy-rsa&#x2F;vars# 初始化后的目录，在pki里面init-pki complete; you may now create a CA or requests.Your newly created PKI dir is: &#x2F;opt&#x2F;easy-rsa&#x2F;pki</code></pre></div></figure><p>生成证书</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#.&#x2F;easyrsa build-ca# 需要输入密码和姓名信息</code></pre></div></figure><p>生成后的证书文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#tree...├── pki│   ├── ca.crt# ca证书文件....│   ├── private│   │   └── ca.key# ca私钥....14 directories, 18 files</code></pre></div></figure><h4 id="3）创建server证书"><a href="#3）创建server证书" class="headerlink" title="3）创建server证书"></a>3）创建server证书</h4><p>1、创建server证书请求文件与服务器私钥，nopass表示不加密私钥文件，其他默认即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#.&#x2F;easyrsa gen-req server nopass...Keypair and certificate request completed. Your files are:# req文件为请求文件，用于请求创建证书req: &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;reqs&#x2F;server.req# key文件为server私钥文件key: &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;private&#x2F;server.key</code></pre></div></figure><p>2、给server端证书签名，并生成server证书文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#.&#x2F;easyrsa sign server server...Certificate created at: &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;issued&#x2F;server.crt# 需要输入yes和前面设置的密码</code></pre></div></figure><h4 id="4）创建client证书"><a href="#4）创建client证书" class="headerlink" title="4）创建client证书"></a>4）创建client证书</h4><p>1、创建client证书请求文件和私钥</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#.&#x2F;easyrsa gen-req client nopass...req: &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;reqs&#x2F;client.reqkey: &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;private&#x2F;client.key</code></pre></div></figure><p>2、给client端证书签名，生成client证书文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#.&#x2F;easyrsa sign client client...Certificate created at: &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;issued&#x2F;client.crt</code></pre></div></figure><h4 id="5）创建dh-pem算法文件"><a href="#5）创建dh-pem算法文件" class="headerlink" title="5）创建dh-pem算法文件"></a>5）创建dh-pem算法文件</h4><p>密钥交换时的认证方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#.&#x2F;easyrsa gen-dh...DH parameters of size 2048 created at &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;dh.pem</code></pre></div></figure><h4 id="6）目录汇总"><a href="#6）目录汇总" class="headerlink" title="6）目录汇总"></a>6）目录汇总</h4><p>服务端生成文件的作用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#tree.├── easyrsa├── openssl-easyrsa.cnf├── pki│   ├── ca.crt# CA证书│   ├── certs_by_serial│   │   ├── C3D54868BA8E3E17F9B7413AC6B14344.pem│   │   └── DDF5E7679F3F220F3BB2466868D040F3.pem│   ├── dh.pem# dh算法文件│   ├── index.txt│   ├── index.txt.attr│   ├── index.txt.attr.old│   ├── index.txt.old│   ├── issued│   │   ├── client.crt# client证书│   │   └── server.crt# server证书│   ├── openssl-easyrsa.cnf│   ├── private│   │   ├── ca.key│   │   ├── client.key# server私钥│   │   └── server.key# client私钥...14 directories, 30 files</code></pre></div></figure><h3 id="2-3-3-服务端配置文件，启动服务"><a href="#2-3-3-服务端配置文件，启动服务" class="headerlink" title="2.3.3 服务端配置文件，启动服务"></a>2.3.3 服务端配置文件，启动服务</h3><p>openvpn安装完之后的目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;opt&#x2F;easy-rsa]#cd &#x2F;etc&#x2F;openvpn&#x2F;[root@mn01 &#x2F;etc&#x2F;openvpn]#tree.├── client└── server</code></pre></div></figure><p>创建服务端配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;etc&#x2F;openvpn]#cat server&#x2F;server.confport 1194 #端口proto udp #协议dev tun #采用路由隧道模式tunca ca.crt #ca证书文件位置，放在&#x2F;etc&#x2F;opnevpnr中cert server.crt # 服务端公钥文件key server.key #服务端私钥文件dh dh.pem #加密算法文件server 10.8.0.0 255.255.255.0 #给客户端分配地址池(ip地址范围)，注意：不能和VPN服务器内网网段有相同push &quot;route 172.16.1.0 255.255.255.0&quot; #客户端连接后,推送给客户端的路由规则#ifconfig-pool-persist ipp.txt #地址池记录文件位置 未来让openvpn 客户端固定ip地址使用的.keepalive 10 120 #存活时间，10秒ping一次,120 如未收到响应则视为断线max-clients 100 #最多允许100个客户端连接status &#x2F;var&#x2F;log&#x2F;openvpn-status.log # 服务状态文件存放路径log &#x2F;var&#x2F;log&#x2F;openvpn.log # openvpn日志记录位置verb 3 # verbose日志输出级别 数字越大越详细 最多11(debug)client-to-client # 客户端与客户端之间支持通信persist-key # 通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keys 对私钥进行缓存.persist-tun #检测超时后，重新启动VPN，一直保持tun是linkup的。否则网络会先linkdown然后再linkupduplicate-cn #客户端密钥(证书和私钥)是否可以重复</code></pre></div></figure><p>拷贝证书到对应目录中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;etc&#x2F;openvpn]#cd &#x2F;opt&#x2F;easy-rsa&#x2F;pki&#x2F;[root@mn01 &#x2F;opt&#x2F;easy-rsa&#x2F;pki]#cp  ca.crt  &#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;[root@mn01 &#x2F;opt&#x2F;easy-rsa&#x2F;pki]#cp dh.pem &#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;[root@mn01 &#x2F;opt&#x2F;easy-rsa&#x2F;pki]#cp issued&#x2F;server.crt private&#x2F;server.key &#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;</code></pre></div></figure><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;]#systemctl daemon-reload [root@mn01 &#x2F;]#systemctl enable --now openvpn-server@server</code></pre></div></figure><p>启动后如果设置了密码，需要输入</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;etc&#x2F;openvpn]#ss -lntup |grep 1194Broadcast message from root@mn01 (Wed 2024-08-21 15:35:54 CST):Password entry required for &#39;Enter Private Key Password:&#39; (PID 4787).Please enter password with the systemd-tty-ask-password-agent tool![root@mn01 &#x2F;etc&#x2F;openvpn]#systemd-tty-ask-password-agentEnter Private Key Password: *********</code></pre></div></figure><p>查看进程状态</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;etc&#x2F;openvpn]#ss -lntup |grep 1194udp    UNCONN     0      0         *:1194                  *:*                   users:((&quot;openvpn&quot;,pid&#x3D;4786,fd&#x3D;5))[root@mn01 &#x2F;etc&#x2F;openvpn]#ip a s tun04: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100    link&#x2F;none     inet 10.8.0.1 peer 10.8.0.2&#x2F;32 scope global tun0       valid_lft forever preferred_lft forever    inet6 fe80::34d5:c7f6:e5ac:1b53&#x2F;64 scope link flags 800        valid_lft forever preferred_lft forever</code></pre></div></figure><p>查看路由状态</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;etc&#x2F;openvpn]#route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         10.0.0.2        0.0.0.0         UG    102    0        0 ens3310.0.0.0        0.0.0.0         255.255.255.0   U     102    0        0 ens3310.8.0.0        10.8.0.2        255.255.255.0   UG    0      0        0 tun010.8.0.2        0.0.0.0         255.255.255.255 UH    0      0        0 tun0172.16.1.0      0.0.0.0         255.255.255.0   U     101    0        0 ens36</code></pre></div></figure><h3 id="2-3-4-客户端配置文件，连接访问"><a href="#2-3-4-客户端配置文件，连接访问" class="headerlink" title="2.3.4 客户端配置文件，连接访问"></a>2.3.4 客户端配置文件，连接访问</h3><h4 id="1）安装OpenVPN客户端"><a href="#1）安装OpenVPN客户端" class="headerlink" title="1）安装OpenVPN客户端"></a>1）安装OpenVPN客户端</h4><p>windows下载安装OpenVPN-GUI</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https:&#x2F;&#x2F;openvpn.net&#x2F;community-downloads&#x2F;</code></pre></div></figure><h4 id="2）准备配置文件"><a href="#2）准备配置文件" class="headerlink" title="2）准备配置文件"></a>2）准备配置文件</h4><p>将客户端需要的文件拷贝出来，放到一起</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;tmp]#ls client-gs&#x2F;ca.crt  client.crt  client.key</code></pre></div></figure><p>创建ovpn文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">client #指定当前VPN是客户端dev tun #使用tun隧道传输协议proto udp #使用udp协议传输数据remote 10.0.0.61 1194 #openvpn服务器IP地址端口号resolv-retry infinite #断线自动重新连接，在网络不稳定的情况下非常有用nobind #不绑定本地特定的端口号ca ca.crt #指定CA证书的文件路径cert client.crt #指定当前客户端的证书文件路径key client.key #指定当前客户端的私钥文件路径verb 3 #指定日志文件的记录详细级别，可选0-9，等级越高日志内容越详细persist-key #通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keys</code></pre></div></figure><p>存放的目录可以在OpenVPN客户端中指定</p><p><img src="/../../../img/image-20240821155451333.png" alt="image-20240821155451333"></p><p>全部文件如下</p><p><img src="/../../../img/image-20240821155504577.png" alt="image-20240821155504577"></p><h4 id="3）连接OpenVPN和测试"><a href="#3）连接OpenVPN和测试" class="headerlink" title="3）连接OpenVPN和测试"></a>3）连接OpenVPN和测试</h4><p>右键小图标 — 连接，成功后变为绿色状态</p><p><img src="/../../../img/image-20240821155626815.png" alt="image-20240821155626815"></p><p>测试访问服务端内网的172网段，测试成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 开启VPN可以访问C:\Users\gs&gt;ping 172.16.1.61正在 Ping 172.16.1.61 具有 32 字节的数据:来自 172.16.1.61 的回复: 字节&#x3D;32 时间&lt;1ms TTL&#x3D;64来自 172.16.1.61 的回复: 字节&#x3D;32 时间&lt;1ms TTL&#x3D;64来自 172.16.1.61 的回复: 字节&#x3D;32 时间&#x3D;6ms TTL&#x3D;64来自 172.16.1.61 的回复: 字节&#x3D;32 时间&#x3D;1ms TTL&#x3D;64# 关闭VPN无法访问C:\Users\gs&gt;ping 172.16.1.61正在 Ping 172.16.1.61 具有 32 字节的数据:请求超时。</code></pre></div></figure><h2 id="2-4-OpenVPN连接内网"><a href="#2-4-OpenVPN连接内网" class="headerlink" title="2.4 OpenVPN连接内网"></a>2.4 OpenVPN连接内网</h2><p>应用场景：</p><p>​目前我们可以已经可以通过OpenVPN来连接内网的mn01服务器（172.16.1.61），但是内网的其他的服务器仍是访问不到的，比如db01（172.16.1.51）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[C:\~]$ ping 172.16.1.51正在 Ping 172.16.1.51 具有 32 字节的数据:请求超时。请求超时。</code></pre></div></figure><p>原因是什么？</p><ul><li>流量可以过去，但是回来没有路由，过不来</li></ul><p>让我们来解决这个问题吧！</p><p>1、服务端mn01：开启内核转发功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;tmp]#echo &#39;net.ipv4.ip_forward &#x3D; 1&#39; &gt;&gt;&#x2F;etc&#x2F;sysctl.conf[root@mn01 &#x2F;tmp]#sysctl -pnet.ipv4.ip_forward &#x3D; 1</code></pre></div></figure><p>2、内网服务器db01：添加路由规则（回来的路由）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]#route add -net 10.8.0.0&#x2F;24 gw 172.16.1.61</code></pre></div></figure><p>OK，再试试，已经通了！</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[C:\~]$ ping 172.16.1.51正在 Ping 172.16.1.51 具有 32 字节的数据:来自 172.16.1.51 的回复: 字节&#x3D;32 时间&#x3D;1ms TTL&#x3D;63来自 172.16.1.51 的回复: 字节&#x3D;32 时间&#x3D;1ms TTL&#x3D;63来自 172.16.1.51 的回复: 字节&#x3D;32 时间&#x3D;5ms TTL&#x3D;63来自 172.16.1.51 的回复: 字节&#x3D;32 时间&lt;1ms TTL&#x3D;63</code></pre></div></figure><h2 id="2-5-OpenVPN密码认证"><a href="#2-5-OpenVPN密码认证" class="headerlink" title="2.5 OpenVPN密码认证"></a>2.5 OpenVPN密码认证</h2><p>方便设置客户端帐号，如：</p><table><thead><tr><th>用户分离</th></tr></thead><tbody><tr><td><strong>服务端</strong></td></tr><tr><td>ca.crt</td></tr><tr><td>server.key</td></tr><tr><td>server.crt</td></tr><tr><td><strong>客户端-张三</strong></td></tr><tr><td>ca.crt</td></tr><tr><td>zhangsan.key</td></tr><tr><td>zhangsan.crt</td></tr><tr><td>zhagnsan.ovpn</td></tr><tr><td><strong>客户端-托马斯-gao</strong></td></tr><tr><td>ca.crt</td></tr><tr><td>tomcat-gao.key</td></tr><tr><td>tomcat-gao.crt</td></tr><tr><td>tomcat-gao.ovpn</td></tr></tbody></table><h3 id="2-5-1-服务端开启密码认证功能"><a href="#2-5-1-服务端开启密码认证功能" class="headerlink" title="2.5.1 服务端开启密码认证功能"></a>2.5.1 服务端开启密码认证功能</h3><p>1、修改配置文件，添加四行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">script-security 3 # 允许使用自定义脚本auth-user-pass-verify &#x2F;etc&#x2F;openvpn&#x2F;check.sh via-env # 指定认证脚本username-as-common-name # 开启用户密码登陆方式验证client-cert-not-required # 只使用用户密码方式验证登录，不加则代表需要证书和用户名密码双重验证登录</code></pre></div></figure><p>2、创建check.sh脚本文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">#!&#x2F;bin&#x2F;bash############################################################### File Name:check.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################PASSFILE&#x3D;&quot;&#x2F;etc&#x2F;openvpn&#x2F;openvpnfile&quot; #密码文件 用户名 密码明文LOG_FILE&#x3D;&quot;&#x2F;var&#x2F;log&#x2F;openvpn-password.log&quot; #用户登录情况的日志TIME_STAMP&#x3D;&#96;date &quot;+%Y-%m-%d %T&quot;&#96;if [ ! -r &quot;$&#123;PASSFILE&#125;&quot; ]; then  echo &quot;$&#123;TIME_STAMP&#125;: Could not open password file \&quot;$&#123;PASSFILE&#125;\&quot; for reading.&quot; &gt;&gt; $&#123;LOG_FILE&#125;  exit 1fiCORRECT_PASSWORD&#x3D;&#96;awk &#39;!&#x2F;^;&#x2F;&amp;&amp;!&#x2F;^#&#x2F;&amp;&amp;$1&#x3D;&#x3D;&quot;&#39;$&#123;username&#125;&#39;&quot;&#123;print $2;exit&#125;&#39; $&#123;PASSFILE&#125;&#96;if [ &quot;$&#123;CORRECT_PASSWORD&#125;&quot; &#x3D; &quot;&quot; ]; then   echo &quot;$&#123;TIME_STAMP&#125;: User does not exist: username&#x3D;\&quot;$&#123;username&#125;\&quot;, password&#x3D;\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;  exit 1fiif [ &quot;$&#123;password&#125;&quot; &#x3D; &quot;$&#123;CORRECT_PASSWORD&#125;&quot; ]; then   echo &quot;$&#123;TIME_STAMP&#125;: Successful authentication: username&#x3D;\&quot;$&#123;username&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;  exit 0fiecho &quot;$&#123;TIME_STAMP&#125;: Incorrect password: username&#x3D;\&quot;$&#123;username&#125;\&quot;, password&#x3D;\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;exit 1</code></pre></div></figure><p>3、脚本设置执行权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 700 check.sh</code></pre></div></figure><p>4、创建用户和密码文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01 &#x2F;etc&#x2F;openvpn]#cat openvpnfile xiaoming 123xiaozhou 223</code></pre></div></figure><p>5、重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart openvpn-server@server.service</code></pre></div></figure><h3 id="2-5-2-客户端连接"><a href="#2-5-2-客户端连接" class="headerlink" title="2.5.2 客户端连接"></a>2.5.2 客户端连接</h3><h4 id="1）手动输入帐号密码的方式"><a href="#1）手动输入帐号密码的方式" class="headerlink" title="1）手动输入帐号密码的方式"></a>1）手动输入帐号密码的方式</h4><p>修改配置文件，关闭秘钥认证，开启密码认证</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">client #指定当前VPN是客户端dev tun #使用tun隧道传输协议proto udp #使用udp协议传输数据remote 10.0.0.61 1194 #openvpn服务器IP地址端口号resolv-retry infinite #断线自动重新连接，在网络不稳定的情况下非常有用nobind #不绑定本地特定的端口号ca ca.crt #指定CA证书的文件路径;cert client.crt # 注释，因为不需要密钥认证了;key client.key # 注释，因为不需要密钥认证了verb 3 #指定日志文件的记录详细级别，可选0-9，等级越高日志内容越详细persist-key #通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keysauth-user-pass # 开启密码认证</code></pre></div></figure><p>测试连接，会弹出输入帐号密码的框</p><p><img src="/../../../img/image-20240821171242085.png" alt="image-20240821171242085"></p><p>连接成功</p><p><img src="/../../../img/image-20240821171312095.png" alt="image-20240821171312095"></p><h4 id="2）保存到文件的方式"><a href="#2）保存到文件的方式" class="headerlink" title="2）保存到文件的方式"></a>2）保存到文件的方式</h4><p>创建一个保存帐号密码的文件</p><p><img src="/../../../img/image-20240821171537460.png" alt="image-20240821171537460"></p><p>在ovpn配置文件中指定即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">auth-user-pass login.conf</code></pre></div></figure><h1 id="三、JumpServer跳板机"><a href="#三、JumpServer跳板机" class="headerlink" title="三、JumpServer跳板机"></a>三、JumpServer跳板机</h1><p>为什么需要使用跳板机？</p><ul><li>普通日常运维一般使用远程连接工具，一台台登录，这种方式虽然方便，但是不方便做行为审计，如何时何地做了什么？难以批量管理。</li><li>自动化运维推荐使用跳板机管理服务器，不仅方便审计，还可以利用自动化工具对服务器进行批量管理。</li></ul><h2 id="3-1-常用跳板机选择"><a href="#3-1-常用跳板机选择" class="headerlink" title="3.1 常用跳板机选择"></a>3.1 常用跳板机选择</h2><table><thead><tr><th>跳板机</th><th></th></tr></thead><tbody><tr><td>teleport</td><td>功能简单，使用方便，简约风</td></tr><tr><td>Jms(JumpServer)</td><td>功能详细，需要系统配置要求会更高</td></tr><tr><td>其他开源软件…</td><td></td></tr><tr><td>商业软件&#x2F;硬件</td><td></td></tr></tbody></table><h2 id="3-2-实验环境准备"><a href="#3-2-实验环境准备" class="headerlink" title="3.2 实验环境准备"></a>3.2 实验环境准备</h2><table><thead><tr><th>主机</th><th>IP</th><th>用途</th></tr></thead><tbody><tr><td>jms01</td><td>10.0.0.65</td><td>跳板机</td></tr><tr><td>web01</td><td>10.0.0.5</td><td>被管理机器</td></tr><tr><td>web02</td><td>10.0.0.6</td><td>被管理机器</td></tr></tbody></table><h2 id="3-3-快速上手-单机部署"><a href="#3-3-快速上手-单机部署" class="headerlink" title="3.3 快速上手  - 单机部署"></a>3.3 快速上手  - 单机部署</h2><blockquote><p>选用开源软件 JumpServer</p><p>官网：<a href="https://www.jumpserver.org/">https://www.jumpserver.org/</a></p></blockquote><h3 id="3-3-1-下载安装包"><a href="#3-3-1-下载安装包" class="headerlink" title="3.3.1 下载安装包"></a>3.3.1 下载安装包</h3><p>1、下载安装包，上传至服务器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 选择LTS版本：3.10.13 jumpserver-offline-installer-v3.10.13-amd64.tar.gz</code></pre></div></figure><p>2、安装依赖包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y wget curl tar gettext iptables</code></pre></div></figure><h3 id="3-3-2-部署数据库和缓存"><a href="#3-3-2-部署数据库和缓存" class="headerlink" title="3.3.2 部署数据库和缓存"></a>3.3.2 部署数据库和缓存</h3><p>1、部署MySQL数据库，（PostgreSQL、MySQL 或 MariaDB 三选一）</p><p>安装方式<a href="http://gsproj.github.io/2024/05/13/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/19-web%E9%9B%86%E7%BE%A4-Tomcat-2-%E5%AE%8C%E7%BB%93/">参考连接</a>中的5.2.2节，至服务启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@h3cy02 tools]# systemctl start mysqld[root@h3cy02 tools]# systemctl status mysqld● mysqld.service - LSB: start and stop MySQL   Loaded: loaded (&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;mysqld; bad; vendor preset: disabled)   Active: active (running) since Fri 2024-09-06 10:03:15 CST; 4s ago...Sep 06 10:03:15 h3cy02 mysqld[51584]: SUCCESS!Sep 06 10:03:15 h3cy02 systemd[1]: Started LSB: start and stop MySQL.[root@h3cy02 tools]# mysql -uroot -pEnter password: ...Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; </code></pre></div></figure><p>创建jumpserver数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; show create database jumpserver;</code></pre></div></figure><p>创建jumpserver用户，用于连接jumpserver数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; create user jumpserver@&#39;localhost&#39; identified with mysql_native_password by &#39;redhat123&#39;;Query OK, 0 rows affected (0.01 sec)mysql&gt; grant all on jumpserver.* to jumpserver@&#39;localhost&#39;;Query OK, 0 rows affected (0.00 sec)</code></pre></div></figure><p>修改MySQL的ROOT密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;rxxxx3&#39;;</code></pre></div></figure><p>2、部署Redis（源码方式）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载源码wget https:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.2.6.tar.gz# 解压tar -xf redis-6.2.6.tar.gz # 编译安装make -j 8 &amp;&amp; make install# 测试[root@h3cy02 redis-6.2.6]# redis-cli  --versionredis-cli 6.2.6# 创建服务文件[root@h3cy02 ~]# cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;redis-server.service [Unit]Description&#x3D;Redis ServerAfter&#x3D;network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-serverKillMode&#x3D;process[Install]WantedBy&#x3D;multi-user.target# 启动服务[root@h3cy02 systemd]# systemctl enable --now redis-server.service Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;redis-server.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;redis-server.service.[root@h3cy02 systemd]# systemctl status redis-server.service ● redis-server.service - Redis Server   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;redis-server.service; enabled; vendor preset: disabled)   Active: active (running) since Fri 2024-09-06 10:24:52 CST; 5s ago Main PID: 57145 (redis-server)   CGroup: &#x2F;system.slice&#x2F;redis-server.service           └─57145 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-server *:6379</code></pre></div></figure><h3 id="3-3-4-部署docker和docker-compose"><a href="#3-3-4-部署docker和docker-compose" class="headerlink" title="3.3.4 部署docker和docker-compose"></a>3.3.4 部署docker和docker-compose</h3><p>在线安装方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加阿里源yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo# 列出列表[root@h3cy02 yum.repos.d]# yum list docker-ce --showduplicates | sort -rLoaded plugins: fastestmirror, langpacksdocker-ce.x86_64            3:26.1.4-1.el7                      docker-ce-stabledocker-ce.x86_64            3:26.1.3-1.el7                      docker-ce-stable....# 安装Docker18yum install -y docker-ce</code></pre></div></figure><p>离线安装方法<strong>（采用）</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;static&#x2F;stable&#x2F;x86_64&#x2F;docker-27.2.0.tgz# 解压tar -xf docker-27.2.0.tgz# 部署cp -a .&#x2F;* &#x2F;usr&#x2F;local&#x2F;bin&#x2F;# 设置服务文件# vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service[Unit]Description&#x3D;Docker Application Container EngineDocumentation&#x3D;https:&#x2F;&#x2F;docs.docker.comAfter&#x3D;network-online.target firewalld.serviceWants&#x3D;network-online.target[Service]Type&#x3D;notifyExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;dockerdExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPIDTimeoutStartSec&#x3D;0RestartSec&#x3D;2Restart&#x3D;alwaysStartLimitBurst&#x3D;3StartLimitInterval&#x3D;60sLimitNOFILE&#x3D;infinityLimitNPROC&#x3D;infinityLimitCORE&#x3D;infinityTasksMax&#x3D;infinityDelegate&#x3D;yesKillMode&#x3D;processOOMScoreAdjust&#x3D;-500[Install]WantedBy&#x3D;multi-user.target# 启动服务systemctl enable --now docker.service</code></pre></div></figure><p>安装docker-compose</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载curl -SL https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;v2.16.0&#x2F;docker-compose-linux-x86_64 -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose# 执行权限chmod a+x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose# 测试[root@h3cy02 docker]# docker-compose -vDocker Compose version v2.16.0</code></pre></div></figure><h3 id="3-3-3-部署Jumpserver（离线安装）"><a href="#3-3-3-部署Jumpserver（离线安装）" class="headerlink" title="3.3.3 部署Jumpserver（离线安装）"></a>3.3.3 部署Jumpserver（离线安装）</h3><p>离线安装目前只支持 linux&#x2F;amd64架构，其他架构需要在线安装</p><p>1、设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压安装包，放到&#x2F;opt文件夹[root@h3cy02 tarball]# tar -xf jumpserver-offline-installer-v3.10.13-amd64.tar.gz -C &#x2F;opt&#x2F;# 软连接ln -s &#x2F;opt&#x2F;jumpserver-offline-installer-v3.10.13-amd64&#x2F; &#x2F;opt&#x2F;jumpserver# 根据需要修改配置文件模板mkdir configcp config-example.txt &#x2F;config&#x2F;config.txt# 修改mysql的部分DB_HOST&#x3D;localhostDB_PORT&#x3D;3306DB_USER&#x3D;jumpserverDB_PASSWORD&#x3D;rxxxx3DB_NAME&#x3D;jumpserver</code></pre></div></figure><p>2、执行安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进入目录cd &#x2F;opt&#x2F;jumpserver# 安装[root@h3cy02 jumpserver]# .&#x2F;jmsctl.sh install</code></pre></div></figure><p>安装成功的显示</p><p><img src="/../../../img/image-20240906121933414.png" alt="image-20240906121933414"></p><p>3、启动命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动.&#x2F;jmsctl.sh start# 停止.&#x2F;jmsctl.sh down# 卸载.&#x2F;jmsctl.sh uninstall# 帮助.&#x2F;jmsctl.sh -h</code></pre></div></figure><p>4、80端口访问站点</p><p><img src="/../../../img/image-20240909094020576.png" alt="image-20240909094020576"></p><p>初始密码：admin &#x2F; admin</p><p>5、进入管理页面后，配置资产、授权等页面，实现跳板机访问内网服务器</p><p><img src="/../../../img/image-20240909103404023.png" alt="image-20240909103404023"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Centos改网卡名</title>
    <link href="/2024/08/02/06_%E6%9D%82%E8%AE%B0/Centos%E6%94%B9%E7%BD%91%E5%8D%A1%E5%90%8D/"/>
    <url>/2024/08/02/06_%E6%9D%82%E8%AE%B0/Centos%E6%94%B9%E7%BD%91%E5%8D%A1%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>掌握如何将Centos的网卡名修改为eth命令格式</p><h1 id="一、临时生效"><a href="#一、临时生效" class="headerlink" title="一、临时生效"></a>一、临时生效</h1><p>为防止重启后网卡名乱变，统一改成eth0，eth1这种格式</p><p><strong>1、重启系统，在grab界面按E，编辑</strong></p><p><img src="/../../img/image-20240816161308524.png" alt="image-20240816161308524"></p><p><strong>2、修改启动项，添加</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net.ifnames&#x3D;0 biosdevname&#x3D;0</code></pre></div></figure><p><img src="/../../img/image-20240816161458583.png" alt="image-20240816161458583"></p><p>Ctrl + X保存退出，重启后网卡名已改名，由ens33改为eth0</p><p><img src="/../../img/image-20240816161736929.png" alt="image-20240816161736929"></p><p><strong>3、修改网卡配置文件，把网卡名修正</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;# 配置文件改名mv ifcfg-ens33 ifcfg-eth0# 内部的网络接口名称修改vim ifcfg-eth0</code></pre></div></figure><p><img src="/../../img/image-20240816161841244.png" alt="image-20240816161841244"></p><p>所有网卡都要修改，改完后重启网络服务即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart network</code></pre></div></figure><h1 id="二、永久生效"><a href="#二、永久生效" class="headerlink" title="二、永久生效"></a>二、永久生效</h1><p>如需永久生效，在Centos中需要修改grub文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;default&#x2F;grub ...GRUB_CMDLINE_LINUX&#x3D;&quot;rd.lvm.lv&#x3D;centos&#x2F;root rd.lvm.lv&#x3D;centos&#x2F;swap rhgb quiet net.ifnames&#x3D;0 biosdevname&#x3D;0&quot;...</code></pre></div></figure><p>最后用<code>grub2-mkconfig</code>命令重新生成grub配置并更新内核</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg </code></pre></div></figure><p>配置完后重启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reboot</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GPU服务器组网</title>
    <link href="/2024/08/02/06_%E6%9D%82%E8%AE%B0/GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%84%E7%BD%91/"/>
    <url>/2024/08/02/06_%E6%9D%82%E8%AE%B0/GPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%84%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单台GPU服务器内部组成"><a href="#一、单台GPU服务器内部组成" class="headerlink" title="一、单台GPU服务器内部组成"></a>一、单台GPU服务器内部组成</h1><p>典型的8卡H100服务器的内部组成主要包括以下部分：</p><ul><li>CPU + 总线</li><li>内存 + 总线</li><li>PCIE通道 + PCIE交换芯片</li><li>网卡</li><li>GPU</li><li>NVLink</li><li>NVSwtich</li></ul><p><img src="/./../../img/image-20241204100420560.png" alt="image-20241204100420560"></p><h1 id="二、小型本地组网"><a href="#二、小型本地组网" class="headerlink" title="二、小型本地组网"></a>二、小型本地组网</h1><p><img src="/./../../img/image-20241204105503096.png" alt="image-20241204105503096"></p><p>三、中型组网</p><p><img src="/./../../img/image-20241204115802558.png" alt="image-20241204115802558"></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>人工智能集群了解</title>
    <link href="/2024/08/02/06_%E6%9D%82%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <url>/2024/08/02/06_%E6%9D%82%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="一、InfiniBand算力网络"><a href="#一、InfiniBand算力网络" class="headerlink" title="一、InfiniBand算力网络"></a>一、InfiniBand算力网络</h1><h2 id="1-1-技术背景"><a href="#1-1-技术背景" class="headerlink" title="1.1 技术背景"></a>1.1 技术背景</h2><p>infiniband直译为“无限带宽”技术，是一个高性能计算的计算机网络通信标准。大致发展路线如下：</p><ul><li><p>上世纪90年代：为了连接更多的外部设备，英特尔推出PCI总线，刚开始都用这个</p></li><li><p>1999年，FIO Developers Forum（IBM、康柏以及惠普）和NGIO Forum（英特尔、微软、SUN）进行了合并，创立了InfiniBand贸易协会，诞生的目的，就是为了取代PCI</p></li><li><p>2001年，从英特尔公司和伽利略技术公司离职的员工，在以色列创立了一家芯片公司Mellanox，2001年加入InifiniBand联盟，并推出首款InfiniBand产品</p></li><li><p>2002年，InfiniBand阵营突遭巨变，英特尔公司“临阵脱逃”，决定转向开发PCI Express，微软也退出了InfiniBand的开发。</p></li><li><p>2009年，TOP500中有181个采用infiniband，以太网仍是主流256个，Mellanox(麦洛斯)也在不断壮大，成为infiniband的引导者。</p></li><li><p>2010年，Mellanox和Voltaire公司合并，InfiniBand主要供应商只剩下Mellanox和QLogic。</p></li><li><p>2012年英特尔收购QLogic，再次回到infiniband赛道</p></li><li><p>2015年，TOP500中有257套采用infiniband，占比为51.4%，标志着infiniband战胜以太网，成为了超级计算机最首选的内部连接技术，Mellanox在infiniband中的市场占比高达80%</p></li><li><p>2015年至2019年，面对infiniband的挑战，以太网也不甘示弱，接连推出ROCE V1和ROCE V2，大幅缩小与infiniband的技术性能差距，结合本身固有的成本和兼容性优势，又反杀回来，25G以太网成为行业新宠，反杀infiniband</p></li><li><p>2019年，英伟达豪掷69亿美元，击败对手英特尔和微软，成功收购Mellanox，AIGC大模型崛起，整个社会对高性能计算和智能计算的需求发生了井喷。InfiniBand也基本变成了英伟达家的私有协议</p></li></ul><p>目前网络性能这块主要是infiniband和高速以太网的缠斗</p><p>不差钱的选infiniband，性价比选高速以太网</p><blockquote><p>RDMA网络的两个分支，IB和ROCE</p><p>前者价格贵，成本高，但是传输速率高，通信效率好</p><p>ROCE网络差点，但它的硬件价格会便宜些</p><p>如果是大规模生产型，不差钱的情况下，选IB</p><p>小型或者实验室型，对时延没太多要求，选ROCE</p></blockquote><h2 id="1-2-RDMA协议"><a href="#1-2-RDMA协议" class="headerlink" title="1.2 RDMA协议"></a>1.2 RDMA协议</h2><h3 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h3><p>infiniband率先引入RDMA（Remote Direct Memeory Access）远程直接数据存取协议</p><p>为了解决网络传输中服务器端数据处理的延迟而产生的</p><h3 id="1-2-3-RDMA原理"><a href="#1-2-3-RDMA原理" class="headerlink" title="1.2.3 RDMA原理"></a>1.2.3 RDMA原理</h3><p>传统Socket通信，数据要<strong>层层打包</strong>，从用户空间 –&gt; 操作系统内核 —&gt; 硬件，对于CPU来说就是持续的<strong>大开销</strong></p><p><img src="/../../img/image-20240802163341581.png" alt="Socket通信"></p><p>RDMA直接绕开操作系统内核，直接让数据在应用层传递到网络接口</p><p><img src="/../../img/image-20240802163429357.png" alt="RDMA通信"></p><p>是一种高带宽、低延迟、低CPU消耗的网络互联协议，采用此协议的网络技术主要有四个，IB、ROCEV1&#x2F;V2、IWARP，<strong>主流常用</strong></p><p><strong>IB和ROCEV2</strong>，ROCEV1已被弃用，IWARP也不常用，它们的架构如下：</p><p><img src="/../../img/image-20240802163834145.png" alt="使用RDMA协议的网络技术"></p><h2 id="1-3-infiniband的商用产品"><a href="#1-3-infiniband的商用产品" class="headerlink" title="1.3 infiniband的商用产品"></a>1.3 infiniband的商用产品</h2><p>英伟达：NVDIA Quantum-2 第七代infiniband架构 2021年，包括</p><p><img src="/../../img/image-20240801161118159.png" alt="infiniband相关的商用产品"></p><p>Quantum-2系列交换机采用了紧凑型的1U设计，包括风冷和也冷版本，芯片制程工艺7纳米</p><p>64个400Gbps端口或者128个200Gpbs的端口，灵活搭配，提供总计51.2Tbps的双向吞吐量</p><p>ConnectX-7 infiniband适配器，支持PCIE GEN4和Gen5，具有多种外形规格，可以提供400Gpbs的单或双网络端口</p><h2 id="1-4-网络拓扑示例"><a href="#1-4-网络拓扑示例" class="headerlink" title="1.4 网络拓扑示例"></a>1.4 网络拓扑示例</h2><p><img src="/../../img/image-20240802113806046.png" alt="infiniband实践的网络拓扑"></p><h1 id="二、AI算力集群"><a href="#二、AI算力集群" class="headerlink" title="二、AI算力集群"></a>二、AI算力集群</h1><p>如何规模化部署一个AI算力集群？主要由以下4部分组成：</p><p>1、集群网络：首选RDMA网络</p><p>2、算力服务器：DGX &#x2F; HGX，如<code>NVIDIA HGX H100</code> ，或者其他算力服务器</p><p>3、操作系统：Linux操作系统 &#x2F; Laxcus分布式操作系统</p><p>4、应用软件：AI大模型，向量数据库，其他辅助软件</p><h1 id="三、液冷技术"><a href="#三、液冷技术" class="headerlink" title="三、液冷技术"></a>三、液冷技术</h1><h2 id="3-1-浸没式液冷技术"><a href="#3-1-浸没式液冷技术" class="headerlink" title="3.1 浸没式液冷技术"></a>3.1 浸没式液冷技术</h2><p>是一种典型的直接接触型液冷，它是将发热的电子元件浸没在冷媒<code>冷却液</code>中，依靠液体流动循环带走热量。</p><p>浸没式液冷由于发热元件与冷媒全方位直接接触，散热效率相比于传统的散热方式<code>风冷</code>和<code>水冷</code>，它的散热效率更高些；</p><p>相对于<code>冷板</code>或<code>喷淋液冷</code>，它的噪音更低。</p><p>目前浸没式液冷技术主要分为：单相液冷和双相液态冷</p><p><img src="/../../img/image-20240802165924614.png" alt="浸没式液冷技术"></p><p>浸没式液冷技术对比传统风冷技术的优势：</p><ul><li>节能性更加极致：冷媒与发热器件直接接触，换热效率更高，且可实现全面自然冷却，系统PUE&lt;1.05；</li><li>器件散热更加均匀：采用全浸没方式，服务器内部温度场更加均匀，器件可靠性更有保障；</li><li>无泄漏风险：采用绝缘、环保的冷却液体，即使发生泄露对基础设施硬件和外界环境均无任何风险；</li><li>噪声更低：服务器全部元器件均可通过液冷方式散热，内部实现无风扇设计，满载运行噪音&lt;45dB；</li><li>功率密度大幅提升：单机柜功率密度可达60kW以上。</li></ul><h2 id="3-1-单相液冷和两相液冷"><a href="#3-1-单相液冷和两相液冷" class="headerlink" title="3.1 单相液冷和两相液冷"></a>3.1 单相液冷和两相液冷</h2><h3 id="3-1-1-两相液冷技术"><a href="#3-1-1-两相液冷技术" class="headerlink" title="3.1.1 两相液冷技术"></a>3.1.1 两相液冷技术</h3><p><img src="/../../img/image-20240802105959781.png" alt="两相液冷图示"></p><p>优势：</p><ul><li>冷却液发生了相变，所以传热效率很高。</li></ul><p>缺点：</p><ul><li>相变过程中，冷却液蒸发为气态过程中会发生逃逸，所以对容器的密封性有一定的要求；</li><li>但是又不能太密封，防止冷却系统中断出现事故，所以需要设置一定的安全设施</li></ul><h3 id="3-1-2-单相液冷技术"><a href="#3-1-2-单相液冷技术" class="headerlink" title="3.1.2 单相液冷技术"></a>3.1.2 单相液冷技术</h3><p><img src="/../../img/image-20240802110238146.png" alt="单相液冷图示"></p><p>优势：</p><ul><li>单相液冷要求冷却液的沸点较高，这样冷却液挥发流失控制相对简单，与IT设备的元器件兼容性比较好，不需要频繁补充冷却液</li></ul><p>缺点：</p><ul><li>相对于两相液冷其散热效率要低一些</li></ul><h1 id="四、英伟达H100-GPU服务器"><a href="#四、英伟达H100-GPU服务器" class="headerlink" title="四、英伟达H100 GPU服务器"></a>四、英伟达H100 GPU服务器</h1><p>了解英伟达H100 GPU服务器</p><h2 id="4-1-机型参数"><a href="#4-1-机型参数" class="headerlink" title="4.1 机型参数"></a>4.1 机型参数</h2><p>型号：超微SYS-821GE-TNHR</p><p>英伟达H100加速卡服务器（8块卡），售价约260万 - 300万人民币一台</p><p>高度8u，进深 80cm，重量110公斤，四个人才能抬起</p><p>整机功率：约1万W</p><p>CPU：英特尔至强 Platinum 8468处理器 * 2 （四代铂金系列）</p><ul><li>105M高速缓存</li><li>主频2.10GHz，睿频3.8Ghz</li><li>48核心</li></ul><p>内存：32根64G DDR5内存条，一共2T内存</p><blockquote><p>补充：内存与显存比例3：1最好</p><p>这里显存一共80G * 8 &#x3D; 640G，刚好3：1</p></blockquote><h3 id="4-1-1-前面板"><a href="#4-1-1-前面板" class="headerlink" title="4.1.1 前面板"></a>4.1.1 前面板</h3><p><img src="/../../img/image-20240802135744858.png" alt="超微H100服务器前面板"></p><h3 id="4-1-2-后面板"><a href="#4-1-2-后面板" class="headerlink" title="4.1.2 后面板"></a>4.1.2 后面板</h3><p>后面板主要包含：两个电源模块、网卡接口、风扇</p><p>如图所示：</p><p><img src="/../../img/image-20240802145043149.png" alt="超微H100服务器后面板"></p><blockquote><p>中间部位的8张400G网卡：一块网卡对应一张GPU芯片处理的数据</p><p>旁边的一张400G网卡：用于连接存储网络</p><p>上方的两个千兆口：用于连接管理网络</p></blockquote><p>包含网口的IO模组是可以拆卸的，整机最多支持12张PCIE5.0的X16插槽</p><p><img src="/../../img/image-20240802145647352.png" alt="IO模组支持的PCIE通道"></p><p>拆卸出来是这样</p><p><img src="/../../img/image-20240802145543209.png" alt="IO模组拆出来的样子"></p><h3 id="4-1-3-GPU模组"><a href="#4-1-3-GPU模组" class="headerlink" title="4.1.3 GPU模组"></a>4.1.3 GPU模组</h3><p>取出H100模组，掰下，往外抽</p><p><img src="/../../img/image-20240802140315377.png" alt="如何拆下GPU模组"></p><p>GPU模块俯视图：</p><p><img src="/../../img/image-20240802141641117.png" alt="GPU模块俯视图"></p><p>将GPU卡拆下，可以看到SXM接口，通过此种接口，将8块H100 GPU连到一个基板上，组成一个整体的H100模组</p><p><img src="/../../img/image-20240802141926425.png" alt="SXM接口图示"></p><blockquote><p>GPU模组：</p><p>实际并不大，只占用1U-2U的空间，因为考虑到散热才做成8U那么大</p></blockquote><h2 id="4-2-英伟达的GDS技术"><a href="#4-2-英伟达的GDS技术" class="headerlink" title="4.2 英伟达的GDS技术"></a>4.2 英伟达的GDS技术</h2><p>GDS技术全称（GPU Direct Storage），数据能直接从存储设备传输到GPU中，再也不需要经过CPU和系统内存</p><p><img src="/../../img/image-20240802134640196.png" alt="传统数据传输和GDS方式的对比"></p><p>优势：</p><ul><li>提高数据传输的效率</li><li>降低延迟</li><li>提高训练数据的载入速度</li><li>提升大模型的训练性能</li></ul><h2 id="4-3-英伟达H100-GPU介绍"><a href="#4-3-英伟达H100-GPU介绍" class="headerlink" title="4.3 英伟达H100 GPU介绍"></a>4.3 英伟达H100 GPU介绍</h2><p>了解H100 GPU的参数，以及部分原理</p><h3 id="4-3-1-GPU参数"><a href="#4-3-1-GPU参数" class="headerlink" title="4.3.1 GPU参数"></a>4.3.1 GPU参数</h3><p>作为A100（7纳米）的继承者，采用全新的Hopper架构，台积电4纳米工艺</p><p>H100 GPU参数，以及与A100的对比信息</p><table><thead><tr><th>参数</th><th>H100参数</th><th>A100参数</th></tr></thead><tbody><tr><td>架构</td><td>Ampere</td><td>Hopper</td></tr><tr><td>CUDA Cores（核心数）</td><td>16896</td><td>6912</td></tr><tr><td>工艺</td><td>台积电4纳米</td><td>台积电7纳米</td></tr><tr><td>晶体管数量</td><td>800亿</td><td>540亿</td></tr><tr><td>显存</td><td>80GB的HBM3高速缓存</td><td>&#x2F;</td></tr><tr><td>显存带宽</td><td>SXM版本3TB&#x2F;s，PCIE版本2TB&#x2F;s</td><td>&#x2F;</td></tr><tr><td>INT8</td><td>2000 TOPS</td><td>624 TOPS</td></tr><tr><td>FP16</td><td>1000 TFLOPS</td><td>312 TFLOPS</td></tr><tr><td>TF32</td><td>500 TFLOPS</td><td>156 TFLOPS</td></tr><tr><td>FP64</td><td>60 TFLOPS</td><td>19.5 TFLOPS</td></tr><tr><td>功耗（TDP）</td><td>700W &#x2F; 每颗GPU</td><td>400W</td></tr><tr><td>单颗GPU的尺寸</td><td>8cm x 15.2cm</td><td>&#x2F;</td></tr></tbody></table><h3 id="4-3-2-GPU协同工作原理"><a href="#4-3-2-GPU协同工作原理" class="headerlink" title="4.3.2  GPU协同工作原理"></a>4.3.2  GPU协同工作原理</h3><p>H100模组由8块H100 GPU芯片组成，那么他们是如何协同工作的？</p><p>通过底下的芯片，组成<code>NVLink</code>，它是一种GPU到GPU的高速互联技术，同样也是英伟达推出的，以这些芯片为桥梁，允许多个GPU之间进行高速通信。</p><p>目前是第四代NVLink技术，为每个GPU提供高达900GB&#x2F;s的双向带宽。至多可以互联256个GPU芯片</p><p><img src="/../../img/image-20240802143248714.png" alt="NVLink技术相关的芯片"></p><p>NVSwitch技术图示</p><p><img src="/../../img/image-20240802143436994.png" alt="NVSwitch技术图示"></p><h3 id="4-3-3-PCIE交换机"><a href="#4-3-3-PCIE交换机" class="headerlink" title="4.3.3 PCIE交换机"></a>4.3.3 PCIE交换机</h3><p>H100整机中，有一个模块叫做PCIE交换机，用于CPU和GPU之间的通信</p><p>PCIE交换机能将CPU和主板芯片所提供的PCIE通道 扩展为 更多的PCIE通道，从而允许连接更多的PCIE设备</p><p>这个型号的机子中有4块交换芯片</p><p><img src="/../../img/image-20240802151040132.png" alt="PCI-E switch芯片"></p><p>CPU不能直接通过NVLink与GPU通信，必须使用PCIE交换机作为中间连接，</p><ul><li>数据先到PCIE交换机</li><li>再到NVLink交换机</li><li>再到GPU</li></ul><p>层层转包，从而实现CPU与 GPU的通信</p><p><img src="/../../img/image-20240802151318169.png" alt="PCI-E交换机实现CPU和GPU通信"></p><h3 id="4-3-4-由PCI-E通道衍生的问题"><a href="#4-3-4-由PCI-E通道衍生的问题" class="headerlink" title="4.3.4 由PCI-E通道衍生的问题"></a>4.3.4 由PCI-E通道衍生的问题</h3><h4 id="4-3-4-1-PCI-E通道带宽的问题"><a href="#4-3-4-1-PCI-E通道带宽的问题" class="headerlink" title="4.3.4.1 PCI-E通道带宽的问题"></a>4.3.4.1 PCI-E通道带宽的问题</h4><p>从超微服务器结构设计来看，所有的服务器外部设备，都必须通过这个PCIE交换机来与CPU通信，因此系统的带宽和延迟瓶颈，都有可能出现在PCI-E交换这个环节</p><p><img src="/../../img/image-20240802152245614.png" alt="PCI-E通道带宽问题"></p><p>带宽不够？此时PCIE交换机的作用就来了，在主板旁边，提供了两个直连CPU的PCI-E扩展口，可以通过扩展板连接</p><p><img src="/../../img/image-20240802154333498.png" alt="主板旁边的PCI-E扩展口"></p><p>比如安装一张Riser卡（400G的IB卡）</p><p><img src="/../../img/image-20240802154510002.png" alt="400G IB卡"></p><h4 id="4-3-4-2-不同型号PCIE通道的坑"><a href="#4-3-4-2-不同型号PCIE通道的坑" class="headerlink" title="4.3.4.2 不同型号PCIE通道的坑"></a>4.3.4.2 不同型号PCIE通道的坑</h4><p>有些服务器配置一样，但是速度就是慢很多，就是因为PCIE X16通道只有4条，而超微的有8条！</p><p><img src="/../../img/image-20240802154119282.png" alt="其他型号的PCI-E通道只有4条"></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day02-网工入门（二）</title>
    <link href="/2024/07/28/08_%E7%BD%91%E7%BB%9C/day02-%E7%BD%91%E5%B7%A5%E5%85%A5%E9%97%A8-02/"/>
    <url>/2024/07/28/08_%E7%BD%91%E7%BB%9C/day02-%E7%BD%91%E5%B7%A5%E5%85%A5%E9%97%A8-02/</url>
    
    <content type="html"><![CDATA[<h1 id="网工入门（二）"><a href="#网工入门（二）" class="headerlink" title="网工入门（二）"></a>网工入门（二）</h1><h1 id="一、IP地址和子网掩码"><a href="#一、IP地址和子网掩码" class="headerlink" title="一、IP地址和子网掩码"></a>一、IP地址和子网掩码</h1><h2 id="1-1-IP地址概念"><a href="#1-1-IP地址概念" class="headerlink" title="1.1 IP地址概念"></a>1.1 IP地址概念</h2><p>什么是IP地址？</p><ul><li>IP地址是用来标识网络中一台主机的唯一标志</li><li>通常采用32位点分十进制表示</li></ul><p><img src="/../../img/image-20240728200558838.png" alt="image-20240728200558838"></p><p>IP地址分为两部分：网络位和主机位</p><ul><li>网络位：表示某一个IP子网</li><li>主机位：表示本IP子网内的某台主机</li></ul><p>怎么区分IP地址的网络位和主机位？需要用到子网掩码的知识</p><h2 id="1-2-子网掩码"><a href="#1-2-子网掩码" class="headerlink" title="1.2 子网掩码"></a>1.2 子网掩码</h2><p>它是用来区分IP地址的网络位和主机位的，用连续的<code>1</code>来表示网络位，用连续的<code>0</code>来表示主机位，比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 192.168.1.1 子网掩码255.255.255.0网络位 192.168.1 主机位 1# 192.168.1.2 子网掩码 255.255.0.0网络位 192.168主机位 1.2</code></pre></div></figure><p>子网掩码的简写表示</p><p><img src="/../../img/image-20240728201728956.png" alt="image-20240728201728956"></p><h3 id="1-2-1-子网掩码案例"><a href="#1-2-1-子网掩码案例" class="headerlink" title="1.2.1 子网掩码案例"></a>1.2.1 子网掩码案例</h3><p>如果是不规则的192.168.1.3，子网掩码 255.255.255.192，它的网络位怎么分呢？</p><p><img src="/../../img/image-20240728201346021.png" alt="image-20240728201346021"></p><p>这个网段的IP范围（网络位相同）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 从192.168.1.00000000# 到192.168.1.00111111# 即192.168.1.0 --&gt; 192.168.0.63</code></pre></div></figure><blockquote><p>用这个原理，可以判断两个IP地址是否在同网段，网络位相同就是在同一网段</p></blockquote><h2 id="1-3-IP地址分类与子网划分"><a href="#1-3-IP地址分类与子网划分" class="headerlink" title="1.3 IP地址分类与子网划分"></a>1.3 IP地址分类与子网划分</h2><p>IP地址分为三类：</p><ul><li>网络地址，主机位全0</li><li>广播地址，主机位全1</li><li>可用地址</li></ul><p><img src="/../../img/image-20240728202234929.png" alt="image-20240728202234929"></p><h3 id="1-3-1-案例：计算可用地址"><a href="#1-3-1-案例：计算可用地址" class="headerlink" title="1.3.1 案例：计算可用地址"></a>1.3.1 案例：计算可用地址</h3><p>172.16.10.1&#x2F;16这个B类地址的网络地址、广播地址以及可用地址分别是什么？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 网络位：172.16# 主机范围172.16.00000000.00000000# 网络地址172.16.11111111.11111111# 广播地址# 可用范围172.16.00000000.00000001# 172.16.0.1&#x2F;16172.16.11111111.11111110# 172.16.255.254&#x2F;16</code></pre></div></figure><h2 id="1-4-公网IP和私网IP"><a href="#1-4-公网IP和私网IP" class="headerlink" title="1.4 公网IP和私网IP"></a>1.4 公网IP和私网IP</h2><p>公网IP，由IANA统一分配，数量有限</p><p>私网IP，局域网使用，用于解决公网地址IP不够用的问题</p><p><img src="/../../img/image-20240728212719466.png" alt="image-20240728212719466"></p><h2 id="1-5-特殊IP地址"><a href="#1-5-特殊IP地址" class="headerlink" title="1.5 特殊IP地址"></a>1.5 特殊IP地址</h2><p><img src="/../../img/image-20240728212921502.png" alt="image-20240728212921502"></p><h2 id="1-6-IPV4和IPV6"><a href="#1-6-IPV4和IPV6" class="headerlink" title="1.6 IPV4和IPV6"></a>1.6 IPV4和IPV6</h2><p>IPV6的技术背景：</p><ul><li>IPV4地址数量有限，于2011年完全用尽，IPV4地址枯竭问题日益严重</li><li>IPV6地址数量多，接近无限，用于解决IP分配问题</li><li>IPV6配置较为麻烦，但是性能比IPV4好</li></ul><p><img src="/../../img/image-20240728213138467.png" alt="image-20240728213138467"></p><h1 id="二、交换机转发原理"><a href="#二、交换机转发原理" class="headerlink" title="二、交换机转发原理"></a>二、交换机转发原理</h1><p>收到数据包，根据数据包中的目标MAC和接口进行转发</p><h2 id="2-1-交换机三种转发方式"><a href="#2-1-交换机三种转发方式" class="headerlink" title="2.1 交换机三种转发方式"></a>2.1 交换机三种转发方式</h2><p>三种方式分别是：</p><ul><li>泛洪（一对多，发给所有）</li><li>转发（一对一发送）</li><li>丢弃</li></ul><p><img src="/../../img/image-20240728213543484.png" alt="image-20240728213543484"></p><p>三种方式会在什么情况下触发？</p><p>从交换机收到的数据包说起，数据包里包含MAC地址和接口信息</p><p><img src="/../../img/image-20240728213801811.png" alt="image-20240728213801811"></p><p>交换机查询收到的数据包：</p><ul><li>如果没查到对应的目标MAC地址，会采用泛洪的方式</li><li>如果查到了对应的目标MAC地址，会采用一对一的方式转发，不会泛洪</li><li>如果目标接口就是发出的接口，会丢弃数据包</li></ul><h2 id="2-2-ARP协议介绍"><a href="#2-2-ARP协议介绍" class="headerlink" title="2.2 ARP协议介绍"></a>2.2 ARP协议介绍</h2><p>在交换机上可以查看mac地址表</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sytem-viewdisplay mac-address</code></pre></div></figure><p>ARP协议用在哪里？</p><p>PC发数据包，要给数据包加上目标MAC，然后一个正常的访问操作（如PC1 ping 1.1.1.2）只知道对方的IP，并不知道对方的MAC地址，像这种情况是怎么获取到对方的MAC地址的呢？</p><p>此时就用到了ARP协议：</p><ul><li>PC1会先发一个ARP请求包，请求目标主机的MAC地址。</li><li>ARP请求包，是一个广播包，发给所有主机</li><li>目标主机收到ARP请求，通过ARP协议，回应MAC地址回去</li><li>PC1收到目标主机的ARP回复，收到目标主机的MAC</li><li>PC1再发包，因为已经有了MAC地址，查表（ARP缓存表）单播（一对一）发送就行，不用广播了</li></ul><p>在PC机可以查到IP和MAC对应的ARP缓存表</p><p><img src="/../../img/image-20240728215147439.png" alt="image-20240728215147439"></p><h1 id="三、防火墙"><a href="#三、防火墙" class="headerlink" title="三、防火墙"></a>三、防火墙</h1><h2 id="3-1-防火墙的概念"><a href="#3-1-防火墙的概念" class="headerlink" title="3.1 防火墙的概念"></a>3.1 防火墙的概念</h2><p>什么是防火墙？</p><ul><li>是一个硬件设备，常用于企业网络中</li><li>部署在不同的区域之间，加强安全的作用</li></ul><p>防火墙的接口类型：</p><ol><li>路由模式（三层）：物理口可以直接配置IP</li><li>交换模式（二层）：物理口不能直接配IP，可以配置vlan和trunk（portswitch命令切换）</li></ol><p>防火墙的安全域：</p><ul><li>信任区：我的内网，自己人</li><li>非信任区：外网，外人</li><li>DMZ区：中间区域（如服务器区），内网主机、外网用户都要访问</li></ul><h2 id="3-2-防火墙上手"><a href="#3-2-防火墙上手" class="headerlink" title="3.2 防火墙上手"></a>3.2 防火墙上手</h2><p>实验拓扑</p><p><img src="/../../img/image-20240728220604009.png" alt="image-20240728220604009"></p><p>实现目标：</p><ul><li>电脑能上网（192.168.1.1能ping通6.6.6.6）</li></ul><p>步骤概览：</p><ol><li>AR2路由器需要加上默认静态路由，下一跳10.10.10.2</li><li>防火墙有到6.6.6.0&#x2F;24的直连路由，不需要配置路由，配置IP即可</li><li>配置防火墙设置安全域，配置安全策略，允许PC出去</li><li>内网主机是私网IP，需要做NAT转换</li><li>配置回来的路由（<strong>非常重要，容易忽视</strong>）</li></ol><p>完整步骤：</p><p>1、 AR2配置默认静态路由</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置syip route-static 6.6.6.0 24 10.10.10.2# 查询dis ip routing-table 6.6.6.6</code></pre></div></figure><p>2、防火墙FW1配置IP地址</p><blockquote><p>用的ensp的USG6000V1防火墙，用户名admin，密码Admin@123</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 登录Username:Password:# 进入配置模式sy# 关闭提示undo in en# 进入接口，配置IPint g1&#x2F;0&#x2F;1ip add 10.10.10.2 24qint g1&#x2F;0&#x2F;2ip add 6.6.6.1 24</code></pre></div></figure><p>3、配置防火墙安全策略，允许PC出去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 把内网接口加入信任区域firewall zone trustadd int g1&#x2F;0&#x2F;1# 把外网接口加入非信任区域firewall zone untrustadd int g1&#x2F;0&#x2F;2# 配置放行策略，运行信任区域访问非信任区域security-plicy# 进入安全策略配置模式rule name shangwang # 新建规则source-zone trust# 源destination untrust # 目标action permit# 允许</code></pre></div></figure><p>4、内网主机是私网IP，私网IP默认不能访问外网，需要做NAT转换</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nat-policy # 进入nat策略配置模式rule name shangwang # 新建规则source-zone trust # 源desitinatio-zone untrust # 目标action source-nat easy-ip # nat转换</code></pre></div></figure><blockquote><p>什么是easy-ip？</p><ul><li>做地址转换的时候，自动转换成设备出接口的地址（案例中的6.6.6.1），不用设置地址池了</li></ul></blockquote><p>5、FW1上配置回来的路由</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip route-static 192.168.1.0 24 10.10.10.1</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>1、网工入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day01-网工入门（一）</title>
    <link href="/2024/07/27/08_%E7%BD%91%E7%BB%9C/day01-%E7%BD%91%E5%B7%A5%E5%85%A5%E9%97%A8-01/"/>
    <url>/2024/07/27/08_%E7%BD%91%E7%BB%9C/day01-%E7%BD%91%E5%B7%A5%E5%85%A5%E9%97%A8-01/</url>
    
    <content type="html"><![CDATA[<h1 id="网工入门（一）"><a href="#网工入门（一）" class="headerlink" title="网工入门（一）"></a>网工入门（一）</h1><h1 id="一、华为认证的级别"><a href="#一、华为认证的级别" class="headerlink" title="一、华为认证的级别"></a>一、华为认证的级别</h1><p>华为认证有三个级别</p><p>HCIA基础网工</p><p>HCIP高级工程师</p><p>HCIE网络专家</p><h1 id="二、网络工程师学习路线"><a href="#二、网络工程师学习路线" class="headerlink" title="二、网络工程师学习路线"></a>二、网络工程师学习路线</h1><p><font color=green><strong>1、入门（使用华为2020年HCIA资料）</strong></font></p><ul><li>OSI七层模型</li><li>常见的网络设备功能和原理</li><li>通信原理<ul><li>交换原理</li><li>路由原理</li></ul></li></ul><p><font color=blue><strong>2、进阶</strong></font></p><ul><li><p>如何组建高可靠性网络</p><ul><li>VRRP</li><li>MSTP</li><li>堆叠（CSS&#x2F;IRF&#x2F;VSU）</li><li>多出口</li></ul></li><li><p>网络高性能</p><ul><li>动态路由</li><li>路由策略</li><li>策略路由（针对报文进行数据管理）</li></ul></li><li><p>广域网</p><ul><li>PPP（点到点通信）</li><li>VPN技术</li></ul></li></ul><p><font color=red><strong>3、资深</strong></font></p><ul><li>BGP技术</li><li>VXLAN（普通vlan只有4096个，vxlan有16万个vlan）</li><li>evpn（自动化管理）</li><li>sdn（软件自动化管理，写一段脚本自动完成）</li><li>排错能力</li></ul><h1 id="三、ENSP安装"><a href="#三、ENSP安装" class="headerlink" title="三、ENSP安装"></a>三、ENSP安装</h1><p>参考：<a href="https://blog.csdn.net/qq_45945548/article/details/124512961">https://blog.csdn.net/qq_45945548/article/details/124512961</a></p><h1 id="四、IP地址"><a href="#四、IP地址" class="headerlink" title="四、IP地址"></a>四、IP地址</h1><h2 id="4-1-IP地址的概念"><a href="#4-1-IP地址的概念" class="headerlink" title="4.1 IP地址的概念"></a>4.1 IP地址的概念</h2><p>IP地址的格式：192.168.1.1，子网掩码255.255.255.0</p><p>分为<strong>主机位</strong>和<strong>网络位</strong>，其网络位是 192.168.1</p><p>由子网掩码来决定网络位的长度</p><h2 id="4-2-配置IP地址的案例"><a href="#4-2-配置IP地址的案例" class="headerlink" title="4.2 配置IP地址的案例"></a>4.2 配置IP地址的案例</h2><p>ENSP模拟，使用AR2220设备</p><p>拓扑图</p><p><img src="/../../img/image-20240726170650471.png" alt="image-20240726170650471"></p><p>左边设备</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">system-viewinterface g0&#x2F;0&#x2F;0ip address 192.168.1.1 255.255.255.0</code></pre></div></figure><p>右边设备</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">system-viewinterface g0&#x2F;0&#x2F;0ipaddress 192.168.1.2 255.255.255.0</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ping 192.168.1.2</code></pre></div></figure><h2 id="4-2-配置DHCP案例"><a href="#4-2-配置DHCP案例" class="headerlink" title="4.2 配置DHCP案例"></a>4.2 配置DHCP案例</h2><p>拓扑图</p><p><img src="/../../img/image-20240726170746364.png" alt="image-20240726170746364"></p><p>路由器配置开启DHCP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">system-viewint g0&#x2F;0&#x2F;0ip add 192.168.1.1 255.255.255.0quit# 开启DHCPdhcp enableint g0&#x2F;0&#x2F;0dhcp select interface</code></pre></div></figure><p>台式机配置DHCP获取IP</p><h2 id="4-3-配置DNS服务器"><a href="#4-3-配置DNS服务器" class="headerlink" title="4.3 配置DNS服务器"></a>4.3 配置DNS服务器</h2><p>1、添加一台Server虚拟机，设置IP（192.168.1.100）和DNS解析服务</p><p><img src="/../../img/image-20240726171420168.png" alt="image-20240726171420168"></p><p>2、网关路由器AR1设置DNS</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">system-viewint g0&#x2F;0&#x2F;0dhcp server dns-list 192.168.1.100</code></pre></div></figure><h1 id="五、网关"><a href="#五、网关" class="headerlink" title="五、网关"></a>五、网关</h1><p>实验拓扑如下，目标主机和我现在的主机不是一个网段，该怎么才能访问到它？</p><p><img src="/../../img/image-20240726171727832.png" alt="image-20240726171727832"></p><p>此时需要引入”网关”的概念，工作原理如下：</p><ul><li>192.168的主机把数据包交给网关</li><li>网关根据路由表把数据包转发到100.100网段</li></ul><p>查看IP路由表</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">display ip routing-table</code></pre></div></figure><h1 id="六、静态路由"><a href="#六、静态路由" class="headerlink" title="六、静态路由"></a>六、静态路由</h1><p>网络拓扑</p><p><img src="/../../img/image-20240726172446909.png" alt="image-20240726172446909"></p><p>直接用PC1去ping Server1，中间发生的事情：</p><ul><li>PC1去ping 192.168.3.10，发现跟自己不是一个网段，把数据包丢给路由器AR1</li><li>路由器AR1查路由表（display ip routing-table），空的</li><li>结果不通</li></ul><p>需要给路由器配置路由才行（静态路由）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># AR1路由器（过去）system-view# 目标 子网掩码 下一跳ip route-static 192.168.3.0 255.255.255.0 192.168.2.10# AR2路由器（回来）system-viewip route-static 192.168.1.0 255.255.255.0 192.168.2.1</code></pre></div></figure><h1 id="七、网络安全入门"><a href="#七、网络安全入门" class="headerlink" title="七、网络安全入门"></a>七、网络安全入门</h1><h2 id="7-1-VLAN-虚拟局域网"><a href="#7-1-VLAN-虚拟局域网" class="headerlink" title="7.1 VLAN 虚拟局域网"></a>7.1 VLAN 虚拟局域网</h2><h3 id="7-1-1-VLAN基础配置"><a href="#7-1-1-VLAN基础配置" class="headerlink" title="7.1.1 VLAN基础配置"></a>7.1.1 VLAN基础配置</h3><p>实现不同虚拟局域网之间的隔离，能降低病毒的影响</p><p>拓扑图：</p><p><img src="/../../img/image-20240726173941498.png" alt="image-20240726173941498"></p><p>实验现象：</p><ul><li>本来1.1.1.1跟1.1.1.2是能互相ping通的，配置完vlan隔离后，将不能互通</li></ul><p>配置三层交换机</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">system-view# 创建vlanvlan 10qvlan 20q# 接口加入vlanint g0&#x2F;0&#x2F;1port link-type accessport default vlan 10quit# 接口加入vlanint g0&#x2F;0&#x2F;2port link-type accessport default vlan 20quit# 查看vlandisplay vlan</code></pre></div></figure><blockquote><p>交换机接口模式</p><p>access：用来连接终端，电脑、打印机 等</p><p>trunk：用来连接其他交换机</p></blockquote><h3 id="7-1-2-trunk模式"><a href="#7-1-2-trunk模式" class="headerlink" title="7.1.2 trunk模式"></a>7.1.2 trunk模式</h3><p>拓扑图：</p><p><img src="/../../img/image-20240726174310558.png" alt="image-20240726174310558"></p><p>通过设置接口为trunk模式，数据包会在传递时携带vlan的标识</p><p>完整拓扑：</p><p><img src="/../../img/image-20240726174639065.png" alt="image-20240726174639065"></p><p>trunk配置方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># LSW1system-viewint g0&#x2F;0&#x2F;3# 允许所有vlan通过port trunk allow-pass vlan all# 或者一条条指定# port trunk allow-pass vlan 10# port trunk allow-pass vlan 20# LSW2system-viewint g0&#x2F;0&#x2F;1port trunk allow-pass vlan all</code></pre></div></figure><p>两边PC都做好配置，可以实现效果</p><ul><li>同VLAN能通，如PC1（1.1.1.1）能ping通PC3（1.1.1.3）</li><li>不同VLAN不能通，如PC1不能ping通PC2（1.1.1.2）和PC4（1.1.1.4）</li></ul><h3 id="7-1-3-VLAN互连技术-三层交换"><a href="#7-1-3-VLAN互连技术-三层交换" class="headerlink" title="7.1.3 VLAN互连技术 - 三层交换"></a>7.1.3 VLAN互连技术 - 三层交换</h3><p>使用三层交换机实现不同VLAN通信</p><p>使用场景：</p><ul><li>先用vlan把用户隔离开（主要隔离故障，如病毒等）</li><li>再用<strong>三层交换</strong>，把隔离的用户连起来（正常的主机）</li></ul><p>拓扑图</p><p><img src="/../../img/image-20240726175750423.png" alt="image-20240726175750423"></p><p>LSW1配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建VLANvlan 10vlan 20# 配置trunkint g0&#x2F;0&#x2F;0&#x2F;1port link-type trunkport trunk allow-pass vlan all# 配置ipint vlan 10ip add 1.1.1.254int vlan 20ip add 2.2.2.254</code></pre></div></figure><p>LSW2配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建VLANsystem-viewvlan 10vlan 20# 接口划分VLANint g0&#x2F;0&#x2F;0&#x2F;1 port link-type accessport default vlan 10int g0&#x2F;0&#x2F;0&#x2F;2 port link-type accessport default vlan 20# 设置TRUNKint g0&#x2F;0&#x2F;0&#x2F;2 port link-type trunkport trunk allow-pass vlan all</code></pre></div></figure><p>保存配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save</code></pre></div></figure><h3 id="7-1-4-VLAN互连技术-单臂路由"><a href="#7-1-4-VLAN互连技术-单臂路由" class="headerlink" title="7.1.4 VLAN互连技术 - 单臂路由"></a>7.1.4 VLAN互连技术 - 单臂路由</h3><p>一台路由器来实现不同的VLAN通信</p><p>单臂路由的拓扑图</p><p><img src="/../../img/image-20240727195146719.png" alt="image-20240727195146719"></p><p>路由器AR1配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sy# 创建子接口int g0&#x2F;0&#x2F;0.10int g0&#x2F;0&#x2F;0.20# 子接口关联VLANint g0&#x2F;0&#x2F;0.10dot1q termination vid 10# 开启ARP广播功能arp broadcast enable# 配置IP地址ip address 1.1.1.254 255.255.255.0# VLAN 20同理int g0&#x2F;0&#x2F;0.20dot1q termination vid 20arp broadcast enableip address 2.2.2.254 255.255.255.0</code></pre></div></figure><p>实现效果，1.1.1.1能ping通2.2.2.1</p><h2 id="7-2-ACL访问控制列表"><a href="#7-2-ACL访问控制列表" class="headerlink" title="7.2 ACL访问控制列表"></a>7.2 ACL访问控制列表</h2><p>拓扑图：</p><p><img src="/../../img/image-20240727195342844.png" alt="image-20240727195342844"></p><p>实现效果：</p><ul><li><p>先配置三层交换，vlan互相可以通</p></li><li><p>再配置ACL做点限制</p><ul><li><p>vlan 20可以访问vlan 30</p></li><li><p>但是vlan 10不可以访问vlan 30</p></li></ul></li></ul><blockquote><p>ACL分为基本和高级</p><ul><li>基本ACL只会看源地址，不会检查目标地址</li><li>而高级ACL可以针对目标地址来控制</li></ul></blockquote><p>在三层交换机LSW1配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进入system-view模式sy# 创建ACL - 高级acl name test advance# 添加规则1, 禁止10访问30rule deny ip source 192.168.10.0 0.0.0.255 destination 192.168.30.0 0.0.0.255# 添加规则2，允许其他所有rule permit ip rouce any destination any# 接口绑定ACLint g0&#x2F;0&#x2F;1traffic-filter inbound acl name test</code></pre></div></figure><p>查看ACL列表</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">display acl all</code></pre></div></figure><p>查看接口绑定的ACL</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">int g0&#x2F;0&#x2F;1display this</code></pre></div></figure><h1 id="八、NAT网络地址转换"><a href="#八、NAT网络地址转换" class="headerlink" title="八、NAT网络地址转换"></a>八、NAT网络地址转换</h1><p>如何连接互联网？</p><p>1、写默认路由</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip route 0.0.0.0 0.0.0.0 下一跳</code></pre></div></figure><p>2、写NAT，将私网地址转换为公网地址</p><h2 id="8-1-动态NAT"><a href="#8-1-动态NAT" class="headerlink" title="8.1 动态NAT"></a>8.1 动态NAT</h2><p>动态NAT：</p><ul><li>一批主机对应一个NAT地址池，随机分配公网地址</li></ul><p>拓扑图</p><p><img src="/../../img/image-20240727200907428.png" alt="image-20240727200907428"></p><p>如果没有配置NAT，192.168.1.1能ping通到64.1.1.1，但是ping不通64.1.1.10</p><p><img src="/../../img/image-20240727201347838.png" alt="image-20240727201347838"></p><p>配置NAT，实现私网地址192.168.1.1转换成公网地址，从而实现上网（ping 通61.1.1.10）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在AR1配置ACLsy# 创建基础ACLacl name neiwang basicrule permit source 192.168.0.0 0.0.255.255# 创建NAT地址池(转成什么公网地址)nat address-group 64.1.1.2 64.1.1.6# 查看ACL-neiwang的编号,得到2999dis acl all# 在出接口绑定ACL和NAT地址池int g0&#x2F;0&#x2F;1nat outbound 2999 address-group 1</code></pre></div></figure><h2 id="8-2-静态NAT"><a href="#8-2-静态NAT" class="headerlink" title="8.2 静态NAT"></a>8.2 静态NAT</h2><p>静态NAT：一批主机，一对一转换公网地址</p><p><font color=red><strong>适用于服务器发布，方便外面的访问进来</strong></font></p><p><img src="/../../img/image-20240727202334155.png" alt="image-20240727202334155"></p><p>实验拓扑</p><p><img src="/../../img/image-20240727202550102.png" alt="image-20240727202550102"></p><p>核心配置，转换公网地址119.1.1.123</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># AR1 # 配置路由syip route-static 200.200.200.0 255.255.255.0 119.1.1.2# 接口设置静态NATint g0&#x2F;0&#x2F;1 nat server global 119.1.1.123 inside 172.16.0.1</code></pre></div></figure><p>实现的效果</p><ul><li>200.200.200.200可以ping通119.1.1.123，实现公网发布</li><li>但是ping 172.16.0.1是不会通的，因为AR2上会有回来的路由</li></ul><h1 id="九、Telnet"><a href="#九、Telnet" class="headerlink" title="九、Telnet"></a>九、Telnet</h1><p>模拟telnet远程控制路由器</p><p>拓扑图：</p><p><img src="/../../img/image-20240728185739738.png" alt="image-20240728185739738"></p><p>cloud设备做配置，与物理机网卡相连</p><p><img src="/../../img/image-20240728185538475.png" alt="image-20240728185538475"></p><p>在给物理网卡手动设置个IP</p><p><img src="/../../img/image-20240728185701138.png" alt="image-20240728185701138"></p><p>路由器AR1开通远程管理</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sy# 开5个user-interface vty 0 4# 设置认证授权authentication-mode aaa # 退出q# 创建用户local-user testuser password cipher 123456# 用户授权local-user testuser privilege level 15# 允许telnetlocal-user testuser serivce-type telnet# 开启telnet服务telnet server on</code></pre></div></figure><p>在物理机使用telnet管理路由器</p><p><img src="/../../img/image-20240728190145795.png" alt="image-20240728190145795"></p><h1 id="十、中小型网络系统综合实验"><a href="#十、中小型网络系统综合实验" class="headerlink" title="十、中小型网络系统综合实验"></a>十、中小型网络系统综合实验</h1><h2 id="10-1-实验拓扑"><a href="#10-1-实验拓扑" class="headerlink" title="10.1 实验拓扑"></a>10.1 实验拓扑</h2><p>拓扑图如下：</p><p><img src="/../../img/image-20240728192430900.png" alt="image-20240728192430900"></p><h2 id="10-2-实验步骤"><a href="#10-2-实验步骤" class="headerlink" title="10.2 实验步骤"></a>10.2 实验步骤</h2><h3 id="10-2-1-接入层交换机LSW2-3配置"><a href="#10-2-1-接入层交换机LSW2-3配置" class="headerlink" title="10.2.1 接入层交换机LSW2&#x2F;3配置"></a>10.2.1 接入层交换机LSW2&#x2F;3配置</h3><p>1、LSW2 – 不需要做配置，只有一个vlan10</p><p>2、LSW3划分vlan 20 20</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">syvlan batch 20 30int e0&#x2F;0&#x2F;2port link-type accessport default vlan 20port trunk allo-pass vlan allint e0&#x2F;0&#x2F;3port link-type accessport default vlan 30int e0&#x2F;0&#x2F;1port link-type trunkport trunk allow-pass vlan all</code></pre></div></figure><h3 id="10-2-2-网关交换机LSW1配置"><a href="#10-2-2-网关交换机LSW1配置" class="headerlink" title="10.2.2 网关交换机LSW1配置"></a>10.2.2 网关交换机LSW1配置</h3><blockquote><p>做三层交换，vlan互通</p></blockquote><p>内网互通配置如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建vlan网关配置ip地址syvlan batch 10 20 30 40int vlan 10ip add 192.168.10.254 24int vlan 20ip add 192.168.20.254 24int vlan 30ip add 192.168.30.254 24int vlan 40ip add 192.168.40.254 24# 开启DHCP功能，给vlan10 20 30分IP（PC机器记得开启DHCP）dhcp enableint vlan 10dhcp select interfacedhcp select dns-list 172.16.100.1int vlan 20dhcp select interfacedhcp select dns-list 172.16.100.1int vlan 30dhcp select interfacedhcp select dns-list 172.16.100.1# 检查配置display ip int p# 配置g0&#x2F;0&#x2F;2 vlan 10 accessint g0&#x2F;0&#x2F;2port link-type accessport default vlan 10# 配置g0&#x2F;0&#x2F;3 trunkint g0&#x2F;0&#x2F;3port link-type trunkport trunk allow-pass vlan all# 配置g0&#x2F;0&#x2F;4 vlan 40 accessint g0&#x2F;0&#x2F;4port link-type accessport default vlan 40# 配置g0&#x2F;0&#x2F;1与路由器连接vlan 100int g0&#x2F;0&#x2F;1port link-type accessport default vlan 100int vlan 100ip address 10.10.10.2 255.255.255.0</code></pre></div></figure><p>配置完之后的效果：PC机能通过DHCP获取IP，且vlan间能互相通信。</p><p>与外网互通 – 静态路由配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip route-static 0.0.0.0 0.0.0.0 10.10.10.1</code></pre></div></figure><h3 id="10-2-3-DNS服务器配置"><a href="#10-2-3-DNS服务器配置" class="headerlink" title="10.2.3 DNS服务器配置"></a>10.2.3 DNS服务器配置</h3><p>设置IP</p><p><img src="/../../img/image-20240728192107617.png" alt="image-20240728192107617"></p><p>开启DNS服务</p><p><img src="/../../img/image-20240728192142268.png" alt="image-20240728192142268"></p><h3 id="10-2-4-网关路由器AR1配置"><a href="#10-2-4-网关路由器AR1配置" class="headerlink" title="10.2.4 网关路由器AR1配置"></a>10.2.4 网关路由器AR1配置</h3><p>接口设置IP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置g0&#x2F;0&#x2F;0与交换机连接syint g0&#x2F;0&#x2F;0ip add 10.10.10.1 24# 配置g0&#x2F;0&#x2F;1与外网AR2连接int g0&#x2F;0&#x2F;1ip add 64.1.1.1 24</code></pre></div></figure><p>路由配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 出去的路由ip route-static 0.0.0.0 0.0.0.0 64.1.1.10# 回来的路由ip route-static 192.168.0.0 255.255.0.0 10.10.10.2ip route-static 172.16.100.0 255.255.255.0 10.10.10.2</code></pre></div></figure><p>出去上网的NAT配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建ACLacl 2000# 设置规则rule permit source 192.168.0.0 0.0.255.255# 退出q# 设置地址池nat address-group 1 64.1.1.5 64.1.1.15# 接口绑定natint g0&#x2F;0&#x2F;1nat outbound 2000 address-group 1</code></pre></div></figure><h3 id="10-2-5-PC1不能访问外网-ACL"><a href="#10-2-5-PC1不能访问外网-ACL" class="headerlink" title="10.2.5 PC1不能访问外网 - ACL"></a>10.2.5 PC1不能访问外网 - ACL</h3><blockquote><p>在AR1配置</p></blockquote><p>命令如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建ACLacl 2001rule deny source 192.168.10.0 0.0.0.255 rule permit source any# 允许其他# 绑定接口int g0&#x2F;0&#x2F;0traffic-filter inbound acl 2001</code></pre></div></figure><h3 id="10-2-6-内网服务器发布"><a href="#10-2-6-内网服务器发布" class="headerlink" title="10.2.6 内网服务器发布"></a>10.2.6 内网服务器发布</h3><blockquote><p>在AR1配置</p></blockquote><p>将内网服务器172.16.100.1通过公网地址发布出去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">int g0&#x2F;0&#x2F;1nat server global 64.1.1.3 inside 172.16.100.1</code></pre></div></figure><p>实现效果：</p><p>外网PC 8.8.8.8和9.9.9.9可以通过64.1.1.3访问到内网服务器</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>1、网工入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day03-HCIA课程(一)</title>
    <link href="/2024/07/27/08_%E7%BD%91%E7%BB%9C/day03-HCIA%E8%AF%BE%E7%A8%8B-01/"/>
    <url>/2024/07/27/08_%E7%BD%91%E7%BB%9C/day03-HCIA%E8%AF%BE%E7%A8%8B-01/</url>
    
    <content type="html"><![CDATA[<h1 id="HCIA课程（一）"><a href="#HCIA课程（一）" class="headerlink" title="HCIA课程（一）"></a>HCIA课程（一）</h1><h1 id="零、设备基础配置"><a href="#零、设备基础配置" class="headerlink" title="零、设备基础配置"></a>零、设备基础配置</h1><p>网络拓扑</p><p><img src="C:\Users\z\AppData\Roaming\Typora\typora-user-images\image-20240802101243434.png" alt="image-20240802101243434"></p><h2 id="0-1-设备系统参数的配置方法"><a href="#0-1-设备系统参数的配置方法" class="headerlink" title="0.1 设备系统参数的配置方法"></a>0.1 设备系统参数的配置方法</h2><blockquote><p>设备名称、系统时间、时区</p></blockquote><p>查看系统信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">display version# 可以查看路由器的软件版本与设备名称# VRP...Version 5.1.60...# Huawei AR2220E ...</code></pre></div></figure><p>修改系统时间</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改方式一clock time zone Local add 08:00:00# 修改方式二clock datetime 12:00:00 2024-08-02# 查看时间display clock</code></pre></div></figure><p>帮助命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">display ?</code></pre></div></figure><p>进入系统视图</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;Huawei&gt;system viewEnter system view, return user view with Crtl+Z.</code></pre></div></figure><p>修改设备名称</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysname R1</code></pre></div></figure><p>配置登录信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">header shell infomation &quot;Welcome to the Huawei certification lab.&quot;</code></pre></div></figure><p>配置console口参数，需要密码登录，空闲20分钟自动退出 </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[R1]user-interface console 0[R1]authentication-mode password[R1-ui-console0]set authtication password cipherEnter Password(&lt;8-128&gt;):# 空闲20分钟自动退出，默认是10分钟[R1-ui-console0]idel-timeout 20# 查看配置[R1-ui-console]display this</code></pre></div></figure><p>管理设备配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 保存当前配置文件save# 查看保存的配置文件display saved-configuration# 查看当前配置信息display current-configuration</code></pre></div></figure><p>查看下次启动时使用的配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;R3&gt;display startup...Next startup saved-configuration file:flash:&#x2F;vrpcfg.zip...</code></pre></div></figure><p>删除闪存中的配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;R1&gt;reset  saved-configuration</code></pre></div></figure><p>重启设备的方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reboot</code></pre></div></figure><h1 id="一、OSI七层模型"><a href="#一、OSI七层模型" class="headerlink" title="一、OSI七层模型"></a>一、OSI七层模型</h1><table><thead><tr><th>模型层</th><th>作用</th><th>协议</th></tr></thead><tbody><tr><td>应用层</td><td>为计算机用户提供服务</td><td>DNS、HTTP、Telnet、FTP</td></tr><tr><td>表示层</td><td>数据格式（编解码、加密解密、压缩解压缩）</td><td>HTML、DOC、JPEG、MP3</td></tr><tr><td>会话层</td><td>管理应用程序之间的会话</td><td></td></tr><tr><td>传输层</td><td>为两台主机进程之间的通信提供数据传输服务</td><td>TCP、UDP、SSL</td></tr><tr><td>网络层</td><td>路由和寻址</td><td>IP、ARP、ICMP、OSPF</td></tr><tr><td>数据链路层</td><td>帧编码和误差纠正控制</td><td>MAC&#x2F;LLC、VLAN</td></tr><tr><td>物理层</td><td>比特流传输</td><td>RS-232、RJ45</td></tr></tbody></table><h1 id="二、TCP-IP四层模型"><a href="#二、TCP-IP四层模型" class="headerlink" title="二、TCP&#x2F;IP四层模型"></a>二、TCP&#x2F;IP四层模型</h1><table><thead><tr><th>模型层</th><th>说明</th></tr></thead><tbody><tr><td>应用层</td><td>对应（应用层、表示层、会话层）</td></tr><tr><td>传输层</td><td>对应（传输层）</td></tr><tr><td>网络层</td><td>对应（网络层）</td></tr><tr><td>网络接口层</td><td>对应（数据链路层、物理层）</td></tr></tbody></table><h1 id="三、数据包的封装和解封装"><a href="#三、数据包的封装和解封装" class="headerlink" title="三、数据包的封装和解封装"></a>三、数据包的封装和解封装</h1><p>两台机器之间的数据是怎样传输的？</p><p>1、封装操作：</p><ul><li>发送方机器，将数据一层层打标签封装</li></ul><p><img src="/../../img/image-20240730161057963.png" alt="image-20240730161057963"></p><p>2、数据传输</p><p>封装好的数据，在网络中传递</p><p><img src="/../../img/image-20240730161211929.png" alt="image-20240730161211929"></p><p>3、解封装</p><p>接收方收到数据后，对数据包进行解封装</p><p><img src="/../../img/image-20240730161257831.png" alt="image-20240730161257831"></p><h1 id="四、华为网络设备的操作系统-ARP"><a href="#四、华为网络设备的操作系统-ARP" class="headerlink" title="四、华为网络设备的操作系统-ARP"></a>四、华为网络设备的操作系统-ARP</h1><h2 id="4-1-VRP概述"><a href="#4-1-VRP概述" class="headerlink" title="4.1 VRP概述"></a>4.1 VRP概述</h2><p>VRP是华为公司数据通信产品的通用操作系统，目前主流的是<strong>VRP5</strong>的版本，最新的是VRP8版本，版本发展路线如下：</p><p><img src="/../../img/image-20240730161532461.png" alt="image-20240730161532461"></p><h2 id="4-2-VRP的文件系统"><a href="#4-2-VRP的文件系统" class="headerlink" title="4.2 VRP的文件系统"></a>4.2 VRP的文件系统</h2><h3 id="4-2-1-配置文件"><a href="#4-2-1-配置文件" class="headerlink" title="4.2.1 配置文件"></a>4.2.1 配置文件</h3><p><strong>系统软件</strong>和<strong>配置文件</strong>比较重要</p><p><img src="/../../img/image-20240730161728917.png" alt="image-20240730161728917"></p><h3 id="4-2-2-存储设备"><a href="#4-2-2-存储设备" class="headerlink" title="4.2.2 存储设备"></a>4.2.2 存储设备</h3><p>存储设备包括：</p><ul><li>FLASH<ul><li>不容易丢失数据，主要存放系统软件、配置文件等。如补丁和PAF文件，一般上传到FLASH或SD CARD中</li></ul></li><li>NVRAM<ul><li>随机读写存储器，用于存储日志缓存文件，定时器超时或者缓存写满后再写入Flash</li></ul></li><li>SDRAM<ul><li>相当于电脑内存</li></ul></li><li>SD CARD<ul><li>外置存储卡</li></ul></li><li>USB</li></ul><h3 id="4-2-3-设备初始化过程"><a href="#4-2-3-设备初始化过程" class="headerlink" title="4.2.3 设备初始化过程"></a>4.2.3 设备初始化过程</h3><p><img src="/../../img/image-20240730162309647.png" alt="image-20240730162309647"></p><h3 id="4-2-4-设备管理方式"><a href="#4-2-4-设备管理方式" class="headerlink" title="4.2.4 设备管理方式"></a>4.2.4 设备管理方式</h3><p>分为web界面管理和命令行管理</p><p><img src="/../../img/image-20240730162344237.png" alt="image-20240730162344237"></p><h3 id="4-2-5-VRP用户界面"><a href="#4-2-5-VRP用户界面" class="headerlink" title="4.2.5 VRP用户界面"></a>4.2.5 VRP用户界面</h3><p>Console口和VTY界面</p><p><img src="/../../img/image-20240730162410709.png" alt="image-20240730162410709"></p><p><strong>Console口的连接方式</strong></p><p>Console线</p><p><img src="/../../img/image-20240730162506316.png" alt="image-20240730162506316"></p><p>接到网络设备的Console口</p><p><img src="/../../img/image-20240730162524327.png" alt="image-20240730162524327"></p><h3 id="4-2-6-VRP的用户级别"><a href="#4-2-6-VRP的用户级别" class="headerlink" title="4.2.6 VRP的用户级别"></a>4.2.6 VRP的用户级别</h3><p><img src="/../../img/image-20240730162930680.png" alt="image-20240730162930680"></p><h2 id="4-3-VRP系统的基本配置命令"><a href="#4-3-VRP系统的基本配置命令" class="headerlink" title="4.3 VRP系统的基本配置命令"></a>4.3 VRP系统的基本配置命令</h2><p>1、配置设备名称</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysname myswitch</code></pre></div></figure><p>2、设置系统时间</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看时间dis clock # 设置时区clock timezone 命令# 设置时间clock datetime 19:00:00 2021-9-26# 设置设备的夏时令clock daylight-saving-time</code></pre></div></figure><p>3、设置权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">command-privilege 命令</code></pre></div></figure><p>4、配置用户通过password方式登录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user-interface vty 0 4 set authentication password cipher mypassword</code></pre></div></figure><p>5、配置接口IP地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">interface g0&#x2F;0&#x2F;1ip address 192.168.1.0 255.255.255.0</code></pre></div></figure><p>6、查看当前运行的配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">display current-configuration</code></pre></div></figure><p>7、保存配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save</code></pre></div></figure><p>8、查看保存的配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">display saved-configuration</code></pre></div></figure><p>9、清除已保存的配置（清空还原）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reset saved-configuration</code></pre></div></figure><p>10、查看系统启动配置的参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">display startup</code></pre></div></figure><p>11、指定配置文件</p><p>默认用的<code>flash:/vrpcfg.zip</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 指定修改startup saved-configuration myfile</code></pre></div></figure><p>12、设备重启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reboot</code></pre></div></figure><h3 id="4-3-1-案例"><a href="#4-3-1-案例" class="headerlink" title="4.3.1 案例"></a>4.3.1 案例</h3><p>文件夹操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 获取当前文件夹路径pwd# 查看文件夹中的文件dir# 创建文件夹mkdir test# 删除文件夹rmdir test</code></pre></div></figure><p>文件操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 移动文件move file.txt flash:&#x2F;dhcp&#x2F;# 重命名文件rename huawei.txt save.zip# 复制文件copy save.zip save.bak# 删除文件delete file.txt# 取消删除文件undelete file.txt</code></pre></div></figure><h1 id="五、子网划分"><a href="#五、子网划分" class="headerlink" title="五、子网划分"></a>五、子网划分</h1><p>案例：</p><p><img src="/../../img/image-20240730164657343.png" alt="image-20240730164657343"></p><p>以每个子网需要分10台为例：</p><p>需要往后借<code>2^n - 2 &gt;= 10</code>得到<code>n &gt;= 4</code>位</p><p><img src="/../../img/image-20240730164910023.png" alt="image-20240730164910023"></p><h1 id="六、路由"><a href="#六、路由" class="headerlink" title="六、路由"></a>六、路由</h1><h2 id="6-1-路由分类"><a href="#6-1-路由分类" class="headerlink" title="6.1 路由分类"></a>6.1 路由分类</h2><p>路由分为直连路由、静态路由和动态路由</p><p><img src="/../../img/image-20240731220816171.png" alt="image-20240731220816171"></p><h2 id="6-2-路由优先级"><a href="#6-2-路由优先级" class="headerlink" title="6.2 路由优先级"></a>6.2 路由优先级</h2><h3 id="6-2-1-路由优先级概念"><a href="#6-2-1-路由优先级概念" class="headerlink" title="6.2.1 路由优先级概念"></a>6.2.1 路由优先级概念</h3><p>路由的优先级用于控制路由路线，如图所示：</p><p><img src="/../../img/image-20240731220945242.png" alt="image-20240731220945242"></p><p>查看路由优先级：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看路由表，其中的Pre即为优先级# 如有去1.1.1.1和去2.2.2.2的两台路，查看去1.1.1.1的路由信息display ip routing-table 1.1.1.1</code></pre></div></figure><p>结果如图，Pre项就是优先级，<strong>数值越小，优先级越高</strong>：</p><p><img src="/../../img/image-20240731221230515.png" alt="image-20240731221230515"></p><p>优先级对比过程</p><ul><li>先比较路由的掩码，掩码长的优先<ul><li>如一条路由是20.0.0.0&#x2F;8</li><li>另一条路由是20.10.10.0&#x2F;24（优先）</li></ul></li><li>比较路由的Preference（小的优先）</li><li>如Pre相同，则比较路由的Cost（小的优先）</li><li>如果都相同，形成等价路由</li></ul><h3 id="6-2-2-浮动路由配置"><a href="#6-2-2-浮动路由配置" class="headerlink" title="6.2.2 浮动路由配置"></a>6.2.2 浮动路由配置</h3><p>配置多条路的路由方式，称为浮动路由，配置方式如下：</p><p><img src="/../../img/image-20240731222430227.png" alt="image-20240731222430227"></p><h2 id="6-3-动态路由"><a href="#6-3-动态路由" class="headerlink" title="6.3 动态路由"></a>6.3 动态路由</h2><h3 id="6-3-1-动态路由分类"><a href="#6-3-1-动态路由分类" class="headerlink" title="6.3.1 动态路由分类"></a>6.3.1 动态路由分类</h3><p>按工作区域分类：</p><ul><li>IGP（内部网关协议）<ul><li>RIP</li><li>OSPF（开放式最短路径优先）</li><li>IS-IS</li></ul></li><li>EGP（外部网关协议）<ul><li>BGP</li></ul></li></ul><p>按工作机制和算法分类</p><ul><li>距离矢量路由协议<ul><li>RIP</li></ul></li><li>链路状态路由协议<ul><li>OSPF</li><li>IS-IS</li></ul></li></ul><h3 id="6-3-2-OSPF快速上手"><a href="#6-3-2-OSPF快速上手" class="headerlink" title="6.3.2 OSPF快速上手"></a>6.3.2 OSPF快速上手</h3><p>实验拓扑</p><p><img src="/../../img/image-20240731222744356.png" alt="image-20240731222744356"></p><h1 id="七、链路聚合"><a href="#七、链路聚合" class="headerlink" title="七、链路聚合"></a>七、链路聚合</h1><p>一根线容易出问题，可以用两根线做绑定，这正方法称为链路聚合。</p><h2 id="7-1-手动模式"><a href="#7-1-手动模式" class="headerlink" title="7.1 手动模式"></a>7.1 手动模式</h2><h3 id="7-1-1-手动模式配置方法"><a href="#7-1-1-手动模式配置方法" class="headerlink" title="7.1.1 手动模式配置方法"></a>7.1.1 手动模式配置方法</h3><blockquote><p>手动配置链路聚合</p></blockquote><p>实验拓扑如下：</p><p><img src="/../../img/image-20240731223302974.png" alt="image-20240731223302974"></p><p> LSW1操作步骤（LSW2的两个接口做同样操作）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进入配置模式sy# 创建链路聚合口interface Eth-Trunk 1q# 接口加入链路聚合口int g0&#x2F;0&#x2F;1e-trunk 1# 接口加入链路聚合口int g0&#x2F;0&#x2F;2e-trunk 1</code></pre></div></figure><p>查看配置情况</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">display interface Eth-Trunk 1</code></pre></div></figure><p>可以看到聚合链路已经配置成功</p><p><img src="/../../img/image-20240731223610661.png" alt="image-20240731223610661"></p><p>测试使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 直接使用聚合口，可以当普通口来用int eth 1port default vlan 10quitint vlan 10ip add 1.1.1.1&#x2F;24</code></pre></div></figure><h3 id="7-1-2-手动模式的优缺点"><a href="#7-1-2-手动模式的优缺点" class="headerlink" title="7.1.2 手动模式的优缺点"></a>7.1.2 手动模式的优缺点</h3><p>优点：</p><ul><li>适合不支持LACP协议的老旧设备</li><li>正常情况下，所有链路都是活动链路，平均分担流量</li></ul><p><img src="/../../img/image-20240731224306805.png" alt="image-20240731224306805"></p><p>缺点1：设备间没有报文交互，只能通过管理员确认，接口一定要配置正确，不然容易出错，将包发到错误的交换机</p><p><img src="/../../img/image-20240731224421058.png" alt="image-20240731224421058"></p><p>缺点2：手动模式下，设备只能通过物理层状态判断对端接口是否正常工作</p><p><img src="/../../img/image-20240731224544874.png" alt="image-20240731224544874"></p><h2 id="7-2-LACP动态模式"><a href="#7-2-LACP动态模式" class="headerlink" title="7.2 LACP动态模式"></a>7.2 LACP动态模式</h2><h3 id="7-2-1-介绍"><a href="#7-2-1-介绍" class="headerlink" title="7.2.1 介绍"></a>7.2.1 介绍</h3><p>为解决手动链路聚合存在的两个问题，需要使用LACP动态链路聚合</p><p>LACPDU概念：</p><p><img src="/../../img/image-20240731224744337.png" alt="image-20240731224744337"></p><p>系统优先级概念：</p><p><img src="/../../img/image-20240731224817024.png" alt="image-20240731224817024"></p><h3 id="7-2-2-使用场景"><a href="#7-2-2-使用场景" class="headerlink" title="7.2.2 使用场景"></a>7.2.2 使用场景</h3><p><img src="/../../img/image-20240731224938537.png" alt="image-20240731224938537"></p><p><img src="/../../img/image-20240731224953711.png" alt="image-20240731224953711"></p><h3 id="7-2-3-配置动态链路聚合"><a href="#7-2-3-配置动态链路聚合" class="headerlink" title="7.2.3 配置动态链路聚合"></a>7.2.3 配置动态链路聚合</h3><p>实现拓扑：</p><p><img src="/../../img/image-20240731225608004.png" alt="image-20240731225608004"></p><p>核心配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建链路聚合组interface eth-trunk 1# 配置链路聚合模式mode lacp # 或者manual load-balance# 配置最大活动接口数int eth-trunk 1max active-linknumber 2# 配置最小活动接口数# int eth-trunk 1# least active-linknumber 100# 将接口加入聚合组(方法一)int g0&#x2F;0&#x2F;1eth-trunk 1# 将接口加入聚合组(方法二)int eth-trunk 1trunkport g0&#x2F;0&#x2F;1# 允许不同速率的端口加入同一聚合口int eth-trunk 1mixed-rate link enable# 配置系统优先级lacp priority 30000 # 系统默认优先级是32768，越小越优先</code></pre></div></figure><h1 id="八、STP和RSTP"><a href="#八、STP和RSTP" class="headerlink" title="八、STP和RSTP"></a>八、STP和RSTP</h1><h2 id="8-1-STP实验"><a href="#8-1-STP实验" class="headerlink" title="8.1 STP实验"></a>8.1 STP实验</h2><p>作用：避免网络中的环路问题</p><h3 id="8-1-1-配置根桥"><a href="#8-1-1-配置根桥" class="headerlink" title="8.1.1 配置根桥"></a>8.1.1 配置根桥</h3><p>网络拓扑图</p><p><img src="/../../img/image-20240805145254611.png" alt="配置STP实验拓扑图"></p><p>S1配置为根桥</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进入配置模式&lt;Quidway&gt;system-viewEnter system view ...# 重命名[Quidway]sysname S1# S1配置为根桥[S1]stp mode stp[S1]stp root primary</code></pre></div></figure><p>S2配置为备桥</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进入配置模式&lt;Quidway&gt;system-viewEnter system view ...# 重命名[Quidway]sysname S2# 关闭无关端口[S2]int g0&#x2F;0&#x2F;1[S2]shutdown# S1配置为备桥[S2]stp mode stp[S2]stp root secondary</code></pre></div></figure><p>查看STP信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看STP信息display stp brief# 查看端口的STP状态display stp interface g0&#x2F;0&#x2F;10</code></pre></div></figure><p><img src="/../../img/image-20240805150241870.png" alt="image-20240805150241870"></p><p><img src="/../../img/image-20240805150248879.png" alt="image-20240805150248879"></p><h3 id="8-1-2-控制根桥选举"><a href="#8-1-2-控制根桥选举" class="headerlink" title="8.1.2 控制根桥选举"></a>8.1.2 控制根桥选举</h3><p>查看根桥信息，如果<code>CIST Bridge</code>和<code>CIST Roor/ERPC</code>字段相同，则为根桥</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;S1&gt;display stp...CIST Bridge:0.d0d0-4ba6-aab0...# 相同为根桥CIST Root&#x2F;ERPC:0.d0d0-4ba6-aab0&#x2F;0(This bridge is the root) </code></pre></div></figure><p>再看S2的就不相同</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;S2&gt;display stp...CIST Bridge:0.d0d0-4ba6-ac20...# 不同不是根桥CIST Root&#x2F;ERPC:0.d0d0-4ba6-aab0&#x2F;2000</code></pre></div></figure><p>通过配置优先级，使S2成为根桥，S1成为备份根桥</p><blockquote><p>值越小，优先级越高</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># S1配置[S1]undo stp root[S1]stp priority 8192# S2配置[S1]undo stp root[S1]stp priority 4096</code></pre></div></figure><p>配置完，再通过<code>display stp</code>命令查看选举情况</p><h3 id="8-1-3-控制根端口选举"><a href="#8-1-3-控制根端口选举" class="headerlink" title="8.1.3 控制根端口选举"></a>8.1.3 控制根端口选举</h3><p>查看端口角色</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">&lt;S1&gt;display stop brief</code></pre></div></figure><p>设置端口stp优先级</p><blockquote><p>值越小，优先级越高</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[S2]int g0&#x2F;0&#x2F;9[S2-G&#x2F;0&#x2F;0&#x2F;9]stp port priority 32[S2-G&#x2F;0&#x2F;0&#x2F;9]quit# g0&#x2F;0&#x2F;10成为根端口[S2]int g0&#x2F;0&#x2F;10[S2-G&#x2F;0&#x2F;0&#x2F;9]stp port priority 16</code></pre></div></figure><h2 id="8-2-RSTP实验"><a href="#8-2-RSTP实验" class="headerlink" title="8.2 RSTP实验"></a>8.2 RSTP实验</h2><p>使用场景：</p><ul><li>公司使用二层网络结构，核心层和接入层，作为网络管理员，需要使用RSTP来避免网络中产生二层环路的问题。</li></ul><p>拓扑图</p><p><img src="/../../img/image-20240805153846100.png" alt="image-20240805153846100"></p><h3 id="8-2-1-实验环境准备"><a href="#8-2-1-实验环境准备" class="headerlink" title="8.2.1 实验环境准备"></a>8.2.1 实验环境准备</h3><p>前提准备：</p><ul><li>设置设备名<code>sysname S1</code></li><li>关闭无用端口，确保实验准确性<code>int g0/0/1</code>和<code>shutdown</code></li><li>确保stp已经启用<code>stp enable</code></li></ul><h3 id="8-2-2-清除设备上已有的配置"><a href="#8-2-2-清除设备上已有的配置" class="headerlink" title="8.2.2 清除设备上已有的配置"></a>8.2.2 清除设备上已有的配置</h3><p>如：清除S1上配置的STP优先级和开销</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[S1]undo stp priority[S1]int g0&#x2F;0&#x2F;9[S1-G0&#x2F;0&#x2F;9]undo stp cost</code></pre></div></figure><h3 id="8-2-3-配置RSTP并验证"><a href="#8-2-3-配置RSTP并验证" class="headerlink" title="8.2.3 配置RSTP并验证"></a>8.2.3 配置RSTP并验证</h3><p>S1和S2的STP模式改为RSTP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[S1]stp mode rstp[S2]stp mode rstp</code></pre></div></figure><p>查看rstp的简要信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[S1]display stp</code></pre></div></figure><h3 id="8-2-4-配置边缘端口"><a href="#8-2-4-配置边缘端口" class="headerlink" title="8.2.4 配置边缘端口"></a>8.2.4 配置边缘端口</h3><p>配置连接用户终端的端口为边缘端口，边缘端口可以不通过RSTP计算，直接由Discarding状态转变为Forwarding状态。如本例中，S1和S2的G0&#x2F;0&#x2F;1端口都连接的是一台路由器，可以配置为边缘端口，加快RSTP的收敛速度</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[S1]int g0&#x2F;0&#x2F;1[S1-G0&#x2F;0&#x2F;1]undo shutdown[S1-G0&#x2F;0&#x2F;1]stp edged-port enable[S2]int g0&#x2F;0&#x2F;1[S2-G0&#x2F;0&#x2F;1]undo shutdown[S2-G0&#x2F;0&#x2F;1]stp edged-port enable</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>2、HCIA课程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day78-Devops-Jenkins(四)-完结</title>
    <link href="/2024/07/18/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day78-Devops-Jenkins-4/"/>
    <url>/2024/07/18/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day78-Devops-Jenkins-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Devops架构-Jenkins-04-完结"><a href="#Devops架构-Jenkins-04-完结" class="headerlink" title="Devops架构-Jenkins-04-完结"></a>Devops架构-Jenkins-04-完结</h1><p>今日内容：</p><ul><li>案例07–jenkins+ansible实现项目自动化</li></ul><h1 id="一、Jenkins-Ansible实现"><a href="#一、Jenkins-Ansible实现" class="headerlink" title="一、Jenkins+Ansible实现"></a>一、Jenkins+Ansible实现</h1><h2 id="1-1-整体流程"><a href="#1-1-整体流程" class="headerlink" title="1.1 整体流程"></a>1.1 整体流程</h2><ol><li>开发书写、提交代码 + Dockerfile（代码已做修改并提交成V3.0，网页标题改为<code>Flappy Bird V3.0!</code>）</li><li>jk 拉取代码</li><li>jk 构建镜像并推送到私有仓库</li><li>jk 管理web，在web上拉取镜像并运行容器（之前的案例是写的shell，这里改为ans来实现）</li><li>web或lb：进行部署测试</li></ol><blockquote><p>注意：由于是jenkins服务器调用ansible，机器上必须已经安装了ansible才行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@devops02 &#x2F;]#yum install ansible</code></pre></div></figure></blockquote><h2 id="1-2-Jenkins调用Ans剧本"><a href="#1-2-Jenkins调用Ans剧本" class="headerlink" title="1.2 Jenkins调用Ans剧本"></a>1.2 Jenkins调用Ans剧本</h2><h3 id="1-2-1-创建Jenkins项目"><a href="#1-2-1-创建Jenkins项目" class="headerlink" title="1.2.1 创建Jenkins项目"></a>1.2.1 创建Jenkins项目</h3><p>创建freestyle项目，配置从06案例复制</p><p><img src="/../../../img/image-20240718110029803.png" alt="image-20240718110029803"></p><h3 id="1-2-2-shell构建步骤调整"><a href="#1-2-2-shell构建步骤调整" class="headerlink" title="1.2.2 shell构建步骤调整"></a>1.2.2 shell构建步骤调整</h3><p>修改原有的shell构建步骤，只保留到上传Docker镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#0.判断git_tag是否为默认if [ &quot;$git_tag&quot; &#x3D; &quot;origin&#x2F;master&quot; ];then  git_tag&#x3D;latestfi#1. 构建镜像docker build -t reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_$&#123;git_tag&#125; .#2. 推送到私有仓库#docker login -uxxx -pxxx 私有仓库地址docker push reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_$&#123;git_tag&#125;</code></pre></div></figure><p><img src="/../../../img/image-20240718121619473.png" alt="image-20240718121619473"></p><h3 id="1-2-3-增加Ans构建步骤"><a href="#1-2-3-增加Ans构建步骤" class="headerlink" title="1.2.3 增加Ans构建步骤"></a>1.2.3 增加Ans构建步骤</h3><p>配置Ans剧本构建步骤，并运行测试剧本</p><p><img src="/../../../img/image-20240718110351860.png" alt="image-20240718110351860"></p><p>3、配置-添加密钥凭证：</p><p>选择ssh用户名+私钥的方式，填写用户名和私钥</p><p><img src="/../../../img/image-20240718111300091.png" alt="image-20240718111300091"></p><p><img src="/../../../img/image-20240718111349705.png" alt="image-20240718111349705"></p><p>4、配置-填写剧本路径、hosts文件路径，并指定刚才创建的认证配置</p><p><img src="/../../../img/image-20240718111536067.png" alt="image-20240718111536067"></p><p>测试剧本和hosts文件的内容如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;]#cat &#x2F;server&#x2F;scripts&#x2F;playbook&#x2F;test.yml - hosts: web  gather_facts: false  tasks:    - name: test      shell: hostname -I &gt;&gt;&#x2F;tmp&#x2F;test.log[root@devops02 &#x2F;]#cat &#x2F;server&#x2F;scripts&#x2F;playbook&#x2F;hosts[web]172.16.1.82</code></pre></div></figure><p>5、配置-添加参数</p><p>点击高级选项，再点击添加额外参数按钮</p><p><img src="/../../../img/image-20240718112032281.png" alt="image-20240718112032281"></p><p>按图示进行配置，指定标签参数</p><p><img src="/../../../img/image-20240718112137409.png" alt="image-20240718112137409"></p><p>6、测试运行，输出小牛及success正常</p><p><img src="/../../../img/image-20240718113442691.png" alt="image-20240718113442691"></p><h3 id="1-2-2-书写部署项目的剧本"><a href="#1-2-2-书写部署项目的剧本" class="headerlink" title="1.2.2 书写部署项目的剧本"></a>1.2.2 书写部署项目的剧本</h3><p>将测试剧本换掉，改成部署项目的剧本</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">[root@devops02 &#x2F;server&#x2F;scripts&#x2F;playbook]#cat bird.yml - hosts: web  vars:    - img_name: &quot;ngx_bird_&#123;&#123;ans_git_tag&#125;&#125;&quot;  gather_facts: false  tasks:    - name: 3. 获取80端口是否冲突      #过滤宿主机占用80端口的容器      shell: docker ps -a |grep &#39;:80-&gt;&#39;      #存放到port变量中json形式数据 port.rc返回值      register: port      #用于指定这个模块什么条件下才算是报错了.      #&#39;&quot;not found&quot; in port.stdout&#39; 命令的结果中如果出现 not found字样比如command not found则报错.      #ignore_errors: true      failed_when: &#39;&quot;not found&quot; in port.stdout&#39;        - name: 4. 获取80端口是否冲突,如果有冲突则删除容器      shell: docker ps -a |grep &#39;:80-&gt;&#39;|awk &#39;&#123;print $NF&#125;&#39; |xargs docker rm -f      #当docker ps -a |grep &#39;:80??&#39;命令的返回值是0的时候才会运行删除容器的操作.#port.rc &#x3D;&#x3D; 0      when: port.rc &#x3D;&#x3D; 0        - name: 5. 获取是否有重名的docker容器,如果有冲突则删除容器      shell: docker ps -a |grep -w &quot;&#123;&#123;img_name&#125;&#125;&quot;      register: container_name      failed_when: &#39;&quot;not found&quot; in container_name.stdout&#39;        - name: 6. 获取是否有重名的docker容器,如果有冲突则删除容器      shell: docker ps -a |grep -w &quot;&#123;&#123;img_name&#125;&#125;&quot;|awk &#39;&#123;print $NF&#125;&#39; |xargs docker rm -f      when: container_name &#x3D;&#x3D; 0        - name: debug      debug:        msg: &quot;变量name的值:&#123;&#123;img_name&#125;&#125;，变量git_tag的值&#123;&#123;ans_git_tag&#125;&#125; &#123;&#123;port&#125;&#125; &#123;&#123;container_name&#125;&#125;&quot;        - name: 7. 启动容器      shell: docker run -d --name &quot;&#123;&#123;img_name&#125;&#125;&quot; -p 80:80 --restart&#x3D;always reg.test.cn:5000&#x2F;gblog&#x2F;web:&#123;&#123;img_name&#125;&#125;</code></pre></div></figure><h3 id="1-2-3-最终测试"><a href="#1-2-3-最终测试" class="headerlink" title="1.2.3 最终测试"></a>1.2.3 最终测试</h3><p>1、选择tag开始构建</p><p><img src="/../../../img/image-20240718121837753.png" alt="image-20240718121837753"></p><p>2、构建成功</p><p><img src="/../../../img/image-20240718121330177.png" alt="image-20240718121330177"></p><p>3、访问网站，显示V3.0</p><p><img src="/../../../img/image-20240718121358174.png" alt="image-20240718121358174"></p><h1 id="二、Jenkins进阶"><a href="#二、Jenkins进阶" class="headerlink" title="二、Jenkins进阶"></a>二、Jenkins进阶</h1><h2 id="2-1-Jenkins分布式"><a href="#2-1-Jenkins分布式" class="headerlink" title="2.1 Jenkins分布式"></a>2.1 Jenkins分布式</h2><p>技术背景：</p><ul><li>Jenkins服务器上即运行了maven编译，又运行了Ansible来执行剧本，还运行了docker来构建镜像，压力有点大，一台机器顶不住了</li></ul><p>解决方法：</p><ul><li>把一些功能拆分出去</li><li>运行指定任务的时候指定这个新的jenkins节点即可</li></ul><h2 id="2-2-拆分Docker功能"><a href="#2-2-拆分Docker功能" class="headerlink" title="2.2 拆分Docker功能"></a>2.2 拆分Docker功能</h2><p>将构建docker镜像功能交给对应的docker节点</p><h3 id="2-2-1-前期准备"><a href="#2-2-1-前期准备" class="headerlink" title="2.2.1 前期准备"></a>2.2.1 前期准备</h3><p>在Docker节点上安装java，与jenkins服务器保持一致即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装jdk17[root@docker02 ~]#yum install &#x2F;tmp&#x2F;jdk-17_linux-x64_bin.rpm# 查看版本[root@docker02 ~]#java --versionjava 17.0.11 2024-04-16 LTSJava(TM) SE Runtime Environment (build 17.0.11+7-LTS-207)Java HotSpot(TM) 64-Bit Server VM (build 17.0.11+7-LTS-207, mixed mode, sharing)</code></pre></div></figure><h3 id="2-2-2-jenkins添加docker节点"><a href="#2-2-2-jenkins添加docker节点" class="headerlink" title="2.2.2 jenkins添加docker节点"></a>2.2.2 jenkins添加docker节点</h3><p>1、首页 — 系统管理 — 节点管理 — 新建节点</p><p><img src="/../../../img/image-20240718152323248.png" alt="image-20240718152323248"></p><p>2、填写节点名称</p><p><img src="/../../../img/image-20240718152404510.png" alt="image-20240718152404510"></p><p>3、填写节点详细信息</p><p><img src="/../../../img/image-20240718152715220.png" alt="image-20240718152715220"></p><p>4、新增认证方式</p><p><img src="/../../../img/image-20240718152644376.png" alt="image-20240718152644376"></p><p>5、继续填写节点信息</p><p><img src="/../../../img/image-20240718152758013.png" alt="image-20240718152758013"></p><p>6、创建完，出现docker02节点</p><p><img src="/../../../img/image-20240718152841269.png" alt="image-20240718152841269"></p><h3 id="2-2-3-创建任务并绑定到指定节点中"><a href="#2-2-3-创建任务并绑定到指定节点中" class="headerlink" title="2.2.3 创建任务并绑定到指定节点中"></a>2.2.3 创建任务并绑定到指定节点中</h3><p>主要配置：限制项目的运行节点</p><p><img src="/../../../img/image-20240718153029251.png" alt="image-20240718153029251"></p><p>直接运行即可，可见Docker构建操作在Docker02机器上完成</p><p><img src="/../../../img/image-20240718153142209.png" alt="image-20240718153142209"></p><h2 id="2-2-RBAC认证"><a href="#2-2-RBAC认证" class="headerlink" title="2.2 RBAC认证"></a>2.2 RBAC认证</h2><h3 id="2-2-1-什么是RBAC认证？"><a href="#2-2-1-什么是RBAC认证？" class="headerlink" title="2.2.1 什么是RBAC认证？"></a>2.2.1 什么是RBAC认证？</h3><p>技术背景：</p><ul><li>目前jenkins的认证没有做用户权限划分，登录的用户可以做任何事情，<strong>权限比较混乱</strong>，需要一种技术来给jenkins用户划分权限。</li></ul><p>RBAC一种基于role(角色)的认证体系，可以给用户分配角色（role），role可以理解成权限集合，如：</p><ul><li>dev-auto角色，负责内部测试环境的job</li><li>dev角色，负责管理所有的开发job</li><li>ops角色，负责管理生产环境job</li></ul><p>未来把用户或用户组与对应的role关联即可拥有相关的权限  </p><h3 id="2-2-2-开启RBAC认证"><a href="#2-2-2-开启RBAC认证" class="headerlink" title="2.2.2 开启RBAC认证"></a>2.2.2 开启RBAC认证</h3><p>1、安装RBAC认证插件</p><p>插件名：Matrix Authorization Strategy </p><p><img src="/../../../img/image-20240718153912642.png" alt="image-20240718153912642"></p><p>2、启用RBAC认证</p><p>首页 – 系统管理 – 全局安全配置。将授权策略改为“Role-Based Strategy”</p><p><img src="/../../../img/image-20240718154522449.png" alt="image-20240718154522449"></p><p>3、角色划分</p><p>首页 — 系统管理 — Manage and Assign Roles ，进入配置页面</p><p><img src="/../../../img/image-20240718154850289.png" alt="image-20240718154850289"></p><p>在里面可以配置各jenkins用户的权限</p><p><img src="/../../../img/image-20240718155209928.png" alt="image-20240718155209928"></p><h3 id="2-2-3-创建Roles"><a href="#2-2-3-创建Roles" class="headerlink" title="2.2.3 创建Roles"></a>2.2.3 创建Roles</h3><p>1、创建一个jenkins用户dev，首页 — 系统管理 — 管理用户</p><p><img src="/../../../img/image-20240718155519650.png" alt="image-20240718155519650"> </p><p>2、Roles管理，添加权限</p><p>进入管理角色的页面</p><p><img src="/../../../img/image-20240718162211684.png" alt="image-20240718162211684"></p><p>添加全局权限：dev-global，权限是只读</p><p><img src="/../../../img/image-20240718155957567.png" alt="image-20240718155957567"></p><p>添加Item权限，设置关键字<code>dev测试环境.*</code>，如图所示</p><p><img src="/../../../img/image-20240718160326407.png" alt="image-20240718160326407"></p><blockquote><p>这个<code>dev测试环境.*</code>实际上是指jenkins的项目文件夹，限制权限，只能访问这个文件夹里面的项目</p><p><img src="/../../../img/image-20240718160700897.png" alt="image-20240718160700897"></p></blockquote><h3 id="2-2-4-Roles关联用户"><a href="#2-2-4-Roles关联用户" class="headerlink" title="2.2.4 Roles关联用户"></a>2.2.4 Roles关联用户</h3><p>进入分配角色的页面</p><p><img src="/../../../img/image-20240718162228153.png" alt="image-20240718162228153"></p><p>将2.2.3中创建的Roles跟用户关联</p><p><img src="/../../../img/image-20240718162129222.png" alt="image-20240718162129222"></p><h1 id="三、Jenkins-pipeline全流程"><a href="#三、Jenkins-pipeline全流程" class="headerlink" title="三、Jenkins pipeline全流程"></a>三、Jenkins pipeline全流程</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>pipeline又叫流水线，基于Jenkins的工作框架，通过”代码的方式”，将多个任务联合起来.  </p><p>使用流水线的好处：</p><ul><li>便于模块化管理</li><li>方便检查和排错，不像在页面点点点的，要一个个配置去排查</li><li>整体运行思路清晰</li></ul><h2 id="3-2-流水线的格式"><a href="#3-2-流水线的格式" class="headerlink" title="3.2 流水线的格式"></a>3.2 流水线的格式</h2><p>有三大核心：</p><ul><li>agent：指定主机，类似于ansible hosts 指定在哪些机器运行pipeline</li><li>stages：指定任务，类似于 ansible tasks</li><li>steps：具体的指令，类似于ansible中调用各种模块</li></ul><p><img src="/../../../img/image-20240718163634095.png" alt="image-20240718163634095"></p><h3 id="3-2-1-创建流水线"><a href="#3-2-1-创建流水线" class="headerlink" title="3.2.1 创建流水线"></a>3.2.1 创建流水线</h3><p>1、新建jenkins项目 — 选择“流水线”</p><p><img src="/../../../img/image-20240718163238057.png" alt="image-20240718163238057"></p><p>2、填入脚本</p><p><img src="/../../../img/image-20240718180917519.png" alt="image-20240718180917519"></p><p>脚本内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pipeline &#123;agent anyenvironment &#123;host&#x3D;&quot;oldboylinux.com&quot;&#125;stages &#123;stage(&#39;1.Open&#39;) &#123;steps &#123;echo &quot;open eyes $host&quot;&#125;&#125;stage(&#39;2.CloseAlarm&#39;) &#123;steps &#123;echo &quot;close alarm $host&quot;&#125;&#125;stage(&#39;3.Go_to_sleep&#39;) &#123;steps &#123;echo &quot;go-to-sleep $host&quot;&#125;&#125;&#125;&#125;</code></pre></div></figure><p>3、测试执行</p><p>执行成功，会生成阶段视图</p><p><img src="/../../../img/image-20240718180959080.png" alt="image-20240718180959080"></p><p>查看输出</p><p><img src="/../../../img/image-20240718181020464.png" alt="image-20240718181020464"></p><h2 id="3-3-上线JAVA项目"><a href="#3-3-上线JAVA项目" class="headerlink" title="3.3 上线JAVA项目"></a>3.3 上线JAVA项目</h2><h3 id="3-3-1-流程概述"><a href="#3-3-1-流程概述" class="headerlink" title="3.3.1 流程概述"></a>3.3.1 流程概述</h3><p>1、Jenkins拉取gitlab代码，获取tag标签</p><p>2、Jenkins调用Sonarqube进行代码质量分析</p><p>3、略：Jenkins调用发送脚本，发送代码质量检查结果</p><p>4、Jenkins调用maevn进行构建</p><p>5、Jenkins调用部署脚本</p><ul><li>进入Web服务器</li><li>分发代码，解压代码，软连接，重启服务</li><li>负载均衡接入web服务器</li></ul><p>6、略：Jenkins通过脚本，发送上线结果</p><h3 id="3-3-2-流水线语法不会怎么办？"><a href="#3-3-2-流水线语法不会怎么办？" class="headerlink" title="3.3.2 流水线语法不会怎么办？"></a>3.3.2 流水线语法不会怎么办？</h3><p>jenkins自带有流水线语法片段生成器，只要在里面先按照文本框的格式输入内容，就可以一键生成pipeline流水线代码片段，进入的方式如图，点击“项目”—“流水线语法”</p><p><img src="/../../../img/image-20240719090725511.png" alt="image-20240719090725511"></p><p>比如我们想获取Git拉取代码的流水线代码：</p><p><img src="/../../../img/image-20240719090935114.png" alt="image-20240719090935114"></p><p>从而获得代码片段</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git credentialsId: &#39;1c8a94f0-c53a-47c9-864a-8c1032d009f7&#39;, url: &#39;git@gitlab.test.cn:dev&#x2F;hello-world-war.git&#39;</code></pre></div></figure><p>因此，在我们实际配置中，只需要先把pipeline的框架打起来，再一步步完善，比如此项目的框架</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pipeline &#123;agent anystages &#123;stage(&#39;git_pull&#39;) &#123;# 拉取代码steps &#123;echo &quot;open eyes $host&quot;&#125;&#125;stage(&#39;sonar&#39;) &#123;# sonarqube 代码质量检查steps &#123;echo &quot;close alarm $host&quot;&#125;&#125;stage(&#39;sonar_result_tongzhi&#39;) &#123;# 代码质量检查结果发送steps &#123;echo &quot;&quot;&#125;&#125;stage(&#39;maven_build&#39;) &#123;# java代码编译steps &#123;echo&#125;&#125;stage(&#39;war_deploy&#39;) &#123;# war包分发,部署steps &#123;echo “”&#125;&#125;stage(&#39;deploy_result&#39;) &#123;# war部署 结果steps &#123;echo “”&#125;&#125;&#125;&#125;</code></pre></div></figure><h3 id="3-3-2-详细步骤"><a href="#3-3-2-详细步骤" class="headerlink" title="3.3.2 详细步骤"></a>3.3.2 详细步骤</h3><p>1、创建流水线项目</p><p><img src="/../../../img/image-20240719085405461.png" alt="image-20240719085405461"></p><p>2、拉取代码部分，在框架中填入生成的片段</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stage(&#39;1.git_pull&#39;) &#123;# 拉取代码steps &#123;git branch: &#39;$&#123;git_tag&#125;&#39;, credentialsId: &#39;1c8a94f0-c53a-47c9-864a-8c1032d009f7&#39;, url: &#39;git@gitlab.test.cn:dev&#x2F;hello-world-war.git&#39;&#125;&#125;</code></pre></div></figure><p>3、代码质量检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stage(&#39;2.sonar&#39;) &#123;# sonarqube 代码质量检查steps &#123;sh &#39;&#39;&#39;&#x2F;app&#x2F;tools&#x2F;maven&#x2F;bin&#x2F;mvn clean verify sonar:sonar   \\-Dsonar.projectKey&#x3D;$&#123;JOB_NAME&#125;   \\-Dsonar.projectName&#x3D;$&#123;JOB_NAME&#125;   \\-Dsonar.host.url&#x3D;http:&#x2F;&#x2F;10.0.0.73:9000   \\-Dsonar.token&#x3D;sqp_81b02625e00ab44168ad7199face27a56d1aa1ae&#39;&#39;&#39;&#125;&#125;</code></pre></div></figure><p>3、代码指令检查结果发送</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stage(&#39;3.sonar_result_tongzhi&#39;) &#123;# 代码质量检查结果发送steps &#123;echo &quot;没配置&quot;&#125;&#125;</code></pre></div></figure><p>4、maven编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stage(&#39;4.maven_build&#39;) &#123;# java代码编译steps &#123;sh &#39;&#39;&#39; &#x2F;app&#x2F;tools&#x2F;maven&#x2F;bin&#x2F;mvnclean package -DskipTests &#39;&#39;&#39;&#125;&#125;</code></pre></div></figure><p>4.5 确认是否部署成功（容错判断，略）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stage(&#39;4.5 .确认是否部署&#39;) &#123;steps &#123;input &#39;是否继续进行部署&#39;&#125;&#125;</code></pre></div></figure><p>5、war包分发，部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stage(&#39;5.war_deploy&#39;) &#123;# war包分发,部署steps &#123;sh &#39;&#39;&#39; sh -x &#x2F;server&#x2F;scripts&#x2F;java_deploy_cd.sh &#39;&#39;&#39;echo &quot;deploy&quot;&#125;&#125;</code></pre></div></figure><p>6、发送部署结果（略）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stage(&#39;6.deploy_result&#39;) &#123;# war部署 结果steps &#123;echo &quot;部署结果&quot;&#125;&#125;</code></pre></div></figure><p>7、完整pipeline脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pipeline &#123;agent anystages &#123;stage(&#39;1.git_pull&#39;) &#123;&#x2F;&#x2F; 拉取代码steps &#123;git branch: &#39;master&#39;, credentialsId: &#39;1c8a94f0-c53a-47c9-864a-8c1032d009f7&#39;, url: &#39;git@gitlab.test.cn:dev&#x2F;hello-world-war.git&#39;&#125;&#125;stage(&#39;2.sonar&#39;) &#123;&#x2F;&#x2F; sonarqube 代码质量检查steps &#123;sh &#39;&#39;&#39;&#x2F;app&#x2F;tools&#x2F;maven&#x2F;bin&#x2F;mvn clean verify sonar:sonar   \\-Dsonar.projectKey&#x3D;$&#123;JOB_NAME&#125;   \\-Dsonar.projectName&#x3D;$&#123;JOB_NAME&#125;   \\-Dsonar.host.url&#x3D;http:&#x2F;&#x2F;10.0.0.73:9000   \\-Dsonar.token&#x3D;sqp_917ceb5382cd34fb53347797fbddd99e472057ac&#39;&#39;&#39;&#125;&#125;stage(&#39;3.sonar_result_tongzhi&#39;) &#123;&#x2F;&#x2F; 代码质量检查结果发送steps &#123;echo &quot;没配置&quot;&#125;&#125;stage(&#39;4.maven_build&#39;) &#123;&#x2F;&#x2F; java代码编译steps &#123;sh &#39;&#39;&#39; &#x2F;app&#x2F;tools&#x2F;maven&#x2F;bin&#x2F;mvn clean package -DskipTests &#39;&#39;&#39;&#125;&#125;stage(&#39;5.war_deploy&#39;) &#123;&#x2F;&#x2F; war包分发,部署steps &#123;echo &quot;war包分发部署&quot;&#125;&#125;stage(&#39;6.deploy_result&#39;) &#123;&#x2F;&#x2F; war部署 结果steps &#123;echo &quot;部署结果&quot;&#125;&#125;&#125;&#125;</code></pre></div></figure><h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3 测试"></a>3.3.3 测试</h3><p>运行的时候有很多坑，需要按照日志提示一个个修改，最后才能运行成功</p><p><img src="/../../../img/image-20240719162846314.png" alt="image-20240719162846314"></p><h2 id="3-4-根据tag标签拉取代码"><a href="#3-4-根据tag标签拉取代码" class="headerlink" title="3.4 根据tag标签拉取代码"></a>3.4 根据tag标签拉取代码</h2><p>这部分测试失败了，仅作为了解，后续自己扩展即可</p><p>1、启用功能需要确保<code>Git Parameter</code>插件已安装<img src="/../../../img/image-20240719163113539.png" alt="image-20240719163113539">”</p><p>2、使用参数化构建</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pipeline &#123;agent anyparameters &#123;gitParameter name: &#39;git_tag&#39;,type: &#39;PT_TAG&#39;,defaultValue: &#39;origin&#x2F;master&#39; ,useRepository:&quot;git@gitlab.test.cn:dev&#x2F;hello-world-war.git&quot;&#125;stages &#123;stage(&#39;Hello&#39;) &#123;steps &#123;git branch: &quot;$&#123;params.git_tag&#125;&quot;,url: &#39;git@gitlab.test.cn:dev&#x2F;hello-world-war.git&#39;&#125;&#125;&#125;&#125;</code></pre></div></figure><h1 id="四、Nexus仓库"><a href="#四、Nexus仓库" class="headerlink" title="四、Nexus仓库"></a>四、Nexus仓库</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>什么是Nexus仓库，它的作用是什么？</p><p>技术背景：</p><ul><li>maven编译的时候，npm&#x2F;cnpm编译，需要下载大量的依赖包</li><li>这些依赖包在每次构建的时候都需要使用</li><li>每次都从公网（如阿里云）下载</li><li>可以搭建一个内部软件仓库，用来存放依赖包</li></ul><p>这个存放依赖的仓库就是用过Nexus来实现的。架构如图</p><p><img src="/../../../img/image-20240719221553543.png" alt="image-20240719221553543"></p><h2 id="4-2-极速上手"><a href="#4-2-极速上手" class="headerlink" title="4.2 极速上手"></a>4.2 极速上手</h2><blockquote><p>主机准备：10.0.0.74，作为Nexus服务器</p></blockquote><h3 id="4-2-1-安装Nexus"><a href="#4-2-1-安装Nexus" class="headerlink" title="4.2.1 安装Nexus"></a>4.2.1 安装Nexus</h3><p>1、下载安装包</p><p>网址：<a href="https://help.sonatype.com/en/download.html">https://help.sonatype.com/en/download.html</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># java11的版本wget https:&#x2F;&#x2F;download.sonatype.com&#x2F;nexus&#x2F;3&#x2F;nexus-3.70.1-02-java11-unix.tar.gz</code></pre></div></figure><p>2、安装java11</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压tar -vxf nexus-3.70.1-02-java11-unix.tar.gz -C &#x2F;app&#x2F;tools&#x2F;# 创建软连接ln -s &#x2F;app&#x2F;tools&#x2F;nexus-3.70.1-02&#x2F; &#x2F;app&#x2F;tools&#x2F;nexus# 命令软连接ln -s &#x2F;app&#x2F;tools&#x2F;nexus&#x2F;bin&#x2F;nexus &#x2F;sbin# 启动服务[root@devop04 &#x2F;app&#x2F;tools&#x2F;nexus]#nexus start</code></pre></div></figure><blockquote><p>使用root启动会有提示，不建议使用Root用户</p><p><img src="/../../../img/image-20240719170433272.png" alt="image-20240719170433272"></p></blockquote><h3 id="4-2-2-访问Nexus的管理页面"><a href="#4-2-2-访问Nexus的管理页面" class="headerlink" title="4.2.2 访问Nexus的管理页面"></a>4.2.2 访问Nexus的管理页面</h3><p>1、配置hosts解析</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># &#x2F;etc&#x2F;hosts文件10.0.0.74 nexus.test.cn</code></pre></div></figure><p>2、访问管理页面，默认端口8081，按照提示，输入用户名和密码登录</p><p><a href="http://nexus.test.cn:8081![image-20240719221012175](../../../img/image-20240719221012175.png)">http://nexus.test.cn:8081![image-20240719221012175](../../../img/image-20240719221012175.png)</a></p><p>需要配置访问权限，设置成需要账号密码访问</p><p><img src="/../../../img/image-20240719221210463.png" alt="image-20240719221210463"></p><blockquote><p>注意：</p><p>如果登录后屏幕提示</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;System Requirement: max file descriptors [4096] likely too low, increase to at least [65536].</code></pre></div></figure><p>是文件描述符不满足最低要求，需要增加到65535（每个进程可以打开的文件数量）</p><p>修改方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;# 方法1：永久生效：&gt;vim &#x2F;etc&#x2F;security&#x2F;limits.conf&gt;# 新增&gt;* soft nofile 65536&gt;* hard nofile 65536&gt;# 方法2：临时生效，重启后失效&gt;ulimit -n 65536</code></pre></div></figure></blockquote><h3 id="4-2-3-配置nexus对接阿里云maven源"><a href="#4-2-3-配置nexus对接阿里云maven源" class="headerlink" title="4.2.3 配置nexus对接阿里云maven源"></a>4.2.3 配置nexus对接阿里云maven源</h3><p>1、首页 — 设置 — Repositories — manven central，进入配置页面</p><p><img src="/../../../img/image-20240719223228925.png" alt="image-20240719223228925"></p><p>2、默认的地址速度很慢，改成阿里云的地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;</code></pre></div></figure><p><img src="/../../../img/image-20240719223622663.png" alt="image-20240719223622663"></p><p>3、配置完，可以点击按钮，对maven源做健康检测</p><p><img src="/../../../img/image-20240719223905209.png" alt="image-20240719223905209"></p><h3 id="4-2-4-maven连接使用Nexus"><a href="#4-2-4-maven连接使用Nexus" class="headerlink" title="4.2.4 maven连接使用Nexus"></a>4.2.4 maven连接使用Nexus</h3><p>配置方式有两种</p><table><thead><tr><th>连接nexus方式</th><th>说明</th><th>方法</th></tr></thead><tbody><tr><td>方式01-全局</td><td>所有java项目都连接nexus仓库</td><td>maven conf&#x2F;settings.xml</td></tr><tr><td>方式02-某个项目</td><td>某个项目连接nexus仓库</td><td>java项目下面 pom.xml</td></tr></tbody></table><p>案例：以全局的方式配置</p><blockquote><p>在devops02（10.0.0.72）配置</p></blockquote><p>修改配置文件</p><blockquote><p>注意：</p><p>URL设置处的<code>id</code>得与设置密码的<code>id</code>一致，才能认证成功</p><p><img src="/../../../img/image-20240721233233245.png" alt="image-20240721233233245"></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、备份[root@devops02 &#x2F;]#cp &#x2F;app&#x2F;tools&#x2F;maven&#x2F;conf&#x2F;settings.xml&#123;,.bak&#125;[root@devops02 &#x2F;]#ls &#x2F;app&#x2F;tools&#x2F;maven&#x2F;conf&#x2F;logging  settings.xml  settings.xml.bak  toolchains.xml# 2、配置文件内容[root@devops02 &#x2F;app&#x2F;code&#x2F;hello-world-war-master]#cat &#x2F;app&#x2F;tools&#x2F;maven&#x2F;conf&#x2F;settings.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;settings xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0&quot;          xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchemainstance&quot;          xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;settings-1.0.0.xsd&quot;&gt;  &lt;pluginGroups&gt;  &lt;&#x2F;pluginGroups&gt;  &lt;proxies&gt;  &lt;&#x2F;proxies&gt;  &lt;servers&gt;    &lt;server&gt;      &lt;id&gt;nexus&lt;&#x2F;id&gt;      &lt;username&gt;admin&lt;&#x2F;username&gt;      &lt;password&gt;redhat123&lt;&#x2F;password&gt;    &lt;&#x2F;server&gt;        &lt;server&gt;      &lt;id&gt;central&lt;&#x2F;id&gt;      &lt;username&gt;admin&lt;&#x2F;username&gt;      &lt;password&gt;redhat123&lt;&#x2F;password&gt;    &lt;&#x2F;server&gt;  &lt;&#x2F;servers&gt;  &lt;mirrors&gt;    &lt;mirror&gt;      &lt;id&gt;nexus&lt;&#x2F;id&gt;      &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;      &lt;url&gt;http:&#x2F;&#x2F;10.0.0.74:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;    &lt;&#x2F;mirror&gt;  &lt;&#x2F;mirrors&gt;  &lt;profiles&gt;    &lt;profile&gt;      &lt;id&gt;nexus&lt;&#x2F;id&gt;      &lt;repositories&gt;        &lt;repository&gt;          &lt;id&gt;central&lt;&#x2F;id&gt;          &lt;url&gt;http:&#x2F;&#x2F;10.0.0.74:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;          &lt;releases&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;releases&gt;          &lt;snapshots&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt;        &lt;&#x2F;repository&gt;      &lt;&#x2F;repositories&gt;        &lt;pluginRepositories&gt;        &lt;pluginRepository&gt;          &lt;id&gt;central&lt;&#x2F;id&gt;          &lt;url&gt;http:&#x2F;&#x2F;10.0.0.74:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;          &lt;releases&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;releases&gt;          &lt;snapshots&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt;        &lt;&#x2F;pluginRepository&gt;      &lt;&#x2F;pluginRepositories&gt;    &lt;&#x2F;profile&gt;  &lt;&#x2F;profiles&gt;    &lt;activeProfiles&gt;    &lt;activeProfile&gt;nexus&lt;&#x2F;activeProfile&gt;  &lt;&#x2F;activeProfiles&gt;&lt;&#x2F;settings&gt;</code></pre></div></figure><h3 id="4-2-5-编译与测试"><a href="#4-2-5-编译与测试" class="headerlink" title="4.2.5 编译与测试"></a>4.2.5 编译与测试</h3><p>测试打包命令<code>mv clean package</code>，可见从私服拉取依赖包</p><p><img src="/../../../img/image-20240721233430917.png" alt="image-20240721233430917"></p><p>最后生成war包成功</p><p><img src="/../../../img/image-20240721233513511.png" alt="image-20240721233513511"></p><p>在私服中可以看到刚才拉取的依赖包已经存放到了本地仓库中</p><p><img src="/../../../img/image-20240721233601179.png" alt="image-20240721233601179"></p><h1 id="五、持续集成-持续发布-总结"><a href="#五、持续集成-持续发布-总结" class="headerlink" title="五、持续集成&#x2F;持续发布-总结"></a>五、持续集成&#x2F;持续发布-总结</h1><p>流程图：</p><p><img src="/../../../img/image-20240721233803887.png" alt="image-20240721233803887"></p><h1 id="六、代码上线目标项目"><a href="#六、代码上线目标项目" class="headerlink" title="六、代码上线目标项目"></a>六、代码上线目标项目</h1><p>要求：</p><p>java或go语言为主.</p><ul><li>java: <a href="https://gitee.com/jishenghua/JSH_ERP">https://gitee.com/jishenghua/JSH_ERP</a></li><li>go: <a href="https://gitee.com/mlogclub/bbs-go">https://gitee.com/mlogclub/bbs-go</a></li></ul><p>java前后端分离</p><ul><li>job01:前端<ul><li>拉取代码</li><li>编译(yarn)</li><li>分发与部署(docker)</li></ul></li><li>job02:后端<ul><li>拉取代码</li><li>编译(mvn) jar</li><li>分发与部署(docker)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day77-Devops-Jenkins(三)</title>
    <link href="/2024/07/16/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day77-Devops-Jenkins-3/"/>
    <url>/2024/07/16/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day77-Devops-Jenkins-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Devops架构-Jenkins-03"><a href="#Devops架构-Jenkins-03" class="headerlink" title="Devops架构-Jenkins-03"></a>Devops架构-Jenkins-03</h1><p>今日内容：</p><ul><li>Jenkins构建docker项目</li><li>SonarQube漏洞分析工具上手</li></ul><h1 id="一、案例06：基于Docker的案例实现静态代码"><a href="#一、案例06：基于Docker的案例实现静态代码" class="headerlink" title="一、案例06：基于Docker的案例实现静态代码"></a>一、案例06：基于Docker的案例实现静态代码</h1><h2 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h2><p>1、主机准备</p><table><thead><tr><th>主机</th><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>gitlab</td><td>代码仓库</td><td>10.0.0.71&#x2F;172.16.1.71</td></tr><tr><td>jenkins</td><td>jenkins、生成docker镜像</td><td>10.0.0.72&#x2F;172.16.1.72</td></tr><tr><td>docker02</td><td>registry仓库、docer部署web页面</td><td>10.0.0.82&#x2F;172.16.1.82</td></tr></tbody></table><p>2、静态页面代码准备</p><p>使用github的开源项目：JS-Flappy-Bird-master</p><p>创建一个gitlab项目，并把源码上传上去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git initgit remote add origin git@gitlab.test.cn:dev&#x2F;bird.gitgit statusgit add .git commit -m &#39;添加birds站点代码&#39;git tag -a v1.0 -m v1.0git push origin mastergit push -u origin --tags</code></pre></div></figure><p>添加完如图所示：</p><p><img src="/../../../img/image-20240716154349441.png" alt="image-20240716154349441"></p><h2 id="1-2-创建Docker镜像（手动）"><a href="#1-2-创建Docker镜像（手动）" class="headerlink" title="1.2 创建Docker镜像（手动）"></a>1.2 创建Docker镜像（手动）</h2><p>基于Nginx官方镜像，结合bird代码制作一个新的镜像</p><p>1、安装Docker，并配置阿里云加速</p><p>参考之前的笔记：<a href="https://gblog.site/2024/05/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day59-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-1/">https://gblog.site/2024/05/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day59-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-1/</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;app&#x2F;code&#x2F;bird]#docker --versionDocker version 26.1.4, build 5650f9b</code></pre></div></figure><p>2、bird代码放到指定目录中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;app&#x2F;code&#x2F;bird]#lsflappy.css  index.html  flappy.js  img  README.md</code></pre></div></figure><p>3、书写Dokerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM nginx:stable-alpineLABEL author&#x3D;gs url&#x3D;gblog.site version&#x3D;v1.0COPY . &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;EXPOSE 80</code></pre></div></figure><p>4、构建镜像，测试运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 构建docker build -t web:ngx_bird_v1.0 .# 运行容器docker run -d --name &quot;ngx_bird_v1.0&quot; -p 8848:80 --rm web:ngx_bird_v1.0# 查看运行情况[root@devops02 &#x2F;app&#x2F;code&#x2F;bird]#docker psCONTAINER ID   IMAGE               COMMAND                  CREATED          STATUS          PORTS                                   NAMESa6f717ddde44   web:ngx_bird_v1.0   &quot;&#x2F;docker-entrypoint.…&quot;   10 seconds ago   Up 10 seconds   0.0.0.0:8848-&gt;80&#x2F;tcp, :::8848-&gt;80&#x2F;tcp   ngx_bird_v1.0</code></pre></div></figure><p>网页访问，镜像能正常使用</p><p><img src="/../../../img/image-20240716154631903.png" alt="image-20240716154631903"></p><h2 id="1-3-将镜像上传到私有仓库（手动）"><a href="#1-3-将镜像上传到私有仓库（手动）" class="headerlink" title="1.3 将镜像上传到私有仓库（手动）"></a>1.3 将镜像上传到私有仓库（手动）</h2><p>准备Docker私有仓库（registry），将制作好的Bird镜像，上传到私有仓库中</p><p>1、创建私有仓库</p><p>在docker02机器中，运行registry容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name &quot;my_registry&quot; -p 5000:5000 -v registry:&#x2F;var&#x2F;lib&#x2F;registry --restart&#x3D;always registry:latest</code></pre></div></figure><p>2、jenkins机器配置通过http方式访问私有仓库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置hosts[root@devops02 &#x2F;app&#x2F;code&#x2F;bird]#echo &quot;172.16.1.82 reg.test.cn&quot; &gt;&gt; &#x2F;etc&#x2F;hosts# 配置registry地址## 第一条是阿里云的Docker镜像加速## 第二条是配置registry仓库路径[root@devops02 &#x2F;app&#x2F;code&#x2F;bird]#cat &#x2F;etc&#x2F;docker&#x2F;daemon.json &#123;    &quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;ej7rbvxb.mirror.aliyuncs.com&quot;],&quot;insecure-registries&quot;:[&quot;http:&#x2F;&#x2F;reg.test.cn:5000&quot;]&#125; # 重启服务[root@devops02 &#x2F;app&#x2F;code&#x2F;bird]#systemctl daemon-reload[root@devops02 &#x2F;app&#x2F;code&#x2F;bird]#systemctl restart docker</code></pre></div></figure><p>3、重新生成镜像，并上传到私有仓库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 打标签，创建镜像docker build -t reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_v2.0 .# 上传镜像docker push reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_v2.0</code></pre></div></figure><h2 id="1-4-创建jenkins任务"><a href="#1-4-创建jenkins任务" class="headerlink" title="1.4 创建jenkins任务"></a>1.4 创建jenkins任务</h2><p>将2、3创建和推送Docker镜像的任务自动化，并完成将容器部署在web服务器的任务。</p><p>0、前提准备</p><p>需要把Dockerfile放到到bird项目中，重新打tag – 2.0</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ lsDockerfile  flappy.css  flappy.js  img&#x2F;  index.html  README.md$ git tagv1.0v1.1v2.0</code></pre></div></figure><p>1、新建自由风格任务</p><p><img src="/../../../img/image-20240716161225090.png" alt="image-20240716161225090"></p><p>2、填写Git项目信息</p><p><img src="/../../../img/image-20240716161347975.png" alt="image-20240716161347975"></p><p>3、创建git参数，识别项目tag</p><p><img src="/../../../img/image-20240716161455300.png" alt="image-20240716161455300"></p><p>4、添加shell执行步骤（包含容器部署）</p><p><img src="/../../../img/image-20240716161721908.png" alt="image-20240716161721908"></p><p>具体命令如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#varsweb_servers&#x3D;&quot;172.16.1.82&quot;#0.判断git_tag是否为默认if [ &quot;$git_tag&quot; &#x3D; &quot;origin&#x2F;master&quot; ];then  git_tag&#x3D;latestfi#1. 构建镜像docker build -t reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_$&#123;git_tag&#125; .#2. 推送到私有仓库#docker login -uxxx -pxxx 私有仓库地址docker push reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_$&#123;git_tag&#125;#3. 部署web服务器for ip in $&#123;web_servers&#125;do  ssh root@$&#123;ip&#125; &quot;    # 判断端口是否占用    docker ps |grep -w 80 |awk &#39;&#123;print $NF&#125;&#39; | xargs docker rm -f    # 判断容器的名字是否有冲突.    if [ &#96;docker ps -a |grep -w &quot;ngx_bird_$&#123;git_tag&#125;&quot; |wc -l &#96; -eq 1 ];then      docker rm -f ngx_bird_$&#123;git_tag&#125;    fi        #启动容器    docker run -d --name &quot;ngx_bird_$&#123;git_tag&#125;&quot; \    -p 80:80 --restart&#x3D;always \    http:&#x2F;&#x2F;reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_$&#123;git_tag&#125;&quot;done</code></pre></div></figure><h2 id="1-5-测试运行"><a href="#1-5-测试运行" class="headerlink" title="1.5 测试运行"></a>1.5 测试运行</h2><h3 id="1-5-1-正常流程"><a href="#1-5-1-正常流程" class="headerlink" title="1.5.1 正常流程"></a>1.5.1 正常流程</h3><p>1、选择tag并运行</p><p><img src="/../../../img/image-20240716170105062.png" alt="image-20240716170105062"></p><p>2、运行成功，部署正常</p><p><img src="/../../../img/image-20240716170129887.png" alt="image-20240716170129887"></p><p>3、测试访问页面</p><p><img src="/../../../img/image-20240716170153166.png" alt="image-20240716170153166"></p><h3 id="1-5-1-问题汇总"><a href="#1-5-1-问题汇总" class="headerlink" title="1.5.1 问题汇总"></a>1.5.1 问题汇总</h3><p>1、docker机器没有配置registry仓库，导致项目运行失败，不能download镜像，报错内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Remove one or more containersUnable to find image &#39;reg.test.cn:5000&#x2F;gblog&#x2F;web:ngx_bird_v2.0&#39; locallydocker: Error response from daemon: Get &quot;https:&#x2F;&#x2F;reg.test.cn:5000&#x2F;v2&#x2F;&quot;: http: server gave HTTP response to HTTPS client.See &#39;docker run --help&#39;.Build step &#39;Execute shell&#39; marked build as failureFinished: FAILURE</code></pre></div></figure><p>解决方法：在客户端机器加上配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 ~]#cat &#x2F;etc&#x2F;docker&#x2F;daemon.json &#123;  &quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;bjjtv7cs.mirror.aliyuncs.com&quot;],  &quot;insecure-registries&quot;: [&quot;reg.test.cn:5000&quot;]&#125;</code></pre></div></figure><p>2、HOSTS不能解析</p><p>解决方法：在客户端机器加上hosts解析</p><h1 id="二、SonarQube快速上手"><a href="#二、SonarQube快速上手" class="headerlink" title="二、SonarQube快速上手"></a>二、SonarQube快速上手</h1><h2 id="2-1-SonarQube概述"><a href="#2-1-SonarQube概述" class="headerlink" title="2.1 SonarQube概述"></a>2.1 SonarQube概述</h2><h3 id="2-1-1-什么是Sonar"><a href="#2-1-1-什么是Sonar" class="headerlink" title="2.1.1 什么是Sonar?"></a>2.1.1 什么是Sonar?</h3><p>是一个开源的代码质量管理系统，用于检测代码中的错误，漏洞和代码规范。它可以与Gitlab、Jenkins集成，以便在项目拉取后进行连续的代码检查  </p><h3 id="2-1-2-环境要求"><a href="#2-1-2-环境要求" class="headerlink" title="2.1.2 环境要求"></a>2.1.2 环境要求</h3><p>1、硬件要求：</p><p>SonarQube服务器的小型（个人或小型团队）实例需要至少2GB的RAM<br>才能高效运行，操作系统需要1GB的空闲RAM。如果您正在为大型团队或企业安装实例，需要考虑官网的附加建议。  </p><p>2、软件要求：</p><table><thead><tr><th>版本</th><th>JDK</th><th>数据库</th></tr></thead><tbody><tr><td>7.7</td><td>1.8</td><td>MySQL</td></tr><tr><td>10.6.0</td><td>17</td><td>从7.9后支持MySQL、PostgreSQL(PSQL)、Oracle等</td></tr></tbody></table><h2 id="2-2-安装SonarQube"><a href="#2-2-安装SonarQube" class="headerlink" title="2.2 安装SonarQube"></a>2.2 安装SonarQube</h2><p>安装版本：10.6.0，数据库选择PostgreSQL</p><blockquote><p>以下操作在devops03机器（10.0.0.73）操作</p><p>配置：1C2G</p></blockquote><h3 id="2-2-1-关闭防火墙和SELinux"><a href="#2-2-1-关闭防火墙和SELinux" class="headerlink" title="2.2.1 关闭防火墙和SELinux"></a>2.2.1 关闭防火墙和SELinux</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops03 ~]#systemctl stop firewalld[root@devops03 ~]#systemctl disable firewalld[root@devops03 ~]#setenforce 0</code></pre></div></figure><h3 id="2-2-2-部署PSQL数据库"><a href="#2-2-2-部署PSQL数据库" class="headerlink" title="2.2.2 部署PSQL数据库"></a>2.2.2 部署PSQL数据库</h3><p>1、安装依赖</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y java-11 unzip wget</code></pre></div></figure><p>2、配置PSQL的yum源（版本15）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops03 ~]#cat &#x2F;etc&#x2F;yum.repos.d&#x2F;psql.repo [psql]name&#x3D;psql repobaseurl&#x3D;https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;postgresql&#x2F;repos&#x2F;yum&#x2F;15&#x2F;redhat&#x2F;rhel-7.9-x86_64enabled&#x3D;1gpgcheck&#x3D;0[root@devops03 ~]#yum clean all &amp;&amp; yum makecache</code></pre></div></figure><p>3、安装PSQL15</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops03 ~]#yum install -y postgresql15-server</code></pre></div></figure><p>4、初始化数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops03 ~]#postgresql-15-setup initdbInitializing database ... OK</code></pre></div></figure><p>5、启动服务，查看端口在5432</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops03 ~]#systemctl start postgresql-15.service [root@devops03 ~]#ss -lntup | grep posttcp    LISTEN     0      128    127.0.0.1:5432                  *:*                   users:((&quot;postmaster&quot;,pid&#x3D;17205,fd&#x3D;7))tcp    LISTEN     0      128       [::1]:5432               [::]:*                   users:((&quot;postmaster&quot;,pid&#x3D;17205,fd&#x3D;6))</code></pre></div></figure><p>6、创建sonar数据库和sonar用户，并授权访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 用root用户不能创建数据库[root@devops03 ~]#psqlpsql: error: connection to server on socket &quot;&#x2F;run&#x2F;postgresql&#x2F;.s.PGSQL.5432&quot; failed: FATAL:  role &quot;root&quot; does not exist# 需要切换到自带的postgres用户[root@devops03 ~]#tail -1 &#x2F;etc&#x2F;passwdpostgres:x:26:26:PostgreSQL Server:&#x2F;var&#x2F;lib&#x2F;pgsql:&#x2F;bin&#x2F;bash# 切换用户[root@devops03 ~]#su - postgres# 进到数据库交互命令行[postgres@devops03 ~]$psqlpsql (15.7)Type &quot;help&quot; for help.postgres&#x3D;# CREATE USER sonar WITH PASSWORD &#39;redhat123&#39;;CREATE ROLEpostgres&#x3D;# CREATE DATABASE sonar OWNER sonar;CREATE DATABASEpostgres&#x3D;# GRANT ALL PRIVILEGES ON DATABASE sonar TO sonar;GRANT</code></pre></div></figure><p>7、修改PSQL配置文件，把认证方法改为<code>md5</code></p><p><img src="/../../../img/image-20240716201120469.png" alt="image-20240716201120469"></p><p>8、修改系统配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 文件描述符增大[root@devops03 ~]#ulimit -n 65536[root@devops03 ~]#echo &#39;*        -       nofile       65535&#39; &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf # 修改内核参数[root@devops03 ~]#echo &#39;vm.max_map_count&#x3D;262144&#39; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf[root@devops03 ~]#sysctl -pvm.max_map_count &#x3D; 262144</code></pre></div></figure><h3 id="2-2-3-部署SonarQube"><a href="#2-2-3-部署SonarQube" class="headerlink" title="2.2.3 部署SonarQube"></a>2.2.3 部署SonarQube</h3><p>1、获取二进制包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https:&#x2F;&#x2F;binaries.sonarsource.com&#x2F;Distribution&#x2F;sonarqube&#x2F;sonarqube-10.6.0.92116.zip</code></pre></div></figure><p>2、部署到&#x2F;usr&#x2F;local</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压unzip sonarqube-10.6.0.92116.zip -d &#x2F;usr&#x2F;local# 创建软连接ln -s &#x2F;usr&#x2F;local&#x2F;sonarqube-10.6.0.92116&#x2F; &#x2F;usr&#x2F;local&#x2F;sonarqube</code></pre></div></figure><p>3、创建sonar用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">useradd sonarchown -R sonar:sonar &#x2F;usr&#x2F;local&#x2F;sonarqube -Rchown sonar:sonar &#x2F;usr&#x2F;local&#x2F;sonarqube-10.6.0.92116&#x2F; -R</code></pre></div></figure><p>4、sonarqube连接psql数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops03 &#x2F;usr&#x2F;local&#x2F;sonarqube]#grep -rn &#39;^[a-Z]&#39; conf&#x2F;sonar.properties 25:sonar.jdbc.username&#x3D;sonar26:sonar.jdbc.password&#x3D;redhat12344:sonar.jdbc.url&#x3D;jdbc:postgresql:&#x2F;&#x2F;localhost&#x2F;sonar</code></pre></div></figure><p>5、启动sonarqube（<font color=red>不能用ROOT启动！启动前需要先启动PSQL</font>）</p><blockquote><p>不能用root启动，只能普通用户，否则会报错！</p><p>像组件中带的elasticsearch</p><p><img src="/../../../img/image-20240719145429109.png" alt="image-20240719145429109"></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 不能用root启动，只能普通用户[root@devops03 &#x2F;usr&#x2F;local&#x2F;sonarqube]#su - sonar# 启动服务[sonar@devops03 ~]$&#x2F;usr&#x2F;local&#x2F;sonarqube&#x2F;bin&#x2F;linux-x86-64&#x2F;sonar.sh start&#x2F;bin&#x2F;javaStarting SonarQube...Started SonarQube.</code></pre></div></figure><p>6、查看日志</p><p>确保服务已经成功启动，如果启动失败可以查看对应的日志文件夹</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;sonarqube&#x2F;logs</code></pre></div></figure><h2 id="2-3-安装插件"><a href="#2-3-安装插件" class="headerlink" title="2.3 安装插件"></a>2.3 安装插件</h2><p>网页访问sonarque的管理页面，默认端口9000</p><p>默认账户：admin&#x2F;admin</p><p><img src="/../../../img/image-20240716204724628.png" alt="image-20240716204724628"></p><h3 id="2-3-1-安装中文语言包"><a href="#2-3-1-安装中文语言包" class="headerlink" title="2.3.1 安装中文语言包"></a>2.3.1 安装中文语言包</h3><p>页面上找到Administration –&gt; Marketplace –&gt; 搜索框chinese，出现一个Chinese Pack，然后点击install  </p><p><img src="/../../../img/image-20240716204938417.png" alt="image-20240716204938417"></p><p>重启sonarqube服务，打开页面即可改为中文</p><h2 id="2-4-创建项目与分析"><a href="#2-4-创建项目与分析" class="headerlink" title="2.4 创建项目与分析"></a>2.4 创建项目与分析</h2><h3 id="2-4-1-分析java项目（本地分析方式）"><a href="#2-4-1-分析java项目（本地分析方式）" class="headerlink" title="2.4.1 分析java项目（本地分析方式）"></a>2.4.1 分析java项目（本地分析方式）</h3><p>1、创建新项目</p><p><img src="/../../../img/image-20240716210058826.png" alt="image-20240716210058826"></p><p>填写项目名称，之后一直下一步</p><p><img src="/../../../img/image-20240716210207627.png" alt="image-20240716210207627"></p><p>3、选择分析方法 — 本地</p><p><img src="/../../../img/image-20240716210445677.png" alt="image-20240716210445677"></p><p>4、创建令牌</p><p><img src="/../../../img/image-20240716210508932.png" alt="image-20240716210508932"></p><p>保存生成的令牌</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Analyze &quot;java-simple&quot;: sqp_81b02625e00ab44168ad7199face27a56d1aa1ae</code></pre></div></figure><p>5、选择分析的技术 — maven</p><p><img src="/../../../img/image-20240716210608809.png" alt="image-20240716210608809"></p><p>6、按指示执行命令，分析代码</p><p>分析day76用到的hello-world-war的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 代码目录[root@devops02 &#x2F;app&#x2F;code&#x2F;hello-world-war-master]#lsdist  pom.xml  README.md  src  target# 分析[root@devops02 &#x2F;app&#x2F;code&#x2F;hello-world-war-master]#mvn clean verify sonar:sonar   -Dsonar.projectKey&#x3D;java-simple   -Dsonar.projectName&#x3D;&#39;java-simple&#39;   -Dsonar.host.url&#x3D;http:&#x2F;&#x2F;10.0.0.73:9000   -Dsonar.token&#x3D;sqp_81b02625e00ab44168ad7199face27a56d1aa1ae</code></pre></div></figure><p>结果分析成功</p><p><img src="/../../../img/image-20240716211140310.png" alt="image-20240716211140310"></p><h3 id="2-4-2-在页面检查分析结果"><a href="#2-4-2-在页面检查分析结果" class="headerlink" title="2.4.2 在页面检查分析结果"></a>2.4.2 在页面检查分析结果</h3><p><img src="/../../../img/image-20240716211257957.png" alt="image-20240716211257957"></p><h3 id="2-4-3-扩展-如何分析其他语言的项目（如HTML）"><a href="#2-4-3-扩展-如何分析其他语言的项目（如HTML）" class="headerlink" title="2.4.3 扩展-如何分析其他语言的项目（如HTML）"></a>2.4.3 扩展-如何分析其他语言的项目（如HTML）</h3><blockquote><p>未实践，了解即可，后续涉及到直接百度</p></blockquote><p>1、对于java代码如何处理？需要使用sonar-scanner扫描，在jenkins主机上面部署sonar-scanner即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unzip sonar-scanner-cli-4.6.2.2472-linux.zip -d&#x2F;app&#x2F;tools&#x2F;ln -s &#x2F;app&#x2F;tools&#x2F;sonar-scanner-4.6.2.2472-linux&#x2F;&#x2F;app&#x2F;tools&#x2F;sonar-scannerln -s &#x2F;app&#x2F;tools&#x2F;sonar-scanner&#x2F;bin&#x2F;sonar-scanner&#x2F;sbin&#x2F;</code></pre></div></figure><p>2、使用sonar-scanner扫描代码  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;04-html-gitlab-cdshell-tagsonar-scanner \-Dsonar.projectKey&#x3D;frontend-html \-Dsonar.sources&#x3D;. \-Dsonar.host.url&#x3D;http:Վˌsonar.oldboylinux.cn:9000 \-Dsonar.login&#x3D;dbc24813677df3a6a5847ef61b86d47d4ae7fcd8</code></pre></div></figure><h2 id="2-5-Jenkins与SonarQube集成"><a href="#2-5-Jenkins与SonarQube集成" class="headerlink" title="2.5 Jenkins与SonarQube集成"></a>2.5 Jenkins与SonarQube集成</h2><h3 id="2-5-1-环境准备"><a href="#2-5-1-环境准备" class="headerlink" title="2.5.1 环境准备"></a>2.5.1 环境准备</h3><table><thead><tr><th>环境</th><th>ip</th></tr></thead><tbody><tr><td>gitlab</td><td>10.0.0.71</td></tr><tr><td>jenkins</td><td>10.0.0.72</td></tr><tr><td>sonarqube</td><td>10.0.0.73</td></tr></tbody></table><p>互相设置hosts</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">10.0.0.71 gitlab.test.cn10.0.0.72 jk.test.cn10.0.0.73 sonar.test.cn</code></pre></div></figure><h3 id="2-5-2-配置jenkins项目"><a href="#2-5-2-配置jenkins项目" class="headerlink" title="2.5.2 配置jenkins项目"></a>2.5.2 配置jenkins项目</h3><p>沿用day76创建的<code>05-hello-war-job</code>项目，修改maven构建步骤，在里面添加sonarqube检测</p><p>修改前</p><p><img src="/../../../img/image-20240716212244091.png" alt="image-20240716212244091"></p><p>修改后</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clean package sonar:sonar   -Dsonar.projectKey&#x3D;$&#123;JOB_BASE_NAME&#125;   -Dsonar.projectName&#x3D;$&#123;JOB_BASE_NAME&#125;   -Dsonar.host.url&#x3D;http:&#x2F;&#x2F;10.0.0.73:9000   -Dsonar.token&#x3D;sqp_81b02625e00ab44168ad7199face27a56d1aa1ae</code></pre></div></figure><blockquote><p>注意事项：</p><ul><li>这个<code>$&#123;JOB_BASE_NAME&#125;</code>对应的项目名在sonarqube中一定要有，不然会报错找不到项目</li></ul><p>建议：</p><ul><li>将jenkins的项目名和sonarqube的项目名保持一致</li></ul></blockquote><p>测试执行成功</p><p><img src="/../../../img/image-20240716213100173.png" alt="image-20240716213100173"></p><p>构建时间对应，可以查看到分析结果</p><p><img src="/../../../img/image-20240716213434039.png" alt="image-20240716213434039"></p><p><img src="/../../../img/image-20240716213453877.png" alt="image-20240716213453877"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day76-Devops-Jenkins(二)</title>
    <link href="/2024/07/12/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day76-Devops-Jenkins-2/"/>
    <url>/2024/07/12/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day76-Devops-Jenkins-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Devops架构-Jenkins-02"><a href="#Devops架构-Jenkins-02" class="headerlink" title="Devops架构-Jenkins-02"></a>Devops架构-Jenkins-02</h1><p>今日内容：</p><ul><li>CD持续交付&#x2F;部署的方案介绍</li><li>案例04：Jenkins从gitlab拉取站点代码并部署</li><li>案例05：Jenkins拉取java代码, maven编译后部署</li></ul><h1 id="一、CD持续交付-部署方案"><a href="#一、CD持续交付-部署方案" class="headerlink" title="一、CD持续交付&#x2F;部署方案"></a>一、CD持续交付&#x2F;部署方案</h1><table><thead><tr><th>CD方案</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>1、使用Jenkins执行shell命令、脚本</td><td>简单、通用</td><td>集群中有大批量节点时，效率低</td><td>通用的、初学者</td></tr><tr><td>2、Jenkins插件Publish Over SSH插件实现（分发文件、远程执行命令等）</td><td>简单</td><td>所有被管理节点都要在Jenkins页面配置</td><td>机器较少可以用</td></tr><tr><td>3、Jenkins执行Ansible剧本、Ad-hoc</td><td>便于批量管理与维护</td><td>需要掌握Ans剧本、模块</td><td>网站集群批量更新.jk+ansible命令<br/>或jk+ansible插件</td></tr><tr><td>4、Jenkins执行Docker命令</td><td>更加简单、适用于集群部署</td><td>需要掌握dockerfile、docker-compose的编写</td><td>jk+docker命令或插件、jk+ansible+docker</td></tr><tr><td>5、jenkins交付到k8s集群</td><td>…</td><td>….</td><td>jk+k8s</td></tr></tbody></table><h1 id="二、案例04：搭建开发测试专用的任务"><a href="#二、案例04：搭建开发测试专用的任务" class="headerlink" title="二、案例04：搭建开发测试专用的任务"></a>二、案例04：搭建开发测试专用的任务</h1><p>任务要求：</p><ul><li>开发人员书写代码，上传到代码仓库.</li><li>只要仓库收到开发上传的代码，触发jenkins的<code>04-webhook-job</code>测试任务.</li><li>jenkins去拉取代码仓库最新的代码并部署到测试环境中.</li><li>这个案例一般用于测试环境自动化部署代码.</li></ul><p>案例流程如下：</p><p><img src="/../../../img/image-20240713211637176.png" alt="image-20240713211637176"></p><h2 id="2-1-详细步骤"><a href="#2-1-详细步骤" class="headerlink" title="2.1 详细步骤"></a>2.1 详细步骤</h2><p>步骤概览：</p><ul><li>jenkins添加gitlab插件</li><li>在jenkins创建钩子令牌(认证).</li><li>在gitlab配置jenkins钩子和令牌.</li><li>测试，提交代码</li></ul><h3 id="2-1-1-Jenkins安装插件"><a href="#2-1-1-Jenkins安装插件" class="headerlink" title="2.1.1 Jenkins安装插件"></a>2.1.1 Jenkins安装插件</h3><p>在jenkins安装两个插件<code>gitlab</code>和<code>Generic Webhook Trigger</code></p><p>gitlab插件</p><p><img src="/../../../img/image-20240713211951085.png" alt="image-20240713211951085"></p><p>钩子插件</p><p><img src="/../../../img/image-20240713212035743.png" alt="image-20240713212035743"></p><h3 id="2-1-2-Jenkins创建任务"><a href="#2-1-2-Jenkins创建任务" class="headerlink" title="2.1.2 Jenkins创建任务"></a>2.1.2 Jenkins创建任务</h3><p>1、创建一个自由风格的任务</p><p><img src="/../../../img/image-20240713212510293.png" alt="image-20240713212510293"></p><p>2、配置“丢弃旧的构建”</p><p><img src="/../../../img/image-20240713212535865.png" alt="image-20240713212535865"></p><p>3、设置Git项目仓库信息</p><p><img src="/../../../img/image-20240713212641143.png" alt="image-20240713212641143"></p><p>4、开启构建触发器，获取钩子地址（URL），并创建令牌（Token）</p><p><img src="/../../../img/image-20240713212707264.png" alt="image-20240713212707264"></p><p>继续点下面的“高级” — “Generate”生成token令牌</p><p><img src="/../../../img/image-20240713212939235.png" alt="image-20240713212939235"></p><p>5、设置构建步骤，添加Shell命令</p><p><img src="/../../../img/image-20240713215749779.png" alt="image-20240713215749779"></p><h3 id="2-1-3-Gitlab配置钩子"><a href="#2-1-3-Gitlab配置钩子" class="headerlink" title="2.1.3 Gitlab配置钩子"></a>2.1.3 Gitlab配置钩子</h3><h4 id="1、解除钩子的局域网访问限制"><a href="#1、解除钩子的局域网访问限制" class="headerlink" title="1、解除钩子的局域网访问限制"></a>1、解除钩子的局域网访问限制</h4><p>用root用户登录gitlab，来到管理中心，选择“设置” — “网络”</p><p><img src="/../../../img/image-20240713214608889.png" alt="image-20240713214608889"></p><p>在“出站点请求”—勾选“允许webhook”即可</p><p><img src="/../../../img/image-20240713214739435.png" alt="image-20240713214739435"></p><p>在旧版中的设置截图如下：</p><p><img src="/../../../img/image-20240713213445476.png" alt="image-20240713213445476"></p><p>都允许上</p><p><img src="/../../../img/image-20240713213504959.png" alt="image-20240713213504959"></p><h4 id="2、gitlab配置钩子"><a href="#2、gitlab配置钩子" class="headerlink" title="2、gitlab配置钩子"></a>2、gitlab配置钩子</h4><p>进入webhook的设置页面</p><p><img src="/../../../img/image-20240713213629602.png" alt="image-20240713213629602"></p><p>添加新的webhook</p><p><img src="/../../../img/image-20240713213852380.png" alt="image-20240713213852380"></p><p>再勾上“合并请求事件”，取消勾选“SSL验证”</p><p><img src="/../../../img/image-20240713214038102.png" alt="image-20240713214038102"></p><p>提示：</p><blockquote><p>如果不做第1步的解除限制，在这会报错</p><p><img src="/../../../img/image-20240713214217352.png" alt="image-20240713214217352"></p></blockquote><h3 id="2-1-4-测试执行"><a href="#2-1-4-测试执行" class="headerlink" title="2.1.4 测试执行"></a>2.1.4 测试执行</h3><p>1、先进行推送测试，返回HTTP 200即为正常</p><p><img src="/../../../img/image-20240713215311527.png" alt="image-20240713215311527"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>2、在Jenkins看测试结果，成功收到一条推送</p><p><img src="/../../../img/image-20240713220021961.png" alt="image-20240713220021961"></p><p>3、站点也部署成功</p><p><img src="/../../../img/image-20240713220134058.png" alt="image-20240713220134058"></p><p>4、修改站点代码，自己推送测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改代码$ cat index.htmlhello4 myproj&lt;title&gt;MyProj V4.0 Release&lt;&#x2F;tiltle&gt;# 打新标签，推送$ git add .$ git commit -m &#39;v4.0&#39;$ git tag -a &quot;v4.0&quot; -m &quot;v4.0&quot;$ git push -u origin master$ git push -u origin --tagsEnumerating objects: 1, done.Counting objects: 100% (1&#x2F;1), done.... * [new tag]         v4.0 -&gt; v4.0</code></pre></div></figure><p>5、推送完，查看jenkins，收到推送，并已经处理</p><p><img src="/../../../img/image-20240713222801538.png" alt="image-20240713222801538"></p><p>6、访问站点，已经部署成功，成功实现代码在git上传后Jenkins自动部署</p><p><img src="/../../../img/image-20240713222827973.png" alt="image-20240713222827973"></p><h1 id="三、案例05：Java代码上线"><a href="#三、案例05：Java代码上线" class="headerlink" title="三、案例05：Java代码上线"></a>三、案例05：Java代码上线</h1><p>步骤概览：</p><ul><li>java程序的源代码存放在了代码仓库中.</li><li>通过jk拉取java源代码,通过工具(maven,gradle)对代码进行编译,最终生成war或jar包.</li><li>通过jk,分发部署,重启服务.</li></ul><h2 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h2><table><thead><tr><th>主机</th><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>gitlab</td><td>代码仓库</td><td>10.0.0.71&#x2F;172.16.1.71</td></tr><tr><td>jenkins</td><td>jenkins</td><td>10.0.0.72&#x2F;172.16.1.72</td></tr><tr><td>web03</td><td>tomcat+jdk</td><td>10.0.0.9&#x2F;172.16.1.9</td></tr><tr><td>lb01</td><td>负载均衡</td><td>10.0.0.5&#x2F;172.16.1.5</td></tr></tbody></table><h2 id="3-2-详细步骤"><a href="#3-2-详细步骤" class="headerlink" title="3.2 详细步骤"></a>3.2 详细步骤</h2><p>步骤总览：</p><ul><li>手动上传代码到gitlab</li><li>手动在jenkins上拉取代码</li><li>手动通过maven编译代码生成war&#x2F;jar包</li><li>war包改名为ROOT.war</li><li>部署<ul><li>war包发送到web节点</li><li>war包部署在webapp&#x2F;目录中</li><li>重启tomcat</li></ul></li></ul><h3 id="3-2-1-代码上传到gitlab"><a href="#3-2-1-代码上传到gitlab" class="headerlink" title="3.2.1 代码上传到gitlab"></a>3.2.1 代码上传到gitlab</h3><p>1、gitlab创建空白项目<code>hello-world-war</code></p><p><img src="/../../../img/image-20240716094835318.png" alt="image-20240716094835318"></p><p>2、从gitee获取需要的源码</p><p>代码获取：<a href="https://github.com/efsavage/hello-world-war">https://github.com/efsavage/hello-world-war</a></p><p>3、把源码上传到gitlab的项目中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git initgit remote add origin git@gitlab.test.cn:dev&#x2F;hello-world-war.gitgit statusgit add .git commit -m &#39;添加源码&#39;git tag -a v1.0 -m v1.0git push origin mastergit push -u origin --tags</code></pre></div></figure><h3 id="3-2-2-jenkins服务器部署maven"><a href="#3-2-2-jenkins服务器部署maven" class="headerlink" title="3.2.2 jenkins服务器部署maven"></a>3.2.2 jenkins服务器部署maven</h3><p>mvn会读取项目中的pom.xml文件，实现自动化编译</p><p>1、安装JDK</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 ~]#java --versionjava 17.0.11 2024-04-16 LTSJava(TM) SE Runtime Environment (build 17.0.11+7-LTS-207)Java HotSpot(TM) 64-Bit Server VM (build 17.0.11+7-LTS-207, mixed mode, sha</code></pre></div></figure><p>2、获取maven二进制包，配置环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载wget https:&#x2F;&#x2F;dlcdn.apache.org&#x2F;maven&#x2F;maven-3&#x2F;3.9.8&#x2F;binaries&#x2F;apache-maven-3.9.8-bin.tar.gz# 部署[root@devops02 &#x2F;app&#x2F;rpms]#mkdir &#x2F;app&#x2F;tools[root@devops02 &#x2F;app&#x2F;rpms]#tar -xf apache-maven-3.9.8-bin.tar.gz -C &#x2F;app&#x2F;tools&#x2F;[root@devops02 &#x2F;app&#x2F;rpms]#ln -s &#x2F;app&#x2F;tools&#x2F;apache-maven-3.9.8&#x2F; &#x2F;app&#x2F;tools&#x2F;maven# 设置环境变量[root@devops02 &#x2F;app&#x2F;rpms]#echo &quot;export PATH&#x3D;&#x2F;app&#x2F;tools&#x2F;maven&#x2F;bin:$PATH&quot; &gt;&gt; &#x2F;etc&#x2F;profile[root@devops02 &#x2F;app&#x2F;rpms]#source &#x2F;etc&#x2F;profile# 查看版本信息[root@devops02 &#x2F;app&#x2F;rpms]#mvn --versionApache Maven 3.9.8 (36645f6c9b5079805ea5009217e36f2cffd34256)Maven home: &#x2F;app&#x2F;tools&#x2F;mavenJava version: 17.0.11, vendor: Oracle Corporation, runtime: &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jdk-17-oracle-x64Default locale: en_US, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;3.10.0-1160.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix</code></pre></div></figure><p>3、设置mvn国内下载源（加速）</p><p>编辑<code>/app/tools/maven/conf/settings.xml</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;mirrors&gt; # 在此标签后面添加    &lt;mirror&gt;      &lt;id&gt;aliyun-maven&lt;&#x2F;id&gt;      &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;      &lt;name&gt;阿里云公共仓库&lt;&#x2F;name&gt;      &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&lt;&#x2F;url&gt;  &lt;&#x2F;mirror&gt;</code></pre></div></figure><h3 id="3-2-3-jenkins拉取代码与手动编译"><a href="#3-2-3-jenkins拉取代码与手动编译" class="headerlink" title="3.2.3 jenkins拉取代码与手动编译"></a>3.2.3 jenkins拉取代码与手动编译</h3><p>1、配置maven工具的路径</p><p>进入“系统管理”—“全局工具配置”</p><p>手动改指定<code>settings.xml</code>文件的路径</p><p><img src="/../../../img/image-20240716101220613.png" alt="image-20240716101220613"></p><p>手动指定maven工具的路径</p><p><img src="/../../../img/image-20240716101242040.png" alt="image-20240716101242040"></p><p>2、创建jk自由风格项目</p><p><img src="/../../../img/image-20240716100737824.png" alt="image-20240716100737824"></p><p>3、配置Git项目信息和ssh密钥</p><p><img src="/../../../img/image-20240716100817753.png" alt="image-20240716100817753"></p><p>4、配置maven编译选项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">maven clean package# 删除已有的target目录，重新编译生成war&#x2F;jar包</code></pre></div></figure><p><img src="/../../../img/image-20240716105310410.png" alt="image-20240716105310410"></p><h3 id="3-2-4-运行项目生成war包"><a href="#3-2-4-运行项目生成war包" class="headerlink" title="3.2.4 运行项目生成war包"></a>3.2.4 运行项目生成war包</h3><p>1、第一次运行失败，在生成war包时出现错误</p><p><img src="/../../../img/image-20240716105543157.png" alt="image-20240716105543157"></p><p>2、问题原因：项目中指定的<code>maven-war-plugin</code>插件版本过低</p><p>解决方法：修改项目<code>pom.xml</code>文件，将插件版本改为<code>3.1.1</code>，并重新上传至gitlab</p><p><img src="/../../../img/image-20240716105751359.png" alt="image-20240716105751359"></p><p>参考：<a href="https://blog.csdn.net/qq_41062276/article/details/120214674">https://blog.csdn.net/qq_41062276/article/details/120214674</a></p><p>3、再次运行，生成成功</p><p><img src="/../../../img/image-20240716105853153.png" alt="image-20240716105853153"></p><h3 id="3-2-5-war包部署（手动实现）"><a href="#3-2-5-war包部署（手动实现）" class="headerlink" title="3.2.5 war包部署（手动实现）"></a>3.2.5 war包部署（手动实现）</h3><p>1、配置jenkins服务器到tomcat服务器的密钥认证</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;app&#x2F;tools&#x2F;maven&#x2F;bin]#ssh-copy-id root@172.16.1.9</code></pre></div></figure><p>2、将war包拷贝到tomcat服务器，改名为<code>ROOT.war</code></p><blockquote><p>war包生成路径：<code>/var/lib/jenkins/workspace/05-hello-war-job/target/hello-world-war-1.0.0.war</code></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;app&#x2F;tools&#x2F;maven&#x2F;bin]#scp &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;05-hello-war-job&#x2F;target&#x2F;hello-world-war-1.0.0.war 172.16.1.9:&#x2F;opt&#x2F;ROOT.war</code></pre></div></figure><p>3、配置tomcat项目目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 清理以前的war包[root@web03 &#x2F;opt]#rm &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps&#x2F;ROOT* -fr# 部署新的war包，并重启服务[root@web03 &#x2F;opt]#mv &#x2F;opt&#x2F;ROOT.war &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps&#x2F;[root@web03 &#x2F;opt]#systemctl restart tomcat</code></pre></div></figure><p>4、测试访问：<a href="http://10.0.0.9:8080/">http://10.0.0.9:8080</a></p><p><img src="/../../../img/image-20240716111424306.png" alt="image-20240716111424306"></p><h3 id="3-2-6-war包部署（jenkins实现）"><a href="#3-2-6-war包部署（jenkins实现）" class="headerlink" title="3.2.6 war包部署（jenkins实现）"></a>3.2.6 war包部署（jenkins实现）</h3><p>jenkins添加shell命令步骤</p><p><img src="/../../../img/image-20240716112858722.png" alt="image-20240716112858722"></p><p>脚本如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;您当前部署的代码版本为: $&#123;TAG_NAME&#125;&quot;echo &quot;您任务的URL地址:$&#123;JOB_DISPLAY_URL&#125;&quot;# .varsdate&#x3D;$(date +%F)# web_list后面可以设置为参数化构建,文本参数web_list&#x3D;&quot;172.16.1.9&quot;# 路径 $WORKSPACEsrc_dir&#x3D;.&#x2F;target&#x2F;dst_dir&#x3D;&#x2F;opt&#x2F;# web节点的变量code_dir&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps&#x2F;ROOTcode_file&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps&#x2F;ROOT.war# 1. 分发fenfa() &#123;  for ip in $&#123;web_list&#125;  do    scp $&#123;src_dir&#125;&#x2F;hello-world-war-1.0.0.war root@$&#123;ip&#125;:$&#123;dst_dir&#125;  done&#125;# 2、部署deploy() &#123;  for ip in $&#123;web_list&#125;  do    # 进入&#x2F;opt文件夹    ssh root@$&#123;ip&#125; &quot;cd $&#123;dst_dir&#125;;    # 改war包名字 ROOT-时间.war    mv hello-world-war-1.0.0.war ROOT-$&#123;date&#125;.war;    [ -d $&#123;code_dir&#125; ] &amp;&amp; &#123;      # 将war包、目录、按时间放到临时文件夹中      mkdir -p &#x2F;tmp&#x2F;$&#123;date&#125;;      mv $&#123;code_dir&#125; $&#123;code_file&#125; &#x2F;tmp&#x2F;$&#123;date&#125; ;    &#125;;    # 创建软连接    ln -s $&#123;dst_dir&#125;&#x2F;ROOT-$&#123;date&#125;.war $&#123;code_file&#125;    # 重启服务    systemctl restart tomcat    &quot;  done&#125; # 主函数main() &#123;  fenfa  deploy&#125;main</code></pre></div></figure><p>执行测试成功</p><p><img src="/../../../img/image-20240716112955544.png" alt="image-20240716112955544"></p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day75-Devops-Jenkins(一)</title>
    <link href="/2024/07/10/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day75-Devops-Jenkins-1/"/>
    <url>/2024/07/10/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day75-Devops-Jenkins-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Devops架构-Jenkins-01"><a href="#Devops架构-Jenkins-01" class="headerlink" title="Devops架构-Jenkins-01"></a>Devops架构-Jenkins-01</h1><p>今日内容：</p><ul><li>了解什么是Jenkins</li><li>Jenkins的安装部署方法</li><li>Jenkins项目01-执行Shell命令</li><li>Jenkins项目02-拉取Gitlab上的代码</li><li>Jenkins项目03-基于tag标签拉取代码并部署</li></ul><h1 id="一、Jenkins概述"><a href="#一、Jenkins概述" class="headerlink" title="一、Jenkins概述"></a>一、Jenkins概述</h1><h2 id="1-1-什么是jenkins？"><a href="#1-1-什么是jenkins？" class="headerlink" title="1.1 什么是jenkins？"></a>1.1 什么是jenkins？</h2><ul><li>Jenkins 是一个开源持续集成的工具，是由 JAVA 开发而成。</li><li>Jenkins 是一个调度平台，本身不处理任何事情，调用插件来完成所有的工作</li></ul><p>可以通过jenkins来完成CI&#x2F;CD</p><h2 id="1-2-Jenkins的生态架构"><a href="#1-2-Jenkins的生态架构" class="headerlink" title="1.2 Jenkins的生态架构"></a>1.2 Jenkins的生态架构</h2><p>jenkins能将各种开源软件集成为一体，从而实现不同功能的调度工作</p><p><img src="/../../../img/image-20240710161846461.png" alt="image-20240710161846461"></p><h1 id="二、Jenkins安装部署"><a href="#二、Jenkins安装部署" class="headerlink" title="二、Jenkins安装部署"></a>二、Jenkins安装部署</h1><h2 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h2><table><thead><tr><th>系统要求&#x2F;软件要求</th><th>主机名</th><th>配置</th><th>ip</th></tr></thead><tbody><tr><td>用于部署jenkins</td><td>devops02</td><td>2c4G</td><td>10.0.0.72&#x2F;172.16.1.72</td></tr></tbody></table><p>需要在机器中安装jenkins，安装Jenkins只需要简单几步即可完成。</p><p>Jenkins的安装方式很多，可参考Jenkins官方安装文档  </p><h2 id="2-2-安装jenkins"><a href="#2-2-安装jenkins" class="headerlink" title="2.2 安装jenkins"></a>2.2 安装jenkins</h2><h3 id="2-2-1-部署JDK"><a href="#2-2-1-部署JDK" class="headerlink" title="2.2.1 部署JDK"></a>2.2.1 部署JDK</h3><p>jenkins依赖jdk运行，需要先部署JDK</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y java-11</code></pre></div></figure><h3 id="2-2-2-部署Jenkins（指定安装源版）"><a href="#2-2-2-部署Jenkins（指定安装源版）" class="headerlink" title="2.2.2 部署Jenkins（指定安装源版）"></a>2.2.2 部署Jenkins（指定安装源版）</h3><blockquote><p>适用于网络较好的环境</p></blockquote><p>1、配置jenkins repo源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo[jenkins]name&#x3D;Jenkins-stablebaseurl&#x3D;http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stablegpgcheck&#x3D;0</code></pre></div></figure><p>2、安装jenkins</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 ~]# yum install jenkins -y</code></pre></div></figure><p>3、启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 ~]# systemctl start jenkins[root@devops02 ~]# systemctl enable jenkins</code></pre></div></figure><h3 id="2-2-3-部署Jenkins（下载rpm包安装–采用）"><a href="#2-2-3-部署Jenkins（下载rpm包安装–采用）" class="headerlink" title="2.2.3 部署Jenkins（下载rpm包安装–采用）"></a>2.2.3 部署Jenkins（下载rpm包安装–采用）</h3><p>从官网下载rpm包，再使用yum安装</p><blockquote><p>官网找不到或者下载慢，可以从镜像网站下载</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat/">https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat/</a></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1. 下载安装包wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;redhat&#x2F;jenkins-2.467-1.1.noarch.rpm#2. 安装rpm包yum localinstall -y jenkins-2.467-1.1.noarch.rpmrpm -ql jenkins#3.启动systemctl enable jenkinssystemctl start jenkinssystemctl status jenkins.service</code></pre></div></figure><blockquote><p>遇到的问题：</p><p>实验第一次安装的是最新的jenkins，因为JDK不匹配（官网要求JDK17，实际安装的JDK11），导致服务起不来</p><p><img src="/../../../img/image-20240710170638209.png" alt="image-20240710170638209"></p><p>重新安装的JDK17可以解决</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;# 下载&gt;wget https:&#x2F;&#x2F;download.oracle.com&#x2F;java&#x2F;17&#x2F;latest&#x2F;jdk-17_linux-x64_bin.rp&#x3D;m</code></pre></div></figure></blockquote><h3 id="2-2-4-解锁Jenkins"><a href="#2-2-4-解锁Jenkins" class="headerlink" title="2.2.4 解锁Jenkins"></a>2.2.4 解锁Jenkins</h3><p>访问<a href="http://10.0.0.72:8080，先要配置密码解锁">http://10.0.0.72:8080，先要配置密码解锁</a></p><p><img src="/../../../img/image-20240710170821653.png" alt="image-20240710170821653"></p><p>到了插件页面，选择“关闭”，插件后续再来安装</p><p><img src="/../../../img/image-20240710171001392.png" alt="image-20240710171001392"></p><p>提示安装完成</p><p><img src="/../../../img/image-20240710171016406.png" alt="image-20240710171016406"></p><p>进到Jenkins管理界面</p><p><img src="/../../../img/image-20240710171058647.png" alt="image-20240710171058647"></p><h3 id="2-2-5-安装插件"><a href="#2-2-5-安装插件" class="headerlink" title="2.2.5 安装插件"></a>2.2.5 安装插件</h3><table><thead><tr><th>Jenkins插件安装方式</th><th></th></tr></thead><tbody><tr><td>web页面,选择与安装(联网)</td><td>一个一个找选择,安装重启jenkins</td></tr><tr><td>自己下载插件,jenkins替你安装(hpi)</td><td>web页面一个一个安装,未来批量安装需要脚本</td></tr><tr><td>导入插件(手动,批量)</td><td>去一个机器上面把已经下载安装的插件打包,新机器解压,修改所有者</td></tr></tbody></table><p><font color=red>⚠ ⚠ ⚠ jenkins不同版本的插件不通用.</font></p><p>三种方式的对比：</p><ol><li>联网安装（通过互联网下载插件）<ul><li>需要知道插件名称 ( 需要知道要集成哪些软件或服务; )</li><li>在哪个位置进行插件安装 Manage Jenkins –&gt; Mange Plugins</li><li>缺点1：安装会比较的慢</li><li>缺点2：如果出现警告,要看提示，不要盲目升级，很容易造成 Jenkins连带升级, 会出现其他很多插件无法使用</li></ul></li><li>离线安装（下载 .hpi 文件安装）<ul><li>如GIT插件：<a href="https://mirror.tuna.tsinghua.edu.cn/jenkins/plugins/git/latest/git.hpi">https://mirror.tuna.tsinghua.edu.cn/jenkins/plugins/git/latest/git.hpi</a></li></ul></li><li>导入插件（目录复制）<ul><li>将此前已经安装好的插件备份下来，然后恢复</li><li>问题: 插件存储在哪个路径下：&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;plugins&#x2F;</li></ul></li></ol><h4 id="a）离线安装插件"><a href="#a）离线安装插件" class="headerlink" title="a）离线安装插件"></a>a）离线安装插件</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将离线插件包解压到jenkins插件目录中[root@devops02 &#x2F;app&#x2F;rpms]#tar -xf jenkins-2.361-plugins.tar.gz -C &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;plugins&#x2F;# 重启服务[root@devops02 &#x2F;app&#x2F;rpms]#systemctl restart jenkins</code></pre></div></figure><h4 id="b）联网安装插件"><a href="#b）联网安装插件" class="headerlink" title="b）联网安装插件"></a>b）联网安装插件</h4><p>首页 —&gt; 系统管理</p><p><img src="/../../../img/image-20240711101432320.png" alt="image-20240711101432320"></p><p>选择插件管理</p><p><img src="/../../../img/image-20240711101659999.png" alt="image-20240711101659999"></p><p>选择需要安装的插件</p><p><img src="/../../../img/image-20240711101736521.png" alt="image-20240711101736521"></p><p>等待安装完成</p><p><img src="/../../../img/image-20240711101839876.png" alt="image-20240711101839876"></p><blockquote><p>安装好之后的存放地点</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;plugins]#ls github-api.jpi</code></pre></div></figure></blockquote><h1 id="三、案例01-Jenkins执行Shell命令"><a href="#三、案例01-Jenkins执行Shell命令" class="headerlink" title="三、案例01-Jenkins执行Shell命令"></a>三、案例01-Jenkins执行Shell命令</h1><p>通过jenkins执行命令或脚本</p><h2 id="3-1-Jenkins的运行用户配置"><a href="#3-1-Jenkins的运行用户配置" class="headerlink" title="3.1 Jenkins的运行用户配置"></a>3.1 Jenkins的运行用户配置</h2><blockquote><p>为了方便JK进行操作与管理各种节点，避免出现权限问题。<br>这里把把jenkins运行用户改为root。<br>当然也可以给Jenkins配置sudo权限，这里我们选择修改为root。  </p></blockquote><p>修改配置文件（有两种版本，按实际配置）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 版本一：&#x2F;etc&#x2F;sysconfig&#x2F;jenkins [root@devops02 &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;plugins]#grep &quot;^JEN&quot; &#x2F;etc&#x2F;sysconfig&#x2F;jenkins JENKINS_HOME&#x3D;&quot;&#x2F;var&#x2F;lib&#x2F;jenkins&quot;JENKINS_JAVA_CMD&#x3D;&quot;&quot;JENKINS_USER&#x3D;&quot;root&quot;# 改成root...# 版本二：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;jenkins.serviceUser&#x3D;rootGroup&#x3D;root## 再重启服务systemctl daemon-reloadsystemctl restart jenkins</code></pre></div></figure><h2 id="3-2-案例详细步骤"><a href="#3-2-案例详细步骤" class="headerlink" title="3.2 案例详细步骤"></a>3.2 案例详细步骤</h2><p>需要执行的shell脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">case &quot;$choose&quot; indev) echo &quot;部署到测试环境&quot; ;;prod) echo &quot;部署到生产环境&quot; ;;esac</code></pre></div></figure><h3 id="3-2-1-创建对应的目录"><a href="#3-2-1-创建对应的目录" class="headerlink" title="3.2.1 创建对应的目录"></a>3.2.1 创建对应的目录</h3><p>主界面—&gt;新建任务—&gt;创建dev文件夹</p><p><img src="/../../../img/image-20240711103524016.png" alt="image-20240711103524016"></p><p>下一步继续填写信息，保存即可</p><p><img src="/../../../img/image-20240711103612754.png" alt="image-20240711103612754"></p><p>prod文件夹同上操作，添加完有两个</p><p><img src="/../../../img/image-20240711103919767.png" alt="image-20240711103919767"></p><h3 id="3-2-2-创建freestyle项目"><a href="#3-2-2-创建freestyle项目" class="headerlink" title="3.2.2 创建freestyle项目"></a>3.2.2 创建freestyle项目</h3><p>进入dev文件夹—&gt;新建item</p><p><img src="/../../../img/image-20240711103954785.png" alt="image-20240711103954785"></p><p>填写任务名，选择项目类型</p><blockquote><p>自由风格: 一般用于部署静态，各种都可以  </p><p>maven项目：java代码  </p><p>流水线（pipeline)：把第1个或第2个任务通过指令（代码）方式实现。  </p></blockquote><p><img src="/../../../img/image-20240711104102760.png" alt="image-20240711104102760"></p><h3 id="3-2-3-配置项目基础信息"><a href="#3-2-3-配置项目基础信息" class="headerlink" title="3.2.3 配置项目基础信息"></a>3.2.3 配置项目基础信息</h3><h4 id="a）配置–丢弃旧的构建"><a href="#a）配置–丢弃旧的构建" class="headerlink" title="a）配置–丢弃旧的构建"></a>a）配置–丢弃旧的构建</h4><p>构建 &#x3D;&#x3D;&#x3D; 运行任务，建议开启功能，保留运行记录</p><blockquote><p>根据需求填写保存天数和保存的最大个数</p></blockquote><p><img src="/../../../img/image-20240711104436711.png" alt="image-20240711104436711"></p><h4 id="b）配置-参数化构建过程"><a href="#b）配置-参数化构建过程" class="headerlink" title="b）配置-参数化构建过程"></a>b）配置-参数化构建过程</h4><p>勾选–参数化构建过程–添加参数–选项参数</p><p><img src="/../../../img/image-20240711104605946.png" alt="image-20240711104605946"></p><p>填写信息</p><p><img src="/../../../img/image-20240711104657353.png" alt="image-20240711104657353"></p><h4 id="c）配置-构建步骤"><a href="#c）配置-构建步骤" class="headerlink" title="c）配置-构建步骤"></a>c）配置-构建步骤</h4><p>新增构建步骤–执行shell</p><p><img src="/../../../img/image-20240711104759585.png" alt="image-20240711104759585"></p><p>配置命令或代码，再保存即可</p><p><img src="/../../../img/image-20240711105506122.png" alt="image-20240711105506122"></p><p>命令如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">case &quot;$choose&quot; indev) echo &quot;部署到测试环境&quot; ;;prod) echo &quot;部署到生产环境&quot; ;;esacecho &quot;当前用户是：&#96;whoami&#96;&quot;echo &quot;前路径是: &#96;pwd&#96;&quot;</code></pre></div></figure><h3 id="3-2-4-运行项目"><a href="#3-2-4-运行项目" class="headerlink" title="3.2.4 运行项目"></a>3.2.4 运行项目</h3><h4 id="a）构建运行项目"><a href="#a）构建运行项目" class="headerlink" title="a）构建运行项目"></a>a）构建运行项目</h4><p>保存后，在工程界面运行</p><p><img src="/../../../img/image-20240711105045248.png" alt="image-20240711105045248"></p><p>选择</p><p><img src="/../../../img/image-20240711105207611.png" alt="image-20240711105207611"></p><h4 id="b）检查输出"><a href="#b）检查输出" class="headerlink" title="b）检查输出"></a>b）检查输出</h4><p>左下角构建历史可以检查输出，红的是失败的，绿的是成功</p><p><img src="/../../../img/image-20240711105803093.png" alt="image-20240711105803093"></p><p>可以点进去检查控制台输出，要是有错修改项目信息就可以</p><blockquote><p>实验中因为命令中少写一个<code>&quot;</code>号，头几次运行都是失败的</p></blockquote><p><img src="/../../../img/image-20240711105843911.png" alt="image-20240711105843911"></p><h1 id="四、案例02-Jenkins从Gitlab拉取代码（基于branch）"><a href="#四、案例02-Jenkins从Gitlab拉取代码（基于branch）" class="headerlink" title="四、案例02-Jenkins从Gitlab拉取代码（基于branch）"></a>四、案例02-Jenkins从Gitlab拉取代码（基于branch）</h1><h2 id="4-1-准备windows环境"><a href="#4-1-准备windows环境" class="headerlink" title="4.1 准备windows环境"></a>4.1 准备windows环境</h2><p>1、安装git、创建密钥</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat &#x2F;c&#x2F;Users&#x2F;gs&#x2F;.ssh&#x2F;id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC+0VQ2&#x2F;Zas4iOqt3Zf1BasDAm1ImZNQP64eqlXgchksMVwl&#x2F;qE9qbrG2dR&#x2F;y0wfORJihAOuhCImrYqPArWFfajipietmk14fmAhgzZp6xy6F+6cbdTPRzauwYKCahvLt8ssinVfd2tqbIdkBsyuzrjoO6FBCtQTC17b32lKUtjMe&#x2F;iC+x5PErFaX6x8ZfolUvWiD+yiGY...</code></pre></div></figure><p>2、登录gitlab，创建空项目：myproj</p><p><img src="/../../../img/image-20240711161908008.png" alt="image-20240711161908008"></p><p>3、配置ssh密钥认证</p><p><img src="/../../../img/image-20240711162340899.png" alt="image-20240711162340899"></p><p>4、本地创建项目文件夹，初始化上传至gitlab</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gs@LAPTOP-GS MINGW64 ~&#x2F;Desktop$ mkdir myprojgs@LAPTOP-GS MINGW64 ~&#x2F;Desktop$ cd myproj&#x2F;# 初始化gs@LAPTOP-GS MINGW64 ~&#x2F;Desktop&#x2F;myproj$ git initInitialized empty Git repository in C:&#x2F;Users&#x2F;gs&#x2F;Desktop&#x2F;myproj&#x2F;.git&#x2F;# 配置远程仓库地址（需要提前配置hosts解析）$ git remote add origin http:&#x2F;&#x2F;gitlab.test.cn&#x2F;dev&#x2F;myproj.git# 创建代码gs@LAPTOP-GS MINGW64 ~&#x2F;Desktop&#x2F;myproj (master)$ echo &quot;hello myproj&quot; &gt;&gt; index.html# 上传代码$ git add .$ git commit -m &#39;v1.0&#39;$ git tag -a &quot;v1.0&quot; -m &quot;v1.0&quot;$ git push -u origin master$ git push -u origin --tags</code></pre></div></figure><p>5、web页面检查项目，确保上传成功</p><p><img src="/../../../img/image-20240711163804902.png" alt="image-20240711163804902"></p><h2 id="4-2-配置jenkins"><a href="#4-2-配置jenkins" class="headerlink" title="4.2 配置jenkins"></a>4.2 配置jenkins</h2><blockquote><p>此操作在jenkins服务器配置</p></blockquote><h3 id="4-2-1-配置hosts解析"><a href="#4-2-1-配置hosts解析" class="headerlink" title="4.2.1 配置hosts解析"></a>4.2.1 配置hosts解析</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># &#x2F;etc&#x2F;hosts172.16.1.71 gitlab.test.cn172.16.1.72 jk.test.cn</code></pre></div></figure><h3 id="4-2-2-添加任务"><a href="#4-2-2-添加任务" class="headerlink" title="4.2.2 添加任务"></a>4.2.2 添加任务</h3><p>创建任务</p><p><img src="/../../../img/image-20240711164141296.png" alt="image-20240711164141296"></p><p>配置构建历史记录</p><p><img src="/../../../img/image-20240711164232384.png" alt="image-20240711164232384"></p><h3 id="4-2-3-配置-源码管理"><a href="#4-2-3-配置-源码管理" class="headerlink" title="4.2.3 配置-源码管理"></a>4.2.3 配置-源码管理</h3><p>下面配置源码部分内容，通过git方式拉去代码</p><p>1、获取git仓库地址（从gitlab或gitee获取）  </p><p><img src="/../../../img/image-20240711164415115.png" alt="image-20240711164415115"></p><p>2、在jenkins项目-源码管理中配置git地址</p><p><img src="/../../../img/image-20240711164557175.png" alt="image-20240711164557175"></p><p>3、配置私钥凭证</p><p><img src="/../../../img/image-20240711164638257.png" alt="image-20240711164638257"></p><p>4、选择SSH私钥认证</p><p><img src="/../../../img/image-20240711164700596.png" alt="image-20240711164700596"></p><p>5、选择“Enter directly”</p><p><img src="/../../../img/image-20240711164800148.png" alt="image-20240711164800148"></p><p>6、把window的私钥复制进去</p><p><img src="/../../../img/image-20240711164933353.png" alt="image-20240711164933353"></p><p>7、认证方式选择刚创建的Jenkins</p><p><img src="/../../../img/image-20240711165255458.png" alt="image-20240711165255458"></p><p>8、构建步骤，配置shell命令</p><p><img src="/../../../img/image-20240711165418871.png" alt="image-20240711165418871"></p><p>填写shell命令，对拉取的代码做一定操作</p><p><img src="/../../../img/image-20240711165439642.png" alt="image-20240711165439642"></p><h3 id="4-2-4-运行查看结果"><a href="#4-2-4-运行查看结果" class="headerlink" title="4.2.4 运行查看结果"></a>4.2.4 运行查看结果</h3><p>第一次运行，失败，查看控制台输出</p><p><img src="/../../../img/image-20240712152752448.png" alt="image-20240712152752448"></p><p>提示我们“No ECDSA host key is known for gitlab.test.cn ”，按照蓝色字提示做如下配置：</p><p>首页 — 系统管理 — 全局安全配置 — Git Host Key Verification Configuration</p><p><img src="/../../../img/image-20240712152944584.png" alt="image-20240712152944584"></p><p>保存后，再次构建，运行成功</p><p><img src="/../../../img/image-20240712152849438.png" alt="image-20240712152849438"></p><h3 id="4-2-5-打包拉取到的代码"><a href="#4-2-5-打包拉取到的代码" class="headerlink" title="4.2.5 打包拉取到的代码"></a>4.2.5 打包拉取到的代码</h3><p>修改项目配置，对拉取的代码增加打包操作</p><p><img src="/../../../img/image-20240712153652948.png" alt="image-20240712153652948"></p><p>检查执行结果，构建成功，&#x2F;tmp下成功生成文件</p><p><img src="/../../../img/image-20240712153746480.png" alt="image-20240712153746480"></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;]#ls &#x2F;tmp&#x2F;myproj.tar.gz &#x2F;tmp&#x2F;myproj.tar.gz</code></pre></div></figure><blockquote><p>后续可以在此处实现进一步的操作，比如把代码分发到web服务器并解压，实现代码部署</p></blockquote><h1 id="五、案例03-Jenkins从Gitlab拉取代码（基于tag标签）"><a href="#五、案例03-Jenkins从Gitlab拉取代码（基于tag标签）" class="headerlink" title="五、案例03-Jenkins从Gitlab拉取代码（基于tag标签）"></a>五、案例03-Jenkins从Gitlab拉取代码（基于tag标签）</h1><p>为什么要基于tag拉取代码？</p><ul><li>在案例02中，拉取的代码总是最新的，如果需要基于tag来拉取代码，该如何操作？</li></ul><h2 id="5-1-准备代码"><a href="#5-1-准备代码" class="headerlink" title="5.1 准备代码"></a>5.1 准备代码</h2><p>改修<code>index.html</code>文件的内容，打标签提交，创建v2.0和v3.0的标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># v2.0echo &quot;&lt;title&gt;MyProj V2.0 Release&lt;&#x2F;tiltle&gt;&quot; &gt;&gt; index.htmlgit add .git commit -m v2.0git tag -a v2.0 -m v2.0git push -u origin --allgit push -u origin --tags# v3.0echo &quot;&lt;title&gt;MyProj V3.0 Release&lt;&#x2F;tiltle&gt;&quot; &gt;&gt; index.htmlgit add .git commit -m v3.0git tag -a v3.0 -m v3.0git push -u origin --allgit push -u origin --tags</code></pre></div></figure><p>检查</p><p><img src="/../../../img/image-20240712154851445.png" alt="image-20240712154851445"></p><h2 id="5-2-jenkins安装获取tag的插件"><a href="#5-2-jenkins安装获取tag的插件" class="headerlink" title="5.2 jenkins安装获取tag的插件"></a>5.2 jenkins安装获取tag的插件</h2><p>插件名：git parameter</p><p><img src="/../../../img/image-20240712155103133.png" alt="image-20240712155103133"></p><p>插件安装完，在“参数化构建过程”中会有新的选项</p><p><img src="/../../../img/image-20240712155155500.png" alt="image-20240712155155500"></p><h2 id="5-4-创建jenkins任务"><a href="#5-4-创建jenkins任务" class="headerlink" title="5.4 创建jenkins任务"></a>5.4 创建jenkins任务</h2><p>1、创建自由风格项目</p><p><img src="/../../../img/image-20240712161314975.png" alt="image-20240712161314975"></p><p>2、参数化构建过程—选Git参数</p><p><img src="/../../../img/image-20240712163249672.png" alt="image-20240712163249672"></p><p>填写信息，创建<code>git_tag</code>变量，默认值origin，即master中的最新值</p><p><img src="/../../../img/image-20240712163503837.png" alt="image-20240712163503837"></p><p>3、配置-源码管理</p><p>填写git项目信息</p><p><img src="/../../../img/image-20240712163726106.png" alt="image-20240712163726106"></p><p>4、配置-每次构建之前清空工作目录，防止缓存导致问题</p><p><img src="/../../../img/image-20240712163815888.png" alt="image-20240712163815888"></p><p>5、配置-Build步骤–执行Shell</p><p><img src="/../../../img/image-20240712163955122.png" alt="image-20240712163955122"></p><h2 id="5-5-测试执行"><a href="#5-5-测试执行" class="headerlink" title="5.5 测试执行"></a>5.5 测试执行</h2><p>1、测试执行，在此处可以选择参数值，选择”v2.0”的tag</p><p><img src="/../../../img/image-20240712164059363.png" alt="image-20240712164059363"></p><p>2、执行错误，可以看到<code>$&#123;git-tag&#125;</code>的标签名没有替换成值，有问题</p><p><img src="/../../../img/image-20240712165756849.png" alt="image-20240712165756849"></p><p>3、解决方法：变量命名有问题，改成<code>git_tag</code>可以</p><p><img src="/../../../img/image-20240712165959106.png" alt="image-20240712165959106"></p><p>分支也要记得改</p><p><img src="/../../../img/image-20240712170041378.png" alt="image-20240712170041378"></p><p>shell也是<img src="/../../../img/image-20240712170255940.png" alt="image-20240712170255940"></p><p>4、改完再次测试，成功，可以看到标签变量换成“v2.0”了</p><p><img src="/../../../img/image-20240712170412733.png" alt="image-20240712170412733"></p><p>查看系统中的打包文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;app&#x2F;rpms]#ls &#x2F;tmp&#x2F;myproj-v2.0.tar.gz &#x2F;tmp&#x2F;myproj-v2.0.tar.gz</code></pre></div></figure><h2 id="5-6-将代码部署到web节点"><a href="#5-6-将代码部署到web节点" class="headerlink" title="5.6 将代码部署到web节点"></a>5.6 将代码部署到web节点</h2><p>1、先在web01服务器，把nginx服务配置好</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat myproj.conf server &#123;  listen 8061;  server_name myproj.test.cn;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;myproj.access.log main;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;myproj.error.log notice;  root &#x2F;app&#x2F;code&#x2F;myproj;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>2、配置免密认证，jenkins连接web01不再需要输入密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops02 &#x2F;app&#x2F;rpms]#ssh-keygen[root@devops02 &#x2F;app&#x2F;rpms]#ssh-copy-id root@172.16.1.7# 测试[root@devops02 &#x2F;app&#x2F;rpms]#ssh root@172.16.1.7 hostname -I10.0.0.7 172.16.1.7</code></pre></div></figure><p>3、jenkins配置，修改shell命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;您当前部署的代码版本为:$&#123;git_tag&#125;&quot;#1. 打包压缩tar zcf &#x2F;tmp&#x2F;myproj-$&#123;git_tag&#125;.tar.gz .#2. 分发scp &#x2F;tmp&#x2F;myproj-$&#123;git_tag&#125;.tar.gz root@172.16.1.7:&#x2F;tmp&#x2F;#3. 解压ssh root@172.16.1.7 &quot;tar xf &#x2F;tmp&#x2F;myproj-$&#123;git_tag&#125;.tar.gz -C &#x2F;app&#x2F;code&#x2F;myproj&#x2F;&quot;</code></pre></div></figure><p>3、检查部署结果</p><p>jenkins任务执行成功，</p><p><img src="/../../../img/image-20240712171555867.png" alt="image-20240712171555867"></p><p>nginx页面部署成功，能正常访问</p><p><img src="/../../../img/image-20240712171619376.png" alt="image-20240712171619376"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Ctrl + C不能停止的问题</title>
    <link href="/2024/07/10/06_%E6%9D%82%E8%AE%B0/hexo%E4%B8%8D%E8%83%BDctrlc%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/10/06_%E6%9D%82%E8%AE%B0/hexo%E4%B8%8D%E8%83%BDctrlc%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、打开cmd<br>2、复制 <code>taskkill /F /IM node.exe</code>，粘贴运行；<br>3、搞定！</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day74-Devops-Git与Gitlab</title>
    <link href="/2024/07/09/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day74-Devops-Git%E4%B8%8EGitlab/"/>
    <url>/2024/07/09/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day74-Devops-Git%E4%B8%8EGitlab/</url>
    
    <content type="html"><![CDATA[<h1 id="Devops架构-Git与Gitlab"><a href="#Devops架构-Git与Gitlab" class="headerlink" title="Devops架构-Git与Gitlab"></a>Devops架构-Git与Gitlab</h1><p>今日内容：</p><ul><li>运维的发展过程介绍</li><li>CI CD基础知识</li><li>Git的安装与使用</li><li>Gitlab的安装与使用</li><li>Gitlab的备份与恢复</li><li>Gitlab的迁移与升级</li><li>Gitlab的补充说明（配置邮箱、优化方法）</li></ul><h1 id="一、运维的发展过程"><a href="#一、运维的发展过程" class="headerlink" title="一、运维的发展过程"></a>一、运维的发展过程</h1><p>发展过程描述：</p><ul><li>手工时代（2000-2005）<ul><li>物理服务器、虚拟机</li><li>手动敲命令</li></ul></li><li>自动化时代（2005-2010）<ul><li>shell批量管理、Ansible自动化</li></ul></li><li>平台化时代（2010-2015）<ul><li>自动化运维平台，如CMDB、devops</li></ul></li><li>模块化（2015-2020）<ul><li>各功能相对独立，模块化</li></ul></li><li>智能化&#x2F;云原生&#x2F;微服务（2020-至今）<ul><li>各功能相对独立，模块化</li><li>docker、k8s、zabbix…</li></ul></li></ul><p>云原生时代的描述：</p><p>以Devops、SRE框架为指导，Docker&#x2F;K8S&#x2F;微服务为基础，用分布式方式加上 Python和Go语言，构建一套云技术产品体系，以及进行高级管理工具的二次开发，实现属于公司自己的自动化运维体系以及云技术体系的自动化产品。</p><h1 id="二、CI-CD-CD基础"><a href="#二、CI-CD-CD基础" class="headerlink" title="二、CI-CD-CD基础"></a>二、CI-CD-CD基础</h1><h2 id="2-1-软件的生命周期"><a href="#2-1-软件的生命周期" class="headerlink" title="2.1 软件的生命周期"></a>2.1 软件的生命周期</h2><p>一个软件从0到1再到0的流程</p><p><img src="/../../../img/image-20240709104915342.png" alt="image-20240709104915342"></p><p>代码上线流程:</p><ul><li>开发书写代码</li><li>把代码上传到代码仓库</li><li>通过工具拉取代码到测试环境中,运行代码,测试人员测试.</li><li>通过工具拉取代码部署到生产环境</li></ul><h2 id="2-2-什么是CI-CD？"><a href="#2-2-什么是CI-CD？" class="headerlink" title="2.2 什么是CI&#x2F;CD？"></a>2.2 什么是CI&#x2F;CD？</h2><p>CI：持续集成（Continuous Intergration）：开发的代码集成到代码仓库</p><p>CD：持续交付（Continuous Delivery）：从代码仓库拉取代码部署到测试环境</p><p>CD：持续部署(Continuous Deployment)：从代码仓库拉取代码部署到生产环境</p><h2 id="2-3-什么是DevOps？"><a href="#2-3-什么是DevOps？" class="headerlink" title="2.3 什么是DevOps？"></a>2.3 什么是DevOps？</h2><p>概念如下：</p><ul><li>DevOps：是一种理念，让开发人员可以持续继承，运维人为可以持续交付&#x2F;部署，让整个开发过程自动化部署、上线</li><li>Development 开发</li><li>Operation 运维</li><li>还有个进阶的理念叫DevSevOps，Sec安全</li></ul><p>如何实现？</p><ul><li>开发（存放代码 - CI）：git、gitlab、github、gitee（代码存放平台）</li><li>运维（部署代码 - CD）：jenkins、maven…插件</li></ul><p>整体概念图如下：</p><p><img src="/../../../img/image-20240709105740025.png" alt="image-20240709105740025"></p><p>各流程涉及到的软件</p><p><img src="/../../../img/image-20240709105817560.png" alt="image-20240709105817560"></p><h2 id="2-4-什么是环境？"><a href="#2-4-什么是环境？" class="headerlink" title="2.4 什么是环境？"></a>2.4 什么是环境？</h2><p>在计算机领域，环境分为以下几种：</p><ul><li>开发环境<ul><li>开发人员书写代码、简单测试的环境</li><li>开发人员自己的电脑</li></ul></li><li>测试环境<ul><li>开发人员初步测试的环境</li><li>公司内部小机房</li></ul></li><li>预生产环境<ul><li>正式部署前的最后一轮测试</li><li>与生产环境保持相对一致</li></ul></li><li>生产环境<ul><li>直接提供给用户的环境</li><li>不能轻易修改，需要获得客户许可</li></ul></li></ul><h2 id="2-5-代码发布-部署的流程"><a href="#2-5-代码发布-部署的流程" class="headerlink" title="2.5 代码发布&#x2F;部署的流程"></a>2.5 代码发布&#x2F;部署的流程</h2><p><img src="/../../../img/image-20240709110605439.png" alt="image-20240709110605439"></p><h1 id="三、Git快速上手"><a href="#三、Git快速上手" class="headerlink" title="三、Git快速上手"></a>三、Git快速上手</h1><h2 id="3-1-实验环境准备"><a href="#3-1-实验环境准备" class="headerlink" title="3.1 实验环境准备"></a>3.1 实验环境准备</h2><table><thead><tr><th>角色</th><th>主机名</th><th>ip</th><th>内存</th></tr></thead><tbody><tr><td>gitlab私有代码仓库</td><td>devops01</td><td>10.0.0.71&#x2F;172.16.1.71</td><td>2G(至少) 推荐2C4G</td></tr><tr><td>jenkins</td><td>devops02</td><td>10.0.0.72&#x2F;172.16.1.72</td><td>1G(至少) 推荐2C4G</td></tr><tr><td>sonarqube代码检查</td><td>devops03</td><td>10.0.0.73&#x2F;172.16.1.73</td><td>1c1G</td></tr><tr><td>nexus私服</td><td>devops04</td><td>10.0.0.74&#x2F;172.16.1.74</td><td>1c1G</td></tr></tbody></table><p>安装git</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y git</code></pre></div></figure><h2 id="3-2-Git仓库创建命令"><a href="#3-2-Git仓库创建命令" class="headerlink" title="3.2 Git仓库创建命令"></a>3.2 Git仓库创建命令</h2><h3 id="3-2-1-新建git仓库案例"><a href="#3-2-1-新建git仓库案例" class="headerlink" title="3.2.1 新建git仓库案例"></a>3.2.1 新建git仓库案例</h3><p>1、配置Git相关信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;]#git config --global user.name &#39;gs&#39;[root@devops01 &#x2F;]#git config --global user.email &#39;724262366@qq.com&#39;[root@devops01 &#x2F;]#git config --global color.ui true# 查询信息[root@devops01 &#x2F;]#git config --global --listuser.name&#x3D;gsuser.email&#x3D;724262366@qq.comcolor.ui&#x3D;true</code></pre></div></figure><p>2、创建代码目录，并初始化</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建代码目录[root@devops01 &#x2F;]#mkdir -p &#x2F;app&#x2F;gitest&#x2F;project01&#x2F;[root@devops01 &#x2F;]#cd &#x2F;app&#x2F;gitest&#x2F;project01&#x2F;# git目录初始化[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git initInitialized empty Git repository in &#x2F;app&#x2F;gitest&#x2F;project01&#x2F;.git&#x2F;# 会生成.git目录，自带部分文件[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#ll .git&#x2F;total 12drwxr-xr-x. 2 root root   6 Jul  9 14:08 branches-rw-r--r--. 1 root root  92 Jul  9 14:08 config-rw-r--r--. 1 root root  73 Jul  9 14:08 description-rw-r--r--. 1 root root  23 Jul  9 14:08 HEAD...</code></pre></div></figure><p>3、书写代码，提交到暂存区</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 新建文件[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#echo test &gt;index.html# git状态，找到新文件[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git status# On branch master## Initial commit## Untracked files:#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)##index.htmlnothing added to commit but untracked files present (use &quot;git add&quot; to track)# 提交[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git add .[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git status# On branch master## Initial commit## Changes to be committed:#   (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)##new file:   index.html#</code></pre></div></figure><p>4、提交代码到本地仓库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git commit -m &#39;新增index.html文件&#39;[master (root-commit) 54f7721] 新增index.html文件 1 file changed, 1 insertion(+) create mode 100644 index.html[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git status# On branch masternothing to commit, working directory clean</code></pre></div></figure><p>5、查看提交日志</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git logcommit 54f77216ffb1033b47db7d187b49e6361b742691Author: gs &lt;724262366@qq.com&gt;Date:   Tue Jul 9 14:12:15 2024 +0800    新增index.html文件</code></pre></div></figure><h3 id="3-2-2-小结"><a href="#3-2-2-小结" class="headerlink" title="3.2.2 小结"></a>3.2.2 小结</h3><table><thead><tr><th>名字</th><th>含义</th></tr></thead><tbody><tr><td>git init</td><td>初始化本地仓库目录</td></tr><tr><td>git config –global</td><td>邮箱,用户名,颜色</td></tr><tr><td>git add</td><td>提交数据到缓冲区(暂存区) git add . (所有文件) 或 git add 文件</td></tr><tr><td>git commit</td><td>把暂存区的数据提交到本地仓库 git commit -m “标记&#x2F;说明”</td></tr><tr><td>git status</td><td>显示工作空间的状态</td></tr><tr><td>git reset</td><td>回滚</td></tr><tr><td>git reset –soft cid(版本号)</td><td>把指定的版本数据内容下载到暂存区</td></tr><tr><td>git reset HEAD</td><td>暂存区–&gt;工作空间(被修改的状态)</td></tr><tr><td>git checkout</td><td>文件下载到工作空间并可以使用 git checkout . 或 git checkout 文件</td></tr><tr><td>git reset –mix 版本号</td><td></td></tr><tr><td>git reset –hard 版本号</td><td>把本地仓库指定版本信息数据下载到工作目录中（强制覆盖）</td></tr></tbody></table><h2 id="3-3-Git区域与状态"><a href="#3-3-Git区域与状态" class="headerlink" title="3.3 Git区域与状态"></a>3.3 Git区域与状态</h2><p><img src="/../../../img/image-20240709135758325.png" alt="image-20240709135758325"></p><p><img src="/../../../img/image-20240709135808833.png" alt="image-20240709135808833"></p><h2 id="3-3-Git分支命令（branch）"><a href="#3-3-Git分支命令（branch）" class="headerlink" title="3.3 Git分支命令（branch）"></a>3.3 Git分支命令（branch）</h2><h3 id="3-3-1-分支概述"><a href="#3-3-1-分支概述" class="headerlink" title="3.3.1 分支概述"></a>3.3.1 分支概述</h3><p>分支即是平行空间，假设你在为某个手机系统研发拍照功能，代码已经完成了80%，但如果将这不完整的代码直接提交到git仓库中，又有可能影响到其他人的工作，此时我们便可以在该软件的项目之上创建一个名叫”拍照功能”的分支。</p><ul><li>这种分支只会属于你自己，而其他人看不。</li><li>等代码编写完成后再与原来的项目主分支合并下即可。</li><li>这样即能保证代码不丢失，又不影响其他人的工作。</li></ul><p>默认的分支-master 主分支，这个分支的代码一般都是可用，可以部署到生产环境的。<br>一般开发人员开发代码的时候创建dev分支，shopping分支。应用名称分支，每个分支对应独立功能  </p><p>图示如下：</p><p><img src="/../../../img/image-20240709140041675.png" alt="image-20240709140041675"></p><h2 id="3-3-2-分支创建与合并案例"><a href="#3-3-2-分支创建与合并案例" class="headerlink" title="3.3.2 分支创建与合并案例"></a>3.3.2 分支创建与合并案例</h2><p>1、查看当前项目拥有的分支，默认master主分支</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git branch * master[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#lsindex.html</code></pre></div></figure><p>2、创建shopping分支</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git branch shopping[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git branch * master  shopping</code></pre></div></figure><p>3、切换到shopping分支</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git checkout shoppingSwitched to branch &#39;shopping&#39;[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git branch   master* shopping</code></pre></div></figure><p>4、在shopping分支书写代码并提交</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#echo shopping&gt;shopping.index[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#lsindex.html  shopping.index[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git add .[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git commit -m &#39;添加shopping.index文件&#39;[shopping 2832f59] 添加shopping.index文件 1 file changed, 1 insertion(+) create mode 100644 shopping.index</code></pre></div></figure><p>5、shopping分支合并到master分支中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 确认shopping分支中的文件[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#lsindex.html  shopping.index# 切换到master分支[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git checkout masterSwitched to branch &#39;master&#39;[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#lsindex.html# 合并[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git merge shoppingUpdating 54f7721..2832f59Fast-forward shopping.index | 1 + 1 file changed, 1 insertion(+) create mode 100644 shopping.index  # master分支中出现shopping分支的代码[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#lsindex.html  shopping.index</code></pre></div></figure><p>查看日志</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git logcommit 2832f59c1dd920742751815c785722510e7bdc89Author: gs &lt;724262366@qq.com&gt;Date:   Tue Jul 9 14:18:24 2024 +0800    添加shopping.index文件commit 54f77216ffb1033b47db7d187b49e6361b742691Author: gs &lt;724262366@qq.com&gt;...</code></pre></div></figure><h3 id="3-3-2-小结"><a href="#3-3-2-小结" class="headerlink" title="3.3.2 小结"></a>3.3.2 小结</h3><table><thead><tr><th>git 分支相关命令</th><th></th></tr></thead><tbody><tr><td>git branch</td><td>查看分支</td></tr><tr><td>git branch name</td><td>创建分支</td></tr><tr><td>git branch -d name</td><td>删除分支</td></tr><tr><td>git checkout 分支名字</td><td>切换分支</td></tr><tr><td>git merge 分支名字</td><td>合并(吸收)分支(把指定的分支合并到当前分支中)</td></tr><tr><td>git checkout -b name</td><td>创建分支并切换到这个分支</td></tr></tbody></table><h2 id="3-4-Git远程仓库"><a href="#3-4-Git远程仓库" class="headerlink" title="3.4 Git远程仓库"></a>3.4 Git远程仓库</h2><h3 id="3-4-1-Github的连接与使用"><a href="#3-4-1-Github的连接与使用" class="headerlink" title="3.4.1 Github的连接与使用"></a>3.4.1 Github的连接与使用</h3><p>就是Github的用法，跳过</p><h3 id="3-4-2-Git-tag打标签"><a href="#3-4-2-Git-tag打标签" class="headerlink" title="3.4.2 Git tag打标签"></a>3.4.2 Git tag打标签</h3><p>使用场景：commit太长不好记，可以给每个commit加上tag标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#创建标签COMMIT ID的一个别名,COMMIT ID不好记忆, 标签相对的好记忆.git tag -a &quot;标签名称&quot; -m &quot;描述&quot;基于当前最新的COMMITIDgit tag -a &quot;标签名称&quot; -m &quot;描述&quot;commitID 指定版本打标签#如何上传标签git push origin --tagsgit push origin &quot;标签名称&quot;Master: V1.0 V2.0Dev: b1.0 b2.0git clone -b 标签、分支 https&#x2F;git</code></pre></div></figure><h3 id="3-4-3-gitignore文件"><a href="#3-4-3-gitignore文件" class="headerlink" title="3.4.3 gitignore文件"></a>3.4.3 gitignore文件</h3><p>作用：上传代码的时候，代码中可能包含临时文件cache .swp等，需要排除</p><p>使用方法：在代码根目录中创建文件.gitignore 写上要排除的内容  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat .gitignore#*.jpg*.tmpcache&#x2F;*</code></pre></div></figure><h1 id="四、Gitlab"><a href="#四、Gitlab" class="headerlink" title="四、Gitlab"></a>四、Gitlab</h1><h2 id="4-1-gitlab概述"><a href="#4-1-gitlab概述" class="headerlink" title="4.1 gitlab概述"></a>4.1 gitlab概述</h2><p>私有代码仓库</p><p>精细化权限配置,让系统更安全</p><p>控制用户&#x2F;用户组是否可以提交到主分支 (PR Push Request)</p><p>它使用Ruby语言写成。后来，一些部分用Go语言重写  </p><h2 id="4-2-Gitlab-vs-Github-Gitee"><a href="#4-2-Gitlab-vs-Github-Gitee" class="headerlink" title="4.2 Gitlab vs Github&#x2F;Gitee"></a>4.2 Gitlab vs Github&#x2F;Gitee</h2><table><thead><tr><th>Gitlab</th><th>Github&#x2F;Gitee</th><th></th></tr></thead><tbody><tr><td>共同点</td><td>存放代码,git访问</td><td>存放代码,git访问</td></tr><tr><td>不同点</td><td>精确化控制权限 全面安全措施 定时备份 升级 迁移</td><td>使用权限,用户管理比较弱,无法做到精细化权限.</td></tr></tbody></table><h2 id="4-3-Gitlab-应用场景"><a href="#4-3-Gitlab-应用场景" class="headerlink" title="4.3 Gitlab 应用场景"></a>4.3 Gitlab 应用场景</h2><ul><li>开源免费,搭建简单,维护成本低,符合中小公司口味 </li><li>权限管理,实现代码对部分人可见,安全性高</li><li>离线同步</li></ul><h2 id="4-4-快速上手"><a href="#4-4-快速上手" class="headerlink" title="4.4 快速上手"></a>4.4 快速上手</h2><p>版本选择：</p><ul><li>ce community edition 社区版</li><li>ee enterprice edition 企业版</li></ul><p>步骤总览</p><ol><li>安装Gitlab依赖包</li><li>下载,安装</li><li>配置,访问域名</li><li>初始化,启动</li><li>访问</li></ol><h3 id="4-4-1-安装要求"><a href="#4-4-1-安装要求" class="headerlink" title="4.4.1 安装要求"></a>4.4.1 安装要求</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#系统要求Ubuntu (16.04&#x2F;18.04&#x2F;20.04)Debian (9&#x2F;10)CentOS (7&#x2F;8)openSUSE Leap (15.2)SUSE Linux Enterprise Server (12 SP2&#x2F;12 SP5)Red Hat Enterprise Linux (please use the CentOSpackages and instructions)#硬件要求## 磁盘空间存放代码,比代码空间大7.2k以上的磁盘 sas ssd## CPU4 核心 500用户8 核心 1000用户## 内存4 G内存 500用户8 G内存 1000用户</code></pre></div></figure><h3 id="4-4-2-安装gitlab组件"><a href="#4-4-2-安装gitlab组件" class="headerlink" title="4.4.2 安装gitlab组件"></a>4.4.2 安装gitlab组件</h3><p>获取安装包：<a href="https://packages.gitlab.com/gitlab/gitlab-ce">https://packages.gitlab.com/gitlab/gitlab-ce</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;rpms]#lsgitlab-ce-16.6.8-ce.0.el7.x86_64.rpm</code></pre></div></figure><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;rpms]#yum localinstall -y .&#x2F;gitlab-ce-16.6.8-ce.0.el7.x86_64.rpm </code></pre></div></figure><h3 id="4-4-3-配置访问URL"><a href="#4-4-3-配置访问URL" class="headerlink" title="4.4.3 配置访问URL"></a>4.4.3 配置访问URL</h3><p>修改配置文件内容，配置访问URL</p><blockquote><p>修改前先备份</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;etc&#x2F;gitlab]#vim gitlab.rb...external_url &#39;http:&#x2F;&#x2F;gitlab.test.cn&#39;...</code></pre></div></figure><h3 id="4-4-4-初始化Gitlab"><a href="#4-4-4-初始化Gitlab" class="headerlink" title="4.4.4 初始化Gitlab"></a>4.4.4 初始化Gitlab</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#使用gitlab.rb文件生成子配置文件gitlab-ctl reconfigure#重启所有gitlab相关文件.gitlab-ctl restart# 查看状态gitlb-ctl status</code></pre></div></figure><p>注意，在reconfigure后，会有提示默认的账号密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Notes:Default admin account has been configured with following details:Username: rootPassword: You didn&#39;t opt-in to print initial root password to STDOUT.Password stored to &#x2F;etc&#x2F;gitlab&#x2F;initial_root_password. This file will be cleaned up in first reconfigure run after 24 hours.</code></pre></div></figure><h3 id="4-4-5-登录与查看"><a href="#4-4-5-登录与查看" class="headerlink" title="4.4.5 登录与查看"></a>4.4.5 登录与查看</h3><p>浏览器访问：<a href="http://10.0.0.71/users/sign_in">http://10.0.0.71/users/sign_in</a></p><p><img src="/../../../img/image-20240709230535521.png" alt="image-20240709230535521"></p><p>登陆后的界面</p><p><img src="/../../../img/image-20240709230653903.png" alt="image-20240709230653903"></p><h3 id="4-4-6-汉化"><a href="#4-4-6-汉化" class="headerlink" title="4.4.6 汉化"></a>4.4.6 汉化</h3><p>头像 —&gt; perferances</p><p><img src="/../../../img/image-20240709230837858.png" alt="image-20240709230837858"></p><p>在语言项，改为中文</p><p><img src="/../../../img/image-20240709230913639.png" alt="image-20240709230913639"></p><p>保存后，重新加载页面生效</p><p><img src="/../../../img/image-20240709230947856.png" alt="image-20240709230947856"></p><h3 id="4-4-7-设置密码"><a href="#4-4-7-设置密码" class="headerlink" title="4.4.7 设置密码"></a>4.4.7 设置密码</h3><p>进入“密码”设置页，可以重新设置密码</p><p><img src="/../../../img/image-20240709231303006.png" alt="image-20240709231303006"></p><h3 id="4-4-8-重置密码"><a href="#4-4-8-重置密码" class="headerlink" title="4.4.8 重置密码"></a>4.4.8 重置密码</h3><p>如果密码忘记了，可以按以下方法重置密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-rake &quot;gitlab:password:reset&quot;[root@devops01 &#x2F;etc&#x2F;gitlab]#gitlab-rake &quot;gitlab:password:reset&quot;Enter username: rootEnter password: Confirm password: </code></pre></div></figure><h3 id="4-4-9-删除gitlab"><a href="#4-4-9-删除gitlab" class="headerlink" title="4.4.9 删除gitlab"></a>4.4.9 删除gitlab</h3><p>删除步骤：</p><ul><li>删除rpm包</li><li>&#x2F;var&#x2F;opt&#x2F;gitlab &#x2F;opt&#x2F;gitlab&#x2F; 2个目录删除.</li><li>备份内核参数配置 <code>/opt/gitlab/embedded/etc/*-gitlab-*.conf</code></li></ul><p>如果需要重新安装，待安装完成后，覆盖回去上面几个conf即可  </p><h3 id="4-4-10-500和502错误"><a href="#4-4-10-500和502错误" class="headerlink" title="4.4.10 500和502错误"></a>4.4.10 500和502错误</h3><p>一般是需要等待，gitlab启动较慢造成的，检查资源是否够用  </p><p>如果遇到500错误，可以尝试以下操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-rake db:migrategitlab-ctl reconfiguregitlab-ctl restart</code></pre></div></figure><h2 id="4-5-Gitlab的用户和组"><a href="#4-5-Gitlab的用户和组" class="headerlink" title="4.5 Gitlab的用户和组"></a>4.5 Gitlab的用户和组</h2><h3 id="4-5-1-用户和组的关系"><a href="#4-5-1-用户和组的关系" class="headerlink" title="4.5.1 用户和组的关系"></a>4.5.1 用户和组的关系</h3><p>Gitlab用户、用户组、项目&#x2F;仓库的关系</p><p><img src="/../../../img/image-20240709231903053.png" alt="image-20240709231903053"></p><h3 id="4-5-2-应用案例"><a href="#4-5-2-应用案例" class="headerlink" title="4.5.2 应用案例"></a>4.5.2 应用案例</h3><p>流程概览：</p><ul><li>创建dev开发组</li><li>创建用户gs，添加到dev开发组中</li><li>创建1个项目live_ app，与dev开发组关联</li></ul><h4 id="4-5-2-1-创建用户组dev"><a href="#4-5-2-1-创建用户组dev" class="headerlink" title="4.5.2.1 创建用户组dev"></a>4.5.2.1 创建用户组dev</h4><p>新建群组</p><p><img src="/../../../img/image-20240709232216245.png" alt="image-20240709232216245"></p><p>填写信息</p><p><img src="/../../../img/image-20240709232322635.png" alt="image-20240709232322635"></p><h4 id="4-5-2-2-创建用户gs"><a href="#4-5-2-2-创建用户gs" class="headerlink" title="4.5.2.2 创建用户gs"></a>4.5.2.2 创建用户gs</h4><p><img src="/../../../img/image-20240709232510076.png" alt="image-20240709232510076"></p><p>填写信息</p><p><img src="/../../../img/image-20240709232659060.png" alt="image-20240709232659060"></p><h4 id="4-5-2-3-将用户加到群组"><a href="#4-5-2-3-将用户加到群组" class="headerlink" title="4.5.2.3 将用户加到群组"></a>4.5.2.3 将用户加到群组</h4><p>进入群组，管理权限设置</p><p><img src="/../../../img/image-20240709232954655.png" alt="image-20240709232954655"></p><p>点击“邀请成员”，邀请gs，角色选择owner</p><p><img src="/../../../img/image-20240709233103374.png" alt="image-20240709233103374"></p><p>添加成功</p><p><img src="/../../../img/image-20240709233208644.png" alt="image-20240709233208644"></p><h4 id="4-5-2-4-新建项目"><a href="#4-5-2-4-新建项目" class="headerlink" title="4.5.2.4 新建项目"></a>4.5.2.4 新建项目</h4><p>首页–创建项目</p><p><img src="/../../../img/image-20240709233338545.png" alt="image-20240709233338545"></p><p>创建空白项目，填写信息</p><p><img src="/../../../img/image-20240709233607868.png" alt="image-20240709233607868"></p><p>创建完成，查看项目信息，确保与dev组关联</p><p><img src="/../../../img/image-20240709234003098.png" alt="image-20240709234003098"></p><h4 id="4-5-2-5-测试推送代码"><a href="#4-5-2-5-测试推送代码" class="headerlink" title="4.5.2.5 测试推送代码"></a>4.5.2.5 测试推送代码</h4><p>登录上面的gs用户,然后配置密钥认证(流程类似于github)</p><p><img src="/../../../img/image-20240709234149143.png" alt="image-20240709234149143"></p><p>添加完ssh key</p><p><img src="/../../../img/image-20240709234317655.png" alt="image-20240709234317655"></p><p>推送代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#推送现有的 Git 仓库cd &#x2F;app&#x2F;code&#x2F;live-app&#x2F;#重命名已有的仓库git remote rename origin old-origin#添加新的仓库地址git remote add origin git@10.0.0.71:dev&#x2F;live_app.git#推送所有分支git push -u origin --all#推送所有标签git push -u origin --tags[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git remote add origin git@10.0.0.71:&#x2F;dev&#x2F;live_app.git[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#git push -u origin --allThe authenticity of host &#39;10.0.0.71 (10.0.0.71)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:OVpquCehSKXH4UACbiezs1feEbgyswAvmfM0c1jFOww.ECDSA key fingerprint is MD5:00:f4:c5:99:88:a5:d9:f3:5d:fa:65:d4:57:bd:39:a3.Are you sure you want to continue connecting (yes&#x2F;no)? yesWarning: Permanently added &#39;10.0.0.71&#39; (ECDSA) to the list of known hosts.Counting objects: 9, done.Compressing objects: 100% (5&#x2F;5), done.Writing objects: 100% (9&#x2F;9), 773 bytes | 0 bytes&#x2F;s, done.Total 9 (delta 0), reused 0 (delta 0)...</code></pre></div></figure><p>查看web页面仓库，推送成功</p><p><img src="/../../../img/image-20240709234740289.png" alt="image-20240709234740289"></p><h2 id="4-6-Gitlab的备份与恢复"><a href="#4-6-Gitlab的备份与恢复" class="headerlink" title="4.6 Gitlab的备份与恢复"></a>4.6 Gitlab的备份与恢复</h2><p>目标：</p><ul><li>掌握如何备份Gitlab相关的配置文件</li><li>掌握如何备份Gitlab中的程序代码(代码仓库(项目),用户,用户组,密钥.)</li></ul><h3 id="4-6-1-备份Gitlab服务的配置文件"><a href="#4-6-1-备份Gitlab服务的配置文件" class="headerlink" title="4.6.1 备份Gitlab服务的配置文件"></a>4.6.1 备份Gitlab服务的配置文件</h3><p>备份<code>/etc/gitlab</code>目录下的所有内容即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;app&#x2F;gitest&#x2F;project01]#ls &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb  gitlab.rb.bak  gitlab-secrets.json  initial_root_password  trusted-certs</code></pre></div></figure><h3 id="4-6-2-备份Gitlab里面的内容"><a href="#4-6-2-备份Gitlab里面的内容" class="headerlink" title="4.6.2 备份Gitlab里面的内容"></a>4.6.2 备份Gitlab里面的内容</h3><h4 id="a）开启备份功能"><a href="#a）开启备份功能" class="headerlink" title="a）开启备份功能"></a>a）开启备份功能</h4><p>修改gitlab的配置文件，开启备份功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;etc&#x2F;gitlab]#grep -rn &quot;^[a-Z]&quot; gitlab.rb32:external_url &#39;http:&#x2F;&#x2F;gitlab.test.cn&#39;# 是否可以指定备份目录605:gitlab_rails[&#39;manage_backup_path&#39;] &#x3D; true# 指定备份目录606:gitlab_rails[&#39;backup_path&#39;] &#x3D; &quot;&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;backups&quot;# 备份压缩包的权限610:gitlab_rails[&#39;backup_archive_permissions&#39;] &#x3D; 0644# 备份保留多久（秒，这个值等于7天）615:gitlab_rails[&#39;backup_keep_time&#39;] &#x3D; 604800</code></pre></div></figure><p>配置生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-ctl reconfiguregitlab-ctl restart</code></pre></div></figure><h4 id="b）生成备份"><a href="#b）生成备份" class="headerlink" title="b）生成备份"></a>b）生成备份</h4><p>输入命令，生成备份文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># GitLab 版本 &gt;&#x3D; 12.2 （实验用这个）gitlab-backup create# GitLab 版本 &lt;&#x3D; 12.1gitlab-rake gitlab:backup:create# 执行结果...2024-07-10 07:47:17 UTC -- Deleting backups&#x2F;tmp ... done2024-07-10 07:47:17 UTC -- Warning: Your gitlab.rb and gitlab-secrets.json files contain sensitive data and are not included in this backup. You will need these files to restore a backup.Please back them up manually.2024-07-10 07:47:17 UTC -- Backup 1720597580_2024_07_10_16.6.8 is done.2024-07-10 07:47:17 UTC -- Deleting backup and restore PID file ... done</code></pre></div></figure><p>查看生成的备份压缩包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@devops01 &#x2F;etc&#x2F;gitlab]#ls &#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;backups&#x2F;1720597580_2024_07_10_16.6.8_gitlab_backup.tar</code></pre></div></figure><h4 id="c）恢复"><a href="#c）恢复" class="headerlink" title="c）恢复"></a>c）恢复</h4><p>先停止写入类的服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-ctl stop unicorngitlab-ctl stop sidekiq</code></pre></div></figure><p>再恢复</p><blockquote><p>备份包名字不包含右边内容<code>_gitlab-backup.tar</code></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 新版本GitLab 版本 &gt;&#x3D; 12.2:gitlab-backup restore BACKUP&#x3D;1720597580_2024_07_10_16.6.8# 旧版本GitLab 版本 &lt;&#x3D; 12.1:gitlab-rake gitlab:backup:restore BACKUP&#x3D;1720597580_2024_07_10_16.6.8# 再输入yes继续Do you want to continue (yes&#x2F;no)? yes 输入yes</code></pre></div></figure><p>最后重启gitlab</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-ctl restart</code></pre></div></figure><h4 id="d）自动备份脚本"><a href="#d）自动备份脚本" class="headerlink" title="d）自动备份脚本"></a>d）自动备份脚本</h4><p>脚本如下：<code>backup-gitlab.sh</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# author :gs# desc : backup gitlab all# 1.备份gitlab数据gitlab-backup create# 2.备份gitlab配置和密码文件tar zcf &#x2F;backup&#x2F;gitlab&#x2F;gitlab-conf-$(date+%F).tar.gz &#x2F;etc&#x2F;gitlab&#x2F;# 3. 传输到备份服务器rsync xxx</code></pre></div></figure><p>写入定时任务，每天备份一次</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># crontab00 03 * * * sh &#x2F;server&#x2F;scripts&#x2F;backup-gitlab.sh &amp;&gt;&#x2F;dev&#x2F;null</code></pre></div></figure><h2 id="4-7-Gitlab的升级与迁移"><a href="#4-7-Gitlab的升级与迁移" class="headerlink" title="4.7 Gitlab的升级与迁移"></a>4.7 Gitlab的升级与迁移</h2><h3 id="4-7-1-升级方法"><a href="#4-7-1-升级方法" class="headerlink" title="4.7.1 升级方法"></a>4.7.1 升级方法</h3><p>为什么要升级？</p><ol><li>新功能，非常吸引</li><li>修复bug、漏洞</li><li>公司制定统一版本，为了标准化、自动化</li></ol><p>需要遵循以下升级步骤</p><ul><li>升级至<strong>之前主要版本</strong>的<strong>最新次要版本</strong>。</li><li>升级到<strong>目标主要版本</strong>的<strong>第一个次要版本</strong>（X.0.Z）。</li><li>继续升级到较新的版本</li></ul><p>比如12.0.3升级到14.1.1，需要先一步步升级中间版本，最后再升级到14.1.1</p><p><img src="/../../../img/image-20240710160127666.png" alt="image-20240710160127666"></p><h3 id="4-7-2-迁移方法"><a href="#4-7-2-迁移方法" class="headerlink" title="4.7.2 迁移方法"></a>4.7.2 迁移方法</h3><p>迁移比较简单一些，老主机备份，新主机恢复</p><p><img src="/../../../img/image-20240710160312010.png" alt="image-20240710160312010"></p><h2 id="4-8-开启HTTPS"><a href="#4-8-开启HTTPS" class="headerlink" title="4.8 开启HTTPS"></a>4.8 开启HTTPS</h2><p>如果有证书，可以在配置文件中设置，开启HTTPS，参考如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 为了防止内网渗透，将gitlab服务的访问添加了sslexternal_url &#39;https:&#x2F;&#x2F;gitlab.oldboylinux.cn&#39;nginx[&#39; enable&#39; ] &#x3D; truenginx[&#39;client_max_body_size&#39; ]&#x3D; &#39;250m &#39;nginx[&#39;redirect_http_to_https&#39; ]&#x3D; truenginx[&#39; redirect_http_to_https _port&#39; ] &#x3D; 443# 核心部分，指定证书nginx[&#39;ssl_certificate&#39; ] &#x3D; &quot;path&#x2F; key.crt&quot;# 核心部分，指定私钥nginx[&#39;ssl_certificate_key&#39;] &#x3D; &quot;path&#x2F; key.key&quot;nginx[&#39;ssl_ciphers&#39; ] &#x3D;&quot;ECDHE-RSA-AES256-GCMSHA384:ECDHE-RSA-AES128-GCM-SHA256&quot;nginx[&#39;ssl_prefer_server_ciphers&#39;]&#x3D; &quot;on&quot;nginx[&#39;ssl_protocols&#39;]&#x3D; &quot;TLSv1.2&quot;nginx[&#39;ssl_session_cache &#39; ] &#x3D; &quot;builtin:1000shared:sSL: 10m&quot;nginx[&#39;ssl_session_timeout&#39;]&#x3D; &quot;5m&quot;</code></pre></div></figure><p>修改完，重新初始化，并重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-ctl reconfiguregitlab-ctl restart</code></pre></div></figure><h2 id="4-9-配置邮箱"><a href="#4-9-配置邮箱" class="headerlink" title="4.9 配置邮箱"></a>4.9 配置邮箱</h2><p>默认已经有发送邮件的功能，可以通过配置文件来修改发件人，参考如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置发件人51 ### Email Settings52 gitlab_rails[&#39;gitlab_email_enabled&#39;] &#x3D; true53 gitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &#39;lidao996@163.com&#39;54 gitlab_rails[&#39;gitlab_email_display_name&#39;] &#x3D; &#39;Oldboy_gitlab_tongzhi&#39;# 配置发件人详细信息517 gitlab_rails[&#39;smtp_enable&#39;] &#x3D; true518 gitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.163.com&quot;519 gitlab_rails[&#39;smtp_port&#39;] &#x3D; 465520 gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;lidao996@163.com&quot;521 gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;smtp授权码&quot;522 gitlab_rails[&#39;smtp_domain&#39;] &#x3D; &quot;163.com&quot;523 gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; &quot;login&quot;524 gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; true525 gitlab_rails[&#39;smtp_tls&#39;] &#x3D; true</code></pre></div></figure><p>修改完，重新初始化，并重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-ctl reconfiguregitlab-ctl restart</code></pre></div></figure><h2 id="4-10-Gitlab优化"><a href="#4-10-Gitlab优化" class="headerlink" title="4.10 Gitlab优化"></a>4.10 Gitlab优化</h2><p>优化策略：关闭目前不使用的组件，默认都是true，修改为 false  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 关闭prometheusprometheus[&#39;enable&#39;] &#x3D; falseprometheus[&#39;monitor_kubernetes&#39;] &#x3D; false# 关闭alertmangeralertmanager[&#39;enable&#39;] &#x3D; false# 关闭exporter 如果需要prometheus监控 则可以打开。node_exporter[&#39;enable&#39;] &#x3D; falseredis_exporter[&#39;enable&#39;] &#x3D; falsepostgres_exporter[&#39;enable&#39;] &#x3D; falsegitlab_monitor[&#39;enable&#39;] &#x3D; false# gitlab_exporterprometheus_monitoring[&#39;enable&#39;] &#x3D; falsegrafana[&#39;enable&#39;] &#x3D; false</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day73-监控架构-Prometheus(二)</title>
    <link href="/2024/07/08/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day73-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Promethueus-2%20%20(copy)/"/>
    <url>/2024/07/08/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day73-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Promethueus-2%20%20(copy)/</url>
    
    <content type="html"><![CDATA[<h1 id="监控架构-Prometheus-02"><a href="#监控架构-Prometheus-02" class="headerlink" title="监控架构-Prometheus-02"></a>监控架构-Prometheus-02</h1><p>今日内容：</p><ul><li>基于prometheus的nginx监控</li><li>基于prometheus的Mysql监控</li><li>基于prometheus的docker容器监控</li><li>prometheus的告警配置</li></ul><h1 id="一、前期沟通"><a href="#一、前期沟通" class="headerlink" title="一、前期沟通"></a>一、前期沟通</h1><p>在监控开始部署前，需要在组内完成沟通：</p><ul><li>确定监控指标</li><li>可能需要开发人员配合书写监控页面  </li><li>等等其他沟通</li></ul><h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><p>监控的目标确定：</p><table><thead><tr><th>监控的项目</th><th>exporter</th><th>涉及的主机</th></tr></thead><tbody><tr><td>系统基本信息</td><td>node_exporter</td><td>所有主机</td></tr><tr><td>负载均衡，web</td><td>nginx_exporter</td><td>负载均衡，web服务器</td></tr><tr><td>web中间件:php、java</td><td>jmx_exporter</td><td>web服务器</td></tr><tr><td>数据库</td><td>mysqld_exporter</td><td>数据库服务器</td></tr><tr><td>redis</td><td>redis_exporter</td><td>缓存服务器</td></tr><tr><td>存储</td><td>xxx_exporter</td><td>nfs、对象存储（OSS）、Ceph、minio等</td></tr><tr><td>容器</td><td>cdvisor</td><td>容器服务器</td></tr></tbody></table><h1 id="三、搭建流程"><a href="#三、搭建流程" class="headerlink" title="三、搭建流程"></a>三、搭建流程</h1><p>这里演示nginx和mysql的exporter</p><h2 id="3-1-nginx-exporter部署"><a href="#3-1-nginx-exporter部署" class="headerlink" title="3.1 nginx_exporter部署"></a>3.1 nginx_exporter部署</h2><h3 id="3-1-1-准备web页面"><a href="#3-1-1-准备web页面" class="headerlink" title="3.1.1 准备web页面"></a>3.1.1 准备web页面</h3><p>按照插件需求，需要开启status页面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 访问指定的uri和端口就显示nginx_status页面  [root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;nginx&#x2F;conf.d]#cat status.conf server &#123;  listen 8000;    location &#x2F; &#123;      stub_status;    &#125;&#125;</code></pre></div></figure><h3 id="3-1-2-客户端部署nginx-exporter"><a href="#3-1-2-客户端部署nginx-exporter" class="headerlink" title="3.1.2 客户端部署nginx_exporter"></a>3.1.2 客户端部署nginx_exporter</h3><blockquote><p>插件地址：<a href="https://github.com/nginxinc/nginx-prometheus-exporter">https://github.com/nginxinc/nginx-prometheus-exporter</a></p></blockquote><p>部署方式有三种：</p><ul><li>下载二进制包，直接使用</li><li>docker方式部署</li><li>下载插件源码包，编译安装</li></ul><p>二进制包的方式，前面我们已经在部署node_exporter时用过，这里采用docker的方式部署。</p><blockquote><p>部署在拥有docker环境的服务器–docker01（10.0.0.81）中</p></blockquote><p>1、创建docker容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;nginx&#x2F;conf.d]#docker run -d --name &quot;ngx&quot; -v &#96;pwd&#96;&#x2F;status.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;status.conf --restart&#x3D;always -p 80:80 -p 8000:8000 nginx:stable-alpine30ea712a92191e5ec596f1ce406516a1589e9d7ed5c0a94a5e5cc8fecc45afe9</code></pre></div></figure><p>2、检查环境是否启动成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># docker命令检查[root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;nginx&#x2F;conf.d]#docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED              STATUS              PORTS                                                                          NAMES30ea712a9219   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   About a minute ago   Up About a minute   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp, 0.0.0.0:8000-&gt;8000&#x2F;tcp, :::8000-&gt;8000&#x2F;tcp   ngx# 网页测试[root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;nginx&#x2F;conf.d]#curl 172.16.1.81:8000Active connections: 1 server accepts handled requests 1 1 1 Reading: 0 Writing: 1 Waiting: 0 </code></pre></div></figure><p>3、创建ngx_exporter容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name &quot;ngx_exporter_8000&quot; -p 9113:9113 --restart&#x3D;always nginx&#x2F;nginx-prometheus-exporter:0.10.0 -nginx.scrape-uri &quot;http:&#x2F;&#x2F;172.16.1.81:8000&#x2F;&quot;</code></pre></div></figure><p>4、测试访问metrics页面</p><p><a href="http://10.0.0.81:9113/metrics">http://10.0.0.81:9113/metrics</a></p><p><img src="/../../../img/image-20240708112735461.png" alt="image-20240708112735461"></p><h3 id="3-1-3-服务端配置"><a href="#3-1-3-服务端配置" class="headerlink" title="3.1.3 服务端配置"></a>3.1.3 服务端配置</h3><p>修改prometheus的配置文件，把被监控器加进去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat prometheus.yml ....   - job_name: &quot;pushgateway&quot;    static_configs:      - targets: [&quot;10.0.0.63:9091&quot;]    # 新增nginx_exporter监控       - job_name: &quot;nginx_exporter&quot;    static_configs:      - targets: [&quot;10.0.0.81:9113&quot;]</code></pre></div></figure><p>重启服务，可在网页查看是否添加成功</p><p><img src="/../../../img/image-20240708113234024.png" alt="image-20240708113234024"></p><h3 id="3-1-4-Grafana页面-导入模板"><a href="#3-1-4-Grafana页面-导入模板" class="headerlink" title="3.1.4 Grafana页面-导入模板"></a>3.1.4 Grafana页面-导入模板</h3><blockquote><p>nginx exporter的监控模板下载（ID：9512）：</p><p><a href="https://grafana.com/grafana/dashboards/9512-nginx-connections-overview/">https://grafana.com/grafana/dashboards/9512-nginx-connections-overview/</a></p></blockquote><p>1、下载json文件，导入模板</p><p><img src="/../../../img/image-20240708113909177.png" alt="image-20240708113909177"></p><p>2、默认界面如下</p><p><img src="/../../../img/image-20240708114432191.png" alt="image-20240708114432191"></p><p>这里面的<code>UP</code>是怎么来的？右下角的<code>mapping</code>设置</p><p><img src="/../../../img/image-20240708114407520.png" alt="image-20240708114407520"></p><p>其他面板没有数据，需要自行配置</p><h3 id="3-1-5-Grafana页面-配置面板"><a href="#3-1-5-Grafana页面-配置面板" class="headerlink" title="3.1.5 Grafana页面-配置面板"></a>3.1.5 Grafana页面-配置面板</h3><p>(踩坑)</p><blockquote><p>注意，这里涉及到一个问题：在使用第三方模板时，多数情况下是方便的，但是涉及到某些特殊情况，exporter收集的<strong>参数和模板不一定匹配</strong>，需要根据与实际情况修改。</p></blockquote><p>比如面板中自带的查询语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">irate(nginx_connections_processed_total&#123;instance&#x3D;~&quot;$instance&quot;, app&#x3D;~&quot;$app&quot;, stage&#x3D;&quot;handled&quot;, namespace&#x3D;~&quot;$namespace&quot;&#125;[5m])</code></pre></div></figure><p>在<a href="http://10.0.0.81:9113/metrics%E4%B8%AD%EF%BC%8C%E6%A0%B9%E6%9C%AC%E5%B0%B1%E6%B2%A1%E6%9C%89%60nginx_connections_processed_total%60%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E6%88%90%E6%95%88%E6%9E%9C%E7%B1%BB%E4%BC%BC%E7%9A%84%60nginx_http_requests_total%60%E5%87%BD%E6%95%B0">http://10.0.0.81:9113/metrics中，根本就没有`nginx_connections_processed_total`这个函数，需要修改成效果类似的`nginx_http_requests_total`函数</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># job缺少参数，只能写死，不能写 “$job”irate(nginx_http_requests_total&#123;instance&#x3D;~&quot;$instance&quot;, job&#x3D;~&quot;nginx_exporter&quot;&#125;[5m])</code></pre></div></figure><p>效果如下，数据出来了</p><p><img src="/../../../img/image-20240708115947050.png" alt="image-20240708115947050"></p><p>但是可以看到，我们自行使用的函数，其参数只有2个（instance、job），而此模板面板带的参数有4个（instance、namespace、app、datasource），参数不匹配，<strong>需要对模板参数进行设置</strong></p><h3 id="3-1-6-Grafana页面-模板参数设置"><a href="#3-1-6-Grafana页面-模板参数设置" class="headerlink" title="3.1.6 Grafana页面-模板参数设置"></a>3.1.6 Grafana页面-模板参数设置</h3><p>进到模板对应的设置页面，创建变量</p><p><img src="/../../../img/image-20240708120657581.png" alt="image-20240708120657581"></p><p>填写信息，创建<code>job</code>变量</p><p><img src="/../../../img/image-20240708120828721.png" alt="image-20240708120828721"></p><p>这样修改后，在<code>3.1.5</code>中不能使用<code>“$job”</code>的问题就解决了</p><p><img src="/../../../img/image-20240708121354551.png" alt="image-20240708121354551"></p><p>删除其他多余的变量，再修改instance</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#如果想job与实例是关联的则使用下面即可label_values(up&#123;job&#x3D;&quot;$job&quot;&#125;,instance)</code></pre></div></figure><p><img src="/../../../img/image-20240708121649340.png" alt="image-20240708121649340"></p><p>最后该面板的效果</p><p><img src="/../../../img/image-20240708121836525.png" alt="image-20240708121836525"></p><h3 id="3-1-7-nginx-exporter小结"><a href="#3-1-7-nginx-exporter小结" class="headerlink" title="3.1.7 nginx exporter小结"></a>3.1.7 nginx exporter小结</h3><p>部署小结：</p><ul><li>有相对应的环境</li><li>部署export(docker,直接部署)</li><li>测试exporter是否有数据 10.0.0.81:9113&#x2F;metrics</li><li>配置prometheus服务端管理exporter</li><li>配置grafana(仪表盘(模板),自定义仪表盘(自定义job变量和instance变量))</li></ul><h2 id="3-2-mysqld-exporter部署"><a href="#3-2-mysqld-exporter部署" class="headerlink" title="3.2 mysqld_exporter部署"></a>3.2 mysqld_exporter部署</h2><blockquote><p>本实验需要两台服务器配合：</p><p>db01部署、配置mysqld</p><p>docker01 部署mysqld_exporter</p></blockquote><p>获取exporter：<a href="https://github.com/prometheus/mysqld_exporter">https://github.com/prometheus/mysqld_exporter</a></p><h3 id="3-2-1-db01配置"><a href="#3-2-1-db01配置" class="headerlink" title="3.2.1 db01配置"></a>3.2.1 db01配置</h3><p>按照mysqld_exporter的需求，创建用户并授权</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 官方给的有问题，这是根据网上的方法找到的CREATE USER &#39;exporter&#39;@&#39;%&#39; IDENTIFIED BY &#39;redhat123&#39;;GRANT PROCESS, REPLICATION CLIENT, REPLICATION SLAVE, SLAVE MONITOR, SELECT ON . TO &#39;exporter&#39;@&#39;%&#39;;</code></pre></div></figure><h3 id="3-2-2-docker01配置"><a href="#3-2-2-docker01配置" class="headerlink" title="3.2.2 docker01配置"></a>3.2.2 docker01配置</h3><p>1、创建连接数据库的文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;mysql]#cat my.cnf [client]host &#x3D; 172.16.1.51user &#x3D; exporterpassword &#x3D; redhat123</code></pre></div></figure><p>2、配置连接数据库的变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 格式：export DATA_SOURCE_NAME&#x3D;&#39;login:password@(hostname:port)&#x2F;&#39;[root@docker01 &#x2F;]#export DATA_SOURCE_NAME&#x3D;&#39;exporter:redhat123@(172.16.1.51:3306)&#x2F;&#39;</code></pre></div></figure><p>3、启动Mysqld_exporter</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;]#docker run -d --restart&#x3D;always --name &quot;mysqld_exporter&quot; -v &#x2F;app&#x2F;docker&#x2F;conf&#x2F;mysql&#x2F;my.cnf:&#x2F;etc&#x2F;exporter-my.cnf -e &quot;DATA_SOURCE_NAME&#x3D;&#39;exporter:redhat123@(172.16.1.51:3306)&#x2F;&#39;&quot; -p 9104:9104 prom&#x2F;mysqld-exporter --config.my-cnf&#x3D;&#x2F;etc&#x2F;exporter-my.cnf</code></pre></div></figure><p>4、测试</p><p>查看docker容器状态，显示连不上数据库服务器</p><p><img src="/../../../img/image-20240708143625215.png" alt="image-20240708143625215"></p><p>尝试修改Mysql的用户权限设置也没用，<strong>官方镜像存在问题</strong></p><h3 id="3-2-3-服务端配置"><a href="#3-2-3-服务端配置" class="headerlink" title="3.2.3 服务端配置"></a>3.2.3 服务端配置</h3><p>1、修改prometheus服务端配置文件，新增监控</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat prometheus.yml ...  # 新增nginx_exporter监控       - job_name: &quot;nginx_exporter&quot;    static_configs:      - targets: [&quot;10.0.0.81:9113&quot;]    # 新增mysqld_exporter监控       - job_name: &quot;mysqld_exporter&quot;    static_configs:      - targets: [&quot;10.0.0.81:9104&quot;]</code></pre></div></figure><p>2、测试：在metrics中mysql up的值始终是0，<strong>容器确实有问题</strong></p><p><img src="/../../../img/image-20240708141641881.png" alt="image-20240708141641881"></p><p>官方镜像存在问题，需要自定义镜像！</p><h3 id="3-2-4-自定义docker镜像部署"><a href="#3-2-4-自定义docker镜像部署" class="headerlink" title="3.2.4 自定义docker镜像部署"></a>3.2.4 自定义docker镜像部署</h3><p>1、为解决3.2.3跟3.2.4的问题，创建Dockerfile自定义mysqld_exporter镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">[root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;mysql]#cat Dockerfile FROM alpine:latestLABEL author&#x3D;lidao996ADD mysqld_exporter-0.15.1.linux-amd64.tar.gz &#x2F;app&#x2F;tools&#x2F;COPY my.cnf &#x2F;app&#x2F;tools&#x2F;mysqld_exporter-0.15.1.linux-amd64&#x2F;ENV DATA_SOURCE_NAME&#x3D;&#39;exporter:redhat123@(172.16.1.51:3306)&#x2F;&#39;RUN ln -s &#x2F;app&#x2F;tools&#x2F;mysqld_exporter-0.15.1.linux-amd64 &#x2F;app&#x2F;tools&#x2F;mysqld_exporterWORKDIR &#x2F;app&#x2F;tools&#x2F;mysqld_exporter-0.15.1.linux-amd64&#x2F;EXPOSE 9104CMD [&quot;.&#x2F;mysqld_exporter&quot;,&quot;--config.my-cnf&#x3D;.&#x2F;my.cnf&quot;]</code></pre></div></figure><p>2、在github下载mysqld_exporter，放到对应的文件夹中</p><p><img src="/../../../img/image-20240708142540442.png" alt="image-20240708142540442"></p><p>3、执行Dockerfile，创建镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t my_mysqld_exporter:latest .</code></pre></div></figure><p>4、重新运行容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;mysql]#docker run -d --restart&#x3D;always -p 9104:9104 my_mysqld_exporter:latest7888508b5f0677f0812423ec085c74cd13f32feea358b17a09ffa72888e715a9</code></pre></div></figure><p>5、测试</p><p>查看容器日志：正常，没有连接数据库的报错</p><p><img src="/../../../img/image-20240708155658555.png" alt="image-20240708155658555"></p><p>再次测试访问metrics页面，正常</p><p><img src="/../../../img/image-20240708155721004.png" alt="image-20240708155721004"></p><p>后续可以使用获得的数据，去grafana配置监控页面了</p><h2 id="3-3-容器监控-cdvisor"><a href="#3-3-容器监控-cdvisor" class="headerlink" title="3.3 容器监控-cdvisor"></a>3.3 容器监控-cdvisor</h2><h3 id="3-3-1-部署cdvisor"><a href="#3-3-1-部署cdvisor" class="headerlink" title="3.3.1 部署cdvisor"></a>3.3.1 部署cdvisor</h3><blockquote><p>docker01服务器操作</p></blockquote><p>一键部署，注意端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run \  --volume&#x3D;&#x2F;:&#x2F;rootfs:ro \  --volume&#x3D;&#x2F;var&#x2F;run:&#x2F;var&#x2F;run:ro \  --volume&#x3D;&#x2F;sys:&#x2F;sys:ro \  --volume&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;:&#x2F;var&#x2F;lib&#x2F;docker:ro \  --volume&#x3D;&#x2F;dev&#x2F;disk&#x2F;:&#x2F;dev&#x2F;disk:ro \  --publish&#x3D;8080:8080 \  --detach&#x3D;true \  --name&#x3D;cadvisor \  --privileged \  --device&#x3D;&#x2F;dev&#x2F;kmsg \  google&#x2F;cadvisor:latest</code></pre></div></figure><p>查看是否正常启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;app&#x2F;docker&#x2F;conf&#x2F;mysql]#docker psCONTAINER ID   IMAGE                             COMMAND                  CREATED          STATUS          PORTS                                                                          NAMES0a9345fbc2a7   google&#x2F;cadvisor:latest            &quot;&#x2F;usr&#x2F;bin&#x2F;cadvisor -…&quot;   50 seconds ago   Up 49 seconds   0.0.0.0:8080-&gt;8080&#x2F;tcp, :::8080-&gt;8080&#x2F;tcp                                      cadvisor</code></pre></div></figure><p>测试访问页面：<a href="http://10.0.0.81:8080/">http://10.0.0.81:8080</a></p><p><img src="/../../../img/image-20240709103019307.png" alt="image-20240709103019307"></p><h3 id="3-3-2-Prometheus配置"><a href="#3-3-2-Prometheus配置" class="headerlink" title="3.3.2 Prometheus配置"></a>3.3.2 Prometheus配置</h3><blockquote><p>mn04操作</p></blockquote><p>修改yml配置文件，对接Cdvisor</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat prometheus.yml...    # 新增cadvisor监控       - job_name: &quot;cadvisor-docker&quot;    static_configs:      - targets: [&quot;10.0.0.81:8080&quot;]</code></pre></div></figure><p>重启服务，访问prometheus网页查看效果</p><p><img src="/../../../img/image-20240709103316474.png" alt="image-20240709103316474"></p><h3 id="3-3-3-对接Grafana展示"><a href="#3-3-3-对接Grafana展示" class="headerlink" title="3.3.3 对接Grafana展示"></a>3.3.3 对接Grafana展示</h3><p>模板ID:10619</p><p><img src="/../../../img/image-20240709103518806.png" alt="image-20240709103518806"></p><p>导入</p><p><img src="/../../../img/image-20240709103549729.png" alt="image-20240709103549729"></p><p>默认效果</p><p><img src="/../../../img/image-20240709103610586.png" alt="image-20240709103610586"></p><p>选择“Host”后，监控正常</p><p><img src="/../../../img/image-20240709103706690.png" alt="image-20240709103706690"></p><h2 id="四、警告配置（Altermanager）"><a href="#四、警告配置（Altermanager）" class="headerlink" title="四、警告配置（Altermanager）"></a>四、警告配置（Altermanager）</h2><p>用于实现监控告警功能</p><p>使用流程：</p><ol><li>部署Alertermanager(在prometheus服务端部署)</li><li>修改alertmanger配置</li><li>配置告警规则rules与修改服务端配置</li></ol><h2 id="4-1-部署Altermanager"><a href="#4-1-部署Altermanager" class="headerlink" title="4.1 部署Altermanager"></a>4.1 部署Altermanager</h2><p>1、获取安装包：<a href="https://github.com/prometheus/alertmanager/releases/tag/v0.27.0">https://github.com/prometheus/alertmanager/releases/tag/v0.27.0</a></p><p>2、解压安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#tar -vxf alertmanager-0.27.0.linux-amd64.tar.gz# 创建软连接[root@mn04[ &#x2F;app&#x2F;prometheus]#ln -s &#x2F;app&#x2F;prometheus&#x2F;alertmanager-0.27.0.linux-amd64 &#x2F;app&#x2F;prometheus&#x2F;alertmanager# 命令也是[root@mn04[ &#x2F;app&#x2F;prometheus]#ln -s &#x2F;app&#x2F;prometheus&#x2F;alertmanager&#x2F;alertmanager &#x2F;bin</code></pre></div></figure><p>3、前台启动测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">alertmanager --config.file&#x3D;&#x2F;app&#x2F;prometheus&#x2F;alertmanager&#x2F;alertmanager.yml</code></pre></div></figure><p>4、检查进程与端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#ss -lntup | grep alerudp    UNCONN     0      0      [::]:9094               [::]:*                   users:((&quot;alertmanager&quot;,pid&#x3D;17843,fd&#x3D;7))tcp    LISTEN     0      128    [::]:9093               [::]:*                   users:((&quot;alertmanager&quot;,pid&#x3D;17843,fd&#x3D;8))tcp    LISTEN     0      128    [::]:9094               [::]:*                   users:((&quot;alertmanager&quot;,pid&#x3D;17843,fd&#x3D;3))[root@mn04[ &#x2F;app&#x2F;prometheus]#ps -ef | grep alerroot      17843  15588  0 23:20 pts&#x2F;0    00:00:00 alertmanager --config.file&#x3D;&#x2F;app&#x2F;prometheus&#x2F;alertmanager&#x2F;alertmanager.ymlroot      17902  17854  0 23:21 pts&#x2F;1    00:00:00 grep --color&#x3D;auto aler</code></pre></div></figure><h2 id="4-2-配置Aler（对接第三方平台方式）"><a href="#4-2-配置Aler（对接第三方平台方式）" class="headerlink" title="4.2 配置Aler（对接第三方平台方式）"></a>4.2 配置Aler（对接第三方平台方式）</h2><p>对接第三方平台（睿象云）的方式</p><p><a href="https://www.aiops.com/">https://www.aiops.com</a></p><p><img src="/../../../img/image-20240708232803550.png" alt="image-20240708232803550"></p><h3 id="4-2-1-获取aiops的apikey"><a href="#4-2-1-获取aiops的apikey" class="headerlink" title="4.2.1 获取aiops的apikey"></a>4.2.1 获取aiops的apikey</h3><p>首页点击监控工具，选择prometheus</p><p><img src="/../../../img/image-20240708233404738.png" alt="image-20240708233404738"></p><p>填写应用名称，保存获取key</p><p><img src="/../../../img/image-20240708233504490.png" alt="image-20240708233504490"></p><p>得到key，可按右边的方式配置</p><p><img src="/../../../img/image-20240708233549745.png" alt="image-20240708233549745"></p><h3 id="4-2-3-配置文件"><a href="#4-2-3-配置文件" class="headerlink" title="4.2.3 配置文件"></a>4.2.3 配置文件</h3><p>1、按照官方提示，修改yml配置文件，对接第三方平台</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat alertmanager&#x2F;alertmanager.yml route:  group_by: [&#39;alertname&#39;]  group_wait: 30s  group_interval: 5m  repeat_interval: 1h  receiver: &#39;team-X-pager&#39;receivers:  - name: &#39;team-X-pager&#39;    webhook_configs:      - url: &#39;http:&#x2F;&#x2F;api.aiops.com&#x2F;alert&#x2F;api&#x2F;event&#x2F;prometheus&#x2F;a6c88da68b644807acb2ebb55d70c71e&#39;        send_resolved: trueinhibit_rules:  - source_match:      severity: &#39;critical&#39;    target_match:      severity: &#39;warning&#39;    equal: [&#39;alertname&#39;, &#39;dev&#39;, &#39;instance&#39;]</code></pre></div></figure><p>配置完重启alertmanager服务</p><p>2、访问页面，查看状态</p><p><a href="http://10.0.0.64:9093/#/status">http://10.0.0.64:9093/#/status</a></p><p><img src="/../../../img/image-20240708234115220.png" alt="image-20240708234115220"></p><h3 id="4-2-4-测试-制造故障"><a href="#4-2-4-测试-制造故障" class="headerlink" title="4.2.4 测试-制造故障"></a>4.2.4 测试-制造故障</h3><p>让mn03关机，收到警告与邮件</p><p>警告如图</p><p><img src="/../../../img/image-20240709002502359.png" alt="image-20240709002502359"></p><p>邮件如图</p><p><img src="/../../../img/image-20240709002534109.png" alt="image-20240709002534109"></p><h2 id="4-3-配置Aler（邮件告警方式）"><a href="#4-3-配置Aler（邮件告警方式）" class="headerlink" title="4.3 配置Aler（邮件告警方式）"></a>4.3 配置Aler（邮件告警方式）</h2><h3 id="4-3-1-配置文件"><a href="#4-3-1-配置文件" class="headerlink" title="4.3.1 配置文件"></a>4.3.1 配置文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat alertmanager&#x2F;alertmanager.yml global:# 全局定义部分，定义发件人信息  resolve_timeout: 5m# dns解析的超时时间5分钟  smtp_from: &#39;724262366@qq.com&#39;# 发件人  smtp_smarthost: &#39;smtp.qq.com:465&#39;# smtp服务器  smtp_hello: &#39;qq.com&#39;# 邮件厂商  smtp_auth_username: &#39;724262366@qq.com&#39;# 邮箱名字  smtp_auth_password: &#39;yrubyovtznyybbeg&#39;# 授权码  smtp_require_tls: falseroute:# 收件人间隔时间，收件方式  group_by: [&#39;alertname&#39;]  group_wait: 30s  group_interval: 5m  repeat_interval: 1h# 重复警告时间间隔（每一小时发一次）  receiver: &#39;email&#39; # 什么方式接受警告receivers:# 收件人信息  - name: &quot;email&quot;    email_configs:    - to: &#39;724262366@qq.com&#39;      send_resolved: trueinhibit_rules:  - source_match:      severity: &#39;critical&#39;    target_match:      severity: &#39;warning&#39;    equal: [&#39;alertname&#39;, &#39;dev&#39;, &#39;instance&#39;]</code></pre></div></figure><h3 id="4-3-2-Prometheus对接Altermanager"><a href="#4-3-2-Prometheus对接Altermanager" class="headerlink" title="4.3.2 Prometheus对接Altermanager"></a>4.3.2 Prometheus对接Altermanager</h3><p>1、修改配置文件，开启警告功能，yml文件片段</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat prometheus.yml ...# Alertmanager configurationalerting:  alertmanagers:    - static_configs:        - targets:          # 配置altermanager平台的ip          - &quot;10.0.0.64:9093&quot;# Load rules once and periodically evaluate them according to the global &#39;evaluation_interval&#39;.rule_files:  # - &quot;first_rules.yml&quot;  # - &quot;second_rules.yml&quot;  - &quot;&#x2F;app&#x2F;prometheus&#x2F;prometheus_alert_rules.yml&quot;  # rules文件# A scrape configuration containing exactly one endpoint to scrape:# Here it&#39;s Prometheus itself.scrape_configs:...</code></pre></div></figure><p>2、创建<code>prometheus_alert_rules.yml</code>文件，内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">groups:- name: check_node_status  rules:  - alert: check_node_is_up    expr: up &#x3D;&#x3D; 0    for: 15s    labels:      severity: 1      team: node    annotations:      summary: &quot; &#123;&#123; $labels.instance &#125;&#125; 节点停止运行超过15秒!!!&quot;</code></pre></div></figure><p>3、配置完重启服务</p><h3 id="4-3-3-web页面检查"><a href="#4-3-3-web页面检查" class="headerlink" title="4.3.3 web页面检查"></a>4.3.3 web页面检查</h3><p>在web页面检查规则，如图存在，则配置成功</p><p><img src="/../../../img/image-20240709000856398.png" alt="image-20240709000856398"></p><h3 id="4-3-4-测试-制造故障"><a href="#4-3-4-测试-制造故障" class="headerlink" title="4.3.4 测试-制造故障"></a>4.3.4 测试-制造故障</h3><p>把grafana的服务器（mn03）shutdown，成功收到告警</p><p>先是prometheus页面告警</p><p><img src="/../../../img/image-20240709001139730.png" alt="image-20240709001139730"></p><p>而后收到邮件告警</p><p><img src="/../../../img/image-20240709001221383.png" alt="image-20240709001221383"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day72-监控架构-Prometheus(一)</title>
    <link href="/2024/07/01/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day72-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Promethueus-1/"/>
    <url>/2024/07/01/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day72-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Promethueus-1/</url>
    
    <content type="html"><![CDATA[<h1 id="监控架构-Prometheus-01"><a href="#监控架构-Prometheus-01" class="headerlink" title="监控架构-Prometheus-01"></a>监控架构-Prometheus-01</h1><p>今日内容：</p><ul><li>认识prometheus</li><li>prometheus的基本用法以及数据查询语句</li><li>Prometheus的exporter客户端</li><li>Grafana展示promethues的数据</li><li>使用PushGateway实现自定义监控</li></ul><h1 id="一、Prometheus介绍"><a href="#一、Prometheus介绍" class="headerlink" title="一、Prometheus介绍"></a>一、Prometheus介绍</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>Prometheus（普罗米修斯）监控架构，使用Golang语言实现。</p><p>使用简单，学习门槛较高，Prometheus一般与Grafana配合。  </p><h2 id="2-2-Prometheus对比Zabbix"><a href="#2-2-Prometheus对比Zabbix" class="headerlink" title="2.2 Prometheus对比Zabbix"></a>2.2 Prometheus对比Zabbix</h2><table><thead><tr><th>指标</th><th>Prometheus</th><th>Zabbix</th></tr></thead><tbody><tr><td>语言</td><td>Golang(Go)</td><td>PHP,C,GO</td></tr><tr><td>部署</td><td>二进制，解压即用.</td><td>yum&#x2F;编译安装、数据库、php依赖</td></tr><tr><td>是否容易掌握</td><td>门槛较高</td><td>容易使用</td></tr><tr><td>监控方式</td><td>通过各种exporter，监控一般都是基于http</td><td>各种模板，客户端，自定义监控，各种协议.</td></tr><tr><td>应用场景</td><td>监控服务、容器、k8s。</td><td>监控系统底层，硬件，系统，网络。</td></tr></tbody></table><h1 id="二、极速上手"><a href="#二、极速上手" class="headerlink" title="二、极速上手"></a>二、极速上手</h1><h2 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h2><table><thead><tr><th>角色</th><th>主机名</th><th>ip</th></tr></thead><tbody><tr><td>prometheus服务端</td><td>m04-prometheus pro.oldboylinux.cn</td><td>10.0.0.64&#x2F;172.16.1.64</td></tr><tr><td>grafana</td><td>m03-grafana gra.oldboylinux.cn</td><td>10.0.0.63&#x2F;172.16.1.63</td></tr><tr><td>docker01</td><td>docker01 docker01.oldboylinux.cn</td><td>10.0.0.81&#x2F;172.16.1.81</td></tr></tbody></table><h2 id="2-2-时间同步"><a href="#2-2-时间同步" class="headerlink" title="2.2 时间同步"></a>2.2 时间同步</h2><p>确保各服务器时间一致</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">crontab -e# sync time *&#x2F;3 * * * * &#x2F;sbin&#x2F;ntpdate ntp1.aliyun.com &amp;&gt;&#x2F;dev&#x2F;null</code></pre></div></figure><h2 id="2-3-部署prometheus"><a href="#2-3-部署prometheus" class="headerlink" title="2.3 部署prometheus"></a>2.3 部署prometheus</h2><blockquote><p>mn04操作</p></blockquote><p>1、官网下载安装包，上传到服务器，解压</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p &#x2F;app&#x2F;tar xf prometheus-2.53.0.linux-amd64.tar.gz -C &#x2F;app&#x2F;ln -s &#x2F;app&#x2F;prometheus-2.53.0.linux-amd64&#x2F; &#x2F;app&#x2F;prometheus[root@mn04[ &#x2F;app]#lsprometheus  prometheus-2.53.0.linux-amd64  rpms  src  tools[root@mn04[ &#x2F;app&#x2F;prometheus]#lsconsole_libraries  consoles  LICENSE  NOTICE  prometheus  prometheus.yml  promtool</code></pre></div></figure><p>2、主要文件说明</p><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>prometheus</td><td>prometheus服务端的命令</td></tr><tr><td>prometheus.yml</td><td>配置文件。</td></tr></tbody></table><p>3、查看版本信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#.&#x2F;prometheus --versionprometheus, version 2.53.0 (branch: HEAD, revision: 4c35b9250afefede41c5f5acd76191f90f625898)  build user:       root@7f8d89cbbd64  build date:       20240619-07:39:12  go version:       go1.22.4  platform:         linux&#x2F;amd64  tags:             netgo,builtinassets,stringlabels</code></pre></div></figure><p>4、启动</p><ul><li>前台启动方式</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#.&#x2F;prometheus </code></pre></div></figure><ul><li>后台启动方式</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup &#x2F;app&#x2F;prometheus&#x2F;prometheus &amp;&gt;&gt;&#x2F;var&#x2F;log&#x2F;prometheus.log &amp;</code></pre></div></figure><ul><li>systemctl管理方式（推荐）</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建服务文件[root@mn04[ &#x2F;app&#x2F;prometheus]#cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;prometheus.service [Unit]Description&#x3D;Prometheus ServerAfter&#x3D;network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;app&#x2F;prometheus&#x2F;prometheus --config.file&#x3D;&#x2F;app&#x2F;prometheus&#x2F;prometheus.ymlKillMode&#x3D;process[Install]WantedBy&#x3D;multi-user.target# 启动服务[root@mn04[ &#x2F;app&#x2F;prometheus]#systemctl enable --now prometheus.service Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;prometheus.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;prometheus.service.</code></pre></div></figure><p>5、查看进程信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#ps -ef | grep promeroot       5115   2247  0 09:49 pts&#x2F;0    00:00:00 .&#x2F;prometheusroot       5168   5125  0 09:50 pts&#x2F;1    00:00:00 grep --color&#x3D;auto prome[root@mn04[ &#x2F;app&#x2F;prometheus]#ss -lntup | grep prometcp    LISTEN     0      128    [::]:9090               [::]:*                   users:((&quot;prometheus&quot;,pid&#x3D;5115,fd&#x3D;7))</code></pre></div></figure><p>测试访问<a href="http://10.0.0.64:9090，访问成功">http://10.0.0.64:9090，访问成功</a></p><p><img src="/../../../img/image-20240703095200643.png" alt="image-20240703095200643"></p><h1 id="三、Promethues的监控架构"><a href="#三、Promethues的监控架构" class="headerlink" title="三、Promethues的监控架构"></a>三、Promethues的监控架构</h1><p>Prometheus不像zbbix什么都集成在一起，它是拆分式的。</p><p>1、启动pro服务端</p><ul><li>收集器：收集客户端回传的数据</li><li>TSDB：内置时序数据库，存放收集的数据，（时间 —- 数据）</li><li>HTTP Server：提供Web服务</li></ul><p>2、在被管控机上部署各种exporter（客户端，类似于zbx的agent）</p><ul><li>exporter负责收集数据、传给服务端</li><li>exporter可以在github获取（如：prometheus&#x2F;mysqld_exporter）</li><li>在自定义监控方面，exporter不如zbx的自定义方便，需要动代码，不过一般github提供的很够用，监控指标非常多</li></ul><p>3、前端展示数据（通过PQL查询语句获取）</p><ul><li>Prometheus自带的UI（简单看看）</li><li>Grafana展示</li><li>API接口外传，二次开发</li></ul><p>4、配置告警平台</p><ul><li>pro自身不具备告警的功能，需要安装插件来实现</li></ul><p><img src="/../../../img/image-20240703101249540.png" alt="image-20240703101249540"></p><h1 id="四、简单使用"><a href="#四、简单使用" class="headerlink" title="四、简单使用"></a>四、简单使用</h1><h2 id="4-1-简单过滤"><a href="#4-1-简单过滤" class="headerlink" title="4.1 简单过滤"></a>4.1 简单过滤</h2><p>1、勾上use local time，过滤器选择过滤项，点击执行</p><p><img src="/../../../img/image-20240703102627476.png" alt="image-20240703102627476"></p><p>查看结果（文字）</p><p><img src="/../../../img/image-20240703102725768.png" alt="image-20240703102725768"></p><p>查看结果（图形）</p><p><img src="/../../../img/image-20240703102741598.png" alt="image-20240703102741598"></p><h2 id="4-2-查看所有键值"><a href="#4-2-查看所有键值" class="headerlink" title="4.2 查看所有键值"></a>4.2 查看所有键值</h2><p>浏览器访问：<a href="http://10.0.0.64:9090/metrics">http://10.0.0.64:9090/metrics</a></p><p><img src="/../../../img/image-20240703102850916.png" alt="image-20240703102850916"></p><p>命令行访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -s http:&#x2F;&#x2F;10.0.0.64:9090&#x2F;metrics | grep -v &#39;#&#39;</code></pre></div></figure><h1 id="五、Prometheus命令和配置文件"><a href="#五、Prometheus命令和配置文件" class="headerlink" title="五、Prometheus命令和配置文件"></a>五、Prometheus命令和配置文件</h1><h2 id="5-1-服务端命令行选项"><a href="#5-1-服务端命令行选项" class="headerlink" title="5.1 服务端命令行选项"></a>5.1 服务端命令行选项</h2><table><thead><tr><th>prometheus命令行核心选项</th><th></th></tr></thead><tbody><tr><td>–config.file&#x3D;”prometheus.yml”</td><td>指定配置文件，默认是当前目录下在的prometheus.yml</td></tr><tr><td>–web.listen address&#x3D;”0.0.0.0:9090”</td><td>前端web页面,端口和监听的地址。如果想增加访问认证可以用ngx。</td></tr><tr><td>–web.max-connections&#x3D;512</td><td>并发连接数.</td></tr><tr><td>–storage.tsdb.path&#x3D;”data&#x2F;“</td><td>指定tsdb数据存放目录,相对于安装目录.</td></tr><tr><td>–log.level&#x3D;info</td><td>日志级别,info(一般),debug(超级详细).prometheus日志默认输出到屏幕（标准输 出）</td></tr><tr><td>–log.format&#x3D;logfmt</td><td>日志格式。logfmt默认格式。 json格式（日志收集的时候使用）</td></tr></tbody></table><p>完整的启动命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;app&#x2F;prometheus&#x2F;prometheus --config.file&#x3D;&quot;&#x2F;app&#x2F;prometheus&#x2F;prometheus.yml&quot; --web.listen-address&#x3D;&quot;0.0.0.0:9090&quot; --web.max-connections&#x3D;512 &amp;&gt;&#x2F;var&#x2F;log&#x2F;prometheus.log &amp;</code></pre></div></figure><p>写入开机自启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;rc.local</code></pre></div></figure><p>写入service文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;prometheus.service [Unit]Description&#x3D;Prometheus ServerAfter&#x3D;network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;app&#x2F;prometheus&#x2F;prometheus --config.file&#x3D;&#x2F;app&#x2F;prometheus&#x2F;prometheus.yml --web.listen-address&#x3D;0.0.0.0:9090 --web.max-connections&#x3D;512KillMode&#x3D;process[Install]WantedBy&#x3D;multi-user.target</code></pre></div></figure><h2 id="5-2-配置文件详解"><a href="#5-2-配置文件详解" class="headerlink" title="5.2 配置文件详解"></a>5.2 配置文件详解</h2><p>配置文件<code>prometheus.yml</code></p><p>第一部分：全局定义部分</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># my global configglobal:  # prometheus采集数据的间隔  scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.   # 执行对应的rules(规则)间隔，一般适用于报警规则  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute. &#x2F;&#x2F;   # 采集数据的超时时间，默认是10秒.  # scrape_timeout is set to the global default (10s).</code></pre></div></figure><p>第二部分：警告信息部分</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Alertmanager configuration# 用于配置警告信息，alertmanager配置。alerting:  alertmanagers:    - static_configs:        - targets:          # - alertmanager:9093# Load rules once and periodically evaluate them according to the global &#39;evaluation_interval&#39;.rule_files:  # - &quot;first_rules.yml&quot;  # - &quot;second_rules.yml&quot;</code></pre></div></figure><p>第三部分：数据采集相关的配置（客户端）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># A scrape configuration containing exactly one endpoint to scrape:# Here it&#39;s Prometheus itself.scrape_configs:  # The job name is added as a label &#96;job&#x3D;&lt;job_name&gt;&#96; to any timeseries scraped from this config.  # 任务名字.体现采集哪些机器，哪些指标  - job_name: &quot;prometheus&quot;    # metrics_path defaults to &#39;&#x2F;metrics&#39;    # scheme defaults to &#39;http&#39;.# 静态配置文件，直接指定被采集的对象. 修改后要重启prometheus.    static_configs:      - targets: [&quot;localhost:9090&quot;]    # 动态配置文件，动态读取文件内容，然后进行采集,实时监控    file_sd_configs:</code></pre></div></figure><blockquote><p>从上面的分析可以看出pro服务端配置文件核心是：scrape_configs</p><p>用于配置各种的exporter  </p></blockquote><h3 id="5-2-1-修改配置文件"><a href="#5-2-1-修改配置文件" class="headerlink" title="5.2.1 修改配置文件"></a>5.2.1 修改配置文件</h3><p>配置服务端自我监控，设置名字</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#grep -v &quot;#&quot; prometheus.yml global:alerting:  alertmanagers:    - static_configs:        - targets:rule_files:scrape_configs:  - job_name: &quot;prometheus-server&quot;# 修改    static_configs:      - targets: [&quot;localhost:9090&quot;]</code></pre></div></figure><p>在web页面的”Target”中可以看到</p><p><img src="/../../../img/image-20240703112102644.png" alt="image-20240703112102644"></p><h1 id="六、prometheus的exporter"><a href="#六、prometheus的exporter" class="headerlink" title="六、prometheus的exporter"></a>六、prometheus的exporter</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>prometheus有众多的exporters，基本通过命令或docker运行。  </p><p>命名规则：</p><table><thead><tr><th>exporter</th><th>说明</th></tr></thead><tbody><tr><td>node_exporter</td><td>获取节点基础信息（系统监控）</td></tr><tr><td>xx服务_exporter</td><td>监控指定服务的。</td></tr></tbody></table><p>各种exporter的使用流程基本类似：</p><ul><li>在被控机下载、部署、启动exporter.</li><li>prometheus服务端配置、在配置中添加这主机+端口</li></ul><h2 id="6-2-客户端部署node-exporter"><a href="#6-2-客户端部署node-exporter" class="headerlink" title="6.2 客户端部署node_exporter"></a>6.2 客户端部署node_exporter</h2><p>0、环境准备</p><table><thead><tr><th>节点</th><th>部署的内容</th><th>ip地址</th></tr></thead><tbody><tr><td>mn04-prometheus</td><td>node_exporter</td><td>10.0.0.64&#x2F;172.16.1.64</td></tr><tr><td>mn03-grafana</td><td>node_exporter</td><td>10.0.0.63&#x2F;172.16.1.63</td></tr></tbody></table><p>1、github下载：<a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></p><p>2、开始部署</p><blockquote><p>mn03、04都要操作</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压[root@mn03 &#x2F;app&#x2F;tools]#tar -vxf node_exporter-1.8.1.linux-amd64.tar.gz# 目录软链接[root@mn03 &#x2F;app&#x2F;tools]#ln -s node_exporter-1.8.1.linux-amd64&#x2F; node_exporter# 命令软链接[root@mn03 &#x2F;app&#x2F;tools]#ln -s &#x2F;app&#x2F;tools&#x2F;node_exporter&#x2F;node_exporter &#x2F;bin&#x2F;node_exporter</code></pre></div></figure><p>3、测试使用，查看版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;app&#x2F;tools]#node_exporter --versionnode_exporter, version 1.8.1 (branch: HEAD, revision: 400c3979931613db930ea035f39ce7b377cdbb5b)  build user:       root@7afbff271a3f  build date:       20240521-18:36:22  go version:       go1.22.3  platform:         linux&#x2F;amd64  tags:             unknown</code></pre></div></figure><p>4、创建service服务文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建服务文件[root@mn03 &#x2F;app&#x2F;tools]#cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;node_exporter.service [Unit]Description&#x3D;prometheus node_exporterAfter&#x3D;network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;bin&#x2F;node_exporterKillMode&#x3D;process[Install]WantedBy&#x3D;multi-user.target</code></pre></div></figure><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;app&#x2F;tools]#systemctl daemon-reload [root@mn03 &#x2F;app&#x2F;tools]#systemctl enable --now node_exporter.service </code></pre></div></figure><p>查看状态</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;app&#x2F;tools]#systemctl status node_exporter.service ● node_exporter.service - prometheus node_exporter   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;node_exporter.service; enabled; vendor preset: disabled)   Active: active (running) since Wed 2024-07-03 11:48:51 CST; 5s ago</code></pre></div></figure><p>检查端口信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;app&#x2F;tools]#ps -ef | grep noderoot      15636      1  0 11:48 ?        00:00:00 &#x2F;bin&#x2F;node_exporterroot      15659   2322  0 11:50 pts&#x2F;0    00:00:00 grep --color&#x3D;auto node[root@mn03 &#x2F;app&#x2F;tools]#ss -lntup | grep nodetcp    LISTEN     0      128    [::]:9100               [::]:*                   users:((&quot;node_exporter&quot;,pid&#x3D;15636,fd&#x3D;3))</code></pre></div></figure><h2 id="6-3-服务端配置-静态配置版"><a href="#6-3-服务端配置-静态配置版" class="headerlink" title="6.3 服务端配置-静态配置版"></a>6.3 服务端配置-静态配置版</h2><p>配置yml文件，静态版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat prometheus.yml ...scrape_configs:  # The job name is added as a label &#96;job&#x3D;&lt;job_name&gt;&#96; to any timeseries scraped from this config.  - job_name: &quot;prometheus-server&quot;    # metrics_path defaults to &#39;&#x2F;metrics&#39;    # scheme defaults to &#39;http&#39;.    static_configs:      - targets: [&quot;localhost:9090&quot;]  # 新增  - job_name: &quot;basic_info_node_exporter&quot;    static_configs:      - targets: [&quot;10.0.0.63:9100&quot;]      - targets: [&quot;10.0.0.64:9100&quot;]</code></pre></div></figure><p>重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart prometheus.service</code></pre></div></figure><p>检查，确保web页面中可以查询到配置的主机</p><p><img src="/../../../img/image-20240703131538925.png" alt="image-20240703131538925">测试过滤条件可用</p><p><img src="/../../../img/image-20240703131849860.png" alt="image-20240703131849860"></p><h2 id="6-4-服务端配置-动态配置版"><a href="#6-4-服务端配置-动态配置版" class="headerlink" title="6.4 服务端配置-动态配置版"></a>6.4 服务端配置-动态配置版</h2><p>作用是什么？</p><ul><li>获取的exporter域名+端口，写入配置文件，可以定时读取并加入到prometheus中。</li><li>用于解决，大量主机添加、删除的操作</li></ul><p>在服务端yml文件中配置，动态版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat prometheus.yml ...  - job_name: &quot;prometheus-server&quot;    # metrics_path defaults to &#39;&#x2F;metrics&#39;    # scheme defaults to &#39;http&#39;.    static_configs:      - targets: [&quot;localhost:9090&quot;]  # 静态的不需要了  #- job_name: &quot;basic_info_node_exporter&quot;  #  static_configs:  #    - targets: [&quot;10.0.0.63:9100&quot;]  #    - targets: [&quot;10.0.0.64:9100&quot;]    # 新增动态  - job_name: &quot;basic_info_node_exporter_discovery&quot;    file_sd_configs:      - files:        - &#x2F;app&#x2F;prometheus&#x2F;discovery_node_exporter.json        refresh_interval: 5s</code></pre></div></figure><p>选项的作用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">file_sd_configs: 动态读取与加载配置文件。files: 指定要加载的配置文件.refresh_interval 读取间隔.</code></pre></div></figure><p>创建json文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat discovery_node_exporter.json [  &#123;    &quot;targets&quot;: [      &quot;10.0.0.63:9100&quot;,      &quot;10.0.0.64:9100&quot;    ]  &#125;]</code></pre></div></figure><p>重启服务并测试</p><p><img src="/../../../img/image-20240703132740154.png" alt="image-20240703132740154"></p><h1 id="七、Prometheus的过滤语句"><a href="#七、Prometheus的过滤语句" class="headerlink" title="七、Prometheus的过滤语句"></a>七、Prometheus的过滤语句</h1><h2 id="7-1-基本过滤"><a href="#7-1-基本过滤" class="headerlink" title="7.1 基本过滤"></a>7.1 基本过滤</h2><p>过滤方法：直接写上prometheus的键值，比如获取所有主机的可用内存</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_memory_MemFree_bytes</code></pre></div></figure><p><img src="/../../../img/image-20240703152540842.png" alt="image-20240703152540842"></p><p>值不方便看，可以加入<strong>运算符</strong>，改为<code>G</code>显示</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_memory_MemFree_bytes&#x2F;1024^3</code></pre></div></figure><p><img src="/../../../img/image-20240703152704288.png" alt="image-20240703152704288"></p><p>从Targets页面，点击对应主机可以查看到所有键值</p><p><img src="/../../../img/image-20240703152830610.png" alt="image-20240703152830610"></p><p><img src="/../../../img/image-20240703152902877.png" alt="image-20240703152902877"></p><h2 id="7-2-包含条件的过滤（重要）"><a href="#7-2-包含条件的过滤（重要）" class="headerlink" title="7.2 包含条件的过滤（重要）"></a>7.2 包含条件的过滤（重要）</h2><h3 id="7-2-1-过滤指定主机的数据"><a href="#7-2-1-过滤指定主机的数据" class="headerlink" title="7.2.1 过滤指定主机的数据"></a>7.2.1 过滤指定主机的数据</h3><p>应用场景：只需要指定主机的数据</p><p>比如查看剩余内存的信息，只需要mn04的数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_memory_MemFree_bytes&#123;instance&#x3D;&quot;10.0.0.64:9100&quot;&#125;</code></pre></div></figure><p><img src="/../../../img/image-20240703153110719.png" alt="image-20240703153110719"></p><h3 id="7-2-2-过滤指定主机CPU信息中的iowait"><a href="#7-2-2-过滤指定主机CPU信息中的iowait" class="headerlink" title="7.2.2 过滤指定主机CPU信息中的iowait"></a>7.2.2 过滤指定主机CPU信息中的iowait</h3><p>应用场景：你给的数据太多了，我只要其中一个字段</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_cpu_seconds_total&#123;instance&#x3D;&quot;10.0.0.63:9100&quot;,mode&#x3D;&quot;iowait&quot;&#125;</code></pre></div></figure><p>不指定的情况下，这样</p><p><img src="/../../../img/image-20240703153332017.png" alt="image-20240703153332017"></p><p>指定iowait的效果</p><p><img src="/../../../img/image-20240703153406249.png" alt="image-20240703153406249"></p><h3 id="7-2-3-过滤出所有主机非idle的指标"><a href="#7-2-3-过滤出所有主机非idle的指标" class="headerlink" title="7.2.3 过滤出所有主机非idle的指标"></a>7.2.3 过滤出所有主机非idle的指标</h3><p>应用场景：反向查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_cpu_seconds_total&#123;instance&#x3D;&quot;10.0.0.63:9100&quot;,mode!&#x3D;&quot;idle&quot;&#125;</code></pre></div></figure><p><img src="/../../../img/image-20240703153542725.png" alt="image-20240703153542725"></p><h3 id="7-2-4-使用正则匹配"><a href="#7-2-4-使用正则匹配" class="headerlink" title="7.2.4 使用正则匹配"></a>7.2.4 使用正则匹配</h3><p>查询语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_cpu_seconds_total&#123;mode&#x3D;~&quot;^i.*&quot;&#125;</code></pre></div></figure><p>不使用正则过滤</p><p><img src="/../../../img/image-20240703154026829.png" alt="image-20240703154026829"></p><p>使用后</p><p><img src="/../../../img/image-20240703154013462.png" alt="image-20240703154013462"></p><h3 id="7-2-5-取出最近1分钟系统CPU的信息"><a href="#7-2-5-取出最近1分钟系统CPU的信息" class="headerlink" title="7.2.5 取出最近1分钟系统CPU的信息"></a>7.2.5 取出最近1分钟系统CPU的信息</h3><p>关键字：<code>[1m]</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_cpu_seconds_total&#123;cpu&#x3D;&quot;0&quot;,instance&#x3D;&quot;10.0.0.64:9100&quot;,mode&#x3D;&quot;iowait&quot;&#125;[1m]</code></pre></div></figure><h3 id="7-2-6-条件过滤小结"><a href="#7-2-6-条件过滤小结" class="headerlink" title="7.2.6 条件过滤小结"></a>7.2.6 条件过滤小结</h3><p>PQL过滤，可以使用匹配符号，如<code>=、!=、=~、!~</code>  </p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于.</td></tr><tr><td>!&#x3D;</td><td>不等于.</td></tr><tr><td>&#x3D;~</td><td>支持正则，匹配，要完全匹配对应的内容 node_cpu_seconds_total{mode&#x3D;~”^i.*”}</td></tr><tr><td>!~</td><td>支持正则，不匹配</td></tr></tbody></table><h2 id="7-3-使用函数"><a href="#7-3-使用函数" class="headerlink" title="7.3 使用函数"></a>7.3 使用函数</h2><h3 id="7-3-1-rate函数"><a href="#7-3-1-rate函数" class="headerlink" title="7.3.1 rate函数"></a>7.3.1 rate函数</h3><p><strong>案例01</strong>-过去5分钟内promethues总共收到多少http请求（&#x2F;metrics）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">prometheus_http_requests_total&#123;handler&#x3D;&quot;&#x2F;metrics&quot;&#125;[5m]</code></pre></div></figure><p><img src="/../../../img/image-20240703155944981.png" alt="image-20240703155944981"></p><p>那请求每秒钟加了多少呢？此时可以用rate函数来获取</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rate(prometheus_http_requests_total&#123;handler&#x3D;&quot;&#x2F;metrics&quot;&#125;[5m])# 可以看到每秒约加了0.06</code></pre></div></figure><p><img src="/../../../img/image-20240703160031392.png" alt="image-20240703160031392"></p><p><strong>案例02</strong>-检查过去一分钟内的CPU速率</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rate(node_cpu_seconds_total&#123;instance&#x3D;&quot;10.0.0.64:9100&quot;&#125;[1m])</code></pre></div></figure><p>排除“idle”，查看cpu速率每秒加了多少</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rate(node_cpu_seconds_total&#123;instance&#x3D;&quot;10.0.0.64:9100&quot;,mode!&#x3D;&quot;idle&quot;&#125;[1m])</code></pre></div></figure><p><img src="/../../../img/image-20240703155304052.png" alt="image-20240703155304052"></p><h3 id="7-3-2-sum函数求和"><a href="#7-3-2-sum函数求和" class="headerlink" title="7.3.2 sum函数求和"></a>7.3.2 sum函数求和</h3><p>比如：查询总内存的语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node_memory_MemTotal_bytes# 结果node_memory_MemTotal_bytes&#123;instance&#x3D;&quot;10.0.0.64:9100&quot;, job&#x3D;&quot;basic_info_node_exporter_discovery&quot;&#125; 2076536832node_memory_MemTotal_bytes&#123;instance&#x3D;&quot;10.0.0.63:9100&quot;, job&#x3D;&quot;basic_info_node_exporter_discovery&quot;&#125; 2076536832</code></pre></div></figure><p>使用求和函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sum(node_memory_MemTotal_bytes)# 结果&#123;&#125; 4153073664</code></pre></div></figure><h3 id="7-3-3-count函数求数量"><a href="#7-3-3-count函数求数量" class="headerlink" title="7.3.3 count函数求数量"></a>7.3.3 count函数求数量</h3><p>7.3.2的语句改为count函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">count(node_memory_MemTotal_bytes)# 结果&#123;&#125; 2</code></pre></div></figure><blockquote><p>还有一堆函数，可以在官网查询</p><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/">https://prometheus.io/docs/prometheus/latest/querying/functions/</a></p></blockquote><h2 id="7-4-复杂语句（重要）"><a href="#7-4-复杂语句（重要）" class="headerlink" title="7.4 复杂语句（重要）"></a>7.4 复杂语句（重要）</h2><p>所谓复杂函数，就是把不同语句混合计算，求得结果。</p><p>比如：计算内存使用率</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># （总内存-剩余内存）&#x2F;总内存(node_memory_MemTotal_bytes - node_memory_MemFree_bytes) &#x2F; node_memory_MemTotal_bytes * 100# 结果&#123;instance&#x3D;&quot;10.0.0.64:9100&quot;, job&#x3D;&quot;basic_info_node_exporter_discovery&quot;&#125;58.20359116076589&#123;instance&#x3D;&quot;10.0.0.63:9100&quot;, job&#x3D;&quot;basic_info_node_exporter_discovery&quot;&#125;75.3697972451856</code></pre></div></figure><h1 id="八、Grafana展示数据"><a href="#八、Grafana展示数据" class="headerlink" title="八、Grafana展示数据"></a>八、Grafana展示数据</h1><p>prometheus webui一般用于调试PromQL语句（查询语句）</p><p>展示交给Grafana</p><p>本质：Grafana执行PromQL语句（查询语句）获取数据，然后进行展示  </p><h2 id="8-1-使用流程"><a href="#8-1-使用流程" class="headerlink" title="8.1 使用流程"></a>8.1 使用流程</h2><h3 id="8-1-1-添加数据源"><a href="#8-1-1-添加数据源" class="headerlink" title="8.1.1 添加数据源"></a>8.1.1 添加数据源</h3><p>进入数据源设置界面，点击添加数据源</p><p><img src="/../../../img/image-20240705152430350.png" alt="image-20240705152430350"></p><p>选择prometheus</p><p><img src="/../../../img/image-20240705152453983.png" alt="image-20240705152453983"></p><p>填写信息，保存退出即可</p><p><img src="/../../../img/image-20240705152600954.png" alt="image-20240705152600954"></p><p>回到数据源总览界面，点击配置好的prometheus源进去</p><p><img src="/../../../img/image-20240705152918836.png" alt="image-20240705152918836"></p><p>导入自带的三个仪表盘</p><p><img src="/../../../img/image-20240705152837059.png" alt="image-20240705152837059"></p><h3 id="8-1-2-修改仪表盘"><a href="#8-1-2-修改仪表盘" class="headerlink" title="8.1.2 修改仪表盘"></a>8.1.2 修改仪表盘</h3><p>进到仪表盘页面，进入”Prometheus Stats”仪表盘</p><p><img src="/../../../img/image-20240705153307223.png" alt="image-20240705153307223"></p><p>可以看到默认的数据不全，很多都是缺失的</p><p><img src="/../../../img/image-20240705153343280.png" alt="image-20240705153343280"></p><p>以Uptime面板为例，点进去查看它的查询语句</p><p><img src="/../../../img/image-20240705153809561.png" alt="image-20240705153809561"></p><p>发现是有问题的</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># job名不对(time() - process_start_time_seconds&#123;job&#x3D;&quot;prometheus&quot;, instance&#x3D;~&quot;$node&quot;&#125;)# 修改为(time() - process_start_time_seconds&#123;job&#x3D;&quot;prometheus-server&quot;, instance&#x3D;~&quot;$node&quot;&#125;)</code></pre></div></figure><p>修改后正常获取数据</p><p><img src="/../../../img/image-20240705153857179.png" alt="image-20240705153857179"></p><blockquote><p>这个自带的仪表盘，功能不是很完善，有的面板查询语句是正常的，但是根本查不出数据，更别说在Grafana显示了</p></blockquote><h3 id="8-1-3-导入第三方仪表盘"><a href="#8-1-3-导入第三方仪表盘" class="headerlink" title="8.1.3 导入第三方仪表盘"></a>8.1.3 导入第三方仪表盘</h3><p>为了解决自带仪表盘功能不完善的问题，从grafana官网下载第三方仪表盘</p><p><a href="https://grafana.com/grafana/dashboards/1860-node-exporter-full/">https://grafana.com/grafana/dashboards/1860-node-exporter-full/</a></p><p>同样下载JSON文件</p><p><img src="/../../../img/image-20240705154656705.png" alt="image-20240705154656705"></p><p>再导入进去即可</p><p><img src="/../../../img/image-20240705154805105.png" alt="image-20240705154805105"></p><p>效果如下，丰富很多</p><p><img src="/../../../img/image-20240705154817801.png" alt="image-20240705154817801"></p><h1 id="九、Push-Gateway"><a href="#九、Push-Gateway" class="headerlink" title="九、Push Gateway"></a>九、Push Gateway</h1><p>Pushgateway是一种<strong>中介服务</strong>，可以将无法被Prometheus直接拉取的指标推送给它，然后再向</p><p>Prometheus公开，常用于自定义监控项，以及分布式监控（如 zabbix proxy）</p><h2 id="9-1-使用流程"><a href="#9-1-使用流程" class="headerlink" title="9.1 使用流程"></a>9.1 使用流程</h2><ul><li>部署、启动pushgateway</li><li>服务端ip&#x2F;域名+端口</li><li>写入配置（动态、静态）。</li><li>书写脚本获取你要的信息，把信息发送到pushgateway中。</li></ul><h3 id="9-1-1-安装部署"><a href="#9-1-1-安装部署" class="headerlink" title="9.1.1 安装部署"></a>9.1.1 安装部署</h3><blockquote><p>在grafana节点（mn03）部署push gateway</p></blockquote><p>1、获取安装包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;pushgateway&#x2F;releases&#x2F;tag&#x2F;v1.9.0</code></pre></div></figure><p>2、解压、创建软连接</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -vxf pushgateway-1.9.0.linux-amd64.tar.gz ln -s pushgateway-1.9.0.linux-amd64 pushgateway[root@mn03 &#x2F;app&#x2F;tools]#lsnode_exporter  node_exporter-1.8.1.linux-amd64  pushgateway  pushgateway-1.9.0.linux-amd64  pushgateway-1.9.0.linux-amd64.tar.gz  sersync</code></pre></div></figure><p>3、测试使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;app&#x2F;tools&#x2F;pushgateway]#.&#x2F;pushgateway --versionpushgateway, version 1.9.0 (branch: HEAD, revision: d1ca1a6a426126a09a21f745e8ffbaba550f9643)  build user:       root@2167597b1e9c  build date:       20240608-15:04:08  go version:       go1.22.4  platform:         linux&#x2F;amd64  tags:             unknown</code></pre></div></figure><p>4、启动服务</p><p>手动方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pushgateway &amp;ՎҴ&#x2F;tmp&#x2F;pushgw.log &amp;</code></pre></div></figure><p>systemctl管理方式（推荐）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建service文件[root@mn03 &#x2F;]#cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;pushgateway-server.service [Unit]Description&#x3D;Push Gateway ServerAfter&#x3D;network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;app&#x2F;tools&#x2F;pushgateway&#x2F;pushgateway KillMode&#x3D;process[Install]WantedBy&#x3D;multi-user.target# 重新加载并启动服务[root@mn03 &#x2F;]#systemctl daemon-reload [root@mn03 &#x2F;]#systemctl enable --now pushgateway-server.service Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;pushgateway-server.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;pushgateway-server.service.</code></pre></div></figure><p>4、查看状态，其端口是9091</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;]#systemctl status pushgateway-server.service ● pushgateway-server.service - Push Gateway Server   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;pushgateway-server.service; enabled; vendor preset: disabled)   Active: active (running) since Fri 2024-07-05 16:10:34 CST; 26s ago...[root@mn03 &#x2F;]#ps -ef | grep pushroot      33538      1  0 16:10 ?        00:00:00 &#x2F;app&#x2F;tools&#x2F;pushgateway&#x2F;pushgatewayroot      33555   2322  0 16:11 pts&#x2F;0    00:00:00 grep --color&#x3D;auto push[root@mn03 &#x2F;]#ss -lntup | grep pushtcp    LISTEN     0      128    [::]:9091               [::]:*                   users:((&quot;pushgateway&quot;,pid&#x3D;33538,fd&#x3D;3))</code></pre></div></figure><h3 id="9-1-2-Prometheus配置"><a href="#9-1-2-Prometheus配置" class="headerlink" title="9.1.2 Prometheus配置"></a>9.1.2 Prometheus配置</h3><p>修改Prometheus的配置文件（静态），把push gateway添加进去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#cat prometheus.yml ...  # The job name is added as a label &#96;job&#x3D;&lt;job_name&gt;&#96; to any timeseries scraped from this config.  - job_name: &quot;prometheus-server&quot;    # metrics_path defaults to &#39;&#x2F;metrics&#39;    # scheme defaults to &#39;http&#39;.    static_configs:      - targets: [&quot;localhost:9090&quot;]  # 静态的不需要了  #- job_name: &quot;basic_info_node_exporter&quot;  #  static_configs:  #    - targets: [&quot;10.0.0.63:9100&quot;]  #    - targets: [&quot;10.0.0.64:9100&quot;]    # 新增动态  - job_name: &quot;basic_info_node_exporter_discovery&quot;    file_sd_configs:      - files:        - &#x2F;app&#x2F;prometheus&#x2F;discovery_node_exporter.json        refresh_interval: 5s    # 新增pushgateway监控       - job_name: &quot;pushgateway&quot;    static_configs:      - targets: [&quot;10.0.0.63:9091&quot;]</code></pre></div></figure><p>重启prometheus服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn04[ &#x2F;app&#x2F;prometheus]#systemctl restart prometheus.service </code></pre></div></figure><p>查看是否添加成功</p><p><img src="/../../../img/image-20240705161616911.png" alt="image-20240705161616911"></p><h3 id="9-1-3-使用push-gateway"><a href="#9-1-3-使用push-gateway" class="headerlink" title="9.1.3 使用push gateway"></a>9.1.3 使用push gateway</h3><p>测试自定义监控，以获取CPU核心数的命令为例</p><p>shell命令如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;app&#x2F;tools&#x2F;pushgateway]#lscpu |awk &#39;&#x2F;^CPU\(s\):&#x2F;&#123;print $2&#125;&#39;1</code></pre></div></figure><p>写成脚本，上传数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;server&#x2F;scripts]#cat test-push.sh #!&#x2F;bin&#x2F;bash############################################################### File Name:test-push.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:###############################################################1. vars job&#x3D;&quot;pushgateway&quot;ins&#x3D;&quot;10.0.0.63:9091&quot;pushgw&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.63:9091&quot;cores&#x3D;&#96;lscpu |awk &#39;&#x2F;^CPU\(s\):&#x2F;&#123;print $2&#125;&#39;&#96;#2、推送到pushgatewayecho &quot;cpu_cores $cores&quot; | \curl --data-binary @- $&#123;pushgw&#125;&#x2F;metrics&#x2F;job&#x2F;$&#123;job&#125;&#x2F;instance&#x2F;$&#123;ins&#125;</code></pre></div></figure><p>执行脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;server&#x2F;scripts]#sh -x test-push.sh + job&#x3D;pushgateway+ ins&#x3D;10.0.0.63:9091+ pushgw&#x3D;http:&#x2F;&#x2F;10.0.0.63:9091++ lscpu++ awk &#39;&#x2F;^CPU\(s\):&#x2F;&#123;print $2&#125;&#39;+ cores&#x3D;1+ curl --data-binary @- http:&#x2F;&#x2F;10.0.0.63:9091&#x2F;metrics&#x2F;job&#x2F;pushgateway&#x2F;instance&#x2F;10.0.0.63:9091</code></pre></div></figure><p>执行完，可以去prometheus页面去看看是否添加成功了</p><p><img src="/../../../img/image-20240705162752423.png" alt="image-20240705162752423"></p><p>已经可以看到</p><p><img src="/../../../img/image-20240705162808111.png" alt="image-20240705162808111"></p><p>测试查询语句正常</p><p><img src="/../../../img/image-20240705162734852.png" alt="image-20240705162734852"></p><h2 id="9-2-小结"><a href="#9-2-小结" class="headerlink" title="9.2 小结"></a>9.2 小结</h2><p>push gateway算是对prometheus功能的补充，类似于zbx的自定义监控</p><ul><li>当前学习的只是一个很小的案例，功能很少，</li><li>后续可以根据实际需求，把脚本交给定时任务、或者死循环每5秒执行一次，不断地向push gateway服务器推送数据，确保数据实时有效</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day71-监控架构-Grafana(一)</title>
    <link href="/2024/06/26/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day71-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Grafana-1/"/>
    <url>/2024/06/26/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day71-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Grafana-1/</url>
    
    <content type="html"><![CDATA[<h1 id="监控架构-Grafana-01"><a href="#监控架构-Grafana-01" class="headerlink" title="监控架构-Grafana-01"></a>监控架构-Grafana-01</h1><p>今日内容：</p><ul><li>Grafana概述</li><li>安装Grafana</li><li>如何配置Grafana</li><li>Grafana的第三方模板使用</li></ul><h1 id="一、Grafana极速上手"><a href="#一、Grafana极速上手" class="headerlink" title="一、Grafana极速上手"></a>一、Grafana极速上手</h1><p>Grafana一般用于<strong>大屏展示</strong>，它本身不具备获取监控数据的功能，需要从结合别的工具获取</p><blockquote><p>如：Grafana —&gt; 调用zabbix监控数据 —-&gt; 大屏展示</p></blockquote><h2 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h2><table><thead><tr><th>主机</th><th>作用</th><th>IP</th></tr></thead><tbody><tr><td>mn02</td><td>zabbix服务器</td><td>10.0.0.62</td></tr><tr><td>mn03</td><td>grafana服务器</td><td>10.0.0.63</td></tr><tr><td>nfs01</td><td>zbx客户端</td><td>10.0.0.31</td></tr></tbody></table><h2 id="1-2-安装grafana"><a href="#1-2-安装grafana" class="headerlink" title="1.2 安装grafana"></a>1.2 安装grafana</h2><blockquote><p>在mn03操作</p></blockquote><p>上传安装包并安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装包grafana-9.3.6-1.x86_64.rpm# grafana安装包grafana-9.3.6-alexanderzobnin-zabbix-app-v4.1.10.tar.gz# grafana连zbx的插件# 安装yum install -y .&#x2F;grafana-9.3.6-1.x86_64.rpm</code></pre></div></figure><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable --now grafana-server</code></pre></div></figure><p>查看端口信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 &#x2F;app&#x2F;rpms]#ss -lntup | grep grafanatcp    LISTEN     0      128    [::]:3000               [::]:*                   users:((&quot;grafana-server&quot;,pid&#x3D;3875,fd&#x3D;11))</code></pre></div></figure><p>安装连接zabbix的插件（默认不支持连接zbx）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建插件目录mkdir &#x2F;var&#x2F;lib&#x2F;grafana&#x2F;plugins# 解压插件包tar -vxf grafana-9.3.6-alexanderzobnin-zabbix-app-v4.1.10.tar.gz# 把解压的文件夹放到目录中mv alexanderzobnin-zabbix-app&#x2F; &#x2F;var&#x2F;lib&#x2F;grafana&#x2F;plugins&#x2F;# 查看是否安装成功[root@mn03 &#x2F;app&#x2F;rpms]#grafana-cli plugins lsinstalled plugins:alexanderzobnin-zabbix-app @ 4.1.10Please restart Grafana after installing plugins. Refer to Grafana documentation for instructions if necessary.</code></pre></div></figure><p>测试访问</p><p><a href="http://10.0.0.63:3000/">http://10.0.0.63:3000</a></p><p><img src="/../../../img/image-20240701162145790.png" alt="image-20240701162145790"></p><blockquote><p>默认账号密码admin&#x2F;admin</p></blockquote><p>两个基础设置，界面改为白色，设置中文</p><p><img src="/../../../img/image-20240701162454996.png" alt="image-20240701162454996"></p><h2 id="1-3-grafana连接zabbix"><a href="#1-3-grafana连接zabbix" class="headerlink" title="1.3 grafana连接zabbix"></a>1.3 grafana连接zabbix</h2><h3 id="1-3-1-激活zabbix插件"><a href="#1-3-1-激活zabbix插件" class="headerlink" title="1.3.1 激活zabbix插件"></a>1.3.1 激活zabbix插件</h3><p>plugin页面找到zabbix插件，点击进入</p><p><img src="/../../../img/image-20240701162941703.png" alt="image-20240701162941703"></p><p>激活插件(Enable)</p><p><img src="/../../../img/image-20240701163242850.png" alt="image-20240701163242850"></p><blockquote><p>这里有个坑，在1.2安装完插件后，一定要重启grafana的服务，不然在页面找到插件，会显示没安装，如图：</p><p><img src="/../../../img/image-20240701162958521.png" alt="image-20240701162958522"></p></blockquote><h3 id="1-3-2-添加数据源"><a href="#1-3-2-添加数据源" class="headerlink" title="1.3.2 添加数据源"></a>1.3.2 添加数据源</h3><p>在grafana网站页面，添加数据源(data source)</p><p><img src="/../../../img/image-20240701162749666.png" alt="image-20240701162749666"></p><p>找到zabbix</p><p><img src="/../../../img/image-20240701163340945.png" alt="image-20240701163340945"></p><p>配置信息</p><p><img src="/../../../img/image-20240701164214078.png" alt="image-20240701164214078"></p><p>保存并测试，显示zabbix api版本即为正常</p><p><img src="/../../../img/image-20240701164225180.png" alt="image-20240701164225180"></p><p>导入自带的几个仪表盘(dashboard)</p><p><img src="/../../../img/image-20240701164334383.png" alt="image-20240701164334383"></p><h2 id="1-4-dashboard展示数据"><a href="#1-4-dashboard展示数据" class="headerlink" title="1.4 dashboard展示数据"></a>1.4 dashboard展示数据</h2><h3 id="1-4-1-案例01-展示主机名"><a href="#1-4-1-案例01-展示主机名" class="headerlink" title="1.4.1 案例01-展示主机名"></a>1.4.1 案例01-展示主机名</h3><p>仪表盘导入后，进入仪表盘设置页面</p><p><img src="/../../../img/image-20240702103404951.png" alt="image-20240702103404951"></p><p>进入”Zabbix Server Dashboard”</p><p><img src="/../../../img/image-20240702103544261.png" alt="image-20240702103544261"></p><p>进入Hostname面板的编辑界面</p><p><img src="/../../../img/image-20240702103715016.png" alt="image-20240702103715016"></p><p>修改显示主机名</p><p><img src="/../../../img/image-20240702110313887.png" alt="image-20240702110313887"></p><blockquote><p>其中数据项标志与ZBX的对应情况</p><p>1、进入主机监控项设置页</p><p><img src="/../../../img/image-20240702110453009.png" alt="image-20240702110453009"></p><p>点击标记可以看到</p><p><img src="/../../../img/image-20240702110509474.png" alt="image-20240702110509474"></p></blockquote><h3 id="1-4-2-案例02-显示uptime"><a href="#1-4-2-案例02-显示uptime" class="headerlink" title="1.4.2 案例02-显示uptime"></a>1.4.2 案例02-显示uptime</h3><p><img src="/../../../img/image-20240702112713097.png" alt="image-20240702112713097"></p><p>效果</p><p><img src="/../../../img/image-20240702112731524.png" alt="image-20240702112731524"></p><h3 id="1-4-3-案例03-显示CPU使用率"><a href="#1-4-3-案例03-显示CPU使用率" class="headerlink" title="1.4.3 案例03-显示CPU使用率"></a>1.4.3 案例03-显示CPU使用率</h3><blockquote><p>grafana过滤条件支持正则表达式</p></blockquote><p>在CPU面板处按E进入编辑界面，设置Item保存即可</p><p><img src="/../../../img/image-20240702112847111.png" alt="image-20240702112847111"></p><p>首页效果</p><p><img src="/../../../img/image-20240702113358353.png" alt="image-20240702113358353"></p><h3 id="1-4-4-自定义监控获取zbx服务端的每秒新值"><a href="#1-4-4-自定义监控获取zbx服务端的每秒新值" class="headerlink" title="1.4.4 自定义监控获取zbx服务端的每秒新值"></a>1.4.4 自定义监控获取zbx服务端的每秒新值</h3><p>就是展示这句命令获取的值，取其中的<code>requiredperformance</code>项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zabbix_get -s 127.0.0.1 -k zabbix.stats</code></pre></div></figure><p><img src="/../../../img/image-20240702113659068.png" alt="image-20240702113659068"></p><p>怎么实现？</p><ul><li>需要通过自定义监控创建1个监控项获取zabbix.stats键值（a步骤）</li><li>创建相关项(监控项)对上面监控项结果进行过滤(sed反向引用). （步骤）</li></ul><h4 id="a）创建zbx监控项"><a href="#a）创建zbx监控项" class="headerlink" title="a）创建zbx监控项"></a>a）创建zbx监控项</h4><p>新建监控项，获取所有值</p><p><img src="/../../../img/image-20240702114508614.png" alt="image-20240702114508614"></p><h4 id="b）创建相关监控项，进行过滤"><a href="#b）创建相关监控项，进行过滤" class="headerlink" title="b）创建相关监控项，进行过滤"></a>b）创建相关监控项，进行过滤</h4><p>新建监控项</p><p><img src="/../../../img/image-20240702114758977.png" alt="image-20240702114758977"></p><p>设置“预处理”条件</p><p><img src="/../../../img/image-20240702115626095.png" alt="image-20240702115626095"></p><blockquote><p>正则部分: “requiredperformance”:([0-9.]+)<br>我们想要的内容是: \1  </p></blockquote><p>查看最新数据，能获取到就是成功的</p><p><img src="/../../../img/image-20240702115724444.png" alt="image-20240702115724444"></p><h4 id="c）grafana界面显示"><a href="#c）grafana界面显示" class="headerlink" title="c）grafana界面显示"></a>c）grafana界面显示</h4><p>修改图示面板</p><p><img src="/../../../img/image-20240702115838418.png" alt="image-20240702115838418"></p><p>填写对应监控项</p><p><img src="/../../../img/image-20240702115925378.png" alt="image-20240702115925378"></p><p>完成</p><p><img src="/../../../img/image-20240702115936841.png" alt="image-20240702115936842"></p><h4 id="d）监控其他指标"><a href="#d）监控其他指标" class="headerlink" title="d）监控其他指标"></a>d）监控其他指标</h4><p>未来只需要根据对应的stats值来修改正则，即可以实现</p><p>比如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 案例01&quot;poller&quot;:&#123;&quot;busy&quot;:&#123;&quot;avg&quot;:0.992678&#x2F;&#x2F; 改写正则表达式&quot;poller&quot;:\&#123;&quot;busy&quot;:\&#123;&quot;avg&quot;:([0-9.]+) &#x2F;&#x2F; 我们想要的内容是\1&#x2F;&#x2F; 案例02&quot;history poller&quot;:&#123;&quot;busy&quot;:&#123;&quot;avg&quot;:0.003381&#x2F;&#x2F; 改写正则history poller&quot;:\&#123;&quot;busy&quot;:\&#123;&quot;avg&quot;:([0-9.]+) &#x2F;&#x2F; 我们想要的内容是\1</code></pre></div></figure><h3 id="1-4-5-案例04-展示主机问题列表"><a href="#1-4-5-案例04-展示主机问题列表" class="headerlink" title="1.4.5 案例04-展示主机问题列表"></a>1.4.5 案例04-展示主机问题列表</h3><p>编辑”Zabbix System Status”模板，默认显示错误数，不够直观</p><p><img src="/../../../img/image-20240702120750496.png" alt="image-20240702120750496"></p><p>可以改成显示具体problems</p><p><img src="/../../../img/image-20240702120840104.png" alt="image-20240702120840104"></p><h3 id="1-4-6-展示主机负载信息"><a href="#1-4-6-展示主机负载信息" class="headerlink" title="1.4.6 展示主机负载信息"></a>1.4.6 展示主机负载信息</h3><p>编辑“Zabbix Template Linux Sever”模板</p><p>system load界面修改</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;Linux: Load average (.*m avg)&#x2F;# 普通是Linux: Load average (1m avg)# .*代表所有，像图中的三条线1m、5m、15m</code></pre></div></figure><p><img src="/../../../img/image-20240702121312863.png" alt="image-20240702121312863"></p><p>system cpu界面修改</p><p><img src="/../../../img/image-20240702121510813.png" alt="image-20240702121510813"></p><p>首页展示，可以切换主机，并显示网络情况</p><p><img src="/../../../img/image-20240702121621563.png" alt="image-20240702121621563"></p><h2 id="1-5-更完善的模板"><a href="#1-5-更完善的模板" class="headerlink" title="1.5 更完善的模板"></a>1.5 更完善的模板</h2><p>可以从官网下载界面模板来配置，效果更佳炫酷</p><p>比如：<a href="https://grafana.com/grafana/dashboards/5363-zabbix-full-server-status/">https://grafana.com/grafana/dashboards/5363-zabbix-full-server-status/</a></p><p><img src="/../../../img/image-20240702152415195.png" alt="image-20240702152415195"></p><h3 id="1-5-1-导入官网模板"><a href="#1-5-1-导入官网模板" class="headerlink" title="1.5.1 导入官网模板"></a>1.5.1 导入官网模板</h3><p>如何使用呢？可以使用ID或者导入JSON文件，这里采用下载JSON文件的方式</p><p>主界面—仪表盘—点击”import”</p><p><img src="/../../../img/image-20240702152658753.png" alt="image-20240702152658753"></p><p>上传下载的JSON文件</p><p><img src="/../../../img/image-20240702152731629.png" alt="image-20240702152731629"></p><p>选择zabbix数据源，点击”import”即可</p><p><img src="/../../../img/image-20240702152811981.png" alt="image-20240702152811982"></p><p>效果如下：</p><p><img src="/../../../img/image-20240702152824891.png" alt="image-20240702152824891"></p><h3 id="1-5-2-改为可编辑状态"><a href="#1-5-2-改为可编辑状态" class="headerlink" title="1.5.2 改为可编辑状态"></a>1.5.2 改为可编辑状态</h3><p>导入的模板，默认不可以编辑，需要进行设置，进入设置界面</p><p><img src="/../../../img/image-20240702153051798.png" alt="image-20240702153051798"></p><p>设置为可编辑</p><p><img src="/../../../img/image-20240702153111597.png" alt="image-20240702153111597"></p><h3 id="1-5-3-展示信息"><a href="#1-5-3-展示信息" class="headerlink" title="1.5.3 展示信息"></a>1.5.3 展示信息</h3><p>编辑界面的”Total memeory”</p><p><img src="/../../../img/image-20240702153518717.png" alt="image-20240702153518717"></p><p>编辑”online &#x2F; offline”显示</p><p><img src="/../../../img/image-20240702153728308.png" alt="image-20240702153728308"></p><p>看看效果</p><p><img src="/../../../img/image-20240702153747163.png" alt="image-20240702153747163"></p><h3 id="1-5-4-仪表盘变量的设置与修改"><a href="#1-5-4-仪表盘变量的设置与修改" class="headerlink" title="1.5.4 仪表盘变量的设置与修改"></a>1.5.4 仪表盘变量的设置与修改</h3><p>进入仪表盘设置界面</p><p><img src="/../../../img/image-20240702154812891.png" alt="image-20240702154812891"></p><p>如果有特殊自建的主机组，可以在这修改</p><p><img src="/../../../img/image-20240702154849156.png" alt="image-20240702154849156"></p><p>进去编辑即可</p><p><img src="/../../../img/image-20240702154904362.png" alt="image-20240702154904362"></p><h2 id="1-6-Grafana总结"><a href="#1-6-Grafana总结" class="headerlink" title="1.6 Grafana总结"></a>1.6 Grafana总结</h2><p>本章是对Grafana的基本介绍和功能演示，主要掌握</p><ul><li>收集来自于各种数据源的数据，通过Grafana进行展示。</li><li>自定义仪表盘与使用变量(主机组和主机)。</li><li>熟练使用创建，修改仪表盘即可。</li><li>Zabbix的相关项监控</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day70-监控架构-Zabbix(四)</title>
    <link href="/2024/06/25/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day70-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-4/"/>
    <url>/2024/06/25/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day70-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-4/</url>
    
    <content type="html"><![CDATA[<h1 id="监控架构-Zabbix-04"><a href="#监控架构-Zabbix-04" class="headerlink" title="监控架构-Zabbix-04"></a>监控架构-Zabbix-04</h1><p>今日内容：</p><ul><li>分布式监控上手</li><li>低级自动发现</li><li>ZabbixAPI了解</li><li>Zabbix性能优化方案</li><li>Zabbix高可用配置方法</li><li>Zabbix升级方法</li></ul><h1 id="一、分布式监控"><a href="#一、分布式监控" class="headerlink" title="一、分布式监控"></a>一、分布式监控</h1><h2 id="1-1-分布式监控概述及应用场景"><a href="#1-1-分布式监控概述及应用场景" class="headerlink" title="1.1 分布式监控概述及应用场景"></a>1.1 分布式监控概述及应用场景</h2><p>解决问题：需要监控多个地区&#x2F;多个机房的服务器，但服务器之间内网不通</p><p>面对这种问题有两种方法处理：</p><ul><li>方案一：客户端直接写服务端公网IP<ul><li>优点：配置方便</li><li>缺点：网络带宽、稳定性等问题，可能造成误报</li></ul></li><li>方案二：使用分布式监控</li></ul><p>分布式监控的实现原理，是在中间提供一台代理服务器（如图中上海地区的proxy服务器，值得注意的是，这台代理服务器<strong>也需要数据库</strong>配套服务）</p><p><img src="/../../../img/image-20240625160828054.png" alt="image-20240625160828054"></p><h2 id="1-2-分布式监控实战"><a href="#1-2-分布式监控实战" class="headerlink" title="1.2 分布式监控实战"></a>1.2 分布式监控实战</h2><p>目标：</p><ul><li>应对公司网站服务器较多的场景</li><li>公司网站服务器分散在不同的机房或区域</li></ul><p>整体架构如下：</p><p>（本文档中的测试sever是172.16.1.62，非图中的63）</p><p><img src="/../../../img/image-20240625161248441.png" alt="image-20240625161248441"></p><h3 id="1-2-1-配置代理服务器"><a href="#1-2-1-配置代理服务器" class="headerlink" title="1.2.1 配置代理服务器"></a>1.2.1 配置代理服务器</h3><p>用web01做代理，安装相关软件并配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、安装代理软件yum install -y https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;zabbix&#x2F;zabbix&#x2F;6.0&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-proxy-mysql-6.0.5-1.el7.x86_64.rpm# 2、安装和启动数据库# 准备mariadb的yum repo[root@web01 &#x2F;app]#cat &#x2F;etc&#x2F;yum.repos.d&#x2F;mariadb.repo [mariadb]name &#x3D; MariaDBbaseurl &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;mariadb&#x2F;yum&#x2F;10.5&#x2F;centos7-amd64&#x2F;gpgkey &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;mariadb&#x2F;yum&#x2F;RPM-GPG-KEY-MariaDBgpgcheck &#x3D; 0enabled &#x3D; 1# 安装yum install -y mariadb-server# 3、启动数据库服务systemctl enable --now mariadb# 4、初始化数据库mysql_secure_installation 执行后根据提示yes或noSwitch to unix_socket authentication [Y&#x2F;n] NChange the root password? [Y&#x2F;n] nRemove anonymous users? [Y&#x2F;n] YDisallow root login remotely? [Y&#x2F;n] YRemove test database and access to it? [Y&#x2F;n] YReload privilege tables now? [Y&#x2F;n] Y# 5、进入数据库创建库和用户create database zabbix_proxy character set utf8 collate utf8_bin;grant all privileges on zabbix_proxy.* to zabbix_proxy@&#39;localhost&#39; identified by &#39;redhat123&#39;;# 6、导入数据库（这个sql文件是zabbix包里的）mysql -uroot zabbix_proxy &lt;schema.sql# 查看是否导入成功MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || zabbix_proxy       |+--------------------+4 rows in set (0.000 sec)# 修改zabbix_proxy的配置文件[root@web01 ~]#grep &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_proxy.conf Server&#x3D;172.16.1.62Hostname&#x3D;shanghai_proxyLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_proxy.logLogFileSize&#x3D;0PidFile&#x3D;&#x2F;run&#x2F;zabbix&#x2F;zabbix_proxy.pidSocketDir&#x3D;&#x2F;run&#x2F;zabbixDBHost&#x3D;localhostDBName&#x3D;zabbix_proxyDBUser&#x3D;zabbix_proxyDBPassword&#x3D;redhat123SNMPTrapperFile&#x3D;&#x2F;var&#x2F;log&#x2F;snmptrap&#x2F;snmptrap.logTimeout&#x3D;4LogSlowQueries&#x3D;3000StatsAllowedIP&#x3D;127.0.0.1# 重启服务[root@web01 ~]#systemctl enable --now zabbix-proxy.service </code></pre></div></figure><h3 id="1-2-2-web页面添加代理"><a href="#1-2-2-web页面添加代理" class="headerlink" title="1.2.2 web页面添加代理"></a>1.2.2 web页面添加代理</h3><p>在web页面—&gt;agent代理程页面—-&gt;创建代理</p><p><img src="/../../../img/image-20240625163635357.png" alt="image-20240625163635357"></p><p>填写信息</p><p><img src="/../../../img/image-20240625163730772.png" alt="image-20240625163730772"></p><p>正常情况下，添加完后可以看到代理程序的”最近出现”时间，只要时间即可。</p><p>如果长时间出现not found情况，可以重启下代理和服务端试试</p><p><img src="/../../../img/image-20240625163856771.png" alt="image-20240625163856771"></p><h3 id="1-2-3-zabix客户端修改"><a href="#1-2-3-zabix客户端修改" class="headerlink" title="1.2.3 zabix客户端修改"></a>1.2.3 zabix客户端修改</h3><p>客户端需要将zabbix sever指向代理服务器（web01-172.16.1.7）</p><p>以db01为例</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 &#x2F;]#grep &quot;^[a-Z]&quot; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.conf PidFile&#x3D;&#x2F;var&#x2F;run&#x2F;zabbix&#x2F;zabbix_agent2.pidLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_agent2.logLogFileSize&#x3D;0Server&#x3D;172.16.1.7ServerActive&#x3D;172.16.1.7HostnameItem&#x3D;system.hostnameHostMetadataItem&#x3D;system.unameInclude&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.confControlSocket&#x3D;&#x2F;tmp&#x2F;agent.sockInclude&#x3D;.&#x2F;zabbix_agent2.d&#x2F;plugins.d&#x2F;*.conf</code></pre></div></figure><p>在web页面配合修改，让db01通过代理服务器上传数据</p><p>（测试中，页面自动修改了）</p><p><img src="/../../../img/image-20240625164332259.png" alt="image-20240625164332259"></p><p>在主机总览中可以看到db01走的是web01代理</p><p><img src="/../../../img/image-20240625164415991.png" alt="image-20240625164415991"></p><p>从代理程序总览中，也可以看到添加成功</p><p><img src="/../../../img/image-20240625164501958.png" alt="image-20240625164501958"></p><h1 id="二、低级自动发现（了解）"><a href="#二、低级自动发现（了解）" class="headerlink" title="二、低级自动发现（了解）"></a>二、低级自动发现（了解）</h1><p>什么是低级自动发现？</p><ul><li>在前面的教程中已经学过自动发现和自动注册。它们是用于发现主机的</li><li>而低级自动发现（又称为LLD），用于发现监控项 （触发器，图形），一般用于发现网卡、磁盘分区等等</li></ul><p><img src="/../../../img/image-20240625165054076.png" alt="image-20240625165054076"></p><h1 id="三、Zabbix-API"><a href="#三、Zabbix-API" class="headerlink" title="三、Zabbix API"></a>三、Zabbix API</h1><h2 id="3-1-Zabbix-API概述"><a href="#3-1-Zabbix-API概述" class="headerlink" title="3.1 Zabbix API概述"></a>3.1 Zabbix API概述</h2><p>开源软件&#x2F;商业软件的的api接口</p><ul><li>常用于进行二次开发</li></ul><p>cmdb (存储与管理企业IT架构中设备的各种配置信息)</p><ul><li>自动化运维平台，web页面管理(Golang,Python)</li></ul><h2 id="3-2-Zabbix-API使用流程"><a href="#3-2-Zabbix-API使用流程" class="headerlink" title="3.2 Zabbix API使用流程"></a>3.2 Zabbix API使用流程</h2><p>使用流程：</p><ul><li>根据zabbix用户名和密码，获取token(令牌)</li><li>使用token,访问或调取zabbix资源</li></ul><p>调用zabbix-api的各种方法</p><ol><li>curl命令</li><li>api测试工具</li></ol><p>在zabx 5.x中可以使用如下方法调用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -s -v -X POST -H ContentType:application&#x2F;json-rpc 10.0.0.62&#x2F;api_jsonrpc.php -d &#39;&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;,&quot;method&quot;: &quot;user.login&quot;,&quot;params&quot;: &#123;&quot;user&quot;: &quot;Admin&quot;,&quot;password&quot;: &quot;zabbix&quot;&#125;,&quot;id&quot;: 1,&quot;auth&quot;: null&#125;&#39;</code></pre></div></figure><p>在zbx 6.x中，使用token令牌调用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># token令牌24f749cdcacba78205e151899b323ba3c2a401418907a908601d2684ac5fc3be</code></pre></div></figure><h3 id="3-2-1-创建令牌"><a href="#3-2-1-创建令牌" class="headerlink" title="3.2.1 创建令牌"></a>3.2.1 创建令牌</h3><p>进到”User Setting”项，创建API token</p><p><img src="/../../../img/image-20240625170613437.png" alt="image-20240625170613437"></p><p>填写信息</p><p><img src="/../../../img/image-20240625170700222.png" alt="image-20240625170700222"></p><p>添加完成，令牌显示出来（只会显示一次，注意保存）</p><p><img src="/../../../img/image-20240625170729491.png" alt="image-20240625170729491"></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aaba9f82d156cce0411c1e06cdc2b3ae60fde705b064baa17b4b92c46e86dc0b</code></pre></div></figure><h3 id="3-2-2-API使用案例"><a href="#3-2-2-API使用案例" class="headerlink" title="3.2.2 API使用案例"></a>3.2.2 API使用案例</h3><p>案例：通过zabbix api获取主机列表</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">token&#x3D;aaba9f82d156cce0411c1e06cdc2b3ae60fde705b064baa17b4b92c46e86dc0bcurl -X POST -H &quot;Content-Type: application&#x2F;json-rpc&quot; -d &#39;&#123;  &quot;jsonrpc&quot;: &quot;2.0&quot;,  &quot;method&quot;: &quot;host.get&quot;,  &quot;params&quot;: &#123;    &quot;output&quot;: [      &quot;hostid&quot;,      &quot;host&quot;    ],    &quot;selectInterfaces&quot;: [      &quot;interfaceid&quot;,      &quot;ip&quot;    ]&#125;,&quot;id&quot;: 2,&quot;auth&quot;: &quot;aaba9f82d156cce0411c1e06cdc2b3ae60fde705b064baa17b4b92c46e86dc0b&quot;&#125;&#39; http:&#x2F;&#x2F;zbx.test.cn&#x2F;api_jsonrpc.php | jq# 执行结果  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100   754    0   489  100   265   6988   3787 --:--:-- --:--:-- --:--:--  7086&#123;  &quot;jsonrpc&quot;: &quot;2.0&quot;,  &quot;result&quot;: [    &#123;      &quot;hostid&quot;: &quot;10084&quot;,      &quot;host&quot;: &quot;Zabbix server&quot;,      &quot;interfaces&quot;: [        &#123;          &quot;interfaceid&quot;: &quot;1&quot;,          &quot;ip&quot;: &quot;127.0.0.1&quot;        &#125;      ]    &#125;,    &#123;      &quot;hostid&quot;: &quot;10620&quot;,      &quot;host&quot;: &quot;NFS01 server&quot;,      &quot;interfaces&quot;: [        &#123;          &quot;interfaceid&quot;: &quot;31&quot;,          &quot;ip&quot;: &quot;172.16.1.31&quot;        &#125;      ]    &#125;,    &#123;      &quot;hostid&quot;: &quot;10629&quot;,      &quot;host&quot;: &quot;web01&quot;,      &quot;interfaces&quot;: [        &#123;          &quot;interfaceid&quot;: &quot;40&quot;,          &quot;ip&quot;: &quot;172.16.1.7&quot;        &#125;      ]    &#125;,    &#123;      &quot;hostid&quot;: &quot;10630&quot;,      &quot;host&quot;: &quot;web03&quot;,      &quot;interfaces&quot;: [        &#123;          &quot;interfaceid&quot;: &quot;41&quot;,          &quot;ip&quot;: &quot;172.16.1.9&quot;        &#125;      ]    &#125;,    &#123;      &quot;hostid&quot;: &quot;10631&quot;,      &quot;host&quot;: &quot;db01&quot;,      &quot;interfaces&quot;: [        &#123;          &quot;interfaceid&quot;: &quot;42&quot;,          &quot;ip&quot;: &quot;172.16.1.51&quot;        &#125;      ]    &#125;  ],  &quot;id&quot;: 2&#125;</code></pre></div></figure><p>可见正常获取到各主机信息</p><h1 id="四、Zabbix性能优化"><a href="#四、Zabbix性能优化" class="headerlink" title="四、Zabbix性能优化"></a>四、Zabbix性能优化</h1><h2 id="4-1-优化概述"><a href="#4-1-优化概述" class="headerlink" title="4.1 优化概述"></a>4.1 优化概述</h2><p>优化方法：</p><ol><li>网站架构调整：尽量让用户的请求往前推<ol><li>用户的请求不要到达你的站点服务器</li><li>多走CDN、各种缓存、消息队列</li></ol></li><li>读的多还是写的多？按不同方向优化</li><li>穷：多从软件方面优化</li><li>富：加机器、强配件</li></ol><h2 id="4-2-硬件优化"><a href="#4-2-硬件优化" class="headerlink" title="4.2 硬件优化"></a>4.2 硬件优化</h2><p>硬件优化方向</p><p>CPU、内存、磁盘、网卡（改用10G万兆光卡、光纤）、磁盘组RAID</p><h2 id="4-3-Zabbix服务端配置优化"><a href="#4-3-Zabbix服务端配置优化" class="headerlink" title="4.3 Zabbix服务端配置优化"></a>4.3 Zabbix服务端配置优化</h2><blockquote><p>Zabbix是读少写多，主要优化写</p></blockquote><p>zabbix参数的配置: 缓存和进程数量</p><ul><li>xxxxcache<ul><li>用于zabbix服务端缓存获取的各类数据 (历史数据,趋势数据….)</li></ul></li><li>poller <ul><li>用于数据采集进程 (接收agent的数据的进程，接收snmp、接收jmx、接收ipmi…..)</li></ul></li></ul><h3 id="4-3-1-缓存调整"><a href="#4-3-1-缓存调整" class="headerlink" title="4.3.1 缓存调整"></a>4.3.1 缓存调整</h3><p>配置文件修改参数，调节缓存大小，(使用率高，就把缓存适当调大一些)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 用于存储主机、监控项、触发器数据的共享内存大小CacheSize&#x3D;64M #512M 边调节边看监控 Zabbix server:Zabbix cache usage, % free# 历史数据缓存HistoryCacheSize&#x3D;16M#历史数据索引的缓存HistoryIndexCacheSize&#x3D;4M#趋势数据缓存TrendCacheSize&#x3D;4M#值的缓存ValueCacheSize&#x3D;8M</code></pre></div></figure><blockquote><p>根据图形调整缓存、进程数量，那个缓存用的多，就调那个</p></blockquote><p> 先进入”监测”-“主机”界面，点击”图形”</p><p><img src="/../../../img/image-20240701103402725.png" alt="image-20240701103402725"></p><p>时间修改为最近五分钟，过滤cache</p><p><img src="/../../../img/image-20240701103514200.png" alt="image-20240701103514200"></p><p>查看此项</p><p><img src="/../../../img/image-20240701103543644.png" alt="image-20240701103543644"></p><p>调整<code>CacheSize=64M</code>的效果，<code>Configuration cache</code>使用率从31%降到15%</p><p><img src="/../../../img/image-20240701104939367.png" alt="image-20240701104939367"></p><h3 id="4-3-2-进程数量调整"><a href="#4-3-2-进程数量调整" class="headerlink" title="4.3.2 进程数量调整"></a>4.3.2 进程数量调整</h3><p>修改配置文件，调整poller进程数量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 收集数据进程的数量StartPollers&#x3D;5# 客户端&#x2F;主机 不可达 可达主机 (包括IPMI 和 Java)的轮询进程的初始实例数量StartPollersUnreachable&#x3D;1#用于接收http客户端的数据StartHTTPPollers&#x3D;1#用于收集客户端jmx的数据 (默认是0) java-gateway的时候使用StartJavaPollers&#x3D;5#用于收集zabbix proxy代理的数据的进程数 默认是1StartProxyPollers&#x3D;1#收集ipmi客户端数据StartIPMIPollers&#x3D;0</code></pre></div></figure><p>可以看图形来改，过滤busy关键字</p><p><img src="/../../../img/image-20240701104549301.png" alt="image-20240701104549301"></p><h2 id="4-4-客户端配置优化"><a href="#4-4-客户端配置优化" class="headerlink" title="4.4 客户端配置优化"></a>4.4 客户端配置优化</h2><p>优化方案：</p><p>调整zbx客户端的模式，默认是被动模式，改为主动模式。 </p><ul><li>zbx被动模式简单，但是对zbx服务端压力大，只适用于少量主机的场景</li><li>zbx主动模式，适用于大量主机监控。</li></ul><p>主动模式注意事项：  </p><ul><li>改完配置后，主机客户端类型也要改（zbx客户端主动模式），web模板也要修改</li><li>不绿了。如果监控中只有主动模式，不绿了。</li></ul><p>案例：修改web01配置，改为主动模式</p><p>1、配置文件修改：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.confPidFile&#x3D;&#x2F;var&#x2F;run&#x2F;zabbix&#x2F;zabbix_agent2.pidLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_agent2.logLogFileSize&#x3D;0Server&#x3D;172.16.1.62ServerActive&#x3D;172.16.1.62 # 修改为服务端ip#Hostname 这个注释掉HostnameItem&#x3D;system.hostname # 修改为键值Include&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.confControlSocket&#x3D;&#x2F;tmp&#x2F;agent.sockInclude&#x3D;.&#x2F;zabbix_agent2.d&#x2F;plugins.d&#x2F;*.conf</code></pre></div></figure><p>2、关联主动模式zabbix模板</p><p><img src="/../../../img/image-20240701110420399.png" alt="image-20240701110420399"></p><h2 id="4-5-键值与监控项优化"><a href="#4-5-键值与监控项优化" class="headerlink" title="4.5 键值与监控项优化"></a>4.5 键值与监控项优化</h2><p>优化方案</p><ul><li>增加<strong>更新间隔</strong>时间5m 10m</li><li>推荐使用<strong>自定义模板</strong>，控制功能全面监控，监控项少,精简监控项 (精简)</li><li><strong>历史数据保留</strong>时长减少，设置为30d或7d， 增加<strong>趋势存储数据</strong>保留时间 365d</li></ul><blockquote><p>后续如果涉及到优化，可以百度补充</p></blockquote><h2 id="4-6-数据库优化"><a href="#4-6-数据库优化" class="headerlink" title="4.6 数据库优化"></a>4.6 数据库优化</h2><p>优化方案：</p><p>根据业务类型调整：读少写多</p><ul><li>优化数据库的写入性能，建议使用InnoDB存储引擎或tokudb存储引擎</li><li>数据库分离或数据库拆分</li></ul><h2 id="4-7-优化总结"><a href="#4-7-优化总结" class="headerlink" title="4.7 优化总结"></a>4.7 优化总结</h2><p>优化方案总结：</p><ul><li>针对mysql,写多读少，使用InnoDB存储引擎或tokudb存储引擎</li><li>去掉无用监控项,增加监控项的取值间隔,减少历史数据保存周期,增<br>加趋势数据保留时间</li><li>把被动模式修改为<strong>主动模式</strong>,增加zabbix-proxy(多个机房，跨地区)</li><li>针对于zabbix-server进程调优,谁忙,就加大它的进程数量</li><li>针对于zabbix-server缓存调优,谁的剩余内存少,就加大它的缓存值 </li><li>针对zabbix 历史数据和趋势图的表,进行周期性分表(分表)</li></ul><h1 id="五、Zabbix高可用"><a href="#五、Zabbix高可用" class="headerlink" title="五、Zabbix高可用"></a>五、Zabbix高可用</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>zbx 6.x之前：</p><ul><li>一直是使用多个zbx server + keep alived来实现</li></ul><p>zbx 6.x开始：</p><ul><li>自带高可用功能</li></ul><p>可以通过命令行查看到高可用情况</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~]#zabbix_server -R ha_status</code></pre></div></figure><h2 id="5-2-快速上手"><a href="#5-2-快速上手" class="headerlink" title="5.2 快速上手"></a>5.2 快速上手</h2><h4 id="5-2-1-环境准备"><a href="#5-2-1-环境准备" class="headerlink" title="5.2.1 环境准备"></a>5.2.1 环境准备</h4><table><thead><tr><th>主机</th><th>功能</th></tr></thead><tbody><tr><td>mn02</td><td>zbx主</td></tr><tr><td>mn03</td><td>zbx备</td></tr></tbody></table><p>mn03前提准备：</p><ul><li>分发zbx -server命令</li><li>分发zbx server的配置文件</li><li>分发zbx server 启动配置文件 systemctl daemon-reload</li><li>添加用户zabbix</li><li>安装依赖</li></ul><h3 id="5-2-2-开始配置"><a href="#5-2-2-开始配置" class="headerlink" title="5.2.2 开始配置"></a>5.2.2 开始配置</h3><h4 id="a）服务端配置"><a href="#a）服务端配置" class="headerlink" title="a）服务端配置"></a>a）服务端配置</h4><p>mn02配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~]#grep &quot;^[a-Z]&quot; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.confListenPort&#x3D;10051LogFile&#x3D;&#x2F;tmp&#x2F;zabbix_server.logDBHost&#x3D;172.16.1.51DBName&#x3D;zabbixDBUser&#x3D;zabbixDBPassword&#x3D;zabbixJavaGateway&#x3D;127.0.0.1JavaGatewayPort&#x3D;10052StartJavaPollers&#x3D;5CacheSize&#x3D;64MTimeout&#x3D;4LogSlowQueries&#x3D;3000StatsAllowedIP&#x3D;127.0.0.1# 添加作为HA节点的信息HANodeName&#x3D;mn02NodeAddress&#x3D;172.16.1.62:10051</code></pre></div></figure><p>mn03配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn03 ~]#grep &quot;^[a-Z]&quot; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.confListenPort&#x3D;10051LogFile&#x3D;&#x2F;tmp&#x2F;zabbix_server.logDBHost&#x3D;172.16.1.51DBName&#x3D;zabbixDBUser&#x3D;zabbixDBPassword&#x3D;zabbixJavaGateway&#x3D;127.0.0.1JavaGatewayPort&#x3D;10052StartJavaPollers&#x3D;5CacheSize&#x3D;64MTimeout&#x3D;4LogSlowQueries&#x3D;3000StatsAllowedIP&#x3D;127.0.0.1# 添加作为HA节点的信息HANodeName&#x3D;mn03NodeAddress&#x3D;172.16.1.63:10051</code></pre></div></figure><p>都重启服务，查看HA情况</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 主节点可以看到[root@mn03 ~]#zabbix_server -R ha_statusFailover delay: 60 secondsCluster status:   #  ID                        Name                      Address                        Status      Last Access   1 cly2f5z3s0001xw9yldxunt78 mn02                      172.16.1.62:10051              standby     4s   2 cly2f9z900001mf9xebepvbwv mn03                      172.16.1.63:10051              active      4s# 备节点会提示[root@mn02~]#zabbix_server -R ha_statusRuntime commands can be executed only in active mode</code></pre></div></figure><p>界面也会显示</p><p><img src="/../../../img/image-20240701113639345.png" alt="image-20240701113639345"></p><h4 id="b）客户端配置"><a href="#b）客户端配置" class="headerlink" title="b）客户端配置"></a>b）客户端配置</h4><p>客户端配置多个服务端地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03 ~]# grep &#39;^[a-Z]&#39;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.confPidFile&#x3D;&#x2F;var&#x2F;run&#x2F;zabbix&#x2F;zabbix_agent2.pidLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_agent2.logLogFileSize&#x3D;0Server&#x3D;172.16.1.63,172.16.1.62 #多个服务端，ip、主机名要用逗号分隔。ServerActive&#x3D;172.16.1.63;172.16.1.62 #多个ha集群，节点名字或ip，要用分号分隔。HostnameItem&#x3D;system.hostnameInclude&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.confControlSocket&#x3D;&#x2F;tmp&#x2F;agent.sockInclude&#x3D;.&#x2F;zabbix_agent2.d&#x2F;plugins.d&#x2F;*.conf</code></pre></div></figure><h4 id="c）站点配置"><a href="#c）站点配置" class="headerlink" title="c）站点配置"></a>c）站点配置</h4><p>web页面配置文件<code>zabbix.conf.php</code>，改为空</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 原单个&#x2F;&#x2F; $ZBX_SERVER                  &#x3D; &#39;172.16.1.63&#39;;&#x2F;&#x2F; $ZBX_SERVER_PORT             &#x3D; &#39;10051&#39;;# 改为空，会自动切换&#x2F;&#x2F; $ZBX_SERVER                  &#x3D; &#39;&#39;;&#x2F;&#x2F; $ZBX_SERVER_PORT             &#x3D; &#39;&#39;;</code></pre></div></figure><blockquote><p>参考自zabbix官方手册</p><p><a href="https://www.zabbix.com/documentation/current/zh/manual/concepts/server/ha">https://www.zabbix.com/documentation/current/zh/manual/concepts/server/ha</a></p><p><img src="/../../../img/image-20240701121437251.png" alt="image-20240701121437251"></p></blockquote><p>手动调整服务端的开关，可以在页面看到切换效果</p><p><img src="/../../../img/image-20240701121526700.png" alt="image-20240701121526700"></p><h4 id="d）web界面展示高可用节点"><a href="#d）web界面展示高可用节点" class="headerlink" title="d）web界面展示高可用节点"></a>d）web界面展示高可用节点</h4><p>右上角可以编辑展示信息，添加一个展示“高可用节点”的构件</p><p><img src="/../../../img/image-20240701121844597.png" alt="image-20240701121844597"></p><p>效果如图</p><p><img src="/../../../img/image-20240701121942383.png" alt="image-20240701121942383"></p><h3 id="5-2-3-问题总结"><a href="#5-2-3-问题总结" class="headerlink" title="5.2.3 问题总结"></a>5.2.3 问题总结</h3><h4 id="a）脑裂问题"><a href="#a）脑裂问题" class="headerlink" title="a）脑裂问题"></a>a）脑裂问题</h4><p>问题现象：</p><ul><li>有两个主，两台机器都是active</li></ul><p>分析思路：</p><ul><li>一般是服务端配置文件错误，注意里面的zbx服务端IP、数据库IP</li></ul><h1 id="六、Zabbix升级"><a href="#六、Zabbix升级" class="headerlink" title="六、Zabbix升级"></a>六、Zabbix升级</h1><p>服务端升级路线：</p><ul><li>zbx 2.x 3.x 4.x 5.x –&gt; zbx 6.x</li></ul><p>升级步骤：</p><ol><li>准备好新的数据库，备份好旧的数据库内容。</li><li>按照数据库升级要求变更数据库内容（<strong>这一步最重要</strong>）</li><li>准备新的zabbix_server(rpm包)、命令和配置文件。</li><li>备份,替换旧的zbx_server命令.检查。</li><li>前端页面，根据要求准备好php对应版本即可。</li><li>备份,放入新的前端代码即可。</li><li>调试。</li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day69-监控架构-Zabbix(三)</title>
    <link href="/2024/06/20/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day69-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-3/"/>
    <url>/2024/06/20/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day69-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-3/</url>
    
    <content type="html"><![CDATA[<h1 id="监控架构-Zabbix-02"><a href="#监控架构-Zabbix-02" class="headerlink" title="监控架构-Zabbix-02"></a>监控架构-Zabbix-02</h1><p>今日内容：</p><ul><li>Zabbix监控不同客户端的方法</li><li>主机自动发现与注册</li><li>Zabbix全网监控项目</li></ul><h1 id="一、Zabbix的各种客户端"><a href="#一、Zabbix的各种客户端" class="headerlink" title="一、Zabbix的各种客户端"></a>一、Zabbix的各种客户端</h1><h2 id="1-1-Zabbix支持的客户端"><a href="#1-1-Zabbix支持的客户端" class="headerlink" title="1.1 Zabbix支持的客户端"></a>1.1 Zabbix支持的客户端</h2><p>Zabbix不是仅能监控Linux客户端，对于其他客户端也支持</p><table><thead><tr><th>zabbix客户端</th><th>应用场景</th></tr></thead><tbody><tr><td>Zabbix-Agent2（最常用）</td><td>适用于几乎所有情况，支持自定义监控，如linux、window、android、ios</td></tr><tr><td>SNMP客户端</td><td>用于监控网络设备</td></tr><tr><td>JMX</td><td>监控JAVA APP，未来推荐自定义监控（zabbix agent2 + jmap&#x2F;jstats）</td></tr><tr><td>IPMI</td><td>监控物理硬件（物理服务器），也可以直接使用自定义监控（ipmitool + megacli）</td></tr></tbody></table><h2 id="1-2-监控Windows"><a href="#1-2-监控Windows" class="headerlink" title="1.2 监控Windows"></a>1.2 监控Windows</h2><p>步骤：</p><ul><li>安装客户端，配置</li><li>服务端添加主机、关联模板</li><li>调试</li></ul><h3 id="1-2-1-安装windows客户端"><a href="#1-2-1-安装windows客户端" class="headerlink" title="1.2.1 安装windows客户端"></a>1.2.1 安装windows客户端</h3><p>安装的时候填写Zabbix服务端的IP</p><p><img src="/../../../img/image-20240620100621529.png" alt="image-20240620100621529"></p><p>安装完成查看进程</p><p><img src="/../../../img/image-20240620100646297.png" alt="image-20240620100646297"></p><p>查看服务是否开机自启动，打开服务设置窗口</p><p><img src="/../../../img/image-20240620100820689.png" alt="image-20240620100820689"></p><p>查看服务情况</p><p><img src="/../../../img/image-20240620100722031.png" alt="image-20240620100722031"></p><h3 id="1-2-2-安装目录及配置文件"><a href="#1-2-2-安装目录及配置文件" class="headerlink" title="1.2.2 安装目录及配置文件"></a>1.2.2 安装目录及配置文件</h3><p>配置文件目录：<code>C:\Program Files\Zabbix Agent 2  </code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ grep -i &#39;^[a-z]&#39; zabbix_agent2.confLogFile&#x3D;C:\Program Files\Zabbix Agent2\zabbix_agent2.logServer&#x3D;10.0.0.62ServerActive&#x3D;10.0.0.62Hostname&#x3D;DESKTOP-GAMESOFTControlSocket&#x3D;\\.\pipe\agent.sock</code></pre></div></figure><h3 id="1-2-3-Zabbix页面配置"><a href="#1-2-3-Zabbix页面配置" class="headerlink" title="1.2.3 Zabbix页面配置"></a>1.2.3 Zabbix页面配置</h3><p>使用windows模板</p><p><img src="/../../../img/image-20240620101124644.png" alt="image-20240620101124644"></p><h2 id="1-3-监控SNMP"><a href="#1-3-监控SNMP" class="headerlink" title="1.3 监控SNMP"></a>1.3 监控SNMP</h2><p>snmp：简单网络管理协议</p><h3 id="1-3-1-开启网络设备的SNMP功能"><a href="#1-3-1-开启网络设备的SNMP功能" class="headerlink" title="1.3.1 开启网络设备的SNMP功能"></a>1.3.1 开启网络设备的SNMP功能</h3><p>如：H3C的路由器</p><p>先开启功能，一般v2c和v3用的多</p><p><img src="/../../../img/image-20240620101412980.png" alt="image-20240620101412980"></p><p>再设置团体名</p><p><img src="/../../../img/image-20240620101428889.png" alt="image-20240620101428889"></p><h3 id="1-3-2-Zabbix服务端测试SNMP联通性"><a href="#1-3-2-Zabbix服务端测试SNMP联通性" class="headerlink" title="1.3.2 Zabbix服务端测试SNMP联通性"></a>1.3.2 Zabbix服务端测试SNMP联通性</h3><p>在Zabbix server端安装工具，测试SNMP能否读到数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y net-snmp-utils</code></pre></div></figure><p>测试，获取基本信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">snmpwalk -v 2c -c lidao996 192.168.15.1 SysDesc</code></pre></div></figure><p><img src="/../../../img/image-20240620101707107.png" alt="image-20240620101707107"></p><h3 id="1-3-3-web页面配置"><a href="#1-3-3-web页面配置" class="headerlink" title="1.3.3 web页面配置"></a>1.3.3 web页面配置</h3><p>创建主机</p><p><img src="/../../../img/image-20240620101954862.png" alt="image-20240620101954862"></p><p>切换到“宏”标签，设置宏的值</p><p><img src="/../../../img/image-20240620102041945.png" alt="image-20240620102041945"></p><h3 id="1-3-4-测试"><a href="#1-3-4-测试" class="headerlink" title="1.3.4 测试"></a>1.3.4 测试</h3><p>SNMP图标刚开始是灰色</p><p><img src="/../../../img/image-20240620102146255.png" alt="image-20240620102146255"></p><p>过段时间变为绿色，表示正常监控到</p><p><img src="/../../../img/image-20240620102207341.png" alt="image-20240620102207341"></p><p>检查数据</p><p><img src="/../../../img/image-20240620102350054.png" alt="image-20240620102350054"></p><h2 id="1-3-监控JAVA应用"><a href="#1-3-监控JAVA应用" class="headerlink" title="1.3 监控JAVA应用"></a>1.3 监控JAVA应用</h2><h3 id="1-3-1-方案选型与原理"><a href="#1-3-1-方案选型与原理" class="headerlink" title="1.3.1 方案选型与原理"></a>1.3.1 方案选型与原理</h3><p>两种方案都行，按照需求选用就可以</p><table><thead><tr><th>方案</th><th>监控方案</th></tr></thead><tbody><tr><td>JMX方案</td><td>客户端开启Java jmxremote，ZBX中关联对应的模板，zabbix服务端安装与开启java工具zbx-java-gateway</td></tr><tr><td>自定义监控方案</td><td>通过在java应用服务器中安装zbx agent2和java监控命令（jmap、jstack），再创建自定义监控</td></tr></tbody></table><p><strong>JMX方案的原理</strong></p><p>jmxremote在客户端收集信息，上传到zabbix服务端的zabbix-java-gateway中，经处理显示到web页面上</p><p><img src="/../../../img/image-20240620102948353.png" alt="image-20240620102948353"></p><p><strong>自定义监控方案的原理</strong></p><p>通过zabbix agent2收集jmap、jstats等命令的执行结果，再反馈到Zabbix服务端，经处理显示到web页面上</p><p><img src="/../../../img/image-20240620103153345.png" alt="image-20240620103153345"></p><h3 id="1-3-2-JMX方案实战"><a href="#1-3-2-JMX方案实战" class="headerlink" title="1.3.2 JMX方案实战"></a>1.3.2 JMX方案实战</h3><p>步骤：</p><ol><li>开启远程监控功能</li><li>Zbx服务端部署java gateway，并配置</li><li>添加主机，关联模板</li></ol><h4 id="a）客户端开启远程监控"><a href="#a）客户端开启远程监控" class="headerlink" title="a）客户端开启远程监控"></a>a）客户端开启远程监控</h4><blockquote><p>web03 - 10.0.0.9 操作</p></blockquote><p>以JAVA APP - Tomcat为例，开启jmx远程监控</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03 &#x2F;app&#x2F;tools&#x2F;apache-tomcat-9.0.89]#vim bin&#x2F;catalina.sh# 主要修改如下内容CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port&#x3D;12345 \-Dcom.sun.management.jmxremote.authenticate&#x3D;false \-Dcom.sun.management.jmxremote.ssl&#x3D;false \-Djava.rmi.server.hostname&#x3D;172.16.1.9&quot;</code></pre></div></figure><p>再重启Tomcat服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart tomcat</code></pre></div></figure><p>ps查看进程状态，确保jmxremote开启</p><p><img src="/../../../img/image-20240620104252643.png" alt="image-20240620104252643"></p><p>ss查看端口正常</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03 &#x2F;]#ss -lntup | grep 12345tcp    LISTEN     0      50     [::]:12345              [::]:*                   users:((&quot;java&quot;,pid&#x3D;2039,fd&#x3D;21))</code></pre></div></figure><h4 id="b）服务端部署java-gateway"><a href="#b）服务端部署java-gateway" class="headerlink" title="b）服务端部署java gateway"></a>b）服务端部署java gateway</h4><blockquote><p>mn02 - 10.0.0.62操作</p></blockquote><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y zabbix-java-gateway</code></pre></div></figure><p>启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable zabbix-java-gateway.servicesystemctl start zabbix-java-gateway.service</code></pre></div></figure><p>配置java gateway</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_java_gateway.confLISTEN_PORT&#x3D;10052PID_FILE&#x3D;&quot;&#x2F;var&#x2F;run&#x2F;zabbix&#x2F;zabbix_java_gateway.pid&quot;</code></pre></div></figure><p>配置zbx服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep -n &#39;Java.*&#x3D;&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf317:JavaGateway&#x3D;127.0.0.1325:JavaGatewayPort&#x3D;10052333:StartJavaPollers&#x3D;5</code></pre></div></figure><blockquote><p>配置的服务都要重启！</p></blockquote><p>检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;usr&#x2F;share]#ss -lntup | grep javatcp    LISTEN     0      50     [::]:10052              [::]:*                   users:((&quot;java&quot;,pid&#x3D;18660,fd&#x3D;12))</code></pre></div></figure><h4 id="c）网页添加主机"><a href="#c）网页添加主机" class="headerlink" title="c）网页添加主机"></a>c）网页添加主机</h4><p><img src="/../../../img/image-20240620104916463.png" alt="image-20240620104916463"></p><h4 id="d）测试"><a href="#d）测试" class="headerlink" title="d）测试"></a>d）测试</h4><p>查看JMX图标地状态正常（ZBX监控因为没安装agent2，灰色正常）</p><p><img src="/../../../img/image-20240620105639898.png" alt="image-20240620105639898"></p><p>查看数据，已经能获取到一些</p><p><img src="/../../../img/image-20240620105734187.png" alt="image-20240620105734187"></p><h3 id="1-3-3-JMX方案补充-jar包如何开启远程监控"><a href="#1-3-3-JMX方案补充-jar包如何开启远程监控" class="headerlink" title="1.3.3 JMX方案补充-jar包如何开启远程监控"></a>1.3.3 JMX方案补充-jar包如何开启远程监控</h3><p>在运行jar包的时候，添加参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port&#x3D;12345 \-Dcom.sun.management.jmxremote.authenticate&#x3D;false \-Dcom.sun.management.jmxremote.ssl&#x3D;false \-Djava.rmi.server.hostname&#x3D;172.16.1.9 \-jar xxx.jar</code></pre></div></figure><h2 id="1-4-监控硬件设备"><a href="#1-4-监控硬件设备" class="headerlink" title="1.4 监控硬件设备"></a>1.4 监控硬件设备</h2><p>服务器硬件信息，监控方案有如下</p><table><thead><tr><th>方案</th><th>说明</th></tr></thead><tbody><tr><td>IPMI监控</td><td>开启设备IPMI功能，添加主机选择IPMI即可</td></tr><tr><td>自定义监控</td><td>通过客户端命令实现监控（megacli、ipmitool等）</td></tr></tbody></table><h1 id="二、自动发现与注册"><a href="#二、自动发现与注册" class="headerlink" title="二、自动发现与注册"></a>二、自动发现与注册</h1><p>自动发现与自动注册的对比</p><table><thead><tr><th>方案</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>自动发现（服务端主动）</td><td>ZBX服务端主动去找新主机，如果有则添加</td><td>配置简单，大量添加主机不适合（临时可用）</td></tr><tr><td>自动注册（客户端主动）</td><td>ZBX客户端主动去找服务器，提交自己信息，请求服务</td><td>配置繁琐，适合大量主机场景（经常用）</td></tr></tbody></table><p>对比图</p><p><img src="/../../../img/image-20240620172906307.png" alt="image-20240620172906307"></p><h2 id="2-1-自动发现"><a href="#2-1-自动发现" class="headerlink" title="2.1 自动发现"></a>2.1 自动发现</h2><p>配置步骤</p><ul><li>客户端（zbx agent)，配置文件.</li><li>配置自动发现规则 - 发现主机</li><li>配置自动发现的动作  - 发现主机后关联模板，添加主机，加入主机组，启用</li></ul><h3 id="2-1-1-客户端准备agent"><a href="#2-1-1-客户端准备agent" class="headerlink" title="2.1.1 客户端准备agent"></a>2.1.1 客户端准备agent</h3><p>还是按老样子准备，安装zabbix agent2，配置服务器地址</p><h3 id="2-1-2-web配置自动发现规则"><a href="#2-1-2-web配置自动发现规则" class="headerlink" title="2.1.2 web配置自动发现规则"></a>2.1.2 web配置自动发现规则</h3><p>先删除主机172.16.1.7、9、51</p><p><img src="/../../../img/image-20240620171647152.png" alt="image-20240620171647152"></p><p>进入“配置”页，创建发现规则</p><p><img src="/../../../img/image-20240620171214817.png" alt="image-20240620171214817"></p><p>填写信息</p><p><img src="/../../../img/image-20240620171440450.png" alt="image-20240620171440450"></p><p>配置完成后可以在“监测”页面查看自动发现的状态</p><p><img src="/../../../img/image-20240620171842477.png" alt="image-20240620171842477"></p><p>但是单纯的“发现”并不能将主机添加到zabbix监控中，还需要配置配套的“动作”</p><h3 id="2-1-3-web配置动作"><a href="#2-1-3-web配置动作" class="headerlink" title="2.1.3 web配置动作"></a>2.1.3 web配置动作</h3><p>配置<code>自动发现</code>的动作：</p><ul><li>添加组</li><li>关联模板</li><li>启动主机</li></ul><p>进入“发现动作”配置页面，创建动作，也可以用自带的“Auto discovery..”来修改</p><p><img src="/../../../img/image-20240620172032269.png" alt="image-20240620172032269"></p><p>这里用自带的Auto…来修改，先改名字</p><p><img src="/../../../img/image-20240620172430175.png" alt="image-20240620172430175"></p><p>再添加“启用主机”的操作</p><p><img src="/../../../img/image-20240620172516479.png" alt="image-20240620172516479"></p><p>设置完如图</p><p><img src="/../../../img/image-20240620172539911.png" alt="image-20240620172539911"></p><h3 id="2-1-4-测试自动发现"><a href="#2-1-4-测试自动发现" class="headerlink" title="2.1.4 测试自动发现"></a>2.1.4 测试自动发现</h3><p>耐心等待，自动发现的服务器会重新注册回来，刚开始ZBX的标签是灰色的</p><p><img src="/../../../img/image-20240620172800719.png" alt="image-20240620172800719"></p><p>再等待一会，全部变为绿色</p><p><img src="/../../../img/image-20240620172819292.png" alt="image-20240620172819292"></p><h2 id="2-2-自动注册"><a href="#2-2-自动注册" class="headerlink" title="2.2 自动注册"></a>2.2 自动注册</h2><p>应用场景，经常性添加主机</p><p>准备工作：</p><ul><li>关闭 自动发现 规则</li><li>关闭 自动发现 动作</li><li>自动发现的主机 删除</li><li>zbx客户端配置: 修改zabbix客户端配置文件: ServerActive&#x3D;服务端ip 和Hostname&#x3D;…..</li><li>web页面,动作–&gt;自动注册 autoreg……</li></ul><h3 id="2-2-1-ZBX客户端配置文件"><a href="#2-2-1-ZBX客户端配置文件" class="headerlink" title="2.2.1 ZBX客户端配置文件"></a>2.2.1 ZBX客户端配置文件</h3><p>客户端主动把自己的信息，提供给服务端。</p><p>服务端收到数据后通过 自动注册动作，判断与添加。  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Server&#x3D;172.16.1.62 # 服务端地址。ServerActive&#x3D;172.16.1.62 # 主动模式下的服务端ip地址。#Hostname&#x3D;web01 当前主机名，这个可以注释掉或使用ansible配置。建议注释使用下面的内容,自动获取主机名HostnameItem&#x3D;system.hostname 通过后面指定的键值获取主机名。 # ⚠ Hostname和HostnameItem2选1.# Item监控项、键值。HostMetadataItem&#x3D;system.uname # 主机的元数据键值,类似于自动发现中system.uname判断存活和获取主机信息。</code></pre></div></figure><blockquote><p>这里的system.uname的作用，跟自动发现章节2.1.2中的system.uname作用一致</p></blockquote><p>完整通用配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# grep &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.confPidFile&#x3D;&#x2F;var&#x2F;run&#x2F;zabbix&#x2F;zabbix_agent2.pidLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_agent2.logLogFileSize&#x3D;0Server&#x3D;172.16.1.62ServerActive&#x3D;172.16.1.62HostnameItem&#x3D;system.hostnameHostMetadataItem&#x3D;system.unameInclude&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.confControlSocket&#x3D;&#x2F;tmp&#x2F;agent.sockInclude&#x3D;.&#x2F;zabbix_agent2.d&#x2F;plugins.d&#x2F;*.conf</code></pre></div></figure><p>配置完重启服务</p><h3 id="2-2-2-web页面动作配置"><a href="#2-2-2-web页面动作配置" class="headerlink" title="2.2.2 web页面动作配置"></a>2.2.2 web页面动作配置</h3><p>进入自动注册设置页面</p><p><img src="/../../../img/image-20240620174414447.png" alt="image-20240620174414447"></p><p>创建动作</p><p><img src="/../../../img/image-20240620174531172.png" alt="image-20240620174531172"></p><p>添加操作</p><p><img src="/../../../img/image-20240620174640109.png" alt="image-20240620174640109"></p><p>创建完之后的示例</p><p><img src="/../../../img/image-20240620174702957.png" alt="image-20240620174702957"></p><h3 id="2-2-3-测试"><a href="#2-2-3-测试" class="headerlink" title="2.2.3 测试"></a>2.2.3 测试</h3><p>耐心等待，主机自动完成注册，刚注册“可用性”也是灰色的</p><p><img src="/../../../img/image-20240620175159495.png" alt="image-20240620175159495"></p><p>耐心等待变为绿色即可</p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>自动发现与注册的对比</p><ul><li>自动注册的整体流程与自动发现类似，但是自动注册无法在web页面直接查看是否发现了主机，只能看是否已经添加了主机。</li><li>自动注册的web页面没有地方配置规则，自动注册把规则写入到了客户端配置文件中的。</li><li>自动注册的web页面<strong>只需要配置自动注册的动作</strong>即可，不需要创建自动发现规则</li></ul><h1 id="三、全网监控项目"><a href="#三、全网监控项目" class="headerlink" title="三、全网监控项目"></a>三、全网监控项目</h1><h2 id="3-1-网站需要监控什么？"><a href="#3-1-网站需要监控什么？" class="headerlink" title="3.1 网站需要监控什么？"></a>3.1 网站需要监控什么？</h2><p>比如面试题：尼玛公司监控了什么，自定义监控什么，监控指标是什么</p><p>潜台词：问你网站架构监控了什么</p><h3 id="3-1-1-回答参考"><a href="#3-1-1-回答参考" class="headerlink" title="3.1.1 回答参考"></a>3.1.1 回答参考</h3><p>不推荐的回答案例：（没有经验，小白）</p><ul><li>cpu，内存，磁盘，网络，带宽，负载….</li></ul><p>推荐的回答:</p><p>按照网站层次架构监控的（多个维度监控）</p><ul><li><p>任何一台机器（从下到上）：</p><ul><li>API接口监控:(选做)</li><li>业务&#x2F;app监控</li><li>服务监控</li><li>系统监控</li><li>硬件监控</li></ul></li><li><p>按照用户访问网站的流程监控（一层一层）:</p><ul><li>dns&#x2F;cdn，安全组，负载，web，数据库，存储，备份…</li></ul></li><li><p>补充的监控</p></li></ul><h3 id="3-1-2-任何一台机器监控（从下到上）"><a href="#3-1-2-任何一台机器监控（从下到上）" class="headerlink" title="3.1.2 任何一台机器监控（从下到上）"></a>3.1.2 任何一台机器监控（从下到上）</h3><table><thead><tr><th>监控内容</th><th>详细内容</th><th>具体实现落地</th></tr></thead><tbody><tr><td>API接口监控</td><td>监控指定的api接口，比如zbx api。开发提供.</td><td>curl命令、web场景&#x2F;监测</td></tr><tr><td>业务、应用、 app监控</td><td>检查应用是否可用，书写测试代码。类似于info.php、mysqli.php这种页 面.</td><td>curl命令、web场景&#x2F;监测</td></tr><tr><td>服务监控</td><td>1️⃣基本：进程，端口 <br/>2️⃣专有：服务的状态，不同服务不同。 ᲼<br/>3️⃣日志：最近2000行日志中是否有error&#x2F;failed&#x2F;exception&#x2F;sever</td><td>模板或根据具体要求自定义监控</td></tr><tr><td>系统监控</td><td>cpu、负载、内存、磁盘、网络、带宽、io、关键文件是否变化、进程、僵尸进程、 是否有非堡垒机登录</td><td>模板+自定义（僵尸进程，用户 异地登录）</td></tr><tr><td>硬件监控</td><td>物理服务器，温度，风扇转速，raid状态</td><td>ipmi 或 自定义监控 (ipmitool&#x2F;megacli)</td></tr></tbody></table><h3 id="3-1-3-按照用户访问流程监控（一层一层）"><a href="#3-1-3-按照用户访问流程监控（一层一层）" class="headerlink" title="3.1.3 按照用户访问流程监控（一层一层）"></a>3.1.3 按照用户访问流程监控（一层一层）</h3><p>监控内容</p><table><thead><tr><th>监控内 容</th><th>详细内容</th><th>具体实现落地</th></tr></thead><tbody><tr><td>DNS</td><td>解析是否OK。</td><td>自定义监控-ping&#x2F;dig&#x2F;….. 域名: whois baidu.com 过滤过期 证书: curl -Lsv <a href="http://www.baidu.com/">www.baidu.com</a> -o &#x2F;dev&#x2F;null过滤expire date 过 期</td></tr><tr><td>CDN</td><td>是否可用.命中率.(web检查)</td><td>分布式ping: 商业：监控宝，听云 免费网站: <a href="http://www.17ce.com,ping.chinaz.com/">www.17ce.com,ping.chinaz.com</a> 开源软件: smokeping</td></tr><tr><td>负载</td><td>ngx服务情况，证书过期，网站访问 量,并发</td><td>ngx&#x2F;haproxy&#x2F;keepalived状态：模板 证书：模板、自定义监控。 网站访问量（运营）：ip,pv,uv(网站第三方插件实现百度统计)， matomo(php piwiki) 并发：统计80,443端口连接数。 负载均衡健康检查模式upstream_check 自定义监控 访问日志(状态码),错误日志(error,failed数量) 服务:ngx,keepalived(vip数量,备节点是否有vip)</td></tr><tr><td>web</td><td>主要监控服务情况</td><td>具体服务使用对应模板即可。 ngx php tomcat(war)&#x2F;jar包</td></tr><tr><td>数据库</td><td>redis,mysql</td><td>模板即可。</td></tr><tr><td>存储</td><td>nfs</td><td>自定义监控，存储目前多少空间,能否使用.模拟挂载,创建文件检查结果.</td></tr><tr><td>备份</td><td>备份的数据量</td><td>自定义监控,系统是否有备份,发送邮件ՎՎʢ占用多少空间.</td></tr></tbody></table><h4 id="a-DNS解析"><a href="#a-DNS解析" class="headerlink" title="a) DNS解析"></a>a) DNS解析</h4><p>zabbix服务端自定义监控</p><p>1、检查DNS是否可用</p><p>ping就可以，Ping通表示DNS可用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 可以创建带有参数的键值## $1是域名 可以解析返回1,否则返回0check.ping[*]，sh脚本“$1”</code></pre></div></figure><p>2、检查域名过期时间</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 域名过期时间（还剩下多少天）check.domain[*],sh 脚本 &quot;$1&quot; ## $1是域名 显示这个域名还有多久 过期(天)whois baidu.com # 过滤 Expiry 取出这个时间</code></pre></div></figure><p>计算两个时间之间有多少天</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@m02-zbx-server ~]# date -d &quot;2024-04-21&quot;Sun Apr 21 00:00:00 CST 2024[root@m02-zbx-server ~]# date -d &quot;2024-04-21&quot; +%s1713628800[root@m02-zbx-server ~]# date +%s1679036681</code></pre></div></figure><p>3、检查https证书过期时间</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#3. https证书过期时间.check.ssl[*],sh 脚本 &quot;$1&quot; #$1是域名 https:&#x2F;&#x2F;# 获取baidu证书过期时间[root@db01 &#x2F;]#curl -v https:&#x2F;&#x2F;baidu.com |&amp; grep &quot;expire date&quot;|awk -F&#39;: &#39; &#39;&#123;print $2&#125;&#39;Mar 01 23:59:59 2025 GMT# 时间格式转换[root@db01 &#x2F;]#date -d &quot;Mar 01 23:59:59 2025 GMT&quot; +%F2025-03-02[root@db01 &#x2F;]#date -d &quot;Mar 01 23:59:59 2025 GMT&quot; +%s1740873599</code></pre></div></figure><h4 id="b）CDN监控"><a href="#b）CDN监控" class="headerlink" title="b）CDN监控"></a>b）CDN监控</h4><p>主要监控：</p><ul><li>流量</li><li>带宽</li><li>(命中率)</li><li>暂时web页面</li></ul><p>怎么实现？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">调用公有云的api接口获取。python&#x2F;golang</code></pre></div></figure><h4 id="c）负载均衡监控"><a href="#c）负载均衡监控" class="headerlink" title="c）负载均衡监控"></a>c）负载均衡监控</h4><p>监控目标：</p><ul><li>基础指标</li><li>服务状态<ul><li>配置ngxin tengine的负载均衡健康检查页面</li><li>nginx状态监控【使用zabbix自带的模板即可】</li><li>访问日志：主要检查状态码，看每一种状态码的数量（最近一小时、最近5000行）</li></ul></li></ul><blockquote><p>如何查看最近一小时的日志</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@lb01 &#x2F;var&#x2F;log&#x2F;nginx]# date +%Y&#x2F;%m&#x2F;%d&quot; &quot;%H&gt;2023&#x2F;03&#x2F;17 15&gt;[root@lb01 &#x2F;var&#x2F;log&#x2F;nginx]# date +%Y&#x2F;%m&#x2F;%d&quot; &quot;%H -d &#39;-1hour&#39;&gt;2023&#x2F;03&#x2F;17 14&gt;[root@lb01 &#x2F;var&#x2F;log&#x2F;nginx]# sed -n &#39;&#x2F;开始的时间&#x2F;,&#x2F;结束&gt;的时间&#x2F;p&#39; access.log</code></pre></div></figure></blockquote><h4 id="d）web服务监控"><a href="#d）web服务监控" class="headerlink" title="d）web服务监控"></a>d）web服务监控</h4><p>监控内容：</p><ul><li>web：nginx 监控，日志监控</li><li>php：日志监控，服务监控</li><li>java：日志，jmxremote</li><li>xxx</li></ul><h4 id="e-数据库监控"><a href="#e-数据库监控" class="headerlink" title="e) 数据库监控"></a>e) 数据库监控</h4><p>监控内容：</p><ul><li>数据库模板监控</li><li>数据库日志监控</li><li>数据空间监控</li></ul><h4 id="f）存储监控"><a href="#f）存储监控" class="headerlink" title="f）存储监控"></a>f）存储监控</h4><p>NFS存储监控内容：</p><ul><li>系统监控</li><li>服务进程监控</li><li>存储是否可用：挂载并创建文件测试</li><li>共存储是否可用</li></ul><p>对象存储监控内容：</p><ul><li>开发书写代码，测试写入</li></ul><h4 id="g）备份服务器监控"><a href="#g）备份服务器监控" class="headerlink" title="g）备份服务器监控"></a>g）备份服务器监控</h4><p>监控内容</p><ul><li>rsync服务是否正常</li><li>空间是否足够</li><li>md5sum值是否正常</li><li>日常模拟数据恢复、故障演练</li></ul><h4 id="h）docker容器监控"><a href="#h）docker容器监控" class="headerlink" title="h）docker容器监控"></a>h）docker容器监控</h4><ul><li>docker系统监控</li><li>docker模板监控</li></ul><h4 id="i）补充监控"><a href="#i）补充监控" class="headerlink" title="i）补充监控"></a>i）补充监控</h4><p>监控内容：</p><ul><li>apm监控网站性能</li><li>用户访问流程链监控</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day68-监控架构-Zabbix(二)</title>
    <link href="/2024/06/18/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day68-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-2/"/>
    <url>/2024/06/18/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day68-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-2/</url>
    
    <content type="html"><![CDATA[<h1 id="监控架构-Zabbix-02"><a href="#监控架构-Zabbix-02" class="headerlink" title="监控架构-Zabbix-02"></a>监控架构-Zabbix-02</h1><p>今日内容：</p><ul><li>Zabbix自定义监控配置</li><li>监控告警配置（邮箱告警、企业微信告警）</li></ul><h1 id="一、自定义监控（核心）"><a href="#一、自定义监控（核心）" class="headerlink" title="一、自定义监控（核心）"></a>一、自定义监控（核心）</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>zabbix模板提供的模板非常丰富，包含 CPU、磁盘、网络、负载等各个方面，为什么还需要自定义模板呢？</p><p>自定义模板的应用场景</p><ul><li>模板中没有我们需要的监控项</li><li>默认模板监控项过多，不需要这么多</li></ul><h2 id="1-2-自定义监控全流程"><a href="#1-2-自定义监控全流程" class="headerlink" title="1.2 自定义监控全流程"></a>1.2 自定义监控全流程</h2><p>流程概括：</p><ul><li>客户端：书写命令或脚本，修改配置文件</li><li>服务端：测试，web页面操作，能不能监控到</li></ul><table><thead><tr><th>步骤</th><th>流程</th><th>备注</th></tr></thead><tbody><tr><td>客户端</td><td>1、Linux：通过命令、脚本取出对应的值</td><td></td></tr><tr><td></td><td>2、Linux：根据zbx要求按照格式、书写配置文件，创建键值</td><td>键值key用于获取客户端数据</td></tr><tr><td></td><td>3、Linux：重启客户端，测试键值是否可用</td><td>zabbix_agent2 -t</td></tr><tr><td>服务端</td><td>1、Linux：服务端测试键值是否可用</td><td>zabbix_get</td></tr><tr><td></td><td>2、web页面：键值与监控项关联</td><td></td></tr><tr><td></td><td>3、web页面：测试</td><td>图形是否能看到，触发器能否正常发出警告</td></tr></tbody></table><h3 id="1-2-1-客户端配置"><a href="#1-2-1-客户端配置" class="headerlink" title="1.2.1 客户端配置"></a>1.2.1 客户端配置</h3><h4 id="a-通过命令、脚本取出对应的值"><a href="#a-通过命令、脚本取出对应的值" class="headerlink" title="a)  通过命令、脚本取出对应的值"></a>a)  通过命令、脚本取出对应的值</h4><p>监控3306端口是否存在？Linux中的命令操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]#ss -lntup | grep -w 80 | wc -l1</code></pre></div></figure><h4 id="b-创建键值与重启"><a href="#b-创建键值与重启" class="headerlink" title="b)  创建键值与重启"></a>b)  创建键值与重启</h4><p>创建键值文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]#cat &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;database.conf #UserParameter&#x3D;key,cmd#UserParameter&#x3D;check.databse,sh &#x2F;server&#x2F;scripts&#x2F;xxx.shUserParameter&#x3D;check.database,ss -lntup|grep -w 3306|wc -l</code></pre></div></figure><blockquote><p>UserParameter&#x3D;key,cmd<br>UserParameter&#x3D;固定写法，表示要自定义键值<br>key表示键值名字，命名最好就是 单词+”.” (点)<br>cmd表示命令或脚本  </p></blockquote><p>重启客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart zabbix-agent2.service</code></pre></div></figure><p>本地测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 &#x2F;]#zabbix_agent2 -t check.databasecheck.database                                [s|1]</code></pre></div></figure><blockquote><p>自定义创建的conf文件，zabbix客户端配置是如何知道的？</p><p>因为客户端配置文件里自带了include代码行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;Include&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.conf</code></pre></div></figure></blockquote><h3 id="1-2-2-服务端配置"><a href="#1-2-2-服务端配置" class="headerlink" title="1.2.2 服务端配置"></a>1.2.2 服务端配置</h3><p>安装工具并手动测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y zabbix-get</code></pre></div></figure><p>zabbix-get工具用于向客户端要指定键值的数据  </p><p>选项说明：</p><ul><li>-s客户端ip地址</li><li>-p客户端端口号，默认10050</li><li>-k指定键值</li></ul><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;]#zabbix_get -s 172.16.1.51 -p 10050 -k check.database1</code></pre></div></figure><h3 id="1-2-3-web页面配置"><a href="#1-2-3-web页面配置" class="headerlink" title="1.2.3 web页面配置"></a>1.2.3 web页面配置</h3><h4 id="a-配置监控选项"><a href="#a-配置监控选项" class="headerlink" title="a)  配置监控选项"></a>a)  配置监控选项</h4><p>进入监控项配置页面</p><p><img src="/../../../img/image-20240618112656304.png" alt="image-20240618112656304"></p><p>创建监控项</p><p><img src="/../../../img/image-20240618112714346.png" alt="image-20240618112714346"></p><p>填写信息，并提交</p><p><img src="/../../../img/image-20240618112907699.png" alt="image-20240618112907699"></p><p>也可以进行测试</p><p><img src="/../../../img/image-20240618112959091.png" alt="image-20240618112959091"></p><p>添加监控项完成，查看添加的监控项  </p><p><img src="/../../../img/image-20240618113029256.png" alt="image-20240618113029256"></p><h4 id="b-web页面查看"><a href="#b-web页面查看" class="headerlink" title="b) web页面查看"></a>b) web页面查看</h4><p>可以在[最新数据]项中以图表的方式查看</p><p><img src="/../../../img/image-20240618113232394.png" alt="image-20240618113232394"></p><p>查看</p><p><img src="/../../../img/image-20240618113249951.png" alt="image-20240618113249951"></p><h4 id="c-web页面-触发器"><a href="#c-web页面-触发器" class="headerlink" title="c) web页面-触发器"></a>c) web页面-触发器</h4><p>根据监控项获取的数值（内容），决定是否要告警、是否要提示异常。<br>trigger扳机  </p><p>进入触发器设置页面</p><p><img src="/../../../img/image-20240618113453869.png" alt="image-20240618113453869"></p><p>点击“创建触发器”</p><p><img src="/../../../img/image-20240618113518040.png" alt="image-20240618113518040"></p><p><img src="/../../../img/image-20240618113738276.png" alt="image-20240618113738276"></p><p>表达式添加<img src="/../../../img/image-20240618113708802.png" alt="image-20240618113708802"></p><p>添加完可以看到</p><p><img src="/../../../img/image-20240618113813948.png" alt="image-20240618113813948"></p><h4 id="d-web页面-添加图形"><a href="#d-web页面-添加图形" class="headerlink" title="d) web页面-添加图形"></a>d) web页面-添加图形</h4><p>进入图形配置页面</p><p><img src="/../../../img/image-20240618114107588.png" alt="image-20240618114107588"></p><p>创建图形</p><p><img src="/../../../img/image-20240618114123354.png" alt="image-20240618114123354"></p><p>填写信息</p><p><img src="/../../../img/image-20240618114220247.png" alt="image-20240618114220247"></p><p>查看图形</p><p><img src="/../../../img/image-20240618114349960.png" alt="image-20240618114349960"></p><p>图形显示出来了，但是中文乱码</p><p><img src="/../../../img/image-20240618114416100.png" alt="image-20240618114416100"></p><p>解决中文乱码问题后</p><p><img src="/../../../img/image-20240618115227439.png" alt="image-20240618115227439"></p><h2 id="1-3-常用键值与触发器函数"><a href="#1-3-常用键值与触发器函数" class="headerlink" title="1.3 常用键值与触发器函数"></a>1.3 常用键值与触发器函数</h2><h3 id="1-3-1-键值"><a href="#1-3-1-键值" class="headerlink" title="1.3.1 键值"></a>1.3.1 键值</h3><p>在监控项中，键值用于获取数据</p><p>常用键值如下：</p><table><thead><tr><th>键值</th><th>说明</th></tr></thead><tbody><tr><td>agent.hostname</td><td>主机名，获取客户端配置文件中指定的主机名</td></tr><tr><td>system.hostname</td><td>主机名，系统的主机名，类似于hostname</td></tr><tr><td>agent.ping</td><td>服务端与客户端是否畅通，通1，非通非1</td></tr><tr><td>net.if.in[if,]</td><td>网络接口上传（进入）流量统计。返回整数，if表示网卡名字 可以忽略</td></tr><tr><td>net.if.out[if,]</td><td>流量流出统计，返回整数</td></tr><tr><td>proc.num[,,,]</td><td>进程数、返回整数。name进程名字、user用户、state进程状态、cmdline进程对应的命令</td></tr><tr><td>net.tcp.port[,port]</td><td>检查是否能建立TCP连接到指定的端口。返回0 - 不能连接，返回1 - 可以连接</td></tr></tbody></table><p>键值案例:</p><p>1、过滤僵尸进程数量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;usr&#x2F;share]#zabbix_get -s 172.16.1.51 -p 10050 -k proc.num[,,zomb]0</code></pre></div></figure><p>2、查看网卡流出流入的流量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;usr&#x2F;share]#zabbix_get -s 172.16.1.51 -p 10050 -k net.if.in[ens33,]6740169[root@mn02 &#x2F;usr&#x2F;share]#zabbix_get -s 172.16.1.51 -p 10050 -k net.if.out[ens33,]962137</code></pre></div></figure><p>3、查看mysql进程数量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;usr&#x2F;share]#zabbix_get -s 172.16.1.51 -p 10050 -k proc.num[mariadbd]1</code></pre></div></figure><p>4、查看3306端口是否开启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;usr&#x2F;share]#zabbix_get -s 172.16.1.51 -p 10050 -k net.tcp.port[,3306]1</code></pre></div></figure><blockquote><p>以上只是部分，如果需要了解更多可以网上查询</p></blockquote><h3 id="1-3-2-触发器函数"><a href="#1-3-2-触发器函数" class="headerlink" title="1.3.2 触发器函数"></a>1.3.2 触发器函数</h3><p>作用：写在触发器表达式中，用于设置报警条件</p><blockquote><p>触发器函数，要结合键值来使用</p></blockquote><p>常用触发器函数如下：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>last()</td><td>取出最新的值</td></tr><tr><td>nodata()</td><td>是否有数据</td></tr><tr><td>diff()</td><td>是否发生变化，一般配合md5check()</td></tr><tr><td>avg()</td><td>平均值</td></tr><tr><td>min()</td><td>最小值</td></tr><tr><td>max()</td><td>最大值</td></tr></tbody></table><p>案例：分析模板自带的触发器：&#x2F;etc&#x2F;passwd文件的变化情况，检查是否有用户增加或删减</p><p><img src="/../../../img/image-20240619152156362.png" alt="image-20240619152156362"></p><p>里面是这么写的</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">last(&#x2F;db01&#x2F;vfs.file.cksum[&#x2F;etc&#x2F;passwd,sha256],#1)&lt;&gt;last(&#x2F;db01&#x2F;vfs.file.cksum[&#x2F;etc&#x2F;passwd,sha256],#2)</code></pre></div></figure><p>作用是什么？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 检查倒数第一个&#x2F;etc&#x2F;passwd的md5值（最近的倒数第一个）last(&#x2F;db01&#x2F;vfs.file.cksum[&#x2F;etc&#x2F;passwd,sha256],#1)# 检查倒数第2个&#x2F;etc&#x2F;passwd的md5值（最近的倒数第二个）&lt;&gt;last(&#x2F;db01&#x2F;vfs.file.cksum[&#x2F;etc&#x2F;passwd,sha256],#2)</code></pre></div></figure><p>倒数第1个md5的值和倒数第2个md5的值如果不相等了，则报警.</p><h4 id="1-3-2-1-案例：检查swap值"><a href="#1-3-2-1-案例：检查swap值" class="headerlink" title="1.3.2.1 案例：检查swap值"></a>1.3.2.1 案例：检查swap值</h4><p>需求：</p><ul><li>条件1：swap总量大于0(系统有swap)</li><li>条件2：swap当前的使用量大于0(没有直接可以使用的监控项，这里调整为当前swap空闲率小于100)</li></ul><p>如何表示？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、找出满足要求的键值system.swap.size[,total]) #取出swap总数last(&#x2F;web01&#x2F;system.swap.size[,used]) #swap使用大小# 2、条件1:swap总量大于0last(&#x2F;web01&#x2F;system.swap.size[,total])&gt;0# 3、条件2：swap使用量大于0（空闲率小于100）last(&#x2F;web01&#x2F;system.swap.size[,pfree])&lt;100# 4、条件3：与和或-a &#x3D;&#x3D;&gt; and-o &#x3D;&#x3D;&gt; or</code></pre></div></figure><p>完整表达式如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">last(&#x2F;web01&#x2F;system.swap.size[,total])&gt;0 and last(&#x2F;web01&#x2F;system.swap.size[,used])&gt;0</code></pre></div></figure><p>创建触发器，进入触发器配置页面</p><p><img src="/../../../img/image-20240619152950813.png" alt="image-20240619152950813"></p><p>为web01创建触发器</p><p><img src="/../../../img/image-20240619153015348.png" alt="image-20240619153015348"></p><p>填写表达式</p><p><img src="/../../../img/image-20240619153320441.png" alt="image-20240619153320441"></p><h4 id="1-3-2-2-其他案例"><a href="#1-3-2-2-其他案例" class="headerlink" title="1.3.2.2 其他案例"></a>1.3.2.2 其他案例</h4><p>检查内存是否够用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">max(&#x2F;Zabbix server&#x2F;vm.memory.size[available],5m)&lt;&#123;$MEMORY.AVAILABLE.MIN&#125; and last(&#x2F;Zabbix server&#x2F;vm.memory.size[total])&gt;0</code></pre></div></figure><h2 id="1-4-自定义监控-参数案例"><a href="#1-4-自定义监控-参数案例" class="headerlink" title="1.4 自定义监控- 参数案例"></a>1.4 自定义监控- 参数案例</h2><p>目标：检查指定用户是否存在异地登录。<br>最简单想法：检查指定用户登录的ip地址。进行对比。  </p><p>1、命令选择</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">w、who只能显示当前、自此时此刻的登录情况，不适用lastlog 适合</code></pre></div></figure><p>2、键值</p><p>实现取出指定用户登录的IP地址</p><p>服务器：web页面触发器作对比</p><h3 id="1-4-1-客户端配置"><a href="#1-4-1-客户端配置" class="headerlink" title="1.4.1 客户端配置"></a>1.4.1 客户端配置</h3><p>命令获取登录的ip地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;app&#x2F;code&#x2F;zbx&#x2F;assets&#x2F;fonts]#lastlog | grep root | awk &#39;&#123;print $3&#125;&#39;10.0.0.1</code></pre></div></figure><p>书写键值</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;app&#x2F;code&#x2F;zbx&#x2F;assets&#x2F;fonts]#cat &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;web.conf UserParameter&#x3D;ngx.port,ss -lntup |grep -w 80|wc -lUserParameter&#x3D;user.login[*],lastlog -u &quot;$1&quot; |awk &#39;NR&#x3D;&#x3D;2&#123;print $3&#125;&#39;</code></pre></div></figure><p>里面的<code>$1</code>传递参数如何运作？</p><p><img src="/../../../img/image-20240619154505001.png" alt="image-20240619154505001"></p><p>重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart zabbix-agent2.service</code></pre></div></figure><h3 id="1-4-2-服务端测试"><a href="#1-4-2-服务端测试" class="headerlink" title="1.4.2 服务端测试"></a>1.4.2 服务端测试</h3><p>命令测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;usr&#x2F;share]#zabbix_get -s 172.16.1.7 -k user.login[root]root             pts&#x2F;1    10.0.0.1         Wed Jun 19 15:17:51 +0800 2024</code></pre></div></figure><h3 id="1-4-3-web界面配置"><a href="#1-4-3-web界面配置" class="headerlink" title="1.4.3 web界面配置"></a>1.4.3 web界面配置</h3><p>为web01配置监控项，注意使用<code>字符</code>类型</p><p><img src="/../../../img/image-20240619155112017.png" alt="image-20240619155112017"></p><p>测试可以正常获取值</p><p><img src="/../../../img/image-20240619155150760.png" alt="image-20240619155150760"></p><p>配置触发器</p><p><img src="/../../../img/image-20240619155315495.png" alt="image-20240619155315495"></p><h3 id="1-4-4-测试"><a href="#1-4-4-测试" class="headerlink" title="1.4.4 测试"></a>1.4.4 测试</h3><p>使用db01登录web01服务器，之前一直都是用10.0.0.1登录的，这里换了10.0.0.51登录，会报警吗？</p><p>可见产生一条警告</p><p><img src="/../../../img/image-20240619155608270.png" alt="image-20240619155608270"></p><p>按照我们设定的预期报错</p><p><img src="/../../../img/image-20240619155716751.png" alt="image-20240619155716751"></p><p>可以看到新登录的IP为10.0.0.51，报警有效</p><p><img src="/../../../img/image-20240619155742997.png" alt="image-20240619155742997"></p><h2 id="1-5-使用模板"><a href="#1-5-使用模板" class="headerlink" title="1.5 使用模板"></a>1.5 使用模板</h2><p>通过创建自定义模板实现：监控项、触发器、图形的批量使用</p><p>步骤：</p><ol><li>创建模板</li><li>创建自定义监控项</li><li>添加触发器</li><li>添加图形</li><li>模板关联主机</li><li>客户端配置自定义键值</li></ol><h3 id="1-5-1-创建模板"><a href="#1-5-1-创建模板" class="headerlink" title="1.5.1 创建模板"></a>1.5.1 创建模板</h3><p>1、进入创建模板页面</p><p><img src="/../../../img/image-20240619160850620.png" alt="image-20240619160850620"></p><p>2、填写信息</p><p><img src="/../../../img/image-20240619161115893.png" alt="image-20240619161115893"></p><p>3、检查创建完毕</p><p><img src="/../../../img/image-20240619161219562.png" alt="image-20240619161219562"></p><h3 id="1-5-2-添加自定义监控项"><a href="#1-5-2-添加自定义监控项" class="headerlink" title="1.5.2 添加自定义监控项"></a>1.5.2 添加自定义监控项</h3><p>可以从主机中复制，进入主机监控项页面</p><p><img src="/../../../img/image-20240619161354521.png" alt="image-20240619161354521"></p><p>勾选需要复制的项，再点击“复制”</p><p><img src="/../../../img/image-20240619161425952.png" alt="image-20240619161425952"></p><p>选择“模板”，再选择已创建的模板</p><p><img src="/../../../img/image-20240619161503425.png" alt="image-20240619161503425"></p><p>提示复制成功</p><p><img src="/../../../img/image-20240619161530739.png" alt="image-20240619161530739"></p><p>检查模板的监控项，复制的已经加进去了</p><p><img src="/../../../img/image-20240619161609669.png" alt="image-20240619161609669"></p><h3 id="1-5-3-添加自定义触发器和图形"><a href="#1-5-3-添加自定义触发器和图形" class="headerlink" title="1.5.3 添加自定义触发器和图形"></a>1.5.3 添加自定义触发器和图形</h3><p>跟监控项一样的操作，从主机中复制过去就行</p><p><img src="/../../../img/image-20240619161737657.png" alt="image-20240619161737657"></p><p><img src="/../../../img/image-20240619161805750.png" alt="image-20240619161805750"></p><h3 id="1-5-4-模板关联主机"><a href="#1-5-4-模板关联主机" class="headerlink" title="1.5.4 模板关联主机"></a>1.5.4 模板关联主机</h3><p>批量选择要添加模板的主机，批量更新</p><p><img src="/../../../img/image-20240619162105769.png" alt="image-20240619162105769"></p><h3 id="1-5-5-配置linux客户端键值"><a href="#1-5-5-配置linux客户端键值" class="headerlink" title="1.5.5 配置linux客户端键值"></a>1.5.5 配置linux客户端键值</h3><p>分发键值配置文件到db01和nfs01等客户端服务器，重启zbx agent2服务即可</p><h1 id="二、监控告警"><a href="#二、监控告警" class="headerlink" title="二、监控告警"></a>二、监控告警</h1><h2 id="2-1-告警分类"><a href="#2-1-告警分类" class="headerlink" title="2.1 告警分类"></a>2.1 告警分类</h2><p>常用的告警方式</p><table><thead><tr><th>告警方式</th><th>应用场景</th></tr></thead><tbody><tr><td>邮件通知</td><td>个人&#x2F;企业邮箱，免费</td></tr><tr><td>企业微信（告警应用支持，机器人）</td><td>需要企业微信支持，免费</td></tr><tr><td>OA系统（钉钉、飞鸽）</td><td>与阿里云配合使用，免费</td></tr><tr><td>短信</td><td>0.0.45元&#x2F;条，如阿里云短信服务，收费</td></tr><tr><td>电话</td><td>收费</td></tr><tr><td>第三方报警工具：onealert（省事）</td><td>只需要配置onealert平台信息，提供免费&#x2F;收费服务</td></tr></tbody></table><h2 id="2-2-邮件告警配置"><a href="#2-2-邮件告警配置" class="headerlink" title="2.2 邮件告警配置"></a>2.2 邮件告警配置</h2><p>流程：</p><ul><li>创建个人&#x2F;企业邮箱</li><li>开启个人&#x2F;企业邮箱的smtp功能，获取授权码</li><li>发件人：配置zbbix 告警媒介类型</li><li>收件人：配置用户，接受警告</li><li>发件条件：配置动作</li></ul><h3 id="2-2-1-个人邮箱准备"><a href="#2-2-1-个人邮箱准备" class="headerlink" title="2.2.1 个人邮箱准备"></a>2.2.1 个人邮箱准备</h3><p>如QQ邮箱，生成授权码</p><p><img src="/../../../img/image-20240619165311773.png" alt="image-20240619165311773"></p><h3 id="2-2-2-Zabbix配置发件人"><a href="#2-2-2-Zabbix配置发件人" class="headerlink" title="2.2.2 Zabbix配置发件人"></a>2.2.2 Zabbix配置发件人</h3><p>进入”报警媒介类型”设置界面，选择“Email”，也可以点击右上角“创建媒介类型”</p><p><img src="/../../../img/image-20240619165501188.png" alt="image-20240619165501188"></p><p>配置邮件告警</p><p><img src="/../../../img/image-20240619165745223.png" alt="image-20240619165745223"></p><p>告警消息的模板Message templates设置</p><p>**<img src="/../../../img/image-20240619165940108.png" alt="image-20240619165940108"></p><p>测试发送一封邮件</p><p><img src="/../../../img/image-20240619170427864.png" alt="image-20240619170427864"></p><p>生效</p><p><img src="/../../../img/image-20240619170444469.png" alt="image-20240619170444469"></p><h3 id="2-2-3-配置收件人"><a href="#2-2-3-配置收件人" class="headerlink" title="2.2.3 配置收件人"></a>2.2.3 配置收件人</h3><p>在Zabbix管理员设置中，添加报警媒介</p><p><img src="/../../../img/image-20240619170705301.png" alt="image-20240619170705301"></p><p>添加完成，记得点“更新”</p><p><img src="/../../../img/image-20240619170718488.png" alt="image-20240619170718488"></p><h3 id="2-2-4-设置邮件触发条件"><a href="#2-2-4-设置邮件触发条件" class="headerlink" title="2.2.4 设置邮件触发条件"></a>2.2.4 设置邮件触发条件</h3><p>什么情况下给用户发邮件？</p><p>配置触发器动作，启用即可</p><p><img src="/../../../img/image-20240619170910116.png" alt="image-20240619170910116"></p><h3 id="2-2-5-测试，制造故障"><a href="#2-2-5-测试，制造故障" class="headerlink" title="2.2.5 测试，制造故障"></a>2.2.5 测试，制造故障</h3><p>使用10.0.0.51登录10.0.0.7，制造故障，邮件正常收到</p><p><img src="/../../../img/image-20240619171350213.png" alt="image-20240619171350213"></p><h2 id="2-3-企业微信告警配置（了解）"><a href="#2-3-企业微信告警配置（了解）" class="headerlink" title="2.3 企业微信告警配置（了解）"></a>2.3 企业微信告警配置（了解）</h2><p>流程：</p><ul><li>准备企业微信</li><li>企业微信ID和告警机器人ID和secret</li><li>使用脚本调用企业微信的api接口</li><li>发件人：告警媒介（告警机器人）</li><li>收件人：个人 媒体类型</li><li>动作：已经完成</li></ul><h3 id="2-3-1-准备企业微信"><a href="#2-3-1-准备企业微信" class="headerlink" title="2.3.1 准备企业微信"></a>2.3.1 准备企业微信</h3><p>企业微信ID准备</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1.企业微信 id号企业ID ww6ac68d5d41044330#2.创建1个报警机器人(应用)机器人的id(应用id)AgentId1000005##应用密码Ss7VFx8Mkzm8XABMNqVRp31zxNnxhbJ_rJzz8sPDgk4</code></pre></div></figure><p>微信报警脚本准备</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1.企业微信 id号企业IDww6ac68d5d41044330#2.创建1个报警机器人(应用)##机器人的id(应用id)  AgentId1000005##应用密码  Ss7VFx8Mkzm8XABMNqVRp31zxNnxhbJ_rJzz8sPDgk4#修改微信报警的脚本vim &#x2F;usr&#x2F;local&#x2F;share&#x2F;zabbix&#x2F;alertscripts&#x2F;wechat.py#!&#x2F;usr&#x2F;bin&#x2F;env python#-*- coding: utf-8 -*-#author: oldboy-linux#date: 2021#description: Zabbix Wechat Alerts Scriptsimport requestsimport sysimport osimport jsonimport logginglogging.basicConfig(level &#x3D; logging.DEBUG, format &#x3D; &#39;%(asctime)s, %(filename)s, %(levelname)s, %(message)s&#39;,                datefmt &#x3D; &#39;%a, %d %b %Y %H:%M:%S&#39;,                filename &#x3D; os.path.join(&#39;&#x2F;tmp&#39;,&#39;wechat.log&#39;),                filemode &#x3D; &#39;a&#39;)               #id和secret需要修改corpid&#x3D;&#39;wxd074861951c67ba6&#39;appsecret&#x3D;&#39;QtraZrI936DZ0jZ3aSWTZ-lFVheAMgLmq3toM4B9U1A&#39;agentid&#x3D;1#获取accesstokentoken_url&#x3D;&#39;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;gettoken?corpid&#x3D;&#39; + corpid + &#39;&amp;corpsecret&#x3D;&#39; + appsecretreq&#x3D;requests.get(token_url)accesstoken&#x3D;req.json()[&#39;access_token&#39;]#发送消息msgsend_url&#x3D;&#39;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;message&#x2F;send?access_token&#x3D;&#39; + accesstoken#脚本参数#touser&#x3D;sys.argv[1]toparty&#x3D;sys.argv[1]subject&#x3D;sys.argv[2]#toparty&#x3D;&#39;3|4|5|6&#39;message&#x3D;sys.argv[2] + &quot;\n\n&quot; +sys.argv[3]params&#x3D;&#123;#       &quot;touser&quot;: touser,       &quot;toparty&quot;: toparty,        &quot;msgtype&quot;: &quot;text&quot;,        &quot;agentid&quot;: agentid,        &quot;text&quot;: &#123;                &quot;content&quot;: message       &#125;,        &quot;safe&quot;:0&#125;req&#x3D;requests.post(msgsend_url, data&#x3D;json.dumps(params))# 书写日志&#x2F;tmp&#x2F;wechat.loglogging.info(&#39;sendto:&#39; + toparty + &#39;;;subject:&#39; + subject + &#39;;;message:&#39; + message)chmod +x &#x2F;usr&#x2F;lib&#x2F;zabbix&#x2F;alertscripts&#x2F;wechat.py#安装python环境yum install -y python3 python3-pip通过pip3 命令安装requests依赖.pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple requests#测试python3 wechat.py 用户的id或组id 标题 内容 &#39;下雨了&#39;  &#39;打雷下雨收衣服&#39;Traceback (most recent call last):File &quot;&#x2F;usr&#x2F;lib&#x2F;zabbix&#x2F;alertscripts&#x2F;wechat.py&quot;, line 7, in &lt;module&gt;   import requestsImportError: No module named requestspip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-packagepip install requests#web页面 发件人:报警媒介类型&#123;ALERT.SENDTO&#125;  #发给谁&#123;ALERT.SUBJECT&#125; #报警标题&#123;ALERT.MESSAGE&#125; #报警内容故障目前已经解决时间: &#123;EVENT.RECOVERY.TIME&#125; 日期&#123;EVENT.RECOVERY.DATE&#125;故障名称: &#123;EVENT.NAME&#125;故障经历多久: &#123;EVENT.DURATION&#125;故障主机: &#123;HOST.NAME&#125;故障级别: &#123;EVENT.SEVERITY&#125;故障ID: &#123;EVENT.ID&#125;&#123;TRIGGER.URL&#125;#web页面 收件人:接收用户#Web页面 配置--&gt;动作</code></pre></div></figure><p>需要去企业微信后台,开通白名单  </p><p><img src="/../../../img/image-20240619172914240.png" alt="image-20240619172914240"></p><p><img src="/../../../img/image-20240619172930025.png" alt="image-20240619172930025"></p><p><img src="/../../../img/image-20240619172938289.png" alt="image-20240619172938289"></p><p><img src="/../../../img/image-20240619172944777.png" alt="image-20240619172944777"></p><p>错误提示</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">故障提示：python3 wechat-v2-lidao996.py lidao996  &quot;webisdown&quot; &quot;nginx is down&quot;Traceback (most recent call last): File &quot;wechat-v2-lidao996.py&quot;, line 7, in &lt;module&gt;   import requestsModuleNotFoundError: No module named &#39;requests&#39;故障解决：pip3 install requests -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple新的安装方法:python3 -m pip install requests -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</code></pre></div></figure><h3 id="2-3-2-配置发件人"><a href="#2-3-2-配置发件人" class="headerlink" title="2.3.2 配置发件人"></a>2.3.2 配置发件人</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;ALERT.SENDTO&#125;&#123;ALERT.SUBJECT&#125;&#123;ALERT.MESSAGE&#125;</code></pre></div></figure><p>添加报警媒介类型</p><p><img src="/../../../img/image-20240619173115608.png" alt="image-20240619173115608"></p><p>添加报警内容模板</p><p><img src="/../../../img/image-20240619173139714.png" alt="image-20240619173139714"></p><p>测试发件人</p><p><img src="/../../../img/image-20240619173157973.png" alt="image-20240619173157973"></p><h3 id="2-3-3-配置收件人"><a href="#2-3-3-配置收件人" class="headerlink" title="2.3.3 配置收件人"></a>2.3.3 配置收件人</h3><p>添加报警媒介</p><p><img src="/../../../img/image-20240619173307720.png" alt="image-20240619173307720"></p><p>设置企业微信告警</p><p><img src="/../../../img/image-20240619173320019.png" alt="image-20240619173320019"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day67-监控架构-Zabbix(一)</title>
    <link href="/2024/06/05/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day67-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-1/"/>
    <url>/2024/06/05/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day67-%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84-Zabbix-1/</url>
    
    <content type="html"><![CDATA[<h1 id="监控架构-Zabbix-01"><a href="#监控架构-Zabbix-01" class="headerlink" title="监控架构-Zabbix-01"></a>监控架构-Zabbix-01</h1><p>今日内容：</p><p>- </p><h1 id="一、Zabbix概述"><a href="#一、Zabbix概述" class="headerlink" title="一、Zabbix概述"></a>一、Zabbix概述</h1><p>Zabbix是一个CS(服务端&#x2F;客户端)架构的服务.  </p><p>它的整体架构：</p><ul><li>客户端agent收集集群信息</li><li>agent反馈收集的信息给server服务端</li><li>通过前端展示数据</li></ul><p><img src="/../../../img/image-20240605110210091.png" alt="image-20240605110210091"></p><h1 id="二、Zabbix使用指南"><a href="#二、Zabbix使用指南" class="headerlink" title="二、Zabbix使用指南"></a>二、Zabbix使用指南</h1><h2 id="2-1-主机规划"><a href="#2-1-主机规划" class="headerlink" title="2.1 主机规划"></a>2.1 主机规划</h2><h3 id="2-1-1-推荐配置"><a href="#2-1-1-推荐配置" class="headerlink" title="2.1.1 推荐配置"></a>2.1.1 推荐配置</h3><table><thead><tr><th>规模</th><th>平台</th><th>CPU&#x2F;内存</th><th>数据库</th><th>受监控的主机数 量</th></tr></thead><tbody><tr><td>小型</td><td>CentOS</td><td>Virtual Appliance</td><td>MySQL InnoDB</td><td>100</td></tr><tr><td>中型</td><td>CentOS</td><td>2 CPU cores&#x2F;2GB</td><td>MySQL InnoDB</td><td>500</td></tr><tr><td>大型</td><td>RedHat Enterprise Linux</td><td>4 CPU cores&#x2F;8GB</td><td>RAID10 MySQL InnoDB 或 PostgreSQL</td><td>&gt;1000</td></tr><tr><td>极大 型</td><td>RedHat Enterprise Linux</td><td>8 CPU cores&#x2F;16GB</td><td>Fast RAID10 MySQL InnoDB PostgreSQL 或</td><td>&gt;10000</td></tr></tbody></table><h3 id="2-1-2-磁盘容量估算"><a href="#2-1-2-磁盘容量估算" class="headerlink" title="2.1.2 磁盘容量估算"></a>2.1.2 磁盘容量估算</h3><table><thead><tr><th>参数</th><th>所需磁盘空间的计算公式 （单位：字节）</th></tr></thead><tbody><tr><td>Zabbix 配置 文件</td><td>固定大小。通常为 10MB 或更少。</td></tr><tr><td>History (历 史数据)</td><td>days (items&#x2F;refresh rate) 24 3600 bytes items：监控项数量。 days：保留历史数据的天数。 refresh rate：监控项的更新间隔。 bytes：保留单个值所需要占用的字节数，依赖于数据库引擎，通常为 ~90 字节。</td></tr><tr><td>Trends (趋 势数据)</td><td>days (items&#x2F;3600) 24 3600 bytes items：监控项数量。 days：保留历史数据的天数。 bytes：保留单个趋 势数据所需要占用的字节数，依赖于数据库引擎，通常为 ~90 字节。</td></tr><tr><td>Events (事 件数据)</td><td>days events 24 3600 bytes events：每秒产生的事件数量。假设最糟糕的情况下，每秒产生 1 个事件。 days：保留历史数据的天数。 bytes：保留单个趋势数据所需的字节数，取决于数据库引擎，通常为 ~170 字节。</td></tr></tbody></table><h3 id="2-1-3-实验环境准备"><a href="#2-1-3-实验环境准备" class="headerlink" title="2.1.3 实验环境准备"></a>2.1.3 实验环境准备</h3><table><thead><tr><th>角色</th><th>主机名</th><th>eth0&#x2F;eth1</th><th>配置</th></tr></thead><tbody><tr><td>zabbix server</td><td>m02</td><td>10.0.0.62&#x2F;172.16.1.62</td><td>1C1G(实际推荐1C2G)</td></tr><tr><td>Zabbix前端界面</td><td>web01</td><td>10.0.0.7&#x2F;172.16.1.7</td><td>1C1G</td></tr><tr><td>Zabbix数据库</td><td>db01</td><td>10.0.0.51&#x2F;172.16.1.51</td><td>1C1G</td></tr><tr><td>Zabbix客户端</td><td>nfs01</td><td>10.0.0.31&#x2F;172.16.1.31</td><td>1C1G</td></tr><tr><td>其他综合架构部分的主机都是客户端</td><td></td><td></td><td></td></tr></tbody></table><h2 id="2-2-服务端部署-管理端"><a href="#2-2-服务端部署-管理端" class="headerlink" title="2.2 服务端部署-管理端"></a>2.2 服务端部署-管理端</h2><p>部署zabbix服务端流程</p><ol><li>部署ngx+php环境并测试</li><li>部署数据库 mariadb 10.5及以上 然后进行配置</li><li>编译安装zabbix-server服务端及后续配置</li><li>部署前端代码代码进行访问</li><li>web访问</li><li>配置客户端</li></ol><h3 id="2-2-1-部署ngx-php环境"><a href="#2-2-1-部署ngx-php环境" class="headerlink" title="2.2.1 部署ngx+php环境"></a>2.2.1 部署ngx+php环境</h3><blockquote><p>以下操作在web01 - 10.0.0.7中执行</p></blockquote><p>1、准备yum repo</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># nginx的[root@web01 ~]#cat &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo [nginx-stable]name&#x3D;nginx stable repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;gpgcheck&#x3D;1enabled&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.keymodule_hotfixes&#x3D;true# 阿里源加速curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo#webtatic 要求yum install epel-release.noarch -y#webtatic源rpm -Uvhhttps:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;webtaticrelease.rpm </code></pre></div></figure><p>2、安装Nginx和php</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install php72w-cli php72w-fpm php72w-gd php72wmbstring php72w-bcmath php72w-xml php72w-ldap php72wmysqlnd -y</code></pre></div></figure><p>3、检查安装结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]#rpm -qa | egrep &#39;nginx|php&#39;nginx-1.26.0-1.el7.ngx.x86_64php72w-cli-7.2.34-1.w7.x86_64php72w-pecl-igbinary-3.1.2-1.w7.x86_64php72w-gd-7.2.34-1.w7.x86_64php72w-fpm-7.2.34-1.w7.x86_64php72w-opcache-7.2.34-1.w7.x86_64php72w-xml-7.2.34-1.w7.x86_64php72w-pear-1.10.12-1.w7.noarchphp72w-pdo-7.2.34-1.w7.x86_64php72w-pecl-memcached-3.1.5-1.w7.x86_64php72w-mysqlnd-7.2.34-1.w7.x86_64php72w-pecl-mongodb-1.7.4-1.w7.x86_64mod_php72w-7.2.34-1.w7.x86_64php72w-mbstring-7.2.34-1.w7.x86_64php72w-ldap-7.2.34-1.w7.x86_64php72w-common-7.2.34-1.w7.x86_64php72w-process-7.2.34-1.w7.x86_64php72w-devel-7.2.34-1.w7.x86_64php72w-pecl-redis-3.1.6-1.w7.x86_64php72w-embedded-7.2.34-1.w7.x86_64php72w-bcmath-7.2.34-1.w7.x86_64</code></pre></div></figure><p>4、配置nginx虚拟主机</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;]#cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;zbx.test.cn.conf server &#123;  listen 80;  server_name zbx.test.cn;  root &#x2F;app&#x2F;code&#x2F;zbx;  location &#x2F; &#123;    index index.php;  &#125;  location ~ \.php$ &#123;    fastcgi_pass 127.0.0.1:9000;    fastcgi_index index.php;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;  &#125;&#125;</code></pre></div></figure><p>5、配置php</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 更换用户名为www[root@web01 &#x2F;]#sed -ri &#39;&#x2F;^(user|group)&#x2F;s#apache#nginx#g&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf# 进行检查[root@web01 &#x2F;]#egrep &#39;^(user|group)&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf user &#x3D; wwwgroup &#x3D; www</code></pre></div></figure><p>6、创建站点目录和测试文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;]#cat &lt;&lt; EOF &gt; &#x2F;app&#x2F;code&#x2F;zbx&#x2F;index.php&gt; &lt;?php&gt; phpinfo();&gt; ?&gt;&gt; EOF</code></pre></div></figure><p>7、启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable --now nginx php-fpm</code></pre></div></figure><p>8、配置hosts进行测试</p><p><a href="http://zbx.test.cn/">http://zbx.test.cn/</a></p><p><img src="/../../../img/image-20240605115558801.png" alt="image-20240605115558801"></p><h3 id="2-2-2-部署数据库"><a href="#2-2-2-部署数据库" class="headerlink" title="2.2.2 部署数据库"></a>2.2.2 部署数据库</h3><blockquote><p>以下操作在db01 - 10.0.0.51操作</p></blockquote><p>1、配置mariadb的repo源</p><p>zabbix 6.0 不支持默认源中的mariadb（mariadb 5.5版本），需要配置repo源安装新版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置repo[mariadb]name&#x3D;MariaDBbaseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;mariadb&#x2F;yum&#x2F;10.5&#x2F;centos7-amd64&#x2F;gpgkey&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;mariadb&#x2F;yum&#x2F;RPM-GPG-KEY-MariaDBgpgcheck&#x3D;1enabled&#x3D;1# 安装yum install -y mariadb-server# 检查[root@db01 ~]#!rpmrpm -qa | grep -i mariadbMariaDB-common-10.5.25-1.el7.centos.x86_64MariaDB-compat-10.5.25-1.el7.centos.x86_64MariaDB-client-10.5.25-1.el7.centos.x86_64MariaDB-server-10.5.25-1.el7.centos.x86_64</code></pre></div></figure><p>2、启动数据库服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable mariadbsystemctl start mariadb</code></pre></div></figure><p>3、数据库初始配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">数据库初始化mysql_secure_installation 仅1次。Enter current password for root (enter for none):回车Switch to unix_socket authentication [Y&#x2F;n] 输入nChange the root password? [Y&#x2F;n] 输入n 不设置root密码Remove anonymous users? [Y&#x2F;n] 输入YDisallow root login remotely? [Y&#x2F;n] 输入YRemove test database and access to it? [Y&#x2F;n] 输入YReload privilege tables now? [Y&#x2F;n] 输入YThanks for using MariaDB! 表示完成</code></pre></div></figure><p>创建数据库和用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">MariaDB [(none)]&gt; create database zabbix charset utf8 collate utf8_bin;Query OK, 1 row affected (0.000 sec)MariaDB [(none)]&gt; grant all on zabbix.* to &#39;zabbix&#39;@&#39;172.16.1.%&#39; identified by &#39;zabbix&#39;;Query OK, 0 rows affected (0.000 sec)</code></pre></div></figure><p>4、官网下载zabbix源码</p><p><a href="https://www.zabbix.com/cn/download_sources#60LTS">https://www.zabbix.com/cn/download_sources#60LTS</a></p><p>4、导入zabbix数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压[root@db01 ~]#tar -vxf zabbix-6.0.30.tar.gz、# 进入目录cd zabbix-6.0.30&#x2F;database&#x2F;mysql# 导入数据库，注意顺序[root@db01 ~&#x2F;zabbix-6.0.30&#x2F;database&#x2F;mysql]#mysql -uzabbix -pzabbix zabbix&lt; schema.sql [root@db01 ~&#x2F;zabbix-6.0.30&#x2F;database&#x2F;mysql]#mysql -uzabbix -pzabbix zabbix&lt; images.sql [root@db01 ~&#x2F;zabbix-6.0.30&#x2F;database&#x2F;mysql]#mysql -uzabbix -pzabbix zabbix&lt; data.sql [root@db01 ~&#x2F;zabbix-6.0.30&#x2F;database&#x2F;mysql]#mysql -uzabbix -pzabbix zabbix&lt; double.sql [root@db01 ~&#x2F;zabbix-6.0.30&#x2F;database&#x2F;mysql]#mysql -uzabbix -pzabbix zabbix&lt; history_pk_prepare.sql </code></pre></div></figure><p>5、检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~&#x2F;zabbix-6.0.30&#x2F;database&#x2F;mysql]#mysql -uzabbix -p -e &#39;show tables from zabbix;&#39; | wc -lEnter password: 179</code></pre></div></figure><h3 id="2-2-3-编译安装zabbix-server服务端"><a href="#2-2-3-编译安装zabbix-server服务端" class="headerlink" title="2.2.3 编译安装zabbix-server服务端"></a>2.2.3 编译安装zabbix-server服务端</h3><blockquote><p>此操作在mn02 - 10.0.0.62操作</p></blockquote><p>1、安装依赖包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y mysql-devel pcre-devel openssl-devel zlib-devel libxml2-devel net-snmp-devel net-snmp libssh2-devel OpenIPMI-devel libevent-devel openldap-devel libcurl-devel</code></pre></div></figure><p>2、coinfigure 源码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --sysconfdir&#x3D;&#x2F;etc&#x2F;zabbix&#x2F; --enable-server --with-mysql --with-net-snmp --with-libxml2 --with-ssh2 --with-openipmi --with-zlib --with-libpthread --with-libevent --with-openssl --with-ldap --with-libcurl --with-libpcre</code></pre></div></figure><p>3、编译，安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make &amp;&amp; make install</code></pre></div></figure><p>4、检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~&#x2F;zabbix-6.0.30]#echo $?0</code></pre></div></figure><h3 id="2-2-4-zabbix配置和启动"><a href="#2-2-4-zabbix配置和启动" class="headerlink" title="2.2.4 zabbix配置和启动"></a>2.2.4 zabbix配置和启动</h3><p>修改配置文件（连接数据库）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~&#x2F;zabbix-6.0.30]#grep -n &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf12:ListenPort&#x3D;1005138:LogFile&#x3D;&#x2F;tmp&#x2F;zabbix_server.log87:DBHost&#x3D;172.16.1.5199:DBName&#x3D;zabbix115:DBUser&#x3D;zabbix123:DBPassword&#x3D;zabbix507:Timeout&#x3D;4593:LogSlowQueries&#x3D;3000708:StatsAllowedIP&#x3D;127.0.0.1</code></pre></div></figure><p>创建zabbix用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~&#x2F;zabbix-6.0.30]#useradd -s &#x2F;sbin&#x2F;nologin -M zabbix</code></pre></div></figure><p>启动zabbix服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~&#x2F;zabbix-6.0.30]#zabbix_server [root@mn02 ~&#x2F;zabbix-6.0.30]#ss -lntup | grep 10051tcp    LISTEN     0      128       *:10051                 *:*                   users:((&quot;zabbix_server&quot;,pid&#x3D;27130,fd&#x3D;9),(&quot;zabbix_server&quot;,pid&#x3D;27129,fd&#x3D;9)...</code></pre></div></figure><h3 id="2-2-5-systemctl配置"><a href="#2-2-5-systemctl配置" class="headerlink" title="2.2.5 systemctl配置"></a>2.2.5 systemctl配置</h3><p>书写systemctl配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~&#x2F;zabbix-6.0.30]#cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;zabbix-serber.service[Unit]Description&#x3D;Zabbix Server with MySQL DBAfter&#x3D;syslog.target network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;zabbix_server -fUser&#x3D;zabbix[Install]WantedBy&#x3D;multi-user.target</code></pre></div></figure><p>重新加载服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload</code></pre></div></figure><p>关闭已经打开的zabbix服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkill zabbix</code></pre></div></figure><p>使用systemctl控制开启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~&#x2F;zabbix-6.0.30]#systemctl enable zabbix-serverCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;zabbix-server.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;zabbix-server.service.[root@mn02 ~&#x2F;zabbix-6.0.30]#systemctl start zabbix-server</code></pre></div></figure><p>查看状态</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 ~&#x2F;zabbix-6.0.30]#systemctl status zabbix-server● zabbix-server.service - Zabbix Server with MySQL DB   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;zabbix-server.service; enabled; vendor preset: disabled)   Active: active (running) since Fri 2024-06-07 14:51:32 CST; 10s ago Main PID: 27505 (zabbix_server)   CGroup: &#x2F;system.slice&#x2F;zabbix-server.service           ├─27505 &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;zabbix_server -f           ├─27506 &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;zabbix_server: ha manager           ├─27507 &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;zabbix_server: service manage...</code></pre></div></figure><h3 id="2-2-6-部署前端代码"><a href="#2-2-6-部署前端代码" class="headerlink" title="2.2.6 部署前端代码"></a>2.2.6 部署前端代码</h3><blockquote><p>在web01进行部署</p></blockquote><p>上传源码，并拷贝ui</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;tmp&#x2F;zabbix-6.0.30]#cp ui&#x2F;* &#x2F;app&#x2F;code&#x2F;zbx&#x2F;# 修改所有者[root@web01 &#x2F;app&#x2F;code]#chown www.www &#x2F;app&#x2F;code&#x2F;zbx&#x2F; -R</code></pre></div></figure><p>测试访问：<a href="http://zbx.test.cn/">http://zbx.test.cn:80</a></p><p><img src="/../../../img/image-20240607150229575.png" alt="image-20240607150229575"></p><p>遇到错误</p><p><img src="/../../../img/image-20240607150356041.png" alt="image-20240607150356041"></p><p>修改php.ini，重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;app&#x2F;code&#x2F;zbx]#egrep -n &#39;^(max_.*_time|post_max)&#39; &#x2F;etc&#x2F;php.ini368:max_execution_time &#x3D; 300378:max_input_time &#x3D; 600656:post_max_size &#x3D; 80M[root@web01 &#x2F;app&#x2F;code&#x2F;zbx]#systemctl restart php-fpm</code></pre></div></figure><p>刷新一下就过了，继续下一步</p><p><img src="/../../../img/image-20240607150547321.png" alt="image-20240607150547321"></p><p>填写数据库信息，取消勾选<code>数据库TLS加密</code></p><blockquote><p>这里重新尝试的一次，改成中文了</p></blockquote><p><img src="/../../../img/image-20240607152206296.png" alt="image-20240607152206296"></p><p>设置zabbix主机名和时区，点击下一步</p><p><img src="/../../../img/image-20240607152421727.png" alt="image-20240607152421727"></p><p>信息汇总，点击下一步</p><p><img src="/../../../img/image-20240607152439459.png" alt="image-20240607152439459"></p><p>配置完成</p><p><img src="/../../../img/image-20240607152856150.png" alt="image-20240607152856150"></p><p>登录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">默认账号Admin&#x2F;zabbix</code></pre></div></figure><p>因为我们的server是分离部署的，所以进来后，首页会报错，连不上zabbix server</p><p><img src="/../../../img/image-20240607153255449.png" alt="image-20240607153255449"></p><p>修改zabbix的配置文件，设置zbx server</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;app&#x2F;code&#x2F;zbx]#grep -n &#39;^[$]&#39; conf&#x2F;zabbix.conf.php4:$DB[&#39;TYPE&#39;]&#x3D; &#39;MYSQL&#39;;5:$DB[&#39;SERVER&#39;]&#x3D; &#39;172.16.1.51&#39;;6:$DB[&#39;PORT&#39;]&#x3D; &#39;0&#39;;7:$DB[&#39;DATABASE&#39;]&#x3D; &#39;zabbix&#39;;8:$DB[&#39;USER&#39;]&#x3D; &#39;zabbix&#39;;9:$DB[&#39;PASSWORD&#39;]&#x3D; &#39;zabbix&#39;;12:$DB[&#39;SCHEMA&#39;]&#x3D; &#39;&#39;;15:$DB[&#39;ENCRYPTION&#39;]&#x3D; false;16:$DB[&#39;KEY_FILE&#39;]&#x3D; &#39;&#39;;17:$DB[&#39;CERT_FILE&#39;]&#x3D; &#39;&#39;;18:$DB[&#39;CA_FILE&#39;]&#x3D; &#39;&#39;;19:$DB[&#39;VERIFY_HOST&#39;]&#x3D; false;20:$DB[&#39;CIPHER_LIST&#39;]&#x3D; &#39;&#39;;23:$DB[&#39;VAULT_URL&#39;]&#x3D; &#39;&#39;;24:$DB[&#39;VAULT_DB_PATH&#39;]&#x3D; &#39;&#39;;25:$DB[&#39;VAULT_TOKEN&#39;]&#x3D; &#39;&#39;;30:$DB[&#39;DOUBLE_IEEE754&#39;]&#x3D; true;# 添加两条33:$ZBX_SERVER&#x3D; &#39;172.16.1.62&#39;;34:$ZBX_SERVER_PORT&#x3D; &#39;10051&#39;;36:$ZBX_SERVER_NAME&#x3D; &#39;全链路监控zabbix主机&#39;;38:$IMAGE_FORMAT_DEFAULT&#x3D; IMAGE_FORMAT_PNG;</code></pre></div></figure><p>连接成功</p><p><img src="/../../../img/image-20240607153536838.png" alt="image-20240607153536838"></p><h2 id="2-3-客户端部署-被监控端"><a href="#2-3-客户端部署-被监控端" class="headerlink" title="2.3 客户端部署-被监控端"></a>2.3 客户端部署-被监控端</h2><h3 id="2-3-1-安装客户端"><a href="#2-3-1-安装客户端" class="headerlink" title="2.3.1 安装客户端"></a>2.3.1 安装客户端</h3><blockquote><p>以下操作在nfs01进行</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1. 配置zbx源rpm -ivh https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;zabbix&#x2F;zabbix&#x2F;6.0&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-release-6.0-4.el7.noarch.rpmsed -i &#39;s#https:&#x2F;&#x2F;epo.zabbix.com&#x2F;zabbix#https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;zabbix&#x2F;zabbix&#x2F;#g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;zabbix.repo#2. 安装客户端yum install -y zabbix-agent2</code></pre></div></figure><h3 id="2-3-2-配置客户端"><a href="#2-3-2-配置客户端" class="headerlink" title="2.3.2 配置客户端"></a>2.3.2 配置客户端</h3><blockquote><p>这里用zabbix-agent2服务，相比于zabbix-agent，更先进</p></blockquote><p>修改客户端配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01 ~]#grep &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.conf PidFile&#x3D;&#x2F;run&#x2F;zabbix&#x2F;zabbix_agent2.pidLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_agent2.logLogFileSize&#x3D;0Server&#x3D;172.16.1.62# 改了ServerActive&#x3D;172.16.1.62# 改了Hostname&#x3D;NFS01 server #改了Include&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.confPluginSocket&#x3D;&#x2F;run&#x2F;zabbix&#x2F;agent.plugin.sockControlSocket&#x3D;&#x2F;run&#x2F;zabbix&#x2F;agent.sockInclude&#x3D;.&#x2F;zabbix_agent2.d&#x2F;plugins.d&#x2F;*.conf</code></pre></div></figure><p>启动客服端服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable --now zabbix-agent2</code></pre></div></figure><p>检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01 ~]#ps -ef | grep zabbixzabbix     2757      1  0 15:55 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;zabbix_agent2 -c &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.confroot       2921   1738  0 15:59 pts&#x2F;0    00:00:00 grep --color&#x3D;auto zabbix[root@nfs01 ~]#ss -lntup | grep agent2tcp    LISTEN     0      128    [::]:10050              [::]:*                   users:((&quot;zabbix_agent2&quot;,pid&#x3D;2757,fd&#x3D;10))[root@nfs01 ~]#</code></pre></div></figure><h3 id="2-3-3-添加监控主机"><a href="#2-3-3-添加监控主机" class="headerlink" title="2.3.3 添加监控主机"></a>2.3.3 添加监控主机</h3><p>在zabbix首页添加监控主机 nfs01</p><p><img src="/../../../img/image-20240607161916916.png" alt="image-20240607161916916"></p><h2 id="2-4-ZBX中文乱码问题"><a href="#2-4-ZBX中文乱码问题" class="headerlink" title="2.4 ZBX中文乱码问题"></a>2.4 ZBX中文乱码问题</h2><blockquote><p>以下操作在zabbix-web的部署服务器进行，web01</p></blockquote><p>原因：zbx显示中文的字体有问题，导致显示中文异常。<br>解决：把zbx中文字体替换即可  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 字体文件目录cd &#x2F;app&#x2F;code&#x2F;zbx&#x2F;assets&#x2F;fonts&#x2F;# 先备份原字体[root@web01 &#x2F;app&#x2F;code&#x2F;zbx&#x2F;assets&#x2F;fonts]#mv DejaVuSans.ttf  DejaVuSans.ttf.bak# 上传一个中文的ttf字体替换zabbix自用的字体即可.mv MSYH.TTC  DejaVuSans.ttf</code></pre></div></figure><h1 id="三、Zabbix配置详解"><a href="#三、Zabbix配置详解" class="headerlink" title="三、Zabbix配置详解"></a>三、Zabbix配置详解</h1><h2 id="3-1-服务端配置"><a href="#3-1-服务端配置" class="headerlink" title="3.1 服务端配置"></a>3.1 服务端配置</h2><table><thead><tr><th>文件和目录</th><th>作用</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf</td><td>配置文件</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_server.log</td><td>当前放在&#x2F;tmp&#x2F;下面</td></tr><tr><td>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;zabbix-server.service</td><td>手写的systemctl管理文件，如果yum、rpm安装自带</td></tr><tr><td>&#x2F;usr&#x2F;local&#x2F;share&#x2F;zabbix&#x2F;alertscripts&#x2F;</td><td>用于实现告警的脚本</td></tr></tbody></table><p>服务端配置文件详解</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn02 &#x2F;]#grep &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.confListenPort&#x3D;10051# 服务端口LogFile&#x3D;&#x2F;tmp&#x2F;zabbix_server.log# 日志文件DBHost&#x3D;172.16.1.51# 数据库地址DBName&#x3D;zabbix# 数据库名字DBUser&#x3D;zabbix# 数据库用户名DBPassword&#x3D;zabbix# 数据库密码Timeout&#x3D;4# 超时时间LogSlowQueries&#x3D;3000StatsAllowedIP&#x3D;127.0.0.1</code></pre></div></figure><h2 id="3-2-客户端配置"><a href="#3-2-客户端配置" class="headerlink" title="3.2 客户端配置"></a>3.2 客户端配置</h2><table><thead><tr><th>文件和目录</th><th>作用</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.conf</td><td>配置文件</td></tr><tr><td>&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;</td><td>子配置文件目录，用于自定义监控</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;zabbix</td><td>日志</td></tr></tbody></table><p>客户端配置文件详解</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01 ~]#grep &#39;^[a-Z]&#39; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.conf PidFile&#x3D;&#x2F;run&#x2F;zabbix&#x2F;zabbix_agent2.pidLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_agent2.logLogFileSize&#x3D;0Server&#x3D;172.16.1.62# 指定服务端地址ServerActive&#x3D;172.16.1.62Hostname&#x3D;NFS01 server # 指定被监控主机名Include&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.confPluginSocket&#x3D;&#x2F;run&#x2F;zabbix&#x2F;agent.plugin.sockControlSocket&#x3D;&#x2F;run&#x2F;zabbix&#x2F;agent.sockInclude&#x3D;.&#x2F;zabbix_agent2.d&#x2F;plugins.d&#x2F;*.conf</code></pre></div></figure><h2 id="3-3-zbx-agent-VS-zbx-zgent2"><a href="#3-3-zbx-agent-VS-zbx-zgent2" class="headerlink" title="3.3 zbx agent VS zbx zgent2"></a>3.3 zbx agent VS zbx zgent2</h2><table><thead><tr><th>对比项</th><th>agent</th><th>agent2</th></tr></thead><tbody><tr><td>开发语言</td><td>C语言</td><td>Go语言和C语言</td></tr><tr><td>性能</td><td>独立进程方式运行</td><td>1个进行多线程方式运行，减少资源消耗，占用较少的TCP资源，能够承受更高并发</td></tr></tbody></table><h1 id="四、监控任意主机流程"><a href="#四、监控任意主机流程" class="headerlink" title="四、监控任意主机流程"></a>四、监控任意主机流程</h1><p>整体流程如下：</p><ol><li>安装客户端、修改配置文件、测试</li><li>web页面添加主机、关联模板</li><li>调试</li></ol><h2 id="9-1-配置客户端"><a href="#9-1-配置客户端" class="headerlink" title="9.1 配置客户端"></a>9.1 配置客户端</h2><blockquote><p>以监控db01 - 10.0.0.51为例</p></blockquote><p>安装zbx agent2</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]#rpm -Uvh https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;zabbix&#x2F;zabbix&#x2F;6.0&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-agent2-6.0.5-1.el7.x86_64.rpmRetrieving https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;zabbix&#x2F;zabbix&#x2F;6.0&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-agent2-6.0.5-1.el7.x86_64.rpmwarning: &#x2F;var&#x2F;tmp&#x2F;rpm-tmp.9WEw5L: Header V4 RSA&#x2F;SHA512 Signature, key ID a14fe591: NOKEYPreparing...                          ################################# [100%]Updating &#x2F; installing...   1:zabbix-agent2-6.0.5-1.el7        ################################# [100%]</code></pre></div></figure><p>配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]#grep &quot;^[z-Z]&quot; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.conf PidFile&#x3D;&#x2F;var&#x2F;run&#x2F;zabbix&#x2F;zabbix_agent2.pidLogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_agent2.logLogFileSize&#x3D;0Server&#x3D;172.16.1.62ServerActive&#x3D;172.16.1.62Hostname&#x3D;DB01 serverInclude&#x3D;&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.d&#x2F;*.confControlSocket&#x3D;&#x2F;tmp&#x2F;agent.sockInclude&#x3D;.&#x2F;zabbix_agent2.d&#x2F;plugins.d&#x2F;*.conf</code></pre></div></figure><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable zabbix-agent2.servicesystemctl start zabbix-agent2.service</code></pre></div></figure><p>检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]#ps -ef | grep zabbixzabbix     1969      1  0 10:34 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;zabbix_agent2 -c &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent2.confroot       1975   1778  0 10:35 pts&#x2F;0    00:00:00 grep --color&#x3D;auto zabbix</code></pre></div></figure><h2 id="9-2-web页面添加主机"><a href="#9-2-web页面添加主机" class="headerlink" title="9.2 web页面添加主机"></a>9.2 web页面添加主机</h2><p>登录zabbix页面，创建主机</p><p><img src="/../../../img/image-20240618104109960.png" alt="image-20240618104109960"></p><p>刚开始图标是灰色，耐心等待</p><p><img src="/../../../img/image-20240618104224235.png" alt="image-20240618104224235"></p><p>变绿即为添加成功</p><p><img src="/../../../img/image-20240618104310299.png" alt="image-20240618104310299"></p><blockquote><p>后期可以通过ansbile来自动添加监控，也可以通过配置自动发现来实现</p></blockquote><h2 id="9-3-通过模板帮助你监控任意服务"><a href="#9-3-通过模板帮助你监控任意服务" class="headerlink" title="9.3 通过模板帮助你监控任意服务"></a>9.3 通过模板帮助你监控任意服务</h2><p>zabbix提供很多监控模板供用户使用，案例使用的版本就有366个模板</p><p><img src="/../../../img/image-20240618105118722.png" alt="image-20240618105118722"></p><p>可以在侧边栏进入模板页面，比如进入监控nginx的模板</p><p><img src="/../../../img/image-20240618104903880.png" alt="image-20240618104903880"></p><p>这个nginx模板到底监控什么？可以点进去看，里面实际上有很多宏</p><p><img src="/../../../img/image-20240618104939757.png" alt="image-20240618104939757"></p><p>可以按照自己的需求来配置宏，比如当前web服务器的nginx设置如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# cat status.confserver &#123;  listen 8000;  location &#x2F; &#123;    stub_status;  &#125;&#125;</code></pre></div></figure><p>配置宏如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;$NGINX.STUB_STATUS.HOST&#125; localhost&#123;$NGINX.STUB_STATUS.PATH&#125; &#x2F;&#123;$NGINX.STUB_STATUS.PORT&#125; 8000</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day66-综合架构-阿里云进阶（三）</title>
    <link href="/2024/05/31/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day66-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9B%E9%98%B6-3/"/>
    <url>/2024/05/31/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day66-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9B%E9%98%B6-3/</url>
    
    <content type="html"><![CDATA[<h1 id="综合架构-阿里云进阶-03"><a href="#综合架构-阿里云进阶-03" class="headerlink" title="综合架构-阿里云进阶-03"></a>综合架构-阿里云进阶-03</h1><p>今日内容：</p><ul><li>CDN</li><li>阿里云NAT配置</li><li>阿里云安全管理</li></ul><h1 id="一、CDN"><a href="#一、CDN" class="headerlink" title="一、CDN"></a>一、CDN</h1><h2 id="1-1-CDN概述"><a href="#1-1-CDN概述" class="headerlink" title="1.1 CDN概述"></a>1.1 CDN概述</h2><p>CDN的作用：</p><ul><li>为网站进行加速</li><li>一般用于缓存静态资源: html,css,js,图片,视频.</li></ul><p>实现的原理：</p><ul><li>将网站内容缓存到CDN服务商的服务器中</li><li>缓存是分布式缓存，全国各地都有</li><li>根据用户距离，就近提供数据，实现加速访问</li></ul><p>CDN厂商：</p><ul><li>阿里云&#x2F;腾讯云</li><li>蓝汛</li><li>网宿</li><li>GoDaddy</li><li>Cloudflare</li></ul><h2 id="1-2-CDN流程分析"><a href="#1-2-CDN流程分析" class="headerlink" title="1.2 CDN流程分析"></a>1.2 CDN流程分析</h2><p>没使用CDN</p><ul><li>用户向DNS服务器请求IP<ul><li>远端服务返回给用户</li><li>存在速度慢、服务器挂了等问题</li></ul></li><li>用户拿着IP向WEB服务器请求网站数据<ul><li>存在速度慢、服务器挂了等问题</li></ul></li></ul><p><img src="/../../../img/image-20240603160008673.png" alt="image-20240603160008673"></p><p>使用CDN后</p><ul><li>用户向DNS服务器请求IP<ul><li>CDN就近发送IP给用户</li></ul></li><li>用户拿着IP向CDN要网站数据<ul><li>如果有，立即返回</li><li>如果没有，反向代理，CDN从源服务器获取数据，再返回给用户</li></ul></li></ul><p><img src="/../../../img/image-20240603160106460.png" alt="image-20240603160106460"></p><h2 id="1-3-配置CDN"><a href="#1-3-配置CDN" class="headerlink" title="1.3 配置CDN"></a>1.3 配置CDN</h2><h3 id="1-3-1-配置流程"><a href="#1-3-1-配置流程" class="headerlink" title="1.3.1 配置流程"></a>1.3.1 配置流程</h3><p>开通CDN服务</p><p><img src="/../../../img/image-20240603160933406.png" alt="image-20240603160933406"></p><p>添加加速域名</p><p><img src="/../../../img/image-20240603161008778.png" alt="image-20240603161008778"></p><p>获取域名对应的cname链接</p><p><img src="/../../../img/image-20240603161037051.png" alt="image-20240603161037051"></p><p>cdn cname 配置完成, 对cdn进行刷新预热 (源站数据上传cdn上面)  </p><p><img src="/../../../img/image-20240603161141292.png" alt="image-20240603161141292"></p><p>配置刷新示例：</p><p><img src="/../../../img/image-20240603161741121.png" alt="image-20240603161741121"></p><p>配置预热示例：</p><p><img src="/../../../img/image-20240603162057025.png" alt="image-20240603162057025"></p><blockquote><p>刷新vs预热</p><ul><li>刷新：删除CDN上已经缓存的内容，再重新获取（用的多）</li><li>预热：CDN主动访问源站，获取指定内容</li></ul></blockquote><h3 id="1-3-2-验证"><a href="#1-3-2-验证" class="headerlink" title="1.3.2 验证"></a>1.3.2 验证</h3><p>检查方法：</p><ul><li>检查域名DNS解析，域名是否是配置的CDN域名</li><li>浏览器F12检查，是否命中CDN</li></ul><p>访问站点，浏览器F12看”x-cache”</p><p><img src="/../../../img/image-20240603161255392.png" alt="image-20240603161255392"></p><h3 id="1-3-2-CDN开启HTTPS"><a href="#1-3-2-CDN开启HTTPS" class="headerlink" title="1.3.2 CDN开启HTTPS"></a>1.3.2 CDN开启HTTPS</h3><p>默认是关闭</p><p><img src="/../../../img/image-20240603161421240.png" alt="image-20240603161421240"></p><p>HTTPS设置开启</p><p><img src="/../../../img/image-20240603161442951.png" alt="image-20240603161442951"></p><p>配置完之后，是开启状态</p><p><img src="/../../../img/image-20240603161502275.png" alt="image-20240603161502275"></p><p>配置https跳转</p><p><img src="/../../../img/image-20240603161530455.png" alt="image-20240603161530455"></p><h2 id="1-4-CDN收费计算方法"><a href="#1-4-CDN收费计算方法" class="headerlink" title="1.4 CDN收费计算方法"></a>1.4 CDN收费计算方法</h2><ul><li>按峰值带宽计费说明</li><li>按流量计费说明</li><li>预付费-下行流量资源包</li><li>预付费-HTTPS请求数资源包</li></ul><h1 id="二、NAT网关"><a href="#二、NAT网关" class="headerlink" title="二、NAT网关"></a>二、NAT网关</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>什么是阿里云的NAT网关？</p><p>用阿里云实现iptables的NAT功能</p><ul><li>snat共享上网（用的多）</li><li>dnat端口映射（建议少用，比较危险）</li></ul><h2 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h2><h3 id="2-2-1-前期准备"><a href="#2-2-1-前期准备" class="headerlink" title="2.2.1 前期准备"></a>2.2.1 前期准备</h3><p>创建一台只有<code>内网IP</code>的ECS</p><p><img src="/../../../img/image-20240603164100624.png" alt="image-20240603164100624"></p><p>创建NAT网关</p><p><img src="/../../../img/image-20240603164142787.png" alt="image-20240603164142787"></p><p>按需配置</p><p><img src="/../../../img/image-20240603164243277.png" alt="image-20240603164243277"></p><p>确认订单</p><p><img src="/../../../img/image-20240603164311642.png" alt="image-20240603164311642"></p><p>绑定弹性公网IP</p><p><img src="/../../../img/image-20240603164459171.png" alt="image-20240603164459171"></p><h3 id="2-2-2-案例01-共享上网"><a href="#2-2-2-案例01-共享上网" class="headerlink" title="2.2.2 案例01-共享上网"></a>2.2.2 案例01-共享上网</h3><p>设置snat</p><p><img src="/../../../img/image-20240603164536139.png" alt="image-20240603164536139"></p><p>选择粒度和主机</p><p><img src="/../../../img/image-20240603164636308.png" alt="image-20240603164636308"></p><p>添加完之后，只有公网IP的ECS，就能上网了</p><h3 id="2-2-3-案例02-端口映射"><a href="#2-2-3-案例02-端口映射" class="headerlink" title="2.2.3 案例02-端口映射"></a>2.2.3 案例02-端口映射</h3><p>创建DNAT条目</p><p><img src="/../../../img/image-20240603165222196.png" alt="image-20240603165222196"></p><p>按需配置</p><p><img src="/../../../img/image-20240603165235031.png" alt="image-20240603165235031"></p><p>查看配置好的DNAT条目</p><p><img src="/../../../img/image-20240603165255999.png" alt="image-20240603165255999"></p><h1 id="三、阿里云安全管理"><a href="#三、阿里云安全管理" class="headerlink" title="三、阿里云安全管理"></a>三、阿里云安全管理</h1><p>可以查看主机资产信息、漏洞分析、安全处理</p><h2 id="3-1-安全组"><a href="#3-1-安全组" class="headerlink" title="3.1 安全组"></a>3.1 安全组</h2><p>4层和3层，进行处理，默认是白名单</p><p>ECS首页进入配置</p><p><img src="/../../../img/image-20240603165706960.png" alt="image-20240603165706960"></p><p>  预览</p><p><img src="/../../../img/image-20240603165751327.png" alt="image-20240603165751327"></p><p>授权策略</p><p><img src="/../../../img/image-20240603165840371.png" alt="image-20240603165840371"></p><h2 id="3-2-云安全中心"><a href="#3-2-云安全中心" class="headerlink" title="3.2 云安全中心"></a>3.2 云安全中心</h2><p>安全中心webshell告警案例，发现可疑文件</p><p><img src="/../../../img/image-20240603165116165.png" alt="image-20240603165116165"></p><p>根据日志找到可以文件，然后进行处理就行</p><h2 id="3-2-waf防火墙"><a href="#3-2-waf防火墙" class="headerlink" title="3.2 waf防火墙"></a>3.2 waf防火墙</h2><p>用于：</p><ul><li>应用防火墙，7层的防火墙</li><li>iptables &#x2F; 安全组 4层防火墙 (控制 端口和ip)</li></ul><p>配置waf防火墙</p><p><img src="/../../../img/image-20240603170020581.png" alt="image-20240603170020581"></p><p>继续</p><p><img src="/../../../img/image-20240603170036775.png" alt="image-20240603170036775"></p><h1 id="四、BBS-GO项目"><a href="#四、BBS-GO项目" class="headerlink" title="四、BBS-GO项目"></a>四、BBS-GO项目</h1><h2 id="4-1-项目架构"><a href="#4-1-项目架构" class="headerlink" title="4.1 项目架构"></a>4.1 项目架构</h2><p>BBS-GO是一款基于Go语言开发的论坛系统，分为前台页面和后台管理页面，使用阿里云进行部署</p><p><img src="/../../../img/image-20240605101952569.png" alt="image-20240605101952569"></p><blockquote><p>获取源码：gitee bbs-go</p></blockquote><h2 id="4-2-部署步骤"><a href="#4-2-部署步骤" class="headerlink" title="4.2 部署步骤"></a>4.2 部署步骤</h2><h3 id="4-2-1-数据库RDS"><a href="#4-2-1-数据库RDS" class="headerlink" title="4.2.1 数据库RDS"></a>4.2.1 数据库RDS</h3><p>数据库准备  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">数据库用户：bbsgo数据库名字：bbsgo数据库的密码：Bbsgo123数据库的地址：rmbp10i499z66iah5zq.mysql.rds.aliyuncs.com数据库端口：3306</code></pre></div></figure><p>导入数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 按项目文档导入</code></pre></div></figure><h3 id="4-2-2-存储OSS"><a href="#4-2-2-存储OSS" class="headerlink" title="4.2.2 存储OSS"></a>4.2.2 存储OSS</h3><p>创建OSS服务器，获取ak，创建存储桶（bucket），授予用户权限</p><h3 id="4-2-3-编译Go代码"><a href="#4-2-3-编译Go代码" class="headerlink" title="4.2.3 编译Go代码"></a>4.2.3 编译Go代码</h3><blockquote><p>需创建ECS服务器操作</p></blockquote><p>获取代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;gitee.com&#x2F;mlogclub&#x2F;bbs-go.gitcd bbs-go</code></pre></div></figure><blockquote><p>admin&#x2F; #站点前端,后台管理页面的源代码.<br>server&#x2F; #网站后端,Golang语言源代码.<br>site&#x2F; #用户访问入口站点,前端站点,源代码.  </p></blockquote><p>进入server&#x2F;目录，编译Golang代码，生成命令bbs-go</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1. 安装编译Golang语言的环境apt install -y golang#2. 编译的过程中需要自动下载依赖,从github.com下载,速度缓慢.echo &#39;exportGOPROXY&#x3D;https:&#x2F;&#x2F;proxy.golang.com.cn,direct&#39; &gt;&gt; &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile#3. 检查root@ubt-ecs:~&#x2F;bbs-go# echo $GOPROXYhttps:&#x2F;&#x2F;proxy.golang.com.cn,directroot@ubt-ecs:~&#x2F;bbs-go# go versiongo version go1.18.1 linux&#x2F;amd64#4. 准备编译pwd(在server目录下)go build#5. 修改配置文件bbs-go.ymlmkdir -p &#x2F;app&#x2F;code&#x2F;bbs-go&#x2F;&#123;server,site,admin&#125;cp bbs-go bbs-go.example.yaml &#x2F;app&#x2F;code&#x2F;bbsgo&#x2F;server&#x2F;# 配置文件内容参考项目手册</code></pre></div></figure><h3 id="4-2-4-部署site前端代码"><a href="#4-2-4-部署site前端代码" class="headerlink" title="4.2.4 部署site前端代码"></a>4.2.4 部署site前端代码</h3><p>vue&#x2F;nuxt 框架<br>通过nodejs编译,npm命令  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1. 准备Nodejs环境##下载wget -P &#x2F;app&#x2F;tools&#x2F;https&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;nodejsrelease&#x2F;v16.19.1&#x2F;node-v16.19.1-linux-x64.tar.xzcd &#x2F;app&#x2F;tools&#x2F;##解压与软连接tar xf node-v16.19.1-linux-x64.tar.xzln -s node-v16.19.1-linux-x64&#x2F; node##配置环境变量echo &#39;export PATH&#x3D;&#x2F;app&#x2F;tools&#x2F;node&#x2F;bin&#x2F;:$PATH&#39;&gt;&gt;&#x2F;etc&#x2F;profile. &#x2F;etc&#x2F;profile#2. 检查root@ubt-ecs:&#x2F;app&#x2F;tools# node -vv16.19.1root@ubt-ecs:&#x2F;app&#x2F;tools# npm -v8.19.3#3. 配置npm命令源,cnpm淘宝二次开发,性能高,速度快.##安装cnpmnpm install -g cnpm Վʔregistry&#x3D;https:&#x2F;&#x2F;registry.npmmirror.com##永久配置了下npm&#x2F;cnpm源npm config set registryhttps:Վˌregistry.npmmirror.com#4. 前端代码的配置文件nuxt.config.js前端代码中后端服务的ip和地址.proxy: &#123;&#39;&#x2F;api&#x2F;&#39;: &#39;http:Վˌ127.0.0.1:8082&#39;,&#125;,#5. 编译代码进入前端代码目录npm install #根据代码的要求下载与安装前端的依赖.npm run build #编译与构建#6. 启动nuxtnpm run start</code></pre></div></figure><p>ngx配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubt-ecs:~# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;bbsgo.confserver &#123;listen 80;server_name bbs.oldboylinux.cn;location &#x2F; &#123;proxy_pass http:Վˌ127.0.0.1:3000;&#125;&#125;</code></pre></div></figure><p>进行访问，注意配置dns解析  </p><p><img src="/../../../img/image-20240605103219773.png" alt="image-20240605103219773"></p><h3 id="4-2-5-部署admin前端代码"><a href="#4-2-5-部署admin前端代码" class="headerlink" title="4.2.5 部署admin前端代码"></a>4.2.5 部署admin前端代码</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进入admin代码目录cnpm installcnpm install path-to-regexp#cnpm run dev #调用.env.development文件cnpm run build #调用 .env.production 文件 生成静态文件.放在ngx中即可.</code></pre></div></figure><blockquote><p>.env.production配置文件说明  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;root@ubt-ecs:~&#x2F;bbs-go&#x2F;admin# cat .env.production&gt;# just a flag&gt;ENV &#x3D; &#39;production&#39;&gt;# base api&gt;VUE_APP_BASE_API &#x3D; &#39;http:Վˌbbs.oldboylinux.cn&#39;&gt;VUE_APP_BASE_URL &#x3D; &#39;http:Վˌbbs.oldboylinux.cn&#39;&gt;# 接口请求地址HOST，用于admin模块请求服务端接口&gt;# 该配置的值一般设置为server端的HOST，或者site端的&gt;HOST（因为site端代理了server端的所有接口）&gt;VUE_APP_BASE_API &#x3D; &#39;http:Վˌbbs.oldboylinux.cn&#39; #&gt;域名或公网ip.&gt;# site模块访问根目录，作用：例如后台点击帖子标题时，能够正&gt;确跳转到帖子site端的访问路径&gt;VUE_APP_BASE_URL &#x3D; &#39;http:Վˌbbs.oldboylinux.cn&#39;</code></pre></div></figure></blockquote><blockquote><p>admin缺少的依赖  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;cnpm install Վʔsave path-to-regexp</code></pre></div></figure></blockquote><p>run build成功提示,静态资源生成到dist目录,这个目录下面的内容就可以放到ngx中.  </p><p><img src="/../../../img/image-20240605103426270.png" alt="image-20240605103426270"></p><p>准备web环境</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 复制编译好的文件到ngx中mkdir -p &#x2F;app&#x2F;code&#x2F;bbs-go&#x2F;admin&#x2F;cp -r dist&#x2F;* &#x2F;app&#x2F;code&#x2F;bbs-go&#x2F;admin&#x2F;# ngx配置root@ubt-ecs:~&#x2F;bbs-go&#x2F;admin# cat&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;bbsgo.confserver &#123;  listen 80;  server_name bbs.oldboylinux.cn;  location &#x2F; &#123;    proxy_pass http:Վˌ127.0.0.1:3000;  &#125;&#125;server &#123;  listen 8080;  server_name bbsadmin.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;bbs-go&#x2F;admin&#x2F;;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><h1 id="五、云企业网CEN"><a href="#五、云企业网CEN" class="headerlink" title="五、云企业网CEN"></a>五、云企业网CEN</h1><blockquote><p>价格高，用的较少</p></blockquote><p>VPC高速通道，实现不同VPC之间的网络互通</p><p><img src="/../../../img/image-20240605104745091.png" alt="image-20240605104745091"></p><p>关联VPC即可使用</p><p><img src="/../../../img/image-20240605104809815.png" alt="image-20240605104809815"></p><h1 id="六、弹性伸缩ESS"><a href="#六、弹性伸缩ESS" class="headerlink" title="六、弹性伸缩ESS"></a>六、弹性伸缩ESS</h1><blockquote><p>弹性容器ECI</p><p><img src="/../../../img/image-20240605105805960.png" alt="image-20240605105805960"></p><p>弹性实例ECS</p></blockquote><p> 什么是弹性伸缩？</p><ul><li>可以根据我们指定的指标（如CPU、内存、网络等）进行ECS的扩容&#x2F;缩容</li></ul><p>好处：</p><ul><li>能根据业务量大小自动调整服务器资源量，防止访问量过大造成服务宕机、响应时间过长等不良影响</li></ul><p>坑：</p><ul><li>需要购买阿里云配套的服务</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day65-综合架构-阿里云进阶（二）</title>
    <link href="/2024/05/31/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day65-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9B%E9%98%B6-2/"/>
    <url>/2024/05/31/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day65-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9B%E9%98%B6-2/</url>
    
    <content type="html"><![CDATA[<h1 id="综合架构-阿里云进阶-02"><a href="#综合架构-阿里云进阶-02" class="headerlink" title="综合架构-阿里云进阶-02"></a>综合架构-阿里云进阶-02</h1><p>今日内容：</p><ul><li>CLB&#x2F;ALB负载均衡</li><li>域名和DNS配置</li><li>HTTPS证书配置</li></ul><h1 id="一、CLB-ALB负载均衡"><a href="#一、CLB-ALB负载均衡" class="headerlink" title="一、CLB&#x2F;ALB负载均衡"></a>一、CLB&#x2F;ALB负载均衡</h1><p>公有云的负载均衡一般都是现成的产品，一般不需要我们关注产品的底层实现</p><h2 id="1-1-CLB和ALB概述"><a href="#1-1-CLB和ALB概述" class="headerlink" title="1.1 CLB和ALB概述"></a>1.1 CLB和ALB概述</h2><p>负载均衡选型：</p><ul><li>现成产品：<ul><li>CLB：传统型负载均衡，以前叫SLB</li><li>ALB</li></ul></li><li>也可以自己搭建：ECS * 2 + keepalived，需要提供VIP（原来叫havip）</li></ul><p>CLB 对比 ALB</p><p><img src="/../../../img/image-20240601115122209.png" alt="image-20240601115122209"></p><p>CLB和ALB的架构图：</p><p><img src="/../../../img/image-20240601134239238.png" alt="image-20240601134239238"></p><h2 id="1-2-CLB"><a href="#1-2-CLB" class="headerlink" title="1.2 CLB"></a>1.2 CLB</h2><h3 id="1-2-1-CLB的工作原理"><a href="#1-2-1-CLB的工作原理" class="headerlink" title="1.2.1 CLB的工作原理"></a>1.2.1 CLB的工作原理</h3><p>高清：<a href="https://www.processon.com/view/link/5eea0f6d07912929cb4a5dab">https://www.processon.com/view/link/5eea0f6d07912929cb4a5dab</a>  </p><p>CLB背后的实现架构：</p><p><img src="/../../../img/image-20240601134630083.png" alt="image-20240601134630083"></p><p>四层和七层的转发</p><p><img src="/../../../img/image-20240601134639193.png" alt="image-20240601134639193"></p><h3 id="1-2-2-CLB快速上手"><a href="#1-2-2-CLB快速上手" class="headerlink" title="1.2.2 CLB快速上手"></a>1.2.2 CLB快速上手</h3><h4 id="1-2-1-1-环境准备"><a href="#1-2-1-1-环境准备" class="headerlink" title="1.2.1.1 环境准备"></a>1.2.1.1 环境准备</h4><p>准备两台ECS</p><table><thead><tr><th>主机名</th><th>nginx 1.20</th></tr></thead><tbody><tr><td>ecs01</td><td>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;index.html内容ecs001</td></tr><tr><td>ecs02</td><td>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;index.html内容ecs002</td></tr></tbody></table><p>用抢占式的就可以，哪个便宜用哪个。</p><p><img src="/../../../img/image-20240601120357751.png" alt="image-20240601120357751"></p><p>设置网络和安全组</p><p><img src="/../../../img/image-20240601120707329.png" alt="image-20240601120707329"></p><p>登录凭证、实例名设置</p><blockquote><p>如果选了使用密钥对，则账户密码登录会默认关闭</p></blockquote><p><img src="/../../../img/image-20240601120942455.png" alt="image-20240601120942455"></p><p>确认配置</p><p><img src="/../../../img/image-20240601121054608.png" alt="image-20240601121054608"></p><p>两台ECS都登录，并安装nginx，设置nginx的首页，用于区分</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装nginxyum install -y nginxsystemctl enable --now nginx# 配置站点页面echo aliyun.test.cn &#96;hostname&#96; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html# 测试curl localhost</code></pre></div></figure><h4 id="1-2-1-2-使用CLB"><a href="#1-2-1-2-使用CLB" class="headerlink" title="1.2.1.2 使用CLB"></a>1.2.1.2 使用CLB</h4><h5 id="A）创建CLB"><a href="#A）创建CLB" class="headerlink" title="A）创建CLB"></a>A）创建CLB</h5><p>阿里云控制台，创建</p><p><img src="/../../../img/image-20240601121715975.png" alt="image-20240601121715975"></p><p>按需求配置</p><p><img src="/../../../img/image-20240601122442911.png" alt="image-20240601122442911"></p><p><img src="/../../../img/image-20240601122538928.png" alt="image-20240601122538928"></p><h5 id="B）监听配置向导"><a href="#B）监听配置向导" class="headerlink" title="B）监听配置向导"></a>B）监听配置向导</h5><p>详情页进入</p><p><img src="/../../../img/image-20240601122745243.png" alt="image-20240601122745243"></p><p>选择监听协议、端口、设置监听名称</p><p><img src="/../../../img/image-20240601122917230.png" alt="image-20240601122917230"></p><p>添加后端服务器</p><ul><li>如果只有一个upstream，用默认服务器组，有多个则用虚拟服务器组</li></ul><p><img src="/../../../img/image-20240601123037746.png" alt="image-20240601123037746"></p><p>添加完，设置端口</p><p><img src="/../../../img/image-20240601123133098.png" alt="image-20240601123133098"></p><p>健康检查，默认即可，做个简单检查探测</p><p><img src="/../../../img/image-20240601123317602.png" alt="image-20240601123317602"></p><p>提示缺少nc，在ECS上安装即可，安装完再探测OK</p><p><img src="/../../../img/image-20240601123349737.png" alt="image-20240601123349737"></p><h5 id="C）测试"><a href="#C）测试" class="headerlink" title="C）测试"></a>C）测试</h5><p>测试访问CLB的公网IP，负载均衡生效</p><p><img src="/../../../img/image-20240601123545977.png" alt="image-20240601123545977"></p><h3 id="1-2-3-CLB案例-实现动静分离"><a href="#1-2-3-CLB案例-实现动静分离" class="headerlink" title="1.2.3 CLB案例-实现动静分离"></a>1.2.3 CLB案例-实现动静分离</h3><p>架构</p><p><img src="/../../../img/image-20240601133035545.png" alt="image-20240601133035545"></p><p>根据uri进行转发</p><table><thead><tr><th>访问的资源</th><th>访问案例</th><th>那个节点处理</th></tr></thead><tbody><tr><td>静态</td><td>&#x2F;static&#x2F;</td><td>ecs01（设置为虚拟服务器）</td></tr><tr><td>动态（默认）</td><td>其他所有</td><td>ecs02（设置为默认服务器）</td></tr></tbody></table><h4 id="A-环境准备"><a href="#A-环境准备" class="headerlink" title="A) 环境准备"></a>A) 环境准备</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ecs01配置mkdir -p &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static&#x2F;cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;static&#x2F;echo oldboy css static |tee css&#123;01..10&#125;.cssecho oldboy js static |tee js&#123;01..10&#125;.js# ecs02配置cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;echo oldboy html default |tee oldboy&#123;01..10&#125;.html</code></pre></div></figure><h4 id="B-配置CLB转发规则"><a href="#B-配置CLB转发规则" class="headerlink" title="B) 配置CLB转发规则"></a>B) 配置CLB转发规则</h4><p>CLB配置，默认服务器组，删除ECS01，只保留02</p><p><img src="/../../../img/image-20240601124310325.png" alt="image-20240601124310325"></p><p>删除后</p><p><img src="/../../../img/image-20240601124328606.png" alt="image-20240601124328606"></p><p>创建虚拟服务器组</p><p><img src="/../../../img/image-20240601124358844.png" alt="image-20240601124358844"></p><p>添加ECS01为虚拟服务器</p><p><img src="/../../../img/image-20240601124447016.png" alt="image-20240601124447016"></p><p>配置端口80和权重</p><p><img src="/../../../img/image-20240601124522380.png" alt="image-20240601124522380"></p><p>切换到监听标签，配置转发规则</p><p><img src="/../../../img/image-20240601124639627.png" alt="image-20240601124639627"></p><p>设置URL，这里注意<code>/static/</code>跟<code>/static</code>是不同的，要分清</p><p><img src="/../../../img/image-20240601124812171.png" alt="image-20240601124812171"></p><h4 id="C-测试"><a href="#C-测试" class="headerlink" title="C) 测试"></a>C) 测试</h4><p>在windows用curl测试连接</p><p><img src="/../../../img/image-20240601125128639.png" alt="image-20240601125128639"></p><p>但这样怎么知道，到底是走的ECS01还是02？有两种方法可以判断</p><ol><li>抓包</li><li>查看nginx访问日志（用这个）</li></ol><p><img src="/../../../img/image-20240601125536286.png" alt="image-20240601125536286"></p><h4 id="D-报错403分析"><a href="#D-报错403分析" class="headerlink" title="D) 报错403分析"></a>D) 报错403分析</h4><p>在1.4.3测试中，如果只访问到<code>/static/</code>目录，会报403的错误</p><p>一般两种原因：</p><ul><li>权限过低</li><li>首页文件不存在（是这个引起）</li></ul><p>因此也并不算问题，确实没有<code>index.html</code>文件</p><p><img src="/../../../img/image-20240601125718830.png" alt="image-20240601125718830"></p><h3 id="1-2-4-CLB小结"><a href="#1-2-4-CLB小结" class="headerlink" title="1.2.4 CLB小结"></a>1.2.4 CLB小结</h3><p>CLB，原SLB，负责7层和4层的负载均衡</p><ul><li>7层功能更只限对于域名转发和uri的转发（location规则）</li><li>如果是更加复杂的转发，需要自己搭建负载均衡，或者使用ALB</li></ul><h2 id="1-3-ALB负载均衡"><a href="#1-3-ALB负载均衡" class="headerlink" title="1.3 ALB负载均衡"></a>1.3 ALB负载均衡</h2><p>ALB全称应用负载均衡，是对传统负载均衡（CLB）在7层功能上的扩展与加强</p><p>ALB只能用于7层</p><p><img src="/../../../img/image-20240601134908159.png" alt="image-20240601134908159"></p><h3 id="1-3-1-案例01-根据户端类型转发"><a href="#1-3-1-案例01-根据户端类型转发" class="headerlink" title="1.3.1 案例01-根据户端类型转发"></a>1.3.1 案例01-根据户端类型转发</h3><table><thead><tr><th>客户端类型</th><th>转发</th><th>节点</th></tr></thead><tbody><tr><td>Chrome</td><td>转发到PC</td><td>ECS01</td></tr><tr><td>Android</td><td>转发到移动端</td><td>ECS02</td></tr></tbody></table><p>实现原理，类似于在Nginx中做了设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">if ( $http_user_agent ~* &quot;Chrome&quot; ) &#123;proxy_pass http:&#x2F;&#x2F;pc;&#125;if ( $http_user_agent ~* &quot;Android&quot; ) &#123;proxy_pass http:&#x2F;&#x2F;mobile;&#125;</code></pre></div></figure><h4 id="A）准备两台ECS"><a href="#A）准备两台ECS" class="headerlink" title="A）准备两台ECS"></a>A）准备两台ECS</h4><p>配置站点文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#ecs01echo pc_default &gt;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html#ecs02echo mobile &gt;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</code></pre></div></figure><h4 id="B）准备ALB服务器"><a href="#B）准备ALB服务器" class="headerlink" title="B）准备ALB服务器"></a>B）准备ALB服务器</h4><p>点击创建</p><p><img src="/../../../img/image-20240603145330743.png" alt="image-20240603145330743">地域选择</p><p><img src="/../../../img/image-20240603145400789.png" alt="image-20240603145400789"></p><p>网络配置</p><p><img src="/../../../img/image-20240603145431531.png" alt="image-20240603145431531"></p><p>创建关联角色</p><p><img src="/../../../img/image-20240603145514928.png" alt="image-20240603145514928"></p><p>创建完可以看到ALB的域名</p><p><img src="/../../../img/image-20240603145548928.png" alt="image-20240603145548928"></p><h4 id="C）创建后端服务器组"><a href="#C）创建后端服务器组" class="headerlink" title="C）创建后端服务器组"></a>C）创建后端服务器组</h4><p>进入ALB详情页，点击创建</p><p><img src="/../../../img/image-20240603145734145.png" alt="image-20240603145734145"></p><p>填写信息，创建一个”PC端”的</p><p><img src="/../../../img/image-20240603145802860.png" alt="image-20240603145802860"></p><p>再创建一个“移动端”的</p><p><img src="/../../../img/image-20240603145849154.png" alt="image-20240603145849154"></p><p>点“0”进入，编辑后端服务器，添加后端服务器</p><p><img src="/../../../img/image-20240603150107692.png" alt="image-20240603150107692"></p><p>下一步，加个端口</p><p><img src="/../../../img/image-20240603150130883.png" alt="image-20240603150130883"></p><p>另一台，相同操作，添加完有两台后端服务器</p><p><img src="/../../../img/image-20240603150227093.png" alt="image-20240603150227093"></p><h4 id="D）创建监听"><a href="#D）创建监听" class="headerlink" title="D）创建监听"></a>D）创建监听</h4><p>实例详情页，创建监听</p><p><img src="/../../../img/image-20240603150306430.png" alt="image-20240603150306430"></p><p>配置监听</p><p><img src="/../../../img/image-20240603150331581.png" alt="image-20240603150331581"></p><p>选择服务器组</p><p><img src="/../../../img/image-20240603150356184.png" alt="image-20240603150356184"></p><p>提交</p><p><img src="/../../../img/image-20240603150418227.png" alt="image-20240603150418227"></p><h4 id="E）配置Location规则"><a href="#E）配置Location规则" class="headerlink" title="E）配置Location规则"></a>E）配置Location规则</h4><p>编辑转发规则</p><p><img src="/../../../img/image-20240603150448410.png" alt="image-20240603150448410"></p><p>插入新规则</p><p><img src="/../../../img/image-20240603150712023.png" alt="image-20240603150712023"></p><p>填写信息，“移动端”转发</p><p><img src="/../../../img/image-20240603150747887.png" alt="image-20240603150747887"></p><h4 id="F）测试"><a href="#F）测试" class="headerlink" title="F）测试"></a>F）测试</h4><p><img src="/../../../img/image-20240603151031560.png" alt="image-20240603151031560"></p><h3 id="1-3-2-ALB小结"><a href="#1-3-2-ALB小结" class="headerlink" title="1.3.2 ALB小结"></a>1.3.2 ALB小结</h3><p>ALB应用场景：</p><ul><li>流量镜像<ul><li>用户访问的流量过来，复制一份</li><li>一份正常处理，另一份镜像用于其他功能（测试、分析…）</li></ul></li><li>根据域名&#x2F;uri&#x2F; 请求&#x2F;响应报头进行转发 (客户端浏览器,语言)</li><li>其他..</li></ul><p><img src="/../../../img/image-20240603151407856.png" alt="image-20240603151407856"></p><h1 id="二、域名和DNS"><a href="#二、域名和DNS" class="headerlink" title="二、域名和DNS"></a>二、域名和DNS</h1><h2 id="2-1-DNS云解析"><a href="#2-1-DNS云解析" class="headerlink" title="2.1 DNS云解析"></a>2.1 DNS云解析</h2><h3 id="2-1-1-DNS记录类型"><a href="#2-1-1-DNS记录类型" class="headerlink" title="2.1.1 DNS记录类型"></a>2.1.1 DNS记录类型</h3><p>DNS如何对应ip地址或其他内容</p><table><thead><tr><th>记录类型</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>A记录</td><td>IPV4解析</td><td><a href="http://www.test.com/">www.test.com</a> — 10.67.32.11</td></tr><tr><td>AAAA记录</td><td>IPV6解析</td><td></td></tr><tr><td>CNAME记录</td><td>别名记录（CDN常用）</td><td><a href="http://www.test.com/">www.test.com</a> —- <a href="http://www.cdn.test.com/">www.cdn.test.com</a></td></tr><tr><td>MX记录</td><td>配置邮箱、企业邮箱</td><td></td></tr><tr><td>TXT记录</td><td>文本（常用于记录域名所有者）</td><td>Author haris</td></tr></tbody></table><h3 id="2-1-2-配置云解析"><a href="#2-1-2-配置云解析" class="headerlink" title="2.1.2 配置云解析"></a>2.1.2 配置云解析</h3><p>首页进入</p><p><img src="/../../../img/image-20240603153559971.png" alt="image-20240603153559971"></p><p>进入“解析设置”</p><p><img src="/../../../img/image-20240603153622347.png" alt="image-20240603153622347"></p><p>添加“A记录”</p><p><img src="/../../../img/image-20240603153832000.png" alt="image-20240603153832000"></p><p>再添加一条“TXT记录”</p><p><img src="/../../../img/image-20240603153957387.png" alt="image-20240603153957387"></p><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用dig命令dig txt check.oldboylinux.cn</code></pre></div></figure><p><img src="/../../../img/image-20240603154040194.png" alt="image-20240603154040194"></p><h3 id="2-1-3-域名小结"><a href="#2-1-3-域名小结" class="headerlink" title="2.1.3 域名小结"></a>2.1.3 域名小结</h3><p>最常用的DNS记录类型:</p><ul><li>A记录,最常用的记录之一.域名—-ip</li><li>CNAME记录,别名记录,一般用于CDN.</li><li>TXT记录,域名—字符串,一般用于域名验证.</li><li>MX记录,一般用于配置企业邮箱,跟随配置要求进行设置即可.</li></ul><p>DNS术语: 记录类型,主机记录,ttl(Time To Live 缓存,生效)   </p><h1 id="三、HTTPS证书"><a href="#三、HTTPS证书" class="headerlink" title="三、HTTPS证书"></a>三、HTTPS证书</h1><h2 id="3-1-申请证书"><a href="#3-1-申请证书" class="headerlink" title="3.1 申请证书"></a>3.1 申请证书</h2><p>页面点击</p><p><img src="/../../../img/image-20240603154420818.png" alt="image-20240603154420818"></p><p>填写信息</p><p><img src="/../../../img/image-20240603154436704.png" alt="image-20240603154436704"></p><p>查看已签发的证书</p><p><img src="/../../../img/image-20240603154458220.png" alt="image-20240603154458220"></p><h2 id="3-2-证书使用案例"><a href="#3-2-证书使用案例" class="headerlink" title="3.2 证书使用案例"></a>3.2 证书使用案例</h2><h3 id="3-2-1-案例01-负载均衡绑定证书"><a href="#3-2-1-案例01-负载均衡绑定证书" class="headerlink" title="3.2.1 案例01-负载均衡绑定证书"></a>3.2.1 案例01-负载均衡绑定证书</h3><p><img src="/../../../img/image-20240603154533096.png" alt="image-20240603154533096"></p><h3 id="3-2-2-案例02-HTTP升级HTTPS"><a href="#3-2-2-案例02-HTTP升级HTTPS" class="headerlink" title="3.2.2 案例02-HTTP升级HTTPS"></a>3.2.2 案例02-HTTP升级HTTPS</h3><p>负载均衡设置“监听转发”</p><p><img src="/../../../img/image-20240603154644992.png" alt="image-20240603154644992"></p><p>添加完之后，可以看到多了一个443的监听</p><p><img src="/../../../img/image-20240603154720293.png" alt="image-20240603154720293"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day64-综合架构-阿里云进阶（一）</title>
    <link href="/2024/05/31/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day64-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9B%E9%98%B6-1/"/>
    <url>/2024/05/31/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day64-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9B%E9%98%B6-1/</url>
    
    <content type="html"><![CDATA[<h1 id="综合架构-阿里云进阶-01"><a href="#综合架构-阿里云进阶-01" class="headerlink" title="综合架构-阿里云进阶-01"></a>综合架构-阿里云进阶-01</h1><p>今日内容：</p><ul><li>公有云架构介绍</li><li>ECS弹性服务器使用</li><li>RDS数据库服务器使用</li><li>NAS文件存储使用</li><li>OSS对象存储使用</li></ul><h1 id="一、公有云目标"><a href="#一、公有云目标" class="headerlink" title="一、公有云目标"></a>一、公有云目标</h1><p>要求：</p><ul><li>能熟练的说出或识别公有云服务名字</li><li>能熟练说出和画出公有云网站架构</li><li>能熟练使用公有云的产品，比如：ecs、slb、rds、oss….</li><li>熟悉服务购买、续费操作</li></ul><h1 id="二、公有云架构"><a href="#二、公有云架构" class="headerlink" title="二、公有云架构"></a>二、公有云架构</h1><p>用户角度：</p><p><img src="/../../../img/%E5%85%AC%E6%9C%89%E4%BA%91%E6%9E%B6%E6%9E%84-%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6.png" alt="公有云架构-用户角度"></p><p>运维角度：<img src="/../../../img/%E5%85%AC%E6%9C%89%E4%BA%91%E6%9E%B6%E6%9E%84-%E8%BF%90%E7%BB%B4%E8%A7%92%E5%BA%A6.png" alt="公有云架构-运维角度"></p><p>一些专业词汇</p><table><thead><tr><th>专业词汇</th><th></th></tr></thead><tbody><tr><td>ecs</td><td>云服务器</td></tr><tr><td>vpc</td><td>虚拟专用网络 局域网</td></tr><tr><td>安全组</td><td>防火墙,白名单</td></tr><tr><td>实例</td><td>阿里云中任何一个产品或一个功能, 每个实例一般有一个独一无二的id.</td></tr><tr><td>1c1g 2c4g</td><td>云服务器的配置</td></tr><tr><td>快照</td><td>类似于虚拟机的快照, 快照默认按量收费 (购买存储包 包年包月)</td></tr><tr><td>镜像</td><td>创建镜像,需要创建快照—-&gt;镜像 , 镜像可以用来实现克隆的功能. 网站迁移功能</td></tr><tr><td>云盘</td><td>云服务器的磁盘 系统盘 数据盘</td></tr><tr><td>eip</td><td>弹性公网ip, 主要可以给slb,ecs….</td></tr><tr><td>按量负载(后付费)</td><td></td></tr><tr><td>包年包月(预付费)</td><td></td></tr></tbody></table><h1 id="三、ECS弹性服务器"><a href="#三、ECS弹性服务器" class="headerlink" title="三、ECS弹性服务器"></a>三、ECS弹性服务器</h1><h2 id="3-1-创建ECS"><a href="#3-1-创建ECS" class="headerlink" title="3.1 创建ECS"></a>3.1 创建ECS</h2><p>登录阿里云，选择云服务器ECS标签</p><p><img src="/../../../img/image-20240531134951566.png" alt="image-20240531134951566"></p><p>创建实例</p><p><img src="/../../../img/image-20240531135025507.png" alt="image-20240531135025507"></p><h3 id="3-1-1-基础配置"><a href="#3-1-1-基础配置" class="headerlink" title="3.1.1 基础配置"></a>3.1.1 基础配置</h3><h4 id="1）付费模式"><a href="#1）付费模式" class="headerlink" title="1）付费模式"></a>1）付费模式</h4><p><img src="/../../../img/image-20240531135310870.png" alt="image-20240531135310870"></p><table><thead><tr><th>模式</th><th>付费模式</th><th>备注</th></tr></thead><tbody><tr><td>包年包月</td><td>一次性付费</td><td></td></tr><tr><td>按量付费</td><td>按小时计算</td><td>可以临时测试使用</td></tr><tr><td>抢占式</td><td>按小时计算</td><td>价格更加便宜,如果某个地区的云服务器数量不足,可能会被释放 0.1元&#x2F;小时 价格随着需求变化</td></tr></tbody></table><h4 id="2）地区"><a href="#2）地区" class="headerlink" title="2）地区"></a>2）地区</h4><p>先选择地域</p><p><img src="/../../../img/image-20240531135334501.png" alt="image-20240531135334501"></p><p>  再选择可用区</p><p><img src="/../../../img/image-20240531135648999.png" alt="image-20240531135648999"></p><table><thead><tr><th>名词</th><th>说明</th><th>内网是否互通</th></tr></thead><tbody><tr><td>地域 region</td><td>不同的地区 北京(华北2) 杭州(华东1)</td><td>不同地域，内网不通</td></tr><tr><td>可用区 zone</td><td>可用区是同一个地域中的不同机房</td><td>同一个地域中的，不同可用区内网互通.</td></tr></tbody></table><h4 id="3）实例规格"><a href="#3）实例规格" class="headerlink" title="3）实例规格"></a>3）实例规格</h4><p>按需求选择</p><p><img src="/../../../img/image-20240531140020330.png" alt="image-20240531140020330"></p><h4 id="4）系统镜像"><a href="#4）系统镜像" class="headerlink" title="4）系统镜像"></a>4）系统镜像</h4><p>选择镜像名和镜像版本</p><p><img src="/../../../img/image-20240531140118695.png" alt="image-20240531140118695"></p><h4 id="5）存储"><a href="#5）存储" class="headerlink" title="5）存储"></a>5）存储</h4><p>系统盘：装系统</p><p>数据盘：存放数据</p><p><img src="/../../../img/image-20240531140320875.png" alt="image-20240531140320875"></p><h3 id="3-1-2-网络-VPC-和安全组"><a href="#3-1-2-网络-VPC-和安全组" class="headerlink" title="3.1.2 网络(VPC)和安全组"></a>3.1.2 网络(VPC)和安全组</h3><p>VPC是云服务器的虚拟局域网（专有网络）</p><p><img src="/../../../img/image-20240531144544983.png" alt="image-20240531144544983"></p><h4 id="a）创建专有网络"><a href="#a）创建专有网络" class="headerlink" title="a）创建专有网络"></a>a）创建专有网络</h4><p><img src="/../../../img/image-20240531144638192.png" alt="image-20240531144638192"></p><p>填写VPC名字和网段等信息</p><p><img src="/../../../img/image-20240531144731131.png" alt="image-20240531144731131"></p><p>创建交换机</p><p><img src="/../../../img/image-20240531144805921.png" alt="image-20240531144805921"></p><p>整体网络结构</p><p><img src="/../../../img/image-20240531144824221.png" alt="image-20240531144824221"></p><p>再添加一个交换机</p><p><img src="/../../../img/image-20240531144847608.png" alt="image-20240531144847608"></p><h4 id="b）公网流量的收费标准"><a href="#b）公网流量的收费标准" class="headerlink" title="b）公网流量的收费标准"></a>b）公网流量的收费标准</h4><p>公网流量费用按实际使用流量收费，每小时扣费。仅单向收取<strong>流出</strong>流量费用，流入流量免费。例如您在 1 小时内公网流出流量为6.51GB，收取费用为 6.51GB * 0.8 元 &#x2F; GB &#x3D; 5.20 元（注：不同地域“公网流量费用”的单价略有不同，实际价格请参照“当前配置”的<br>报价）  </p><h4 id="c）创建安全组"><a href="#c）创建安全组" class="headerlink" title="c）创建安全组"></a>c）创建安全组</h4><p>设置安全组名称，选择需要开放的端口</p><p><img src="/../../../img/image-20240531145137280.png" alt="image-20240531145137280"></p><h4 id="d）登录凭证（密码、密钥对等）"><a href="#d）登录凭证（密码、密钥对等）" class="headerlink" title="d）登录凭证（密码、密钥对等）"></a>d）登录凭证（密码、密钥对等）</h4><p><img src="/../../../img/image-20240531145234368.png" alt="image-20240531145234368"></p><h3 id="3-1-3-重置实例密码"><a href="#3-1-3-重置实例密码" class="headerlink" title="3.1.3 重置实例密码"></a>3.1.3 重置实例密码</h3><p>忘记实例密码了怎么办？</p><p>进入重置实例密码页面</p><p><img src="/../../../img/image-20240531145622612.png" alt="image-20240531145622612"></p><p>修改密码</p><p><img src="/../../../img/image-20240531145635831.png" alt="image-20240531145635831"></p><h3 id="3-1-4-更换VPC"><a href="#3-1-4-更换VPC" class="headerlink" title="3.1.4 更换VPC"></a>3.1.4 更换VPC</h3><p>VPC怎么更换？</p><p>选择更换专有网络，需要实例停止后才能换</p><p><img src="/../../../img/image-20240531145922957.png" alt="image-20240531145922957"></p><h3 id="3-1-5-磁盘挂载与使用"><a href="#3-1-5-磁盘挂载与使用" class="headerlink" title="3.1.5 磁盘挂载与使用"></a>3.1.5 磁盘挂载与使用</h3><h4 id="a）磁盘扩容"><a href="#a）磁盘扩容" class="headerlink" title="a）磁盘扩容"></a>a）磁盘扩容</h4><p>案例，扩容系统盘的大小</p><p><img src="/../../../img/image-20240531150250536.png" alt="image-20240531150250536"></p><p>设置扩容大小</p><p><img src="/../../../img/image-20240531150346163.png" alt="image-20240531150346163"></p><p>确认结果</p><p><img src="/../../../img/image-20240531150417702.png" alt="image-20240531150417702"></p><h4 id="b）新增云盘"><a href="#b）新增云盘" class="headerlink" title="b）新增云盘"></a>b）新增云盘</h4><p>实例详情页，点击创建云盘</p><p><img src="/../../../img/image-20240531150710110.png" alt="image-20240531150710110"></p><p>填写云盘类型、大小等信息（云盘随实例释放，可以按需求勾选）</p><p><img src="/../../../img/image-20240531150739356.png" alt="image-20240531150739356"></p><p>fdisk查看新硬盘</p><p><img src="/../../../img/image-20240531150852944.png" alt="image-20240531150852944"></p><h3 id="3-1-6-创建快照与镜像"><a href="#3-1-6-创建快照与镜像" class="headerlink" title="3.1.6 创建快照与镜像"></a>3.1.6 创建快照与镜像</h3><h4 id="a）创建快照"><a href="#a）创建快照" class="headerlink" title="a）创建快照"></a>a）创建快照</h4><p>实例详情页，点击创建快照</p><p><img src="/../../../img/image-20240531151059937.png" alt="image-20240531151059937"></p><p>填写快照信息</p><p><img src="/../../../img/image-20240531151138509.png" alt="image-20240531151138509"></p><p>查看快照，详情页的快照标签</p><p><img src="/../../../img/image-20240531151204170.png" alt="image-20240531151204170"></p><h4 id="b）创建自定义镜像"><a href="#b）创建自定义镜像" class="headerlink" title="b）创建自定义镜像"></a>b）创建自定义镜像</h4><p>通过快照，创建自定义的镜像，省去一台台机器重新部署环境的时间</p><p><img src="/../../../img/image-20240531151400382.png" alt="image-20240531151400382"></p><p>实例详情页，点击“创建自定义镜像”即可</p><p><img src="/../../../img/image-20240531151531823.png" alt="image-20240531151531823"></p><p>填写自定义镜像的信息</p><p><img src="/../../../img/image-20240531151651779.png" alt="image-20240531151651779"></p><p>查看创建的镜像</p><p><img src="/../../../img/image-20240531151734639.png" alt="image-20240531151734639"></p><h1 id="四、RDS数据库服务器"><a href="#四、RDS数据库服务器" class="headerlink" title="四、RDS数据库服务器"></a>四、RDS数据库服务器</h1><h2 id="4-1-创建RDS"><a href="#4-1-创建RDS" class="headerlink" title="4.1 创建RDS"></a>4.1 创建RDS</h2><p>类似于阿里云自动创建了一台带mysql数据库的服务器，供我们使用</p><p><img src="/../../../img/image-20240531152026861.png" alt="image-20240531152026861"></p><p>有四种版本：</p><ul><li>基础版本：单点</li><li>高可用版：两台，有故障自动切换</li><li>集群版：多点</li><li>三节点企业版：…</li></ul><p><img src="/../../../img/image-20240531152226787.png" alt="image-20240531152226787"></p><p>查看创建好的RDS</p><p><img src="/../../../img/image-20240531152439287.png" alt="image-20240531152439287"></p><p>数据安全信–添加内网访问地址</p><p><img src="/../../../img/image-20240531153904779.png" alt="image-20240531153904779"></p><h2 id="4-2-连接RDS"><a href="#4-2-连接RDS" class="headerlink" title="4.2 连接RDS"></a>4.2 连接RDS</h2><h3 id="4-2-1-创建数据库帐号"><a href="#4-2-1-创建数据库帐号" class="headerlink" title="4.2.1 创建数据库帐号"></a>4.2.1 创建数据库帐号</h3><p>点击“创建帐号”</p><p><img src="/../../../img/image-20240531152608808.png" alt="image-20240531152608808"></p><p>填写信息</p><p><img src="/../../../img/image-20240531152649837.png" alt="image-20240531152649837"></p><h3 id="4-2-2-网页登录数据库"><a href="#4-2-2-网页登录数据库" class="headerlink" title="4.2.2 网页登录数据库"></a>4.2.2 网页登录数据库</h3><p>点击右上角“登录数据库”，进入数据库管理页面</p><p><img src="/../../../img/image-20240531152752029.png" alt="image-20240531152752029"></p><h3 id="4-2-3-获取RDS的地址"><a href="#4-2-3-获取RDS的地址" class="headerlink" title="4.2.3 获取RDS的地址"></a>4.2.3 获取RDS的地址</h3><p>查看连接详情</p><p><img src="/../../../img/image-20240531152953648.png" alt="image-20240531152953648"></p><p>得到内网地址和端口</p><p><img src="/../../../img/image-20240531153020431.png" alt="image-20240531153020431"></p><h3 id="4-2-4-ECS连接RDS"><a href="#4-2-4-ECS连接RDS" class="headerlink" title="4.2.4 ECS连接RDS"></a>4.2.4 ECS连接RDS</h3><blockquote><p>注意：</p><p>RDS连接ECS需要做网络和安全组的设置：</p><ul><li>网络：RDS和ECS需要在同一个VPC中才能连接</li><li>安全组：网段释放、白名单等</li></ul></blockquote><p>ping测试连通性</p><p><img src="/../../../img/image-20240531153515014.png" alt="image-20240531153515014"></p><p>mysql连接</p><p><img src="/../../../img/image-20240531153536015.png" alt="image-20240531153536015"></p><h2 id="4-3-案例01-部署可道云"><a href="#4-3-案例01-部署可道云" class="headerlink" title="4.3 案例01-部署可道云"></a>4.3 案例01-部署可道云</h2><p>使用云主机ECS + RDS部署Kodebox站点</p><h3 id="4-3-1-RDS数据库部署"><a href="#4-3-1-RDS数据库部署" class="headerlink" title="4.3.1 RDS数据库部署"></a>4.3.1 RDS数据库部署</h3><p>创建kodbox账户</p><p><img src="/../../../img/image-20240531154552134.png" alt="image-20240531154552134"></p><p>创建kodbox数据库，关联账户</p><p><img src="/../../../img/image-20240531154658325.png" alt="image-20240531154658325"></p><h3 id="4-3-2-ECS部署可道云"><a href="#4-3-2-ECS部署可道云" class="headerlink" title="4.3.2 ECS部署可道云"></a>4.3.2 ECS部署可道云</h3><p>命令配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装nginx, epel源yum install -y nginxyum install -y epel-releaserpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;webtaticrelease.rpm# 安装phpyum -y install php72w php72w-cli php72w-common php72w-devel php72w-embedded php72w-gd php72w mbstring php72w-pdo php72w-xml php72w-fpm php72wmysqlnd php72w-opcache php72w-pecl-memcached php72w pecl-redis php72w-pecl-mongodb# 设置php配置文件sed -i &#39;s#apache#nginx#g&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf# nginx配置文件（略过）# 重启服务systemctl enable nginx.service php-fpm.servicesystemctl start nginx.service php-fpm.service# 部署代码wget https:&#x2F;&#x2F;static.kodcloud.com&#x2F;update&#x2F;download&#x2F;kodbox.1.37.zipunzip -q kodbox.1.37.zip -d &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</code></pre></div></figure><p>通过公网地址访问</p><p><img src="/../../../img/image-20240531155204615.png" alt="image-20240531155204615"></p><h1 id="五、NAS-OSS存储服务器"><a href="#五、NAS-OSS存储服务器" class="headerlink" title="五、NAS&#x2F;OSS存储服务器"></a>五、NAS&#x2F;OSS存储服务器</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>按存储类型分类，分为：</p><ul><li>块存储：磁盘、云盘</li><li>文件存储：<ul><li>nfs存储</li><li>samba存储（用于不同系统之间，如Linux &lt;—&gt; windows）</li><li>nas存储</li></ul></li><li>对象存储：自带数据高可用、ceph(开源软件)、阿里云oss</li></ul><p>nas和oss的区别</p><table><thead><tr><th></th><th>nas</th><th>oss</th></tr></thead><tbody><tr><td>共同点</td><td>存储(用户上传的文件)</td><td>存储(用户上传的文件)</td></tr><tr><td>区别00: 命名</td><td>文件存储</td><td>对象存储</td></tr><tr><td>区别01:应用场景</td><td>nfs&#x2F;smb, 适用于低并发,数据量不高情况</td><td>高并发,数据量比较大 10tb 1pb …</td></tr><tr><td>区别02: 容量</td><td>1pb&#x2F;10pb</td><td>无限制</td></tr><tr><td>区别03: 配置与使用</td><td>配置，linux mount进行挂载</td><td>配置，程序代码中调用(AK) access key</td></tr></tbody></table><h2 id="5-2-NAS文件存储"><a href="#5-2-NAS文件存储" class="headerlink" title="5.2 NAS文件存储"></a>5.2 NAS文件存储</h2><h3 id="5-2-1-创建NAS存储"><a href="#5-2-1-创建NAS存储" class="headerlink" title="5.2.1 创建NAS存储"></a>5.2.1 创建NAS存储</h3><p>页面搜索，选择“文件存储 NAS”</p><p><img src="/../../../img/image-20240531155807003.png" alt="image-20240531155807003"></p><p>点击创建“通用型NAS”</p><p><img src="/../../../img/image-20240531155843806.png" alt="image-20240531155843806"></p><p>进行配置</p><p><img src="/../../../img/image-20240531155958415.png" alt="image-20240531155958415"></p><p>创建完成，查看信息</p><p><img src="/../../../img/image-20240531160029643.png" alt="image-20240531160029643"> </p><h3 id="5-2-2-挂载NAS"><a href="#5-2-2-挂载NAS" class="headerlink" title="5.2.2  挂载NAS"></a>5.2.2  挂载NAS</h3><p>进入NAS实例详情页，点击“挂载使用”，查看挂载地址</p><p><img src="/../../../img/image-20240531160208880.png" alt="image-20240531160208880"></p><p>在ECS上挂载</p><p><img src="/../../../img/image-20240531160234012.png" alt="image-20240531160234012"></p><h2 id="5-3-OSS对象存储"><a href="#5-3-OSS对象存储" class="headerlink" title="5.3 OSS对象存储"></a>5.3 OSS对象存储</h2><p>程序代码调用OSS接口来读写</p><h3 id="5-3-1-创建OSS实例"><a href="#5-3-1-创建OSS实例" class="headerlink" title="5.3.1 创建OSS实例"></a>5.3.1 创建OSS实例</h3><p>页面搜索，选择“对象存储OSS”</p><p><img src="/../../../img/image-20240531160503732.png" alt="image-20240531160503732"></p><p>创建存储桶（Bucket）</p><p><img src="/../../../img/image-20240531160541772.png" alt="image-20240531160541772"></p><p>填写信息</p><p><img src="/../../../img/image-20240531160613719.png" alt="image-20240531160613719"></p><h3 id="5-3-2-RAM访问控制–创建用户"><a href="#5-3-2-RAM访问控制–创建用户" class="headerlink" title="5.3.2 RAM访问控制–创建用户"></a>5.3.2 RAM访问控制–创建用户</h3><p>前往RAM控制台</p><p><img src="/../../../img/image-20240531160846344.png" alt="image-20240531160846344"></p><p>创建用户</p><p><img src="/../../../img/image-20240531160934483.png" alt="image-20240531160934483"></p><p>填写信息</p><ul><li>控制台访问：这个用户能使用账户密码访问控制台</li><li>OpenAPI访问：应用能通过API调用OSS（勾上）</li></ul><p><img src="/../../../img/image-20240531161021449.png" alt="image-20240531161021449"></p><p>得到访问密码</p><p><img src="/../../../img/image-20240531161208054.png" alt="image-20240531161208054"></p><h3 id="5-3-3-RAM访问控制–用户授权"><a href="#5-3-3-RAM访问控制–用户授权" class="headerlink" title="5.3.3 RAM访问控制–用户授权"></a>5.3.3 RAM访问控制–用户授权</h3><p>进入RAM访问控制界面，给用户添加权限</p><p><img src="/../../../img/image-20240531161403453.png" alt="image-20240531161403453"></p><p>填写信息，让RAM用户有访问OSS的权限</p><p><img src="/../../../img/image-20240531161450340.png" alt="image-20240531161450340"></p><h3 id="5-3-4-ECS中的可道云连接OSS存储"><a href="#5-3-4-ECS中的可道云连接OSS存储" class="headerlink" title="5.3.4 ECS中的可道云连接OSS存储"></a>5.3.4 ECS中的可道云连接OSS存储</h3><p>需要准备的内容：</p><ul><li><p>创建OSS对象存储、Bucket存储桶、存储桶的名字</p></li><li><p>存储桶的域名和endpoint</p><p><img src="/../../../img/image-20240531161842839.png" alt="image-20240531161842839"></p></li><li><p>RAM的AK ID和AK Secret</p></li><li><p>RAM用户授权管理OSS存储</p></li></ul><p>Kodbox后台管理配置，连接OSS存储</p><p><img src="/../../../img/image-20240531161803935.png" alt="image-20240531161803935"></p><h3 id="5-3-5-测试上传文件"><a href="#5-3-5-测试上传文件" class="headerlink" title="5.3.5 测试上传文件"></a>5.3.5 测试上传文件</h3><p>阿里云管理界面能正常看到文件，说明上传成功</p><p><img src="/../../../img/image-20240531161954311.png" alt="image-20240531161954311"></p><h1 id="六、释放资源"><a href="#六、释放资源" class="headerlink" title="六、释放资源"></a>六、释放资源</h1><p>选择释放设置</p><p><img src="/../../../img/image-20240531162543247.png" alt="image-20240531162543247"></p><p>立即释放</p><p><img src="/../../../img/image-20240531162557496.png" alt="image-20240531162557496"></p><p>确认信息</p><p><img src="/../../../img/image-20240531162612157.png" alt="image-20240531162612157"></p><blockquote><p>快照、自定义镜像都需要收费的，用完及时删除</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day62-容器架构-Docker（四）</title>
    <link href="/2024/05/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day62-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-4/"/>
    <url>/2024/05/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day62-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-4/</url>
    
    <content type="html"><![CDATA[<h1 id="容器架构-Docker-04"><a href="#容器架构-Docker-04" class="headerlink" title="容器架构-Docker-04"></a>容器架构-Docker-04</h1><p>今日内容：</p><ul><li>容器互联</li></ul><h1 id="一、容器互联"><a href="#一、容器互联" class="headerlink" title="一、容器互联"></a>一、容器互联</h1><p>容器互联使用<code>--link</code>选项</p><h2 id="1-1-分离式nginx-php"><a href="#1-1-分离式nginx-php" class="headerlink" title="1.1 分离式nginx + php"></a>1.1 分离式nginx + php</h2><p>docker镜像架构分层次</p><ul><li>基础:系统</li><li>服务:nginx,php,tomcat,jdk,…..</li><li>业务:kodexp</li></ul><p><img src="/../../../img/image-20240530104417170.png" alt="image-20240530104417170"></p><p>实现：</p><h3 id="1-1-1-准备项目代码目录"><a href="#1-1-1-准备项目代码目录" class="headerlink" title="1.1.1 准备项目代码目录"></a>1.1.1 准备项目代码目录</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#lscode  conf  data# code存放kodexp的代码[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#ls code&#x2F;app  Changelog.md  config  data  index.php  plugins  static# 代码权限修改[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#chmod -R 777 code# conf存放配置文件# data存放数据文件</code></pre></div></figure><h3 id="1-1-2-启动php容器"><a href="#1-1-2-启动php容器" class="headerlink" title="1.1.2 启动php容器"></a>1.1.2 启动php容器</h3><ul><li>配置文件挂载：&#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;conf&#x2F;<a href="http://www.conf/">www.conf</a>  –&gt; &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;<a href="http://www.conf/">www.conf</a></li><li>kodexp代码挂载：&#x2F;app&#x2F;docker&#x2F;code&#x2F;kodexp&#x2F; –&gt; &#x2F;app&#x2F;code&#x2F;kodexp</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 准备php配置文件[root@docker02 &#x2F;app&#x2F;docker]#cat www.conf [www]user &#x3D; www-datagroup &#x3D; www-datalisten &#x3D; 0.0.0.0:9000pm &#x3D; dynamicpm.max_children &#x3D; 5pm.start_servers &#x3D; 2pm.min_spare_servers &#x3D; 1pm.max_spare_servers &#x3D; 3# 运行php容器，挂载配置文件和code目录[root@docker02 &#x2F;app&#x2F;docker]#docker run -d --name &quot;kodexp_php&quot; \-v &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;conf&#x2F;www.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf \-v &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;code:&#x2F;app&#x2F;code&#x2F;kodexp php:7-fpm-alpine </code></pre></div></figure><blockquote><p>nginx与php，代码目录一致</p></blockquote><h3 id="1-1-3-启动nginx容器，互联php"><a href="#1-1-3-启动nginx容器，互联php" class="headerlink" title="1.1.3 启动nginx容器，互联php"></a>1.1.3 启动nginx容器，互联php</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># nginx配置[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;conf]#cat nginx.conf user nginx;worker_processes auto;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log notice;pid &#x2F;var&#x2F;run&#x2F;nginx.pid;events &#123;  worker_connections 1024;&#125;http &#123;  include &#x2F;etc&#x2F;nginx&#x2F;mime.types;  default_type application&#x2F;octet-stream;  log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main;  sendfile on;  #tcp_nopush on;  keepalive_timeout 65;  #gzip on;  include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;&#125;# kodexp的配置[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;conf]#cat kodexp.conf server &#123;  listen 80;  server_name kodexp.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;kodexp;  location &#x2F; &#123;    index index.php;  &#125;    location ~ \.php$ &#123;      # php是容器的名字，或者--link指定的容器别名      fastcgi_pass php:9000;      fastcgi_index index.php;      fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;      include fastcgi_params;  &#125;&#125;# 启动容器# --link 容器名字:别名[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#docker run -d --name &quot;kodexp_nginx&quot; -p 10086:80 \--link kodexp_php:php \-v &#96;pwd&#96;&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \-v &#96;pwd&#96;&#x2F;conf&#x2F;kodexp.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;kodexp.conf \-v &#96;pwd&#96;&#x2F;code:&#x2F;app&#x2F;code&#x2F;kodexp&#x2F; \nginx:stable-alpine</code></pre></div></figure><p>测试，设置hosts访问：<a href="http://kodexp.oldboylinux.cn:10086/">http://kodexp.oldboylinux.cn:10086/</a></p><p><img src="/../../../img/image-20240530114344355.png" alt="image-20240530114344355"></p><h3 id="1-1-4-解决GD扩展的问题"><a href="#1-1-4-解决GD扩展的问题" class="headerlink" title="1.1.4 解决GD扩展的问题"></a>1.1.4 解决GD扩展的问题</h3><p>访问显示建议开启GD扩展，可以通过Dockerfile来定制php镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#debian系统FROM php:7.4-fpmRUN apt-get update &amp;&amp; apt-get install -y \libfreetype6-dev \libjpeg62-turbo-dev \libpng-dev \&amp;&amp; docker-php-ext-configure gd --with-freetype --with-jpeg \&amp;&amp; docker-php-ext-install -j$(nproc) gd</code></pre></div></figure><p>构建镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;05_link_nginx_php]#docker build -t php_gd:7.4-fpm .</code></pre></div></figure><p>再使用新建的镜像启动php</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app&#x2F;docker]#docker run -d --name &quot;kodexp_php&quot; \-v &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;conf&#x2F;www.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf \-v &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;code:&#x2F;app&#x2F;code&#x2F;kodexp php_gd:7.4-fpm </code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day63-容器架构-Docker（五）</title>
    <link href="/2024/05/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day63-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-5/"/>
    <url>/2024/05/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day63-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-5/</url>
    
    <content type="html"><![CDATA[<h1 id="容器架构-Docker-05"><a href="#容器架构-Docker-05" class="headerlink" title="容器架构-Docker-05"></a>容器架构-Docker-05</h1><p>今日内容：</p><ul><li>容器编排</li></ul><h1 id="一、容器编排工具Compose"><a href="#一、容器编排工具Compose" class="headerlink" title="一、容器编排工具Compose"></a>一、容器编排工具Compose</h1><h2 id="1-1-容器编排介绍"><a href="#1-1-容器编排介绍" class="headerlink" title="1.1 容器编排介绍"></a>1.1 容器编排介绍</h2><p>目前存在的问题：docker容器的管理(启动,关闭,重启)，需要手动执行，如何自动管理多个容器？  就像docker镜像可以通过Dockerfile一键创建。</p><p>这时，就是能使用容器编排技术。</p><p>单机容器编排工具：</p><ul><li>docker compose</li><li>需要单独安装(epel源中就有),语法yaml格式</li></ul><p>容器集群管理的方法：</p><ul><li>ansible + docker compose + dockerfile</li><li>docker swarm实现集群管理.</li><li>mesos</li><li>未来我们通过k8s kubernetes实现集群管理</li></ul><p>了解：docker三剑客</p><ul><li>docker machine(管理虚拟机)</li><li>docker compose(容器编排)</li><li>docker swarm(集群)</li></ul><h2 id="1-2-compose初步上手"><a href="#1-2-compose初步上手" class="headerlink" title="1.2 compose初步上手"></a>1.2 compose初步上手</h2><h3 id="1-2-1-安装"><a href="#1-2-1-安装" class="headerlink" title="1.2.1 安装"></a>1.2.1 安装</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装[root@docker02 &#x2F;]#yum install -y docker-compose # 准备工作目录[root@docker02 &#x2F;]#mkdir -p &#x2F;server&#x2F;compose&#x2F;01-run-nginx</code></pre></div></figure><h3 id="1-2-1-书写配置文件"><a href="#1-2-1-书写配置文件" class="headerlink" title="1.2.1 书写配置文件"></a>1.2.1 书写配置文件</h3><p>书写格式参考：</p><p><img src="/../../../img/image-20240530125740774.png" alt="image-20240530125740774"></p><p>编写一个简单的compose，部署nginx容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;compose&#x2F;01-run-nginx]#cat docker-compose.yml version: &quot;3.3&quot;services:  nginx_compose:    image: &quot;nginx:stable-alpine&quot;    ports:      - &quot;18848:80&quot;</code></pre></div></figure><blockquote><p>compose文件有一定的命名规则，建议按规范来</p></blockquote><h3 id="1-2-3-运行"><a href="#1-2-3-运行" class="headerlink" title="1.2.3 运行"></a>1.2.3 运行</h3><p>执行yaml文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;compose&#x2F;01-run-nginx]#docker-compose up -dCreating 01runnginx_nginx_compose_1 ... done</code></pre></div></figure><p>查看，使用compose的ps</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看[root@docker02 &#x2F;server&#x2F;compose&#x2F;01-run-nginx]#docker-compose  ps        Name                   Command          State           Ports        -----------------------------------------------------------------------------01runnginx_nginx_comp   &#x2F;docker-entrypoint.sh   Up      0.0.0.0:18848-&gt;80&#x2F;tcpose_1                   ngin ...                        ,:::18848-&gt;80&#x2F;tcp </code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;compose&#x2F;01-run-nginx]#curl localhost:18848&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;...</code></pre></div></figure><h2 id="1-3-docker-compose命令"><a href="#1-3-docker-compose命令" class="headerlink" title="1.3 docker-compose命令"></a>1.3 docker-compose命令</h2><p>docker-compose可以用于创建、运行容器、删除容器、查看容器情况等，包含多种功能。</p><p>实际上这个命令包含了docker container和docker image命令</p><table><thead><tr><th>命令格式</th><th>功能</th></tr></thead><tbody><tr><td>up</td><td>up &#x3D;&#x3D; run，创建并运行容器<br/>其中<code>up -d</code>代表后台运行</td></tr><tr><td>down</td><td>关闭容器、删除容器以及相关资源<font color=red>（慎用！！）</font></td></tr><tr><td>stop&#x2F;start&#x2F;restart</td><td>关闭、开启、重启容器</td></tr><tr><td>ps</td><td>查看容器运行情况，可选用<code>-q</code>选项</td></tr><tr><td>top</td><td>查看容器进程信息</td></tr><tr><td>logs</td><td>容器日志</td></tr><tr><td>rm</td><td>删除容器（需要容器已经关闭）</td></tr><tr><td>images</td><td>查看镜像</td></tr></tbody></table><blockquote><p>注意：</p><p>docker-compose命令只能看到受compose编排的容器信息</p></blockquote><h2 id="1-4-修改docker-compose与生效"><a href="#1-4-修改docker-compose与生效" class="headerlink" title="1.4 修改docker-compose与生效"></a>1.4 修改docker-compose与生效</h2><p>如果docker-compose简单修改端口、数据卷</p><ul><li><code>docker-compose up -d</code>会自动识别，重新创建容器.</li></ul><p>如果容器的名字也改了，会造成新旧容器的端口冲突，会失败</p><ul><li>可以<code> docker-compose up -d --remove-orphans</code> 删除之前容器或失效容器</li></ul><h2 id="1-5-compose文件常用指令"><a href="#1-5-compose文件常用指令" class="headerlink" title="1.5 compose文件常用指令"></a>1.5 compose文件常用指令</h2><p>挂载数据卷、容器之间的依赖、先后顺序。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">depends_on: 依赖,先启动指定的容器然后再启动当前容器.volumes: 数据卷links: 容器连接,本质hosts解析</code></pre></div></figure><blockquote><p>建议到官网查找，按需求使用</p></blockquote><h2 id="1-6-案例-compose部署kodexp"><a href="#1-6-案例-compose部署kodexp" class="headerlink" title="1.6 案例:compose部署kodexp"></a>1.6 案例:compose部署kodexp</h2><p>把容器互联的案例，用compose再实现一遍</p><p>文件目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#lscode  conf  data  docker-compose.yml</code></pre></div></figure><p>原来的命令操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># php[root@docker02 &#x2F;app&#x2F;docker]#docker run -d --name &quot;kodexp_php&quot; \-v &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;conf&#x2F;www.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf \-v &#x2F;app&#x2F;docker&#x2F;kodexp&#x2F;code:&#x2F;app&#x2F;code&#x2F;kodexp php:7-fpm-alpine # nginx[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#docker run -d --name &quot;kodexp_nginx&quot; -p 10086:80 \--link kodexp_php:php \-v &#96;pwd&#96;&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \-v &#96;pwd&#96;&#x2F;conf&#x2F;kodexp.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;kodexp.conf \-v &#96;pwd&#96;&#x2F;code:&#x2F;app&#x2F;code&#x2F;kodexp&#x2F; \nginx:stable-alpine</code></pre></div></figure><p>改用compose的yml文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#cat docker-compose.yml version: &quot;3.3&quot;services:  kodexp_ngx:    image: &quot;nginx:stable-alpine&quot;    ports:      - &quot;12580:80&quot;    links:      - &quot;kodexp_php:php&quot;    depends_on:      - &quot;kodexp_php&quot;    volumes:      - &quot;.&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;      - &quot;.&#x2F;conf&#x2F;kodexp.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;kodexp.conf&quot;      - &quot;.&#x2F;code:&#x2F;app&#x2F;code&#x2F;kodexp&quot;  kodexp_php:    image: &quot;php:7-fpm-alpine&quot;    volumes:      - &quot;.&#x2F;conf&#x2F;www.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm&#x2F;www.conf&quot;      - &quot;.&#x2F;code:&#x2F;app&#x2F;code&#x2F;kodexp&quot;</code></pre></div></figure><p>执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#docker-compose up -d Creating kodexp_kodexp_php_1 ... doneCreating kodexp_kodexp_php_1 ... Creating kodexp_kodexp_ngx_1 ... done</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#docker-compose  ps       Name                  Command           State           Ports         -----------------------------------------------------------------------------kodexp_kodexp_ngx_1   &#x2F;docker-entrypoint.sh    Up      0.0.0.0:12580-&gt;80&#x2F;tcp,                      ngin ...                         :::12580-&gt;80&#x2F;tcp      kodexp_kodexp_php_1   docker-php-entrypoint    Up      9000&#x2F;tcp    </code></pre></div></figure><p><img src="/../../../img/image-20240530165306409.png" alt="image-20240530165306409"></p><blockquote><p>问题记录：</p><p>在启动后容器后，nginx容器显示EXIT 1状态，不正常。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#docker-compose ps       Name                      Command               State     Ports  &gt;------------------------------------------------------------------------&gt;kodexp_kodexp_ngx_1   &#x2F;docker-entrypoint.sh ngin ...   Exit 1           &gt;kodexp_kodexp_php_1   docker-php-entrypoint php-fpm    Up       9000&#x2F;tcp</code></pre></div></figure><p>查看日志发现问题是由kodexp_php容器的别名引起的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;nginx: [emerg] host not found in upstream &quot;php&quot; in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;kodexp.conf:10</code></pre></div></figure><p>修改nginx配置文件，不使用别名即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@docker02 &#x2F;app&#x2F;docker&#x2F;kodexp]#!cat&gt;cat conf&#x2F;kodexp.conf &gt;server &#123; listen 80; server_name kodexp.oldboylinux.cn; root &#x2F;app&#x2F;code&#x2F;kodexp; location &#x2F; &#123;   index index.php; &#125;   location ~ \.php$ &#123;     fastcgi_pass kodexp_php:9000;# 不用别名     fastcgi_index index.php;     fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;     include fastcgi_params; &#125;&gt;&#125;</code></pre></div></figure></blockquote><h2 id="1-7-案例：compose和dockerfile结合使用"><a href="#1-7-案例：compose和dockerfile结合使用" class="headerlink" title="1.7 案例：compose和dockerfile结合使用"></a>1.7 案例：compose和dockerfile结合使用</h2><p>通过dockerfile构建镜像，在通过compose启动容器</p><p>以tengine的bird案例为基准，重构为：tengine+birds+compose</p><p>目录结构</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;01_bird]#lsbird.tar.gz  docker-compose.yml  Dockerfile  tengine-2.3.3.tar.gz</code></pre></div></figure><p>yml内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;01_bird]#cat docker-compose.yml version: &quot;3.3&quot;services:  ngx_bird:    build: .    image: &quot;web:ngx_bird&quot;    ports:      - &quot;80:80&quot;</code></pre></div></figure><p>Dockerfile内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM ubuntu:20.04LABEL author&#x3D;&quot;Haris Gong&quot; \url&#x3D;&#39;gsproj.github.io&#39;ADD tengine-2.3.3.tar.gz &#x2F;tmp&#x2F;ENV Web_User&#x3D;&quot;nginx&quot;ENV Web_Server&#x3D;&quot;tengine&quot;ENV Web_Version&#x3D;&quot;2.3.2&quot;ENV Server_Dir&#x3D;&quot;&#x2F;app&#x2F;tools&#x2F;tengine-2.3.2&quot;ENV Server_Dir_Soft&#x3D;&quot;&#x2F;app&#x2F;tools&#x2F;tengine&quot;RUN sed -ri &#39;s#archive.ubuntu.com|security.ubuntu.com#mirrors.aliyun.com#g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list \&amp;&amp; apt update &amp;&amp; apt-get install -y vim curl libssl-dev make gcc pcre2-utils libpcre3-dev zlib1g-dev \&amp;&amp; cd &#x2F;tmp&#x2F;tengine-2.3.3&#x2F; \&amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;tools&#x2F;$&#123;Web_Server&#125;-$&#123;Web_Version&#125;&#x2F; \--user&#x3D;$&#123;Web_User&#125; \--group&#x3D;$&#123;Web_User&#125; \--with-http_ssl_module \--with-http_v2_module \--with-http_realip_module \--with-http_stub_status_module \--with-http_mp4_module \--with-stream \--with-stream_ssl_module \--with-stream_realip_module \--add-module&#x3D;modules&#x2F;ngx_http_upstream_check_module&#x2F; \--add-module&#x3D;modules&#x2F;ngx_http_upstream_session_sticky_module \&amp;&amp; make -j 1 \&amp;&amp; make install \&amp;&amp; ln -s $&#123;Server_Dir&#125; $&#123;Server_Dir_Soft&#125; \&amp;&amp; ln -s $&#123;Server_Dir_Soft&#125;&#x2F;sbin&#x2F;nginx &#x2F;sbin&#x2F;nginx \&amp;&amp; groupadd $&#123;Web_User&#125; \&amp;&amp; useradd -s &#x2F;sbin&#x2F;nologin -g $&#123;Web_User&#125; $&#123;Web_User&#125;ADD bird.tar.gz $&#123;Server_Dir_Soft&#125;&#x2F;html&#x2F;RUN rm -fr &#x2F;tmp&#x2F;* &#x2F;var&#x2F;cache&#x2F;*EXPOSE 80CMD [ &quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot; ]</code></pre></div></figure><p>执行compose，可见compose自动调用Dockerfile开始构建ngx_bird镜像。</p><p>但是<strong>构建完之后有警告</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;01_bird]#docker-compose up -dCreating network &quot;01bird_default&quot; with the default driverBuilding ngx_birdStep 1&#x2F;13 : FROM ubuntu:20.0420.04: Pulling from library&#x2F;ubuntu7b1a6ab2e44d: Already existsDigest: sha256:626ffe58f6e7566e00254b638eb7e0f3b11d4da9675088f4781a50ae288f3322...Successfully built 2642d663c8d5Successfully tagged web:ngx_bird# ！警告！WARNING: Image for service ngx_bird was built because it did not already exist. To rebuild this image you must use &#96;docker-compose build&#96; or &#96;docker-compose up --build&#96;.Creating 01bird_ngx_bird_1 ... done</code></pre></div></figure><p>按照警告的要求执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;01_bird]#docker-compose up -d --buildBuilding ngx_bird..Successfully built 2642d663c8d5Successfully tagged web:ngx_bird01bird_ngx_bird_1 is up-to-date</code></pre></div></figure><p>已经运行起来了</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;01_bird]#docker-compose ps      Name                Command          State             Ports           -----------------------------------------------------------------------------01bird_ngx_bird_1   nginx -g daemon off;   Up      0.0.0.0:80-&gt;80&#x2F;tcp,:::80-&gt;                                                   80&#x2F;tcp            </code></pre></div></figure><p>测试，访问：<a href="http://10.0.0.82/">http://10.0.0.82:80</a></p><p><img src="/../../../img/image-20240530171048926.png" alt="image-20240530171048926"></p><h1 id="二、Docker镜像仓库"><a href="#二、Docker镜像仓库" class="headerlink" title="二、Docker镜像仓库"></a>二、Docker镜像仓库</h1><p>Docker镜像仓库主要分为四种，具有各自的应用场景</p><table><thead><tr><th>仓库方案</th><th>应用场景</th></tr></thead><tbody><tr><td>镜像保存为压缩包</td><td>save&#x2F;load，仅适用于节点极少的情况，很不方便</td></tr><tr><td>registry镜像仓库</td><td>适用于小型网站集群（镜像不多，环境不复杂），命令行操作，使用方便</td></tr><tr><td>harbor镜像仓库</td><td>企业级镜像仓库（docker、k8s都可用），图形化页面</td></tr><tr><td>公有云的镜像仓库</td><td>在公有云上申请（个人、企业）</td></tr></tbody></table><h2 id="2-1-registry仓库"><a href="#2-1-registry仓库" class="headerlink" title="2.1 registry仓库"></a>2.1 registry仓库</h2><h3 id="2-1-1-环境准备"><a href="#2-1-1-环境准备" class="headerlink" title="2.1.1 环境准备"></a>2.1.1 环境准备</h3><table><thead><tr><th>主机名</th><th>IP地址</th><th>备注</th></tr></thead><tbody><tr><td>docker01</td><td>10.0.0.81</td><td></td></tr><tr><td>docker02</td><td>10.0.0.82</td><td>作为仓库</td></tr></tbody></table><p>所有主机对应主机名能够解析  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt;&gt;&#x2F;etc&#x2F;hosts&lt;&lt;EOF10.0.0.81 docker0110.0.0.82 docker02EOF</code></pre></div></figure><h3 id="2-1-2-极速上手"><a href="#2-1-2-极速上手" class="headerlink" title="2.1.2 极速上手"></a>2.1.2 极速上手</h3><h4 id="A-服务端部署"><a href="#A-服务端部署" class="headerlink" title="A.服务端部署"></a>A.服务端部署</h4><p>1、安装镜像仓库服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;]#docker pull registryUsing default tag: latest</code></pre></div></figure><p>2、配置服务端，允许使用http（未来所有使用私有镜像仓库的节点都要配置）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&lt;&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;bjjtv7cs.mirror.aliyuncs.com&quot;],  &quot;insecure-registries&quot;: [&quot;docker02:5000&quot;]&#125;EOF</code></pre></div></figure><p>配置完重启docker</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart docker</code></pre></div></figure><p>3、启动registry容器（未来可以用compose实现）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建数据卷[root@docker02 &#x2F;]#docker volume create registry[root@docker02 &#x2F;]#docker volume lsDRIVER    VOLUME NAMElocal     oldboydatalocal     registry# 映射端口，并启动docker run -d --name &quot;oldboy_registry&quot;  \-p 5000:5000 -v registry:&#x2F;var&#x2F;lib&#x2F;registry \--restart&#x3D;always registry:latest# --restart表示容器异常退出,会自动重启容器</code></pre></div></figure><p>访问：<a href="http://docker02:5000/v2/_catalog">http://docker02:5000/v2/_catalog</a></p><p>查看私有仓库信息（默认没有什么有用信息）</p><p><img src="/../../../img/image-20240530183620025.png" alt="image-20240530183620025"></p><h4 id="B-客户端上传镜像"><a href="#B-客户端上传镜像" class="headerlink" title="B.客户端上传镜像"></a>B.客户端上传镜像</h4><p>1、客户端docker02，上传镜像</p><p>首先也得设置docker配置文件，并重启docker服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&lt;&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;bjjtv7cs.mirror.aliyuncs.com&quot;],  &quot;insecure-registries&quot;: [&quot;docker02:5000&quot;]&#125;EOF</code></pre></div></figure><p>2、再镜像打标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]#docker imagesREPOSITORY   TAG                        IMAGE ID       CREATED       SIZE...nginx        stable-alpine              373f8d4d4c60   2 years ago   23.2MB...[root@docker01 ~]#docker tag nginx:stable-alpine docker02:5000&#x2F;myimages&#x2F;nginx:stable-alpine[root@docker01 ~]#docker imagesREPOSITORY                     TAG                        IMAGE ID       CREATED       SIZE...nginx                          stable-alpine              373f8d4d4c60   2 years ago   23.2MBdocker02:5000&#x2F;myimages&#x2F;nginx   stable-alpine              373f8d4d4c60   2 years ago   23.2MB...</code></pre></div></figure><p>3、再上传</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]#docker push docker02:5000&#x2F;myimages&#x2F;nginx:stable-alpine The push refers to repository [docker02:5000&#x2F;myimages&#x2F;nginx]6f44c5b5d074: Pushed 002fcf848e67: Pushed e419fa208fe1: Pushed 112ee9c2903a: Pushed 68e5252d0d33: Pushed 1a058d5342cc: Pushed stable-alpine: digest: sha256:f6609f898bcdad15047629edc4033d17f9f90e2339fb5ccb97da267f16902251 size: 1568</code></pre></div></figure><blockquote><p>如果没有提前进行docker配置，会报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@docker01 ~]#docker push docker02:5000&#x2F;myimages&#x2F;nginx:stable-alpine &gt;The push refers to repository [docker02:5000&#x2F;myimages&#x2F;nginx]&gt;Get &quot;https:&#x2F;&#x2F;docker02:5000&#x2F;v2&#x2F;&quot;: http: server gave HTTP response to HTTPS client&gt;[root@docker01 ~]#vim &#x2F;etc&#x2F;docker&#x2F;daemon.json </code></pre></div></figure></blockquote><p>再次访问registry网页，可以看到上传到的镜像</p><p><img src="/../../../img/image-20240530184607477.png" alt="image-20240530184607477"></p><h4 id="C-客户端下载镜像"><a href="#C-客户端下载镜像" class="headerlink" title="C.客户端下载镜像"></a>C.客户端下载镜像</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]#docker pull docker02:5000&#x2F;myimages&#x2F;nginx:stable-alpine stable-alpine: Pulling from myimages&#x2F;nginxDigest: sha256:f6609f898bcdad15047629edc4033d17f9f90e2339fb5ccb97da267f16902251Status: Downloaded newer image for docker02:5000&#x2F;myimages&#x2F;nginx:stable-alpinedocker02:5000&#x2F;myimages&#x2F;nginx:stable-alpine</code></pre></div></figure><h3 id="2-1-3-写成compose"><a href="#2-1-3-写成compose" class="headerlink" title="2.1.3 写成compose"></a>2.1.3 写成compose</h3><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#registry-docker-composeversion: &quot;3.3&quot;services:  oldboy_registry:    container_name: &quot;oldboy_reg&quot;    image: &quot;registry:latest&quot;    ports:      - &quot;5000:5000&quot;    restart: always    volumes:      - &quot;registry:&#x2F;var&#x2F;lib&#x2F;registry&quot;volumes:  registry:</code></pre></div></figure><h2 id="2-2-企业级镜像仓库–harbor"><a href="#2-2-企业级镜像仓库–harbor" class="headerlink" title="2.2 企业级镜像仓库–harbor"></a>2.2 企业级镜像仓库–harbor</h2><h3 id="2-2-1-极速上手"><a href="#2-2-1-极速上手" class="headerlink" title="2.2.1 极速上手"></a>2.2.1 极速上手</h3><h4 id="A-服务端部署-1"><a href="#A-服务端部署-1" class="headerlink" title="A.服务端部署"></a>A.服务端部署</h4><p>1、github下载harbor</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">https:&#x2F;&#x2F;github.com&#x2F;goharbor&#x2F;harbor&#x2F;releases</code></pre></div></figure><p>2、解压</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app]#tar -vxf harbor-offline-installer-v2.9.4.tgz harbor&#x2F;harbor.v2.9.4.tar.gzharbor&#x2F;prepareharbor&#x2F;LICENSEharbor&#x2F;install.sh# 每次修改配置，都需要执行下harbor&#x2F;common.shharbor&#x2F;harbor.yml.tmpl# 配置文件模板</code></pre></div></figure><p>3、hosts文件修改，添加harbor的域名</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt;&gt;&#x2F;etc&#x2F;hosts&lt;&lt;EOF10.0.0.81 docker0110.0.0.82 docker02 harbor.gs.cnEOF</code></pre></div></figure><p>4、编辑harbor配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 从模板复制一份[root@docker02 &#x2F;app&#x2F;harbor]#cp harbor.yml.tmpl harbor.yml# 修改主机名hostname: harbor.gs.cn# 禁用https功能#https:  # https port for harbor, default is 443  #port: 443  # The path of cert and key files for nginx  #certificate: &#x2F;your&#x2F;certificate&#x2F;path  #private_key: &#x2F;your&#x2F;private&#x2F;key&#x2F;path# 修改默认密码harbor_admin_password: redhat123</code></pre></div></figure><p>5、安装harbor</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;app&#x2F;harbor]#.&#x2F;install.sh [Step 0]: checking if docker is installed ...Note: docker version: 26.1.3... ✔ Container harbor-jobservice  Starte...                               3.1s  ✔ Container nginx              Started                                 3.1s ✔ ----Harbor has been installed and started successfully.----</code></pre></div></figure><blockquote><p>注意：</p><p>​要检查80端口是否被占用  </p></blockquote><p>浏览器访问：<a href="http://harbor.gs.cn/">http://harbor.gs.cn</a></p><p><img src="/../../../img/image-20240530191350136.png" alt="image-20240530191350136"></p><blockquote><p>admin &#x2F; redhat123</p></blockquote><h4 id="B-客户端使用"><a href="#B-客户端使用" class="headerlink" title="B. 客户端使用"></a>B. 客户端使用</h4><p>1、配置docker</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]#vim &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123;        &quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;bjjtv7cs.mirror.aliyuncs.com&quot;],        &quot;insecure-registries&quot;: [&quot;harbor.gs.cn&quot;]&#125;# 重启服务systemctl restart docker</code></pre></div></figure><p>2、登录harbor</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]#docker login -uadmin -predhat123 harbor.gs.cnWARNING! Using --password via the CLI is insecure. Use --password-stdin.WARNING! Your password will be stored unencrypted in &#x2F;root&#x2F;.docker&#x2F;config.json.Configure a credential helper to remove this warning. Seehttps:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;login&#x2F;#credentials-storeLogin Succeeded</code></pre></div></figure><p>3、打标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]#docker imagesREPOSITORY                     TAG                        IMAGE ID       CREATED       SIZEtengine                        birds-v1                   403c22c533aa   2 days ago    427MB...[root@docker01 ~]#docker tag tengine:birds-v1 harbor.gs.cn&#x2F;library&#x2F;tengine:birds-v1[root@docker01 ~]#docker imagesREPOSITORY                     TAG                        IMAGE ID       CREATED       SIZEtengine                        birds-v1                   403c22c533aa   2 days ago    427MBharbor.gs.cn&#x2F;library&#x2F;tengine   birds-v1                   403c22c533aa   2 days ago    427MB...</code></pre></div></figure><blockquote><p>tag的目录要跟harbor中的目录一致！</p></blockquote><p>4、上传</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]#docker push harbor.gs.cn&#x2F;library&#x2F;tengine:birds-v1 The push refers to repository [harbor.gs.cn&#x2F;library&#x2F;tengine]6d3a7f85e089: Pushed 000e70118252: Pushed 910ec3ec43d0: Pushed ee1e9dcd2d96: Pushed 9f54eef41275: Pushed birds-v1: digest: sha256:aa0f126752929d60811c709bc5c3042e3dd3e4bb2200e893aee2b8cdede932c6 size: 1369</code></pre></div></figure><p>查看上传的镜像</p><p><img src="/../../../img/image-20240530192036861.png" alt="image-20240530192036861"></p><h3 id="2-2-2-harbor高可用-（了解）"><a href="#2-2-2-harbor高可用-（了解）" class="headerlink" title="2.2.2 harbor高可用 （了解）"></a>2.2.2 harbor高可用 （了解）</h3><p>可以通过harbor自带的镜像同步工具实现.(搭建2个harbor服务器)，找出harbor的镜像目录(registry目录),目录备份&#x2F;同步  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;data&#x2F;registry&#x2F;docker&#x2F;registry&#x2F;v2&#x2F;repositories</code></pre></div></figure><h2 id="2-3-Dockerr命令–脑图"><a href="#2-3-Dockerr命令–脑图" class="headerlink" title="2.3 Dockerr命令–脑图"></a>2.3 Dockerr命令–脑图</h2><p><a href="https://www.processon.com/view/link/6347dbb207912921d8137498">https://www.processon.com/view/link/6347dbb207912921d8137498</a> </p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day61-容器架构-Docker（三）</title>
    <link href="/2024/05/28/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day61-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-3/"/>
    <url>/2024/05/28/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day61-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-3/</url>
    
    <content type="html"><![CDATA[<h1 id="容器架构-Docker-03"><a href="#容器架构-Docker-03" class="headerlink" title="容器架构-Docker-03"></a>容器架构-Docker-03</h1><p>今日内容：</p><p>- </p><h1 id="一、容器自动化Dockerfile"><a href="#一、容器自动化Dockerfile" class="headerlink" title="一、容器自动化Dockerfile"></a>一、容器自动化Dockerfile</h1><p>手动自定义镜像，就像加工流水线，需要一直进行重复的操作：</p><p><img src="/../../../img/image-20240528144044279.png" alt="image-20240528144044279"></p><p>需要使用Dockerfile来让它自动化运行</p><h2 id="1-1-手动实现-创建tengine镜像"><a href="#1-1-手动实现-创建tengine镜像" class="headerlink" title="1.1 手动实现-创建tengine镜像"></a>1.1 手动实现-创建tengine镜像</h2><p>目标：先手动创建tengine镜像，了解流程</p><h3 id="1-1-1-启动Ubuntu容器"><a href="#1-1-1-启动Ubuntu容器" class="headerlink" title="1.1.1 启动Ubuntu容器"></a>1.1.1 启动Ubuntu容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动[root@docker01 &#x2F;]#docker run -itd --name &quot;tengine_bird_v1&quot; ubuntu:20.04 &#x2F;bin&#x2F;bash# 进入[root@docker01 &#x2F;]#docker exec -it tengine_bird_v1 &#x2F;bin&#x2F;bashroot@281122640a6d:&#x2F;# </code></pre></div></figure><h3 id="1-1-2-配置apt源并安装软件"><a href="#1-1-2-配置apt源并安装软件" class="headerlink" title="1.1.2 配置apt源并安装软件"></a>1.1.2 配置apt源并安装软件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 替换为阿里源root@281122640a6d:&#x2F;# sed -ri &#39;s#archive.ubuntu.com|security.ubuntu.com#mirrors.aliyun.com#g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list# 更新缓存root@281122640a6d:&#x2F;# apt update# 安装必要软件root@281122640a6d:&#x2F;# apt-get install -y vim curl</code></pre></div></figure><h3 id="1-1-3-编译安装tengine"><a href="#1-1-3-编译安装tengine" class="headerlink" title="1.1.3 编译安装tengine"></a>1.1.3 编译安装tengine</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载源码包[root@docker01 &#x2F;tmp]#wget http:&#x2F;&#x2F;tengine.taobao.org&#x2F;download&#x2F;tengine-2.3.3.tar.gz# 拷贝到容器中[root@docker01 &#x2F;tmp]#docker cp &#x2F;tmp&#x2F;tengine-2.3.3.tar.gz tengine_bird_v1:&#x2F;rootSuccessfully copied 2.85MB to tengine_bird_v1:&#x2F;root# 容器安装依赖root@281122640a6d:&#x2F;# apt install -y libssl-dev make gcc pcre2-utils libpcre3-dev zlib1g-dev# 解压源码包root@281122640a6d:~# tar -vxf tengine-2.3.3.tar.gz# configureroot@281122640a6d:~# cd tengine-2.3.3.&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;tools&#x2F;tengine-2.3.3&#x2F; \--user&#x3D;nginx \--group&#x3D;nginx \--with-http_ssl_module \--with-http_v2_module \--with-http_realip_module \--with-http_stub_status_module \--with-http_mp4_module \--with-stream \--with-stream_ssl_module \--with-stream_realip_module \--add-module&#x3D;modules&#x2F;ngx_http_upstream_check_module&#x2F; \--add-module&#x3D;modules&#x2F;ngx_http_upstream_session_sticky_module# 编译make -j 1# 安装make install# 检查root@281122640a6d:~&#x2F;tengine-2.3.3# &#x2F;app&#x2F;tools&#x2F;tengine-2.3.3&#x2F;sbin&#x2F;nginx -V   Tengine version: Tengine&#x2F;2.3.3...# 创建软连接ln -s &#x2F;app&#x2F;tools&#x2F;tengine-2.3.3&#x2F; &#x2F;app&#x2F;tools&#x2F;tengineln -s &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;sbin&#x2F;nginx &#x2F;sbin&#x2F;nginx root@281122640a6d:~&#x2F;tengine-2.3.3# which nginx&#x2F;usr&#x2F;sbin&#x2F;nginx</code></pre></div></figure><h3 id="1-1-4-启动测试"><a href="#1-1-4-启动测试" class="headerlink" title="1.1.4 启动测试"></a>1.1.4 启动测试</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加用户和组root@281122640a6d:~&#x2F;tengine-2.3.3# groupadd nginxroot@281122640a6d:~&#x2F;tengine-2.3.3# useradd -s &#x2F;sbin&#x2F;nologin -g nginx nginx# 启动nginxroot@281122640a6d:~&#x2F;tengine-2.3.3# nginx# 替换nginx的index.html内容root@281122640a6d:~&#x2F;tengine-2.3.3# echo &quot;tengine.test.cn&quot; &gt; &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;html&#x2F;index.html # 测试root@281122640a6d:~&#x2F;tengine-2.3.3# curl localhosttengine.test.cn</code></pre></div></figure><h3 id="1-1-5-清理镜像"><a href="#1-1-5-清理镜像" class="headerlink" title="1.1.5 清理镜像"></a>1.1.5 清理镜像</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#  清理代码包,解压目录root@281122640a6d:~&#x2F;tengine-2.3.3# rm -fr &#x2F;tmp&#x2F;*# 清理apt&#x2F;yum缓存root@281122640a6d:~&#x2F;tengine-2.3.3# rm -fr &#x2F;var&#x2F;cache&#x2F;*# 其他的清理,逐步测试</code></pre></div></figure><h3 id="1-1-6-生成镜像"><a href="#1-1-6-生成镜像" class="headerlink" title="1.1.6 生成镜像"></a>1.1.6 生成镜像</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;]#docker commit tengine_bird_v1 tengine:2.3.3-v1sha256:d4c5e64200721ed068583ca21fef9e5df2e2a293d6c449161406c5818f1f23d5# 查看[root@docker01 &#x2F;]#docker imagesREPOSITORY   TAG                        IMAGE ID       CREATED         SIZEtengine      2.3.3-v1                   d4c5e6420072   4 seconds ago   382MBnginx        stable-alpine_restart_v1   21ca067362e8   3 days ago      23.2MBnginx        latest                     605c77e624dd   2 years ago     141MBnginx        stable-alpine              373f8d4d4c60   2 years ago     23.2MBubuntu       20.04                      ba6acccedd29   2 years ago     72.8MBcentos       latest                     5d0da3dc9764   2 years ago     231MB</code></pre></div></figure><h3 id="1-1-7-运行容器（重要）"><a href="#1-1-7-运行容器（重要）" class="headerlink" title="1.1.7 运行容器（重要）"></a>1.1.7 运行容器（重要）</h3><p>运行手动创建的自定义镜像注意事项:⭐ </p><p>启动容器，要有个服务在前台阻塞住，自定义的容器中没有配置的，需要手动指定  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 关闭nginx守护进程模式,前台运行nginx -g &#39;daemon off;&#39;</code></pre></div></figure><p>启动容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;]#docker run -d --name &quot;tengine-2.3.3-v1-test&quot; -p 80:80ne:2.3.3-v1 nginx -g &#39;daemon off;&#39;6706ac141ef17168f0eff0838c2754466d67a7524579adb32b3e5efdd14c7bc7# 查看[root@docker01 &#x2F;]#docker psCONTAINER ID   IMAGE              COMMAND                  CREATED       STATUS             PORTS                               NAMES6706ac141ef1   tengine:2.3.3-v1   &quot;nginx -g &#39;daemon of…&quot;   7 seconds ag  Up 6 seconds       0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   tengine-2.3.3-t281122640a6d   ubuntu:20.04       &quot;&#x2F;bin&#x2F;bash&quot;              About an hou  Up About an hour                                       tengine_bird_</code></pre></div></figure><p>检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;]#curl 10.0.0.81:80tengine.test.cn</code></pre></div></figure><h3 id="1-1-8-日志重定向"><a href="#1-1-8-日志重定向" class="headerlink" title="1.1.8 日志重定向"></a>1.1.8 日志重定向</h3><p>目前自定义的容器日志存放在容器的<code>/app/tools/tengine/logs/</code>目录中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@6706ac141ef1:&#x2F;# ls &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;logs&#x2F;access.log  error.log  nginx.pid</code></pre></div></figure><p>关于日志的处理，有两种方案：</p><ul><li>方案01 日志目录挂载到宿主机的某个目录中.<ul><li>优点：方便使用<code>docker logs</code>查看</li></ul></li><li>方法02 把日志软连接到&#x2F;dev&#x2F;stdout 和&#x2F;dev&#x2F;stderr中,未来可以通过docker logs 查看日志  <ul><li>优点：灵活，多种情况的各种日志推荐使用这个.</li></ul></li></ul><p>这里采用方案二实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@6706ac141ef1:&#x2F;# rm -f &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;logs&#x2F;*      root@6706ac141ef1:&#x2F;# ln -s &#x2F;dev&#x2F;stdout &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;logs&#x2F;access.logroot@6706ac141ef1:&#x2F;# ln -s &#x2F;dev&#x2F;stderr &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;logs&#x2F;error.log</code></pre></div></figure><p>修改完需要重启容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;]#docker restart 670</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;]#!curlcurl 10.0.0.81:80tengine.test.cn[root@docker01 &#x2F;]#docker logs tengine-2.3.3-v1-test 10.0.0.81 - - [28&#x2F;May&#x2F;2024:07:58:27 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 16 &quot;-&quot; &quot;curl&#x2F;7.29.0&quot;</code></pre></div></figure><h2 id="1-2-Dockerfile介绍"><a href="#1-2-Dockerfile介绍" class="headerlink" title="1.2 Dockerfile介绍"></a>1.2 Dockerfile介绍</h2><h3 id="1-2-1-Dockerfile的概述"><a href="#1-2-1-Dockerfile的概述" class="headerlink" title="1.2.1 Dockerfile的概述"></a>1.2.1 Dockerfile的概述</h3><p>应用场景：</p><ul><li>通过1个文件Dockerfile，docker build可以自动化生成自定义镜像</li></ul><p>为何使用Dockerfile:</p><ul><li>我们目前都是手动拉取镜像,手动进行配置,手动安装依赖,手动编译安装,创建用户….，这个过程类似于命令行使用ansible模块(繁琐,不方便重复执行).</li><li>书写Dockerfile把之前手动创建自定义镜像的过程，通过Dockerfile里面的指令实现，类似于书写playbook.</li></ul><h3 id="1-2-2-Dockerfile格式"><a href="#1-2-2-Dockerfile格式" class="headerlink" title="1.2.2 Dockerfile格式"></a>1.2.2 Dockerfile格式</h3><p>Dokerfile主要分为四部分：</p><ol><li>指定基础镜像（FROM）</li><li>自定义镜像信息（LABLE）</li><li>对于镜像的处理指令（RUN）</li><li>容器启动后的入口命令（CMD）</li></ol><p><img src="/../../../img/image-20240528160116805.png" alt="image-20240528160116805"></p><h3 id="1-2-3-使用dockerfile"><a href="#1-2-3-使用dockerfile" class="headerlink" title="1.2.3 使用dockerfile"></a>1.2.3 使用dockerfile</h3><p>创建Dockerfile并生成自动镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建Dockerfile文件[root@docker01 &#x2F;tmp]#cat Dockerfile FROM nginx:stable-alpineLABEL author&#x3D;&quot;Haris Gong&quot;RUN rm -rf &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlRUN echo &#39;docker file oldboyedu linux&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]# 执行[root@docker01 &#x2F;tmp]#docker build -t nginx:diy_img_test_v1 .[+] Building 0.6s (7&#x2F;7) FINISHED                       docker:default &#x3D;&gt; [internal] load build definition from Dockerfile             0.0s &#x3D;&gt; &#x3D;&gt; transferring dockerfile: 301B                             0.0s &#x3D;&gt; [internal] load metadata for docker.io&#x2F;library&#x2F;nginx:stable  0.0s &#x3D;&gt; [internal] load .dockerignore                                0.0s &#x3D;&gt; &#x3D;&gt; transferring context: 2B                                  0.0s &#x3D;&gt; [1&#x2F;3] FROM docker.io&#x2F;library&#x2F;nginx:stable-alpine             0.0s &#x3D;&gt; [2&#x2F;3] RUN rm -rf &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html            0.3s &#x3D;&gt; [3&#x2F;3] RUN echo &#39;docker file oldboyedu linux&#39; &gt; &#x2F;usr&#x2F;share&#x2F;n  0.2s &#x3D;&gt; exporting to image                                           0.1s &#x3D;&gt; &#x3D;&gt; exporting layers                                          0.1s &#x3D;&gt; &#x3D;&gt; writing image sha256:24d3d4dc972c98cc7fe2654274c5bf2a4ed  0.0s &#x3D;&gt; &#x3D;&gt; naming to docker.io&#x2F;library&#x2F;nginx:diy_img_test_v1         0.0s# 查看，已生成[root@docker01 &#x2F;tmp]#docker imagesREPOSITORY   TAG                        IMAGE ID       CREATED          SIZEnginx        diy_img_test_v1            24d3d4dc972c   7 seconds ago    23.2MB... </code></pre></div></figure><p>使用镜像运行容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 运行[root@docker01 &#x2F;tmp]#docker run -d -p 81:80 --name &#39;diy_img&#39; nginx:diy_img_test_v1 797c40f7cdefc80e0c8a279c57cd31675196bde110c9457a1133c4c0e48230a1# 访问站点，成功[root@docker01 &#x2F;tmp]#curl 10.0.0.81:81docker file oldboyedu linux</code></pre></div></figure><h3 id="1-2-4-Dockerfile中的指令"><a href="#1-2-4-Dockerfile中的指令" class="headerlink" title="1.2.4 Dockerfile中的指令"></a>1.2.4 Dockerfile中的指令</h3><p>开头部分</p><table><thead><tr><th>指令</th><th>含义</th><th>应用</th><th>建议</th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td>指定基本镜像</td><td>FROM ubuntu:20.04</td><td>尽量少写ubuntu或ubuntu:latest,尽量指定具体的版本</td></tr><tr><td><strong>LABEL</strong></td><td>用于指定容器的属性信息,作者,个人联系方式(邮件)..</td><td>LABEL maintainer&#x3D;”lidao996”</td><td>推荐使用LABEL，不推荐使用下面的MAINTAINER</td></tr><tr><td>MAINTAINER</td><td>不再使用,推荐使用LABEL 个人信息</td><td></td><td></td></tr><tr><td>ENV</td><td>用于创建Dockerfile中使用的变量</td><td>ENV Tengine_Version空格2.3.3</td><td>创建变量定义软件版本</td></tr></tbody></table><p>中间部分</p><table><thead><tr><th>指令</th><th>含义</th><th>应用</th><th>建议</th></tr></thead><tbody><tr><td><strong>RUN</strong></td><td>制作镜像过程中需要的执行命令</td><td>RUN 系统命令即可</td><td>不建议使用连续多个RUN</td></tr><tr><td>ADD</td><td>把指定文件或目录拷贝到容器中(指定目录)，会解压压缩包</td><td>ADD restart.tar.gz空格&#x2F;app&#x2F;code&#x2F;restart&#x2F;</td><td>拷贝压缩包</td></tr><tr><td><strong>COPY</strong></td><td>把指定文件或目录拷贝到容器中(指定目录)，不支持解压</td><td>CP nginx.conf空格&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</td><td>拷贝文件或目录</td></tr><tr><td>WORKDIR</td><td>指定 容器 的默认工作目录</td><td>WORKDIR &#x2F;app&#x2F;code&#x2F;restart&#x2F; ADD restart.tar.gz空.</td><td>一般配合ADD,COPY使用</td></tr><tr><td>VOLUME</td><td>挂载数据卷</td><td>VOLUME &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</td><td>创建随机数据卷挂载容器的目录.未来推荐docker run的时候指定 -v即可.</td></tr></tbody></table><p>结尾部分</p><table><thead><tr><th>指令</th><th>含义</th><th>应用</th><th>建议</th></tr></thead><tbody><tr><td><strong>EXPOSE</strong></td><td>指定镜像要对外暴露的端口</td><td>EXPOSE 80</td><td>用于指定一个或多个容器的端口.<br/>未来这个端口可以被<code>-p</code>识别.xxxx:80</td></tr><tr><td><strong>CMD</strong></td><td>指定容器的入口命令，入口命令可以在docker run的时候替换</td><td>CMD [“nginx”,”-g”,”daemon off;”]</td><td>建议使用</td></tr><tr><td>ENTRYPOINT</td><td>指定容器的入口命令，入口命令在不可以在docker run的时候替换</td><td>ENTRYPOINT [“executable”,”param1”, “param2”]</td><td>使用不多</td></tr></tbody></table><blockquote><p>CMD和ENTRYPOINT的区别：</p><p>共同点：</p><ul><li>运行容器的时候默认运行CMD或ENTRYPOINT后面的命令</li></ul><p>区别：</p><ul><li>CMD：run的时候可以替换，如果指定了命令内容，cmd内容就会被替换  </li><li>ENTRYPOINT：run的时候无法替换，如果指定了命令内容，仅成为entrypoint命令的参数而已.</li></ul><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]&gt;ENTRYPOINT [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]&gt;# docker run未指定，共同点: 默认运行CMD或ENTRYPOINT后面的命令.&gt;docker run -d test:ngx &gt;# docker run指定参数&gt;docker run -d test:ngx sleep 999&gt;# 使用的是CMD形式运行&gt;sleep 999&gt;# 使用ENTRYPOINT形式运行 &gt;nginx -g &quot;daemon off;&quot; sleep 999</code></pre></div></figure></blockquote><h2 id="1-3-自动实现-创建Tengine镜像"><a href="#1-3-自动实现-创建Tengine镜像" class="headerlink" title="1.3 自动实现-创建Tengine镜像"></a>1.3 自动实现-创建Tengine镜像</h2><p>目录准备</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;server&#x2F;dockerfile]#lsbird.tar.gz  Dockerfile  tengine-2.3.3.tar.gz</code></pre></div></figure><p>编写Dockerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;server&#x2F;dockerfile]#cat Dockerfile FROM ubuntu:20.04LABEL author&#x3D;&quot;Haris Gong&quot; \url&#x3D;&#39;gsproj.github.io&#39;ADD tengine-2.3.3.tar.gz &#x2F;tmp&#x2F;RUN sed -ri &#39;s#archive.ubuntu.com|security.ubuntu.com#mirrors.aliyun.com#g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list \&amp;&amp; apt update &amp;&amp; apt-get install -y vim curl libssl-dev make gcc pcre2-utils libpcre3-dev zlib1g-dev \&amp;&amp; cd &#x2F;tmp&#x2F;tengine-2.3.3&#x2F; \&amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;tools&#x2F;tengine-2.3.3&#x2F; \--user&#x3D;nginx \--group&#x3D;nginx \--with-http_ssl_module \--with-http_v2_module \--with-http_realip_module \--with-http_stub_status_module \--with-http_mp4_module \--with-stream \--with-stream_ssl_module \--with-stream_realip_module \--add-module&#x3D;modules&#x2F;ngx_http_upstream_check_module&#x2F; \--add-module&#x3D;modules&#x2F;ngx_http_upstream_session_sticky_module \&amp;&amp; make -j 1 \&amp;&amp; make install \&amp;&amp; ln -s &#x2F;app&#x2F;tools&#x2F;tengine-2.3.3&#x2F; &#x2F;app&#x2F;tools&#x2F;tengine \&amp;&amp; ln -s &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;sbin&#x2F;nginx &#x2F;sbin&#x2F;nginx \&amp;&amp; groupadd nginx \&amp;&amp; useradd -s &#x2F;sbin&#x2F;nologin -g nginx nginxADD bird.tar.gz &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;html&#x2F;RUN rm -fr &#x2F;tmp&#x2F;* &#x2F;var&#x2F;cache&#x2F;*EXPOSE 80CMD [ &quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot; ]</code></pre></div></figure><p>运行Docerfile创建镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;server&#x2F;dockerfile]#docker build -t tengine:birds-v1 .[+] Building 230.8s (10&#x2F;10) FINISHED                   docker:default &#x3D;&gt; [internal] load build definition from Dockerfile             0.0s &#x3D;&gt; &#x3D;&gt; transferring dockerfile: 1.17kB                           0.0s &#x3D;&gt; [internal] load metadata for docker.io&#x2F;library&#x2F;ubuntu:20.04  0.0s &#x3D;&gt; [internal] load .dockerignore                                0.0s &#x3D;&gt; &#x3D;&gt; transferring context: 2B                                  0.0s &#x3D;&gt; [1&#x2F;5] FROM docker.io&#x2F;library&#x2F;ubuntu:20.04                    0.0s &#x3D;&gt; [internal] load build context                                0.0s &#x3D;&gt; &#x3D;&gt; transferring context: 191B                                0.0s &#x3D;&gt; CACHED [2&#x2F;5] ADD tengine-2.3.3.tar.gz &#x2F;tmp&#x2F;                  0.0s &#x3D;&gt; [3&#x2F;5] RUN sed -ri &#39;s#archive.ubuntu.com|security.ubuntu.c  228.6s &#x3D;&gt; [4&#x2F;5] ADD bird.tar.gz &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;html&#x2F;               0.0s  &#x3D;&gt; [5&#x2F;5] RUN rm -fr &#x2F;tmpՎˇ &#x2F;var&#x2F;cache&#x2F;*                         0.2s  &#x3D;&gt; exporting to image                                           1.9s  &#x3D;&gt; &#x3D;&gt; exporting layers                                          1.9s  &#x3D;&gt; &#x3D;&gt; writing image sha256:403c22c533aa21ac617c1c2144340604675  0.0s  &#x3D;&gt; &#x3D;&gt; naming to docker.io&#x2F;library&#x2F;tengine:birds-v1              0.0s</code></pre></div></figure><p>运行容器，并测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 &#x2F;server&#x2F;dockerfile]#docker run -d -p 82:80 --name diy_birds_test tengine:birds-v1 0ef2d36833a1ebb29aa22c6506828664c3851e1d5075e28ec94987a6adb9e9dc</code></pre></div></figure><p><img src="/../../../img/image-20240528165520939.png" alt="image-20240528165520939"></p><h2 id="1-4-案例"><a href="#1-4-案例" class="headerlink" title="1.4 案例"></a>1.4 案例</h2><h3 id="1-4-1-Dockerfile-ENV使用变量"><a href="#1-4-1-Dockerfile-ENV使用变量" class="headerlink" title="1.4.1 Dockerfile ENV使用变量"></a>1.4.1 Dockerfile ENV使用变量</h3><p>在Dockerfile中，可以使用ENV指令来定义变量，如</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ENV name&#x3D;&quot;Haris&quot;</code></pre></div></figure><p>用变量的方法改写1.3的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM ubuntu:20.04LABEL author&#x3D;&quot;Haris Gong&quot; \url&#x3D;&#39;gsproj.github.io&#39;ADD tengine-2.3.3.tar.gz &#x2F;tmp&#x2F;ENV Web_User&#x3D;&quot;nginx&quot;ENV Web_Server&#x3D;&quot;tengine&quot;ENV Web_Version&#x3D;&quot;2.3.2&quot;ENV Server_Dir&#x3D;&quot;&#x2F;app&#x2F;tools&#x2F;tengine-2.3.2&quot;ENV Server_Dir_Soft&#x3D;&quot;&#x2F;app&#x2F;tools&#x2F;tengine&quot;RUN sed -ri &#39;s#archive.ubuntu.com|security.ubuntu.com#mirrors.aliyun.com#g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list \&amp;&amp; apt update &amp;&amp; apt-get install -y vim curl libssl-dev make gcc pcre2-utils libpcre3-dev zlib1g-dev \&amp;&amp; cd &#x2F;tmp&#x2F;tengine-2.3.3&#x2F; \&amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;tools&#x2F;$&#123;Web_Server&#125;-$&#123;Web_Version&#125;&#x2F; \--user&#x3D;$&#123;Web_User&#125; \--group&#x3D;$&#123;Web_User&#125; \--with-http_ssl_module \--with-http_v2_module \--with-http_realip_module \--with-http_stub_status_module \--with-http_mp4_module \--with-stream \--with-stream_ssl_module \--with-stream_realip_module \--add-module&#x3D;modules&#x2F;ngx_http_upstream_check_module&#x2F; \--add-module&#x3D;modules&#x2F;ngx_http_upstream_session_sticky_module \&amp;&amp; make -j 1 \&amp;&amp; make install \&amp;&amp; ln -s $&#123;Server_Dir&#125; $&#123;Server_Dir_Soft&#125; \&amp;&amp; ln -s $&#123;Server_Dir_Soft&#125;&#x2F;sbin&#x2F;nginx &#x2F;sbin&#x2F;nginx \&amp;&amp; groupadd $&#123;Web_User&#125; \&amp;&amp; useradd -s &#x2F;sbin&#x2F;nologin -g $&#123;Web_User&#125; $&#123;Web_User&#125;ADD bird.tar.gz $&#123;Server_Dir_Soft&#125;&#x2F;html&#x2F;RUN rm -fr &#x2F;tmp&#x2F;* &#x2F;var&#x2F;cache&#x2F;*EXPOSE 80CMD [ &quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot; ]</code></pre></div></figure><p>构建</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#docker build -t tengine:birds-vars_v2 .[+] Building 235.7s (10&#x2F;10) FINISHED                   docker:default...[root@docker02 &#x2F;server&#x2F;dockerfile]#docker imagesREPOSITORY   TAG             IMAGE ID       CREATED          SIZEtengine      birds-vars_v2   9369584ba8ab   54 seconds ago   427MBtengine      birds-v1        a823ac7e01d4   19 minutes ago   409MB</code></pre></div></figure><h3 id="1-4-2-多服务镜像nginx-php"><a href="#1-4-2-多服务镜像nginx-php" class="headerlink" title="1.4.2 多服务镜像nginx+php"></a>1.4.2 多服务镜像nginx+php</h3><p>流程:</p><ul><li>基础镜像:centos:7</li><li>配置yum源.</li><li>安装Nginx</li><li>安装php软件包</li><li>站点目录,传输代码.修改所有者</li><li>写CMD入口脚本(给权限,注意格式 )</li></ul><p>编写Dockerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#cat Dockerfile FROM centos:7ENV WEB_USER&#x3D;nginxADD ngx-dep-php72w.tar.gz &#x2F;tmpCOPY entrypoint.sh &#x2F;RUN curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;Centos-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo \&amp;&amp; curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo \&amp;&amp; sed -i &#39;s#keepCache&#x3D;0#keepCache&#x3D;1#g&#39; &#x2F;etc&#x2F;yum.conf \&amp;&amp; yum localinstall -y &#x2F;tmp&#x2F;*.rpm \&amp;&amp; sed -i &#39;s#apache#$&#123;WEB_USER&#125;#g&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.confEXPOSE 80 9000CMD [&quot;&#x2F;entrypoint.sh&quot;]</code></pre></div></figure><p><img src="/../../../img/image-20240529105035068.png" alt="image-20240529105035068"></p><p>入口脚本文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#cat entrpoint.sh #!&#x2F;bin&#x2F;bashphp-fpmnginx -g &quot;daemon off;&quot;</code></pre></div></figure><p>离线包<code>ngx-dep-php72w.tar.gz</code>的获取方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加php的yum repo[root@docker02 &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7]#vim &#x2F;etc&#x2F;yum.repos.d&#x2F;php.repo[webtatic-php]name &#x3D; php Repositorybaseurl &#x3D; http:&#x2F;&#x2F;us-east.repo.webtatic.com&#x2F;yum&#x2F;el7&#x2F;x86_64enabled &#x3D; 1gpgcheck &#x3D; 0# 获取安装包[root@docker02 &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7]#yum install -y  --downloaddir&#x3D;&#x2F;tmp&#x2F;ngx-php --downloadonly php72w php72w-cli php72w-common php72w-devel php72w-embedded php72w-gd php72wmcrypt php72w-mbstring php72w-pdo php72w-xml php72w-fpm php72w-mysqlnd php72w-opcache php72wpecl-memcached php72w-pecl-redis php72w-peclmongodb nginx# 打包成ngx-dep-php72w.tar.gz</code></pre></div></figure><p>执行Dockerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#lsDockerfile  entrpoint.sh  ngx-dep-php72w.tar.gz  old[root@docker02 &#x2F;server&#x2F;dockerfile]#docker build -t centos:nginx_php_v1 .[+] Building 129.2s (9&#x2F;9) FINISHED                                         ...</code></pre></div></figure><p>测试运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#docker imagesREPOSITORY   TAG             IMAGE ID       CREATED             SIZEcentos       nginx_php_v1    c25c0c0349c1   28 seconds ago      700MB...[root@docker02 &#x2F;server&#x2F;dockerfile]#docker run -d -P --name nginx_php_test centos:nginx_php_v1261c8ef7b4e37a42d05315a9a4b24444e6d097541e9c81b290c28bac5f6db8fb# -P随机端口，映射指定暴露的端口，80、9000[root@docker02 &#x2F;server&#x2F;dockerfile]#docker psCONTAINER ID   IMAGE                 COMMAND            CREATED          STATUS          PORTS                                                                                  NAMES261c8ef7b4e3   centos:nginx_php_v1   &quot;&#x2F;entrypoint.sh&quot;   22 seconds ago   Up 21 seconds   0.0.0.0:32771-&gt;80&#x2F;tcp, :::32771-&gt;80&#x2F;tcp, 0.0.0.0:32770-&gt;9000&#x2F;tcp, :::32770-&gt;9000&#x2F;tcp   nginx_php_test</code></pre></div></figure><h3 id="1-4-3-使用上面的镜像部署可道云"><a href="#1-4-3-使用上面的镜像部署可道云" class="headerlink" title="1.4.3 使用上面的镜像部署可道云"></a>1.4.3 使用上面的镜像部署可道云</h3><p>主配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#cat nginx.conf user nginx;worker_processes auto;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log notice;pid &#x2F;var&#x2F;run&#x2F;nginx.pid;events &#123;  worker_connections 1024;&#125;http &#123;  include &#x2F;etc&#x2F;nginx&#x2F;mime.types;  default_type application&#x2F;octet-stream;  log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main;  sendfile on;  #tcp_nopush on;  keepalive_timeout 65;  #gzip on;  include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;&#125;</code></pre></div></figure><p>子配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#cat kodexp.confserver &#123;  listen 80;  server_name kodexp.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;kodexp;  location &#x2F; &#123;    index index.php;  &#125;    location ~ \.php$ &#123;      fastcgi_pass 127.0.0.1:9000;      fastcgi_index index.php;      fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;      include fastcgi_params;  &#125;&#125;</code></pre></div></figure><p>下载可道云源码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https:&#x2F;&#x2F;static.kodcloud.com&#x2F;update&#x2F;download&#x2F;kodbox.1.50.zip# 解压放到kodexp文件夹中，再打成压缩包</code></pre></div></figure><p>编写Dockerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM centos:nginx_php_v1LABEL author&#x3D;&quot;haris&quot; url&#x3D;&quot;www.gs.com&quot;COPY nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.confCOPY kodexp.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;kodexp.confADD kodexp.tar.gz &#x2F;app&#x2F;codeRUN chown -R nginx.nginx &#x2F;app&#x2F;code&#x2F;kodexp</code></pre></div></figure><p>现在总共是这些文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile]#lsDockerfile  kodexp.conf  kodexp.tar.gz  nginx.conf</code></pre></div></figure><p>运行Dockerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;03_kodebox]#docker build -t mykodebox:v1 .[+] Building 4.3s (10&#x2F;10) FINISHED                                         </code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;03_kodebox]#docker imagesREPOSITORY   TAG            IMAGE ID       CREATED             SIZEmykodebox    v1             cec672b90ed8   26 seconds ago      880MBcentos       nginx_php_v1   c25c0c0349c1   About an hour ago   700MB[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;03_kodebox]#docker run -d -P mykodebox:v1 6a50b56907fb764428b28aaa47019d38b9e4c04d8461516c178438b871807888[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;03_kodebox]#docker psCONTAINER ID   IMAGE          COMMAND            CREATED         STATUS         PORTS                                                                                  NAMES6a50b56907fb   mykodebox:v1   &quot;&#x2F;entrypoint.sh&quot;   9 seconds ago   Up 9 seconds   0.0.0.0:32775-&gt;80&#x2F;tcp, :::32775-&gt;80&#x2F;tcp, 0.0.0.0:32774-&gt;9000&#x2F;tcp, :::32774-&gt;9000&#x2F;tcp   upbeat_shaw</code></pre></div></figure><p>浏览器访问：<a href="http://10.0.0.82:32775![image-20240529121302947](../../../img/image-20240529121302947.png)">http://10.0.0.82:32775![image-20240529121302947](../../../img/image-20240529121302947.png)</a></p><blockquote><p>里面要求连接数据库，连172.16.1.51添加用户即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;grant all on kodbox.* to &#39;kodbox&#39;@&#39;172.16.1.%&#39; identified by &#39;redhat123&#39;;</code></pre></div></figure></blockquote><h3 id="1-4-4-多阶段提交"><a href="#1-4-4-多阶段提交" class="headerlink" title="1.4.4 多阶段提交"></a>1.4.4 多阶段提交</h3><p>目前使用多节点提交实现:</p><p>编译安装一些软件的时候,一般是先安装各种依赖,然后开始编译安装，编译安装一般会生成新的命令.</p><ul><li>1个镜像负责编译安装,生成命令.(临时)</li><li>1个镜像上一个镜像的命令复制过来+服务必要的配置.</li></ul><p>使用最后生成镜像，Dockerfile如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;04_duojieduan]#cat Dockerfile # 设置处理镜像，AS TEMP的意思是临时使用FROM ubuntu:20.04 AS TEMP# 基本信息LABEL author&#x3D;&quot;gs&quot; \  url&#x3D;&quot;www.gs.com&quot;# 变量ENV WEB_SERVER&#x3D;tengine-2.3.3ENV INSTALL_DIR&#x3D;&#x2F;app&#x2F;tools&#x2F;$&#123;WEB_SERVER&#125;ENV NGX_USER&#x3D;nginxENV CPU_CORES&#x3D;1# 传输软件ADD tengine-2.3.3.tar.gz &#x2F;tmp&#x2F;# 环境准备RUN sed -ri &#39;s#archive.ubuntu.com|security.ubuntu.com#mirrors.aliyun.com#g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list \&amp;&amp; apt update \&amp;&amp; apt install -y libssl-dev make gcc pcre2-utils libpcre3-dev zlib1g-dev \&amp;&amp; cd &#x2F;tmp&#x2F;tengine-2.3.3 \&amp;&amp; .&#x2F;configure --prefix&#x3D;$&#123;INSTALL_DIR&#125; \--user&#x3D;$&#123;NGX_USER&#125; \--group&#x3D;$&#123;NGX_USER&#125; \--with-http_ssl_module \--with-http_v2_module \--with-http_realip_module \--with-http_stub_status_module \--with-http_mp4_module \--with-stream \--with-stream_ssl_module \--with-stream_realip_module \--add-module&#x3D;modules&#x2F;ngx_http_upstream_check_module&#x2F; \--add-module&#x3D;modules&#x2F;ngx_http_upstream_session_sticky_module \&amp;&amp; make -j $&#123;CPU_CORES&#125; \&amp;&amp; make install# 编译安装结束，生成tengine的nginx命令# 到此，第一个镜像的任务完成了# 开始第二各镜像的任务FROM ubuntu:20.04ENV NGX_USER&#x3D;nginx# 从TEMP镜像拷贝文件COPY --from&#x3D;TEMP &#x2F;app&#x2F; &#x2F;app&#x2F;RUN sed -ri &#39;s#archive.ubuntu.com|security.ubuntu.com#mirrors.aliyun.com#g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list \&amp;&amp; apt-get updateRUN apt-get install -y libssl-dev pcre2-utils libpcre3-dev zlib1g-devRUN ln -s &#x2F;app&#x2F;tools&#x2F;tengine-2.3.3&#x2F; &#x2F;app&#x2F;tools&#x2F;tengine \&amp;&amp; ln -s &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;sbin&#x2F;nginx &#x2F;sbin&#x2F;nginx \&amp;&amp; useradd -s &#x2F;sbin&#x2F;nologin $&#123;NGX_USER&#125;# 将站点目录文件放到tengine中ADD bird.tar.gz &#x2F;app&#x2F;tools&#x2F;tengine&#x2F;html&#x2F;# 删除临时文件RUN rm -fr &#x2F;tmp&#x2F;* &#x2F;var&#x2F;cache&#x2F;*# 设置暴露80端口EXPOSE 80# 设置入口命令CMD [ &quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot; ]</code></pre></div></figure><p>构建镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;04_duojieduan]#lsbird.tar.gz  Dockerfile  tengine-2.3.3.tar.gz[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;04_duojieduan]#docker build -t tengine:duojieduan-v1 .[+] Building 569.9s (14&#x2F;14) FINISHED                                       </code></pre></div></figure><p>可见TEMP的镜像并没有image保存</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;04_duojieduan]#docker imagesREPOSITORY   TAG             IMAGE ID       CREATED       SIZEtengine      duojieduan-v1   21c446837763   2 hours ago   189MBmykodebox    v1              cec672b90ed8   6 hours ago   880MBcentos       nginx_php_v1    c25c0c0349c1   7 hours ago   700MB</code></pre></div></figure><p>运行容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker02 &#x2F;server&#x2F;dockerfile&#x2F;04_duojieduan]#docker run -d -p 80:80 tengine:duojieduan-v1 d9d5555b57f100ded910cbc3f3171e0a523321dd324ec566e494a9b6fe423b1e</code></pre></div></figure><p><img src="/../../../img/image-20240529175149920.png" alt="image-20240529175149920"></p><h2 id="1-5-Dockerfile小结"><a href="#1-5-Dockerfile小结" class="headerlink" title="1.5 Dockerfile小结"></a>1.5 Dockerfile小结</h2><table><thead><tr><th>生产环境应用建议</th><th>说明</th></tr></thead><tbody><tr><td>尽量保证每个镜像功能单一</td><td>尽量避免多个服务运行在同一个镜像中.</td></tr><tr><td>选择合适的基础镜像</td><td>不一定都要从头做(系统,ngx,tengine,tomcat,jdkՎՎʢ)</td></tr><tr><td>注释与说明</td><td>添加一定的注释和镜像属性信息(LABEL)</td></tr><tr><td>指定版本号</td><td>使用镜像的时候指定版本,nginx:latest php:latest nginx:1.20.2-alpine</td></tr><tr><td>减少镜像层数&#x2F;步骤</td><td>尽可能合并RUN,ADD,COPY</td></tr><tr><td>记得收尾</td><td>清理垃圾,记得清理缓存,临时文件,压缩包….</td></tr><tr><td>合理使用.dockerignore</td><td>构建的忽略的文件(了解),少传输些文件.</td></tr></tbody></table><p>未来应用的时候,镜像做好后存放在镜像仓库中 </p><p>分层次存储</p><p><img src="/../../../img/image-20240528170010736.png" alt="image-20240528170010736"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day60-容器架构-Docker（二）</title>
    <link href="/2024/05/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day60-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-2/"/>
    <url>/2024/05/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day60-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-2/</url>
    
    <content type="html"><![CDATA[<h1 id="容器架构-Docker-02"><a href="#容器架构-Docker-02" class="headerlink" title="容器架构-Docker-02"></a>容器架构-Docker-02</h1><p>今日内容：</p><ul><li>Docker容器管理</li></ul><h1 id="一、Docker容器管理🌟🌟"><a href="#一、Docker容器管理🌟🌟" class="headerlink" title="一、Docker容器管理🌟🌟"></a>一、Docker容器管理🌟🌟</h1><p>运行起来的镜像可以称为容器，1个容器相当于是1个进程。 </p><p>以<code>docker container</code>开头的指令一般表示容器管理指令，部分指令container可以省略  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 完整写法docker container ps# 缩略写法docker ps</code></pre></div></figure><h2 id="1-1-容器管理的操作"><a href="#1-1-容器管理的操作" class="headerlink" title="1.1 容器管理的操作"></a>1.1 容器管理的操作</h2><h3 id="1-1-1-查看容器"><a href="#1-1-1-查看容器" class="headerlink" title="1.1.1 查看容器"></a>1.1.1 查看容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker psCONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS                               NAMES50715f7f85a3   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   4 hours ago   Up 4 hours   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   bold_bartik# 完整写法[root@docker01[ ~]#docker container psCONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS                               NAMES50715f7f85a3   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   4 hours ago   Up 4 hours   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   bold_bartik</code></pre></div></figure><p>案例：查看当前运行中的容器，查看下80端口是否被占用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker ps -aCONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS                               NAMES50715f7f85a3   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   5 hours ago   Up 5 hours   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   bold_bartik# 可见80端口已被占用</code></pre></div></figure><h3 id="1-1-2-创建-运行容器"><a href="#1-1-2-创建-运行容器" class="headerlink" title="1.1.2 创建&#x2F;运行容器"></a>1.1.2 创建&#x2F;运行容器</h3><p>创建容器（一般直接用run）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker create 创建容器 --name</code></pre></div></figure><p>运行容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -it -p 80:80 nginx:latest</code></pre></div></figure><blockquote><p>选项说明：</p><ul><li>-d 容器后台运行.</li><li>-p 端口映射,外部或其他服务器想要访问容器内部的某个服务的端口. </li><li>-p 外部用于访问的端口:容器内部服务的端口</li><li>–name 指定容器的名字  </li><li>-i 以交互式模式运行容器，通常与<code>-t</code>一起</li><li>-i 为程序重新分配一个伪输入终端，通常与<code>-i</code>一起</li></ul><p>docker run 的背后做了很多事情：</p><ul><li>docker create 创建容器.</li><li>docker start 启动容器.</li><li>docker stop 关闭容器. #向容器中的主进程,pid 1 进程发出信号(kill),关闭.</li><li>docker restart重启重启</li></ul></blockquote><p><strong>案例01</strong>：创建一个nginx-alpine的容器并运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建[root@docker01[ ~]#docker run -d -p 80:80 --name test_nginx_alpine_v1 nginx:stable-alpine cd4d36318002007a8354146d376e85d1a711ddfdfeb24d1a393258347844f0fa# 查看[root@docker01[ ~]#docker ps -aCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                               NAMEScd4d36318002   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   31 seconds ago   Up 31 seconds   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   test_nginx_alpine_v1</code></pre></div></figure><p><strong>案例02</strong>：创建centos容器，并交互运行，进入容器内部</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># run 创建并运行centos容器[root@docker01[ ~]#docker run -it --name &quot;my_docker_centos&quot; centosUnable to find image &#39;centos:latest&#39; locallylatest: Pulling from library&#x2F;centosa1d0c7532777: Pull complete Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177Status: Downloaded newer image for centos:latest# 因为-it选项的使用，已经进入容器内部，查看系统版本[root@631cf5e874ba &#x2F;]# cat &#x2F;etc&#x2F;system-releaseCentOS Linux release 8.4.2105</code></pre></div></figure><blockquote><p>注意事项：</p><p>以<code>-it</code>运行的容器，如果退出了会怎么样？</p><ul><li>容器退出后，直接关闭</li></ul><p><strong>这也是<code>-it</code>的缺点！</strong></p></blockquote><h3 id="1-1-3-启动-停止容器"><a href="#1-1-3-启动-停止容器" class="headerlink" title="1.1.3 启动&#x2F;停止容器"></a>1.1.3 启动&#x2F;停止容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动容器docker start# 停止容器docker stop # 重启容器docker restart # 强制停止容器docker kill </code></pre></div></figure><p>案例：以上方法均在容器上用一遍</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker stop cd4d36318002cd4d36318002[root@docker01[ ~]#docker restart cd4d36318002cd4d36318002[root@docker01[ ~]#docker start cd4d36318002cd4d36318002[root@docker01[ ~]#docker kill -s 9 cd4d36318002# -s表示信号 -s 9 等于 kill -9 pid强制结束cd4d36318002[root@docker01[ ~]#docker ps -aCONTAINER ID   IMAGE                 COMMAND                  CREATED              STATUS                        PORTS     NAMEScd4d36318002   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   About a minute ago   Exited (137) 11 seconds ago             test_nginx_alpine_v1</code></pre></div></figure><h3 id="1-1-4-删除容器"><a href="#1-1-4-删除容器" class="headerlink" title="1.1.4 删除容器"></a>1.1.4 删除容器</h3><p>单个删除</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker rm</code></pre></div></figure><p>批量删除</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker rm -f &#96;docker ps -a -q&#96;</code></pre></div></figure><p>案例：删除已有的容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 找到一个容器[root@docker01[ ~]#docker ps -aCONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS                               NAMES50715f7f85a3   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   5 hours ago   Up 5 hours   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   bold_bartik# 删除，不成功，因为容器正在运行[root@docker01[ ~]#docker  rm 50715f7f85a3Error response from daemon: cannot remove container &quot;&#x2F;bold_bartik&quot;: container is running: stop the container before removing or force remove# -f强制删除[root@docker01[ ~]#docker  rm -f 50715f7f85a3</code></pre></div></figure><h3 id="1-1-5-进入正在运行的容器"><a href="#1-1-5-进入正在运行的容器" class="headerlink" title="1.1.5 进入正在运行的容器"></a>1.1.5 进入正在运行的容器</h3><p>方法一<code>exec</code>：将分配一个新的终端</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it 容器id&#x2F;容器名字 &#x2F;bin&#x2F;bash(&#x2F;bin&#x2F;sh)</code></pre></div></figure><p>方法二<code>attach</code>：使用相同的终端</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker attach# 暂时退出：ctrl + p, ctrl + q</code></pre></div></figure><p>案例：exec进入已经运行的容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看已有容器[root@docker01[ ~]#docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                               NAMES5251e5df489e   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   19 minutes ago   Up 19 minutes   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   test_nginx_alpine_v1# 进入容器[root@docker01[ ~]#docker exec -it test_nginx_alpine_v1 &#x2F;bin&#x2F;sh&#x2F; # lsbin                   etc                   mnt                   run                   tmpdev                   home                  opt                   sbin                  usrdocker-entrypoint.d   lib                   proc                  srv                   vardocker-entrypoint.sh  media                 root                  sys# 修改nginx首页内容&#x2F; # cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html # echo &quot;New Page&quot; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </code></pre></div></figure><p>测试访问</p><p><img src="/../../../img/image-20240524154601603.png" alt="image-20240524154601603"></p><h4 id="exec和attach的区别"><a href="#exec和attach的区别" class="headerlink" title="exec和attach的区别"></a>exec和attach的区别</h4><table><thead><tr><th>docker container 指令</th><th>exec</th><th>attach</th></tr></thead><tbody><tr><td>共同点</td><td>连接到容器</td><td>连接到容器</td></tr><tr><td>区别</td><td>连接的时候创建终端</td><td>容器要有终端(容器进程中要有个&#x2F;bin&#x2F;bash 或&#x2F;bin&#x2F;sh) 只能连接到已有的终端中.</td></tr><tr><td>区别</td><td>不同的exec连接互不影响,</td><td>共用,所有连接都一样</td></tr></tbody></table><h3 id="1-1-6-查看容器信息与状态"><a href="#1-1-6-查看容器信息与状态" class="headerlink" title="1.1.6 查看容器信息与状态"></a>1.1.6 查看容器信息与状态</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker inspectdocker statsdocker top</code></pre></div></figure><h3 id="1-1-7-容器夯住才能一直运行🌟"><a href="#1-1-7-容器夯住才能一直运行🌟" class="headerlink" title="1.1.7 容器夯住才能一直运行🌟"></a>1.1.7 容器夯住才能一直运行🌟</h3><p>体会下面2个命令的区别：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name &quot;oldboy_centos_v2&quot; centosdocker run -d --name &quot;oldboy_centos_v2&quot; centos sleep 20</code></pre></div></figure><p>执行后，没加<code>sleep</code>的容器刚运行就消失了，加了<code>sleep</code>的容器维持了20秒</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker run -d --name &quot;oldboy_centos_v2&quot; centosfb8ba4d7a6c5dceffc6123953b2ad5235b0b13454ea7a4b0d072bf3fff0201d0[root@docker01[ ~]#docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                               NAMES5251e5df489e   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   12 minutes ago   Up 12 minutes   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   test_nginx_alpine_v1# centos容器不见了[root@docker01[ ~]#docker run -d --name &quot;oldboy_centos_v3&quot; centos sleep 20bed3239b9850cda3235c73eda64472b8e3bd233ac3a40ede82ddec3acd24d801[root@docker01[ ~]#docker run -psCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                               NAMESbed3239b9850   centos                &quot;sleep 20&quot;               2 seconds ago    Up 1 second                                         oldboy_centos_v35251e5df489e   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   12 minutes ago   Up 12 minutes   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   test_nginx_alpine_v1# centos容器还在</code></pre></div></figure><p>这是因为容器任务执行结束后，它也就自动退出了，因此 ，想要容器在后台（-d）一直运行，那么就要对容器运行的时候<strong>加上初始命令，使容器夯住</strong>(阻塞&#x2F;前台运行)</p><p>例如：如何后台持续运行纯净系统的容器（Centos）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 通过-itd选项来指定命令解释器持续运行[root@docker01[ ~]#docker run -itd --name oldboy_centos_v6 centosc4a59405f253ba62bfaa4f7431be2d21bbd8ca73ce174d27bb8b9f8475c0e872# 容器还在[root@docker01[ ~]#docker ps -aCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS                      PORTS                               NAMESc4a59405f253   centos                &quot;&#x2F;bin&#x2F;bash&quot;              13 seconds ago   Up 13 seconds                                                   oldboy_centos_v6...# 进入容器[root@docker01[ ~]#docker exec -it oldboy_centos_v6 &#x2F;bin&#x2F;bash[root@c4a59405f253 &#x2F;]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</code></pre></div></figure><h3 id="1-1-8-容器传输文件"><a href="#1-1-8-容器传输文件" class="headerlink" title="1.1.8 容器传输文件"></a>1.1.8 容器传输文件</h3><p>怎么跟容器互相传输文件？使用<code>docker cp</code>命令</p><table><thead><tr><th></th><th></th><th>源</th><th>目标</th></tr></thead><tbody><tr><td>宿主机–&gt;容器 上传</td><td>docker cp</td><td>路径或文件</td><td>容器:容器中目录</td></tr><tr><td>容器–&gt;宿主机 下载</td><td>docker cp</td><td>容器:容器中目录</td><td>路径或文件</td></tr></tbody></table><p>案例01：从容器下载文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 拷贝容器中的hosts文件下来[root@docker01[ ~]#docker cp oldboy_centos_v6:&#x2F;etc&#x2F;hosts .&#x2F;docker_centos_hostsSuccessfully copied 2.05kB to &#x2F;root&#x2F;docker_centos_hosts</code></pre></div></figure><p>案例02：上传文件到容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 百度首页，保存到物理机[root@docker01[ ~]#curl -o index.html www.baidu.com  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100  2381  100  2381    0     0  31048      0 --:--:-- --:--:-- --:--:-- 30922# 上传到nginx容器，替换首页[root@docker01[ ~]#docker cp index.html test_nginx_alpine_v1:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlSuccessfully copied 4.1kB to test_nginx_alpine_v1:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</code></pre></div></figure><h3 id="1-1-9-commit自定义镜像🌟"><a href="#1-1-9-commit自定义镜像🌟" class="headerlink" title="1.1.9 commit自定义镜像🌟"></a>1.1.9 commit自定义镜像🌟</h3><p>commit用于处理容器，生成镜像.  </p><p>使用流程:</p><ul><li>运行服务镜像或系统镜像,启动后成为容器.</li><li>根据我们的需求,对容器进行修改.</li><li>测试完成后.</li><li>最后通过commit命令把容器保存为镜像.</li><li>根据新生成的镜像创建容器并测试.</li></ul><p>案例：修改nginx容器，生成自定义镜像</p><ul><li>需求：<ul><li>基于ngx镜像创建容器</li><li>修改站点目录 &#x2F;app&#x2F;code&#x2F;restart&#x2F; (default.conf)</li><li>上传代码,解压</li><li>测试</li><li>commit</li></ul></li></ul><p>1、创建容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker run -d -p 80:80 --name &quot;commit_nginx&quot; nginx:stable-alpine d7919255e43900e6ac3b556e1e27dff6ba3c4932fe354e27a62319a215cc20aa</code></pre></div></figure><p>2、进入容器，修改配置文件，准备环境</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改配置文件&#x2F;etc&#x2F;nginx&#x2F;conf.d # cat default.confserver &#123;    listen       80;    server_name  restart.commit.cn;    root   &#x2F;app&#x2F;code&#x2F;restart;    location &#x2F; &#123;        index  index.html index.htm;    &#125;&#125;# 创建文件夹&#x2F; # mkdir -p &#x2F;app&#x2F;code&#x2F;restart</code></pre></div></figure><p>3、上传html代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#echo &quot;RESTART PAGE&quot; &gt; index.html [root@docker01[ ~]#docker cp index.html  commit_nginx:&#x2F;app&#x2F;code&#x2F;restartSuccessfully copied 2.05kB to commit_nginx:&#x2F;app&#x2F;code&#x2F;restart</code></pre></div></figure><p>重启服务测试下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker restart d7919255e439d7919255e439</code></pre></div></figure><p><img src="/../../../img/image-20240524161534148.png" alt="image-20240524161534148"></p><p>4、根据容器生成镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker commit commit_nginx nginx:stable-alpine_restart_v1sha256:21ca067362e8bf124ea914db502b69de62053cddcdae61699951abc34f8cf832# 查看[root@docker01[ ~]#docker imagesREPOSITORY   TAG                        IMAGE ID       CREATED          SIZEnginx        stable-alpine_restart_v1   21ca067362e8   18 seconds ago   23.2MB...</code></pre></div></figure><p>5、根据新的镜像，重新创建容器，端口81</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker run -d -p 81:80 nginx:stable-alpine_restart_v1 5477c2d5e0c9fab71a23b8bd6183277c2c4219fef8137ba761474909bbd34817</code></pre></div></figure><p>测试访问<a href="http://10.0.0.81:81/">http://10.0.0.81:81</a></p><p><img src="/../../../img/image-20240524161910037.png" alt="image-20240524161910037"></p><h3 id="1-1-10-容器导出导入"><a href="#1-1-10-容器导出导入" class="headerlink" title="1.1.10 容器导出导入"></a>1.1.10 容器导出导入</h3><p>导出容器成tar包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看容器[root@docker01 ~]#docker psCONTAINER ID   IMAGE              COMMAND                  CREATED         STATUS         PORTS                               NAMESe4ee1efb593c   tengine:birds-v1   &quot;nginx -g &#39;daemon of…&quot;   3 seconds ago   Up 2 seconds   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   birds_test# 导出容器[root@docker01 ~]#docker export birds_test -o bird_test.tar</code></pre></div></figure><p>将打包文件拷贝到另一台机器中，导入成镜像（有坑）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 拷贝到docker02中[root@docker01 ~]#scp bird_test.tar 10.0.0.82:&#x2F;tmp# docker02虚拟机中没有任何镜像和容器[root@docker02 ~]#docker imagesREPOSITORY   TAG       IMAGE ID   CREATED   SIZE[root@docker02 ~]#docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES# docker02导入[root@docker02 ~]#docker import &#x2F;tmp&#x2F;bird_test.tar sha256:a823ac7e01d4c783ec8f00356662176c5c279b10999fe6f463a4476a9b16bb05# 坑，导入后生成的镜像没有名字标签[root@docker02 ~]#docker imagesREPOSITORY   TAG       IMAGE ID       CREATED          SIZE&lt;none&gt;       &lt;none&gt;    a823ac7e01d4   11 seconds ago   409MB# 重新添加仓库名和标签[root@docker02 ~]#docker tag a823ac7e01d4 tengine:birds-v1[root@docker02 ~]#docker imagesREPOSITORY   TAG        IMAGE ID       CREATED         SIZEtengine      birds-v1   a823ac7e01d4   3 minutes ago   409MB</code></pre></div></figure><h1 id="二、端口映射"><a href="#二、端口映射" class="headerlink" title="二、端口映射"></a>二、端口映射</h1><p>容器的端口映射怎么实现的？</p><ul><li>使用<code>docker run -p</code>的时候，外界访问docker容器中的服务或端口，需要使用端口映射。</li><li>本质是通过iptables nat规则实现的，在nat表中创建了docker自定义的链</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#iptables -t nat -nLChain PREROUTING (policy ACCEPT)target     prot opt source               destination         DOCKER     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            ADDRTYPE match dst-type LOCALChain INPUT (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination         DOCKER     all  --  0.0.0.0&#x2F;0           !127.0.0.0&#x2F;8          ADDRTYPE match dst-type LOCAChain POSTROUTING (policy ACCEPT)target     prot opt source               destination         MASQUERADE  all  --  172.17.0.0&#x2F;16        0.0.0.0&#x2F;0           MASQUERADE  tcp  --  172.17.0.2           172.17.0.2           tcp dpt:80MASQUERADE  tcp  --  172.17.0.3           172.17.0.3           tcp dpt:80Chain DOCKER (2 references)target     prot opt source               destination         RETURN     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           DNAT       tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:80 to:172.17.0.2:80DNAT       tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:81 to:172.17.0.3:80</code></pre></div></figure><h2 id="2-1-背后具体做了什么？"><a href="#2-1-背后具体做了什么？" class="headerlink" title="2.1 背后具体做了什么？"></a>2.1 背后具体做了什么？</h2><ul><li>添加了对应防火墙规则</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 类似于iptables -t nat -A DOCKER ! -i docker0 -p tcp -m tcp --dport 81 -j DNAT --todestination 10.0.0.81:80</code></pre></div></figure><p>-<br>  开启内核转发功能(需要我们自己开启)  </p><p>查看端口信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#ss -lntup | grep 81tcp    LISTEN     0      128       *:81                    *:*                   users:((&quot;docker-proxy&quot;,pid&#x3D;26582,fd&#x3D;4))tcp    LISTEN     0      128    [::]:81                 [::]:*                   users:((&quot;docker-proxy&quot;,pid&#x3D;26586,fd&#x3D;4))</code></pre></div></figure><h2 id="2-2-用户访问的时候经历了什么"><a href="#2-2-用户访问的时候经历了什么" class="headerlink" title="2.2 用户访问的时候经历了什么"></a>2.2 用户访问的时候经历了什么</h2><p>内部通过<code>虚拟网卡</code>来实现分配，如图</p><p><img src="/../../../img/image-20240524162640454.png" alt="image-20240524162640454"></p><h2 id="2-3-端口映射的案例"><a href="#2-3-端口映射的案例" class="headerlink" title="2.3 端口映射的案例"></a>2.3 端口映射的案例</h2><h3 id="2-3-1-一对一映射"><a href="#2-3-1-一对一映射" class="headerlink" title="2.3.1 一对一映射"></a>2.3.1 一对一映射</h3><p>还是使用<code>docker run -p</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name &quot;oldboy_nginx_80&quot; -p 80:80 nginx:1.20.2-alpine</code></pre></div></figure><p>关于<code>-p</code>选项的详细描述</p><table><thead><tr><th>docker run</th><th></th></tr></thead><tbody><tr><td>-p选项(小写字母P) 宿主机端口:容器中的端口</td><td>-p 80:80 -p 443:443</td></tr><tr><td>-p :容器中端口</td><td>-p :80 表示宿主机端口随机,很少用.</td></tr><tr><td>-p 端口范围:端口范围</td><td>80-88:80-88</td></tr></tbody></table><h3 id="2-3-2-多对多映射"><a href="#2-3-2-多对多映射" class="headerlink" title="2.3.2 多对多映射"></a>2.3.2 多对多映射</h3><p>映射8080,8081,8082 到容器中容器中也是8080,8081,8082  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># -d一个个写[root@docker01[ ~]#dockedocker run -d -p 8080:8080 -p 8081:8081 -p 8082:8082 -p 86:80 nginx:stable-alpine43bcb519597f7a2f00ceea65fcb4664c5e52419d80c92c62dd5fbc1ccc2a0f5e# 查看状态[root@docker01[ ~]#docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS         PORTS                                                                                              NAMES43bcb519597f   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   3 seconds ago   Up 2 seconds   0.0.0.0:8080-8082-&gt;8080-8082&#x2F;tcp, :::8080-8082-&gt;8080-8082&#x2F;tcp, 0.0.0.0:86-&gt;80&#x2F;tcp, :::86-&gt;80&#x2F;tcp   magical_margulis# 查看port信息[root@docker01[ ~]#docker port magical_margulis80&#x2F;tcp -&gt; 0.0.0.0:8680&#x2F;tcp -&gt; [::]:868080&#x2F;tcp -&gt; 0.0.0.0:80808080&#x2F;tcp -&gt; [::]:80808081&#x2F;tcp -&gt; 0.0.0.0:80818081&#x2F;tcp -&gt; [::]:80818082&#x2F;tcp -&gt; 0.0.0.0:80828082&#x2F;tcp -&gt; [::]:8082# 容器中的端口 -&gt; 宿主机端口</code></pre></div></figure><h3 id="2-3-3-IP绑定端口"><a href="#2-3-3-IP绑定端口" class="headerlink" title="2.3.3 IP绑定端口"></a>2.3.3 IP绑定端口</h3><p>用户只能通过宿主机的某个网卡连接这个端口，起安全防护作用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 只能用172.16.1.8:12306来访问容器的80端口[root@docker01[ ~]#docker run -d -p 172.16.1.81:12306:80 nginx:stable-alpine44d0e51e63f65650e0faadd705fb33c944409591b30a4d4731fa1c3643200f75# 查看[root@docker01[ ~]#docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                       NAMES44d0e51e63f6   nginx:stable-alpine   &quot;&#x2F;docker-entrypoint.…&quot;   44 seconds ago   Up 43 seconds   172.16.1.81:12306-&gt;80&#x2F;tcp   nice_mendel</code></pre></div></figure><h1 id="三、数据卷挂载"><a href="#三、数据卷挂载" class="headerlink" title="三、数据卷挂载"></a>三、数据卷挂载</h1><h2 id="3-1-为什么需要挂载数据"><a href="#3-1-为什么需要挂载数据" class="headerlink" title="3.1 为什么需要挂载数据"></a>3.1 为什么需要挂载数据</h2><p>数据放容器里，要是不小心<code>rm -f</code>删了怎么办？</p><p>为了解决这个数据持久化的问题，需要让数据永久<strong>保存在宿主机</strong>中，通过挂载的方式挂</p><p>到容器上</p><p><img src="/../../../img/image-20240524164011370.png" alt="image-20240524164011370"></p><h2 id="3-2-选项补充"><a href="#3-2-选项补充" class="headerlink" title="3.2 选项补充"></a>3.2 选项补充</h2><h3 id="3-2-1-docker-run选项补充"><a href="#3-2-1-docker-run选项补充" class="headerlink" title="3.2.1 docker run选项补充"></a>3.2.1 docker run选项补充</h3><p><code>--rm</code>选项</p><ul><li>容器退出的时候，容器自动删除</li><li>一般用于测试，临时使用容器</li></ul><p><code>--restart</code>选项，容器的重启策略</p><ul><li>always 自动重启</li><li>unless-stopped 只在容器关闭，停止的时候</li><li>on-failure 只在失败的时候重启</li><li>默认，不自动重启</li></ul><h3 id="3-2-2-docker-exec选项补充"><a href="#3-2-2-docker-exec选项补充" class="headerlink" title="3.2.2 docker exec选项补充"></a>3.2.2 docker exec选项补充</h3><p>在进入Mysql或者redis等数据库时候，可以直接exec进入数据库操作终端，而不是&#x2F;bin&#x2F;bash，方法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 对Mysqldocker exec -it 容器 mysql -u root -p# 对redisdocker exec -it 容器 redis-cli</code></pre></div></figure><h2 id="3-3-挂载项目"><a href="#3-3-挂载项目" class="headerlink" title="3.3 挂载项目"></a>3.3 挂载项目</h2><p>将站点文件&#x2F;站点目录、配置文件目录、日志目录以<code>-v</code>的方式挂载</p><h3 id="3-3-1-挂载单个站点文件"><a href="#3-3-1-挂载单个站点文件" class="headerlink" title="3.3.1 挂载单个站点文件"></a>3.3.1 挂载单个站点文件</h3><p>使用数据卷挂载index.html到容器中的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建本地文件mkdir -p &#x2F;app&#x2F;docker&#x2F;test&#x2F;codeecho &quot;&lt;h1&gt;THIS IS MOUNTED PAGE&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;app&#x2F;docker&#x2F;test&#x2F;code&#x2F;index.html# 运行容器（挂载卷）docker run -d \--name &quot;docker_volumnt_ngx_v1&quot; \-p 80:80 \-v &#x2F;app&#x2F;docker&#x2F;test&#x2F;code&#x2F;index.html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html \nginx:stable-alpine# 查看挂载[root@docker01[ ~]#docker inspect docker_volumnt_ngx_v1 | jq .[].HostConfig.Binds[  &quot;&#x2F;app&#x2F;docker&#x2F;test&#x2F;code&#x2F;index.html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html&quot;]</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240524170033688.png" alt="image-20240524170033688"></p><blockquote><p>提示：</p><p>如果宿主机文件内容改变了，需要<strong>重启容器才能生效</strong></p></blockquote><h3 id="3-3-2-挂载站点目录"><a href="#3-3-2-挂载站点目录" class="headerlink" title="3.3.2 挂载站点目录"></a>3.3.2 挂载站点目录</h3><p>需求：</p><ul><li>用数据卷挂载：代码目录.</li><li>用数据卷挂载：配置文件，配置文件目录.</li><li>用数据卷挂载：数据目录(数据库)</li><li>还可以用于日志</li></ul><blockquote><p>补充：</p><p>Nginx - alpine镜像的配置文件：</p><ul><li>配置文件子目录: &#x2F;app&#x2F;docker&#x2F;restart&#x2F;conf&#x2F;nginx&#x2F;conf.d&#x2F;</li><li>挂载到：&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</li><li>配置文件主目录: &#x2F;app&#x2F;docker&#x2F;restart&#x2F;conf&#x2F;nginx&#x2F;nginx.conf</li><li>挂载到：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</li><li>站点目录: &#x2F;app&#x2F;docker&#x2F;restart&#x2F;code&#x2F;</li><li>挂载到：&#x2F;app&#x2F;code&#x2F;restart&#x2F;</li></ul></blockquote><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 物理机，创建文件夹[root@docker01[ &#x2F;app&#x2F;docker&#x2F;test&#x2F;code]#mkdir -p &#x2F;app&#x2F;docker&#x2F;conf&#x2F;nginx&#x2F;conf.d &#x2F;app&#x2F;docker&#x2F;code&#x2F;restart# 启动docker并挂载文件docker run -d --name &quot;oldboy_restart_volume_v1&quot; -p 80:80 \-v &#x2F;app&#x2F;docker&#x2F;restart&#x2F;conf&#x2F;nginx&#x2F;conf.d&#x2F;:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F; \-v &#x2F;app&#x2F;docker&#x2F;restart&#x2F;conf&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \-v &#x2F;app&#x2F;docker&#x2F;restart&#x2F;code&#x2F;:&#x2F;app&#x2F;code&#x2F;restart&#x2F; \--restart&#x3D;always \nginx:alpine</code></pre></div></figure><h2 id="3-4-数据卷空间"><a href="#3-4-数据卷空间" class="headerlink" title="3.4 数据卷空间"></a>3.4 数据卷空间</h2><p>应用场景：只关注容器中的数据不丢，不关注数据具体放在哪里</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建数据卷[root@docker01[ &#x2F;]#docker volume create oldboydataoldboydata# 查看数据卷[root@docker01[ &#x2F;]#docker volume lsDRIVER    VOLUME NAMElocal     oldboydata# 在物理机的实际存放位置[root@docker01[ &#x2F;]#tree &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;oldboydata&#x2F;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;oldboydata&#x2F;└── _data1 directory, 0 files# 挂载数据卷运行[root@docker01[ &#x2F;]#docker run -d --name &quot;nginx_vol&quot; -p 80:80 -v oldboydata:&#x2F;var&#x2F;log&#x2F;nginx&#x2F; nginx:stable-alpine8c2800b434161fd7401b56b45ba236b3e0f10e354baecbc47be03e47e4b70878# 已经生效[root@docker01[ &#x2F;app&#x2F;docker&#x2F;restart&#x2F;conf&#x2F;nginx]#ls -l &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;total 24brw-------. 1 root root 253, 0 May 24 10:35 backingFsBlockDev-rw-------. 1 root root  32768 May 27 09:09 metadata.dbdrwx-----x. 3 root root     19 May 27 09:09 oldboydata[root@docker01[ &#x2F;app&#x2F;docker&#x2F;restart&#x2F;conf&#x2F;nginx]#ls -l &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;oldboydata&#x2F;_data&#x2F;total 0lrwxrwxrwx. 1 root root 11 Nov 17  2021 access.log -&gt; &#x2F;dev&#x2F;stdoutlrwxrwxrwx. 1 root root 11 Nov 17  2021 error.log -&gt; &#x2F;dev&#x2F;stderr</code></pre></div></figure><blockquote><p>注意：</p><p>nginx容器的日志默认是输出到docker标准输出和标准错误输出的，而不是存放在文</p><p>件中。未来查看日志的时候，不用进入到容器，然后tail&#x2F;less使用命令查看.</p><p>直接使用docker logs 容器id或名字 就可以看日志。</p><p>相当于查看access.log或error.log  </p></blockquote><h2 id="3-5-随机数据卷（较少使用）"><a href="#3-5-随机数据卷（较少使用）" class="headerlink" title="3.5 随机数据卷（较少使用）"></a>3.5 随机数据卷（较少使用）</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># -v不指定具体的卷标docker run -d --name &quot;nginx_vol_oldboylogdatav2&quot; -p :80 -v :&#x2F;var&#x2F;log&#x2F;nginx&#x2F; nginx:stable-alpine</code></pre></div></figure><blockquote><p>注意：</p><p>在Docker version 26.1.3中，测试已经不行了，会报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;docker: invalid spec: :&#x2F;var&#x2F;log&#x2F;nginx&#x2F;: empty section between colons</code></pre></div></figure></blockquote><h2 id="3-6-容器时区的问题"><a href="#3-6-容器时区的问题" class="headerlink" title="3.6 容器时区的问题"></a>3.6 容器时区的问题</h2><p>进入容器内执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装tzdata工具，设置时区apk update \&amp;&amp; apk add tzdata \&amp;&amp; cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;locatime \&amp;&amp; echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone</code></pre></div></figure><blockquote><p>测试，时区没有生效。。。。还是要用时网上找吧</p></blockquote><h2 id="3-7-数据卷使用与容器架构"><a href="#3-7-数据卷使用与容器架构" class="headerlink" title="3.7 数据卷使用与容器架构"></a>3.7 数据卷使用与容器架构</h2><p>运行多个docker的时候，只需要维护一份代码</p><p><img src="/../../../img/image-20240528140249375.png" alt="image-20240528140249375"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day59-容器架构-Docker（一）</title>
    <link href="/2024/05/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day59-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-1/"/>
    <url>/2024/05/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day59-%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84-docker-1/</url>
    
    <content type="html"><![CDATA[<h1 id="容器架构-Docker-01"><a href="#容器架构-Docker-01" class="headerlink" title="容器架构-Docker-01"></a>容器架构-Docker-01</h1><p>今日内容：</p><ul><li>服务架构概述</li><li>容器介绍</li><li>Docker快速上手</li></ul><h1 id="一、IAAS-PAAS-SAAS概述"><a href="#一、IAAS-PAAS-SAAS概述" class="headerlink" title="一、IAAS PAAS SAAS概述"></a>一、IAAS PAAS SAAS概述</h1><p>Iaas：基础设施即服务 Infrastructure-as-a-Service</p><p>Paas：平台即服务 Platform-as-a-Service</p><p>Saas：软件即服务 Software-as-a-Service</p><p>Caas：容器即服务 介于IAAS和PAAS</p><p>IAAS，PAAS，SAAS这些服务，用于帮助人们更快实现目标(搭建环境,使用产品)</p><p>从左到右，人们需要管理与维护的地方越来越少，人们可以把重点关注在使用&#x2F;应用上.  </p><p>更形象点：</p><ul><li>IAAS平台:基础设施,阿里云,云厂商.</li><li>PAAS平台:服务&#x2F;运行环境是ok，公有云，负载均衡SLB</li><li>SAAS平台:服务已经准备好，您直接用，具体产品，如processon,wps,亿图</li></ul><p>图示-抽象：</p><p><img src="/../../../img/image-20240524101205606.png" alt="image-20240524101205606"></p><p>图示-具体：</p><p><img src="/../../../img/image-20240524101508600.png" alt="image-20240524101508600"></p><h1 id="二、容器介绍"><a href="#二、容器介绍" class="headerlink" title="二、容器介绍"></a>二、容器介绍</h1><h2 id="2-1-什么是容器"><a href="#2-1-什么是容器" class="headerlink" title="2.1 什么是容器"></a>2.1 什么是容器</h2><p>容器是在隔离环境中运行的一个进程，如果进程结束，容器就会停止.</p><p>容器的隔离环境，拥有自己的ip地址、系统文件、主机名、进程管理，相当于一个mini的系统  </p><h2 id="2-2-容器VS虚拟机🌟"><a href="#2-2-容器VS虚拟机🌟" class="headerlink" title="2.2 容器VS虚拟机🌟"></a>2.2 容器VS虚拟机🌟</h2><table><thead><tr><th></th><th>虚拟机</th><th>容器</th></tr></thead><tbody><tr><td>优点</td><td>1. 使用简单 <br/>2. 也有成熟管理工具,vmware esxi,KVM,Openstack <br/>3. 可以随意定制. <br/>4. 启动虚拟机要经历完整的Linux启动流程</td><td>1. 快速部署(扩容,弹性伸缩)<br/> 2. 大部分环境都有现成镜像<br/> 3. 让我们不再关注系统基础设施,把关注点放在配置,升级,优化 <br/>4. 不依赖硬件 <br/>5. 启动容器秒级.<br/> 6. 相当于一个进程</td></tr><tr><td>缺点</td><td>1. 需要硬件支持虚拟化技术(VT-X) <br/>2. 资源利用率不高 <br/>3. 同一台虚拟跑多个服务,可能有冲突<br/> 4. 占用资源较多. <br/>5. 不满足目前升级,快速扩容,快速部署,回滚不方便.</td><td>1. 使用较为复杂<br/> 2. 共享linux系统内核,推荐使用较新linux内核.</td></tr></tbody></table><p><img src="/../../../img/image-20240524101958278.png" alt="image-20240524101958278"></p><h1 id="三、Docker极速上手"><a href="#三、Docker极速上手" class="headerlink" title="三、Docker极速上手"></a>三、Docker极速上手</h1><blockquote><p>Docker需要Linux内核: 3.10以上. 如果旧的内核需要升级内核才能使用  </p></blockquote><p>Docker版本说明：</p><ul><li><p>分为docker-ce(开源)和docker-ee(企业版)</p></li><li><p>Docker版本从1.13开始改成年-月版本命名方式.</p></li></ul><h2 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h2><p>准备两台机器，用于Docker实验</p><table><thead><tr><th>docker环境</th><th>ip</th><th>配置</th></tr></thead><tbody><tr><td>docker01.oldboylinux.cn</td><td>10.0.0.81&#x2F;172.16.1.81</td><td>2c4G(至少1c2G)</td></tr><tr><td>docker02.oldboylinux.cn</td><td>10.0.0.82&#x2F;172.16.1.82</td><td>2c4G(至少1c2G）</td></tr></tbody></table><h2 id="3-2-安装docker"><a href="#3-2-安装docker" class="headerlink" title="3.2 安装docker"></a>3.2 安装docker</h2><p>步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1.安装相关依赖.yum install -y yum-utils device-mapper-persistentdata lvm2#2.下载官方的docker yum源文件yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo#3.替换yum源地址sed -i &#39;s+download.docker.com+mirrors.tuna.tsinghua.edu.cn&#x2F;docker-ce+&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo#4.清空缓存yum clean allyum makecache#4.安装docker-ceyum install -y docker-cesystemctl enable --now docker#5.检查[root@docker01[ ~]#docker versionClient: Docker Engine - Community Version:           26.1.3 API version:       1.45 Go version:        go1.21.10 Git commit:        b72abbb Built:             Thu May 16 08:36:24 2024 OS&#x2F;Arch:           linux&#x2F;amd64 Context:           defaultCannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</code></pre></div></figure><h2 id="3-3-Docker下载镜像加速"><a href="#3-3-Docker下载镜像加速" class="headerlink" title="3.3 Docker下载镜像加速"></a>3.3 Docker下载镜像加速</h2><blockquote><p>阿里云,腾讯云有加速用的地址  </p><p>如阿里云：<a href="https://help.aliyun.com/zh/acr/user-guide/accelerate-the-pulls-of-docker-official-images#section-9tt-j3m-d2f">https://help.aliyun.com/zh/acr/user-guide/accelerate-the-pulls-of-docker-official-images#section-9tt-j3m-d2f</a></p></blockquote><p>配置镜像加速</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建配置文件夹目录sudo mkdir -p &#x2F;etc&#x2F;docker# 创建配置文件[root@docker01[ ~]#cat &#x2F;etc&#x2F;docker&#x2F;daemon.json &#123;&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;bjjtv7cs.mirror.aliyuncs.com&quot;]&#125;# 重新加载服务[root@docker01[ ~]#sudo systemctl daemon-reload[root@docker01[ ~]#sudo systemctl restart docker</code></pre></div></figure><h2 id="3-4-配置docker自动补全"><a href="#3-4-配置docker自动补全" class="headerlink" title="3.4 配置docker自动补全"></a>3.4 配置docker自动补全</h2><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y bash-completion bash-completion-extras</code></pre></div></figure><h1 id="四、-Docker-C-S架构"><a href="#四、-Docker-C-S架构" class="headerlink" title="四、 Docker C&#x2F;S架构"></a>四、 Docker C&#x2F;S架构</h1><p>什么是CS架构？</p><ul><li>cs client&#x2F;server 客户端&#x2F;服务端</li></ul><p>Docker的C&#x2F;S架构也分为服务端和客户端：</p><ul><li>Docker 服务端:docker daemon 叫dockerd</li><li>Docker 客户端:docker命令(下载镜像,运行容器…)</li></ul><table><thead><tr><th>docker相关词汇</th><th>说明</th></tr></thead><tbody><tr><td>镜像</td><td>存放各种的环境或服务</td></tr><tr><td>容器</td><td>进程,运行起来的镜像.</td></tr><tr><td>仓库(存放镜像)</td><td>远程仓库,本地仓库</td></tr></tbody></table><p>图示：</p><p><img src="/../../../img/image-20240524103829054.png" alt="image-20240524103829054"></p><p>示例：下载nginx镜像到本地仓库，然后启动容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载Niginx镜像[root@docker01[ ~]#docker pull nginxUsing default tag: latestlatest: Pulling from library&#x2F;nginxa2abf6c4d29d: Pull complete a9edb18cadd1: Pull complete 589b7251471a: Pull complete 186b1aaa4aa6: Pull complete b4df32aa5a72: Pull complete a0bcbecc962e: Pull complete Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31Status: Downloaded newer image for nginx:latestdocker.io&#x2F;library&#x2F;nginx:latest# 查看镜像[root@docker01[ ~]#docker imagesREPOSITORY   TAG       IMAGE ID       CREATED       SIZEnginx        latest    605c77e624dd   2 years ago   141MB# 启动容器[root@docker01[ ~]#docker run -d -p 80:80 nginx50715f7f85a3b083d136e92d2969cae4d40f5c31f4b7f243c57e5d31fc748dbd# 查看容器[root@docker01[ ~]#docker psCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                               NAMES50715f7f85a3   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   56 seconds ago   Up 54 seconds   0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp   bold_bartik</code></pre></div></figure><p>测试访问</p><p><img src="/../../../img/image-20240524104300825.png" alt="image-20240524104300825"></p><blockquote><p>以上docker run的选项说明：</p><ul><li><p>-d 容器后台运行</p></li><li><p>-p 端口映射</p></li><li><p>可能需要开启系统的内核转发功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]# tail -1&#x2F;etc&#x2F;sysctl.confnet.ipv4.ip_forward &#x3D; 1[root@docker01[ ~]#sysctl -pnet.ipv4.ip_forward &#x3D; 1</code></pre></div></figure></li><li><p>nginx 镜像名字</p></li></ul></blockquote><h1 id="五、-Dcoker的镜像管理"><a href="#五、-Dcoker的镜像管理" class="headerlink" title="五、 Dcoker的镜像管理"></a>五、 Dcoker的镜像管理</h1><h2 id="5-1-镜像管理操作"><a href="#5-1-镜像管理操作" class="headerlink" title="5.1 镜像管理操作"></a>5.1 镜像管理操作</h2><h3 id="1）查看镜像"><a href="#1）查看镜像" class="headerlink" title="1）查看镜像"></a>1）查看镜像</h3><p>查看镜像列表</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker imagesREPOSITORY   TAG       IMAGE ID       CREATED       SIZEnginx        latest    605c77e624dd   2 years ago   141MB# 或者[root@docker01[ ~]#docker image lsREPOSITORY   TAG       IMAGE ID       CREATED       SIZEnginx        latest    605c77e624dd   2 years ago   141MB</code></pre></div></figure><p>查看所有镜像，包括隐藏镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker images -a</code></pre></div></figure><p>查看单个镜像的详细信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker image inspect nginx:latest [    &#123;        &quot;Id&quot;: &quot;sha256:605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85&quot;,        &quot;RepoTags&quot;: [            &quot;nginx:latest&quot;        ],...</code></pre></div></figure><h3 id="2）搜索镜像"><a href="#2）搜索镜像" class="headerlink" title="2）搜索镜像"></a>2）搜索镜像</h3><p>优先选官方、stars数量多的</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker search nginxNAME                                              DESCRIPTION                                     STARS     OFFICIALnginx                                             Official build of Nginx.                        19857     [OK]unit                                              Official build of NGINX Unit: Universal Web …   29        [OK]nginx&#x2F;nginx-ingress                               NGINX and  NGINX Plus ....</code></pre></div></figure><h3 id="3）拉取-推送镜像"><a href="#3）拉取-推送镜像" class="headerlink" title="3）拉取&#x2F;推送镜像"></a>3）拉取&#x2F;推送镜像</h3><p>拉取和推送的时候注意版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 拉取docker pull nginx# 推动，得要有自己仓库，且认证通过[root@docker01[ ~]#docker push nginxUsing default tag: latestThe push refers to repository [docker.io&#x2F;library&#x2F;nginx]d874fd2bc83b: Layer already exists 32ce5f6a5106: Layer already exists f1db227348d0: Layer already exists b8d6e692a25e: Layer already exists e379e8aedd4d: Layer already exists 2edcec3590a4: Layer already exists # 认证失败，不让推送errors:denied: requested access to the resource is deniedunauthorized: authentication required</code></pre></div></figure><blockquote><p>关于镜像版本的指定：</p><ul><li>只写服务名字一般下载服务的最新版本.</li><li>下载ngx最新版本 nginx:latest</li><li>下载ngx最新稳定的版本 nginx:stable</li><li>下载指定的版本 nginx:1.20.2</li></ul><p>指定系统</p><ul><li>nginx镜像默认的系统是Debian系统</li><li>docker pull nginx:1.20.2-alpine 使用alpine系统更加节约空间</li></ul><table><thead><tr><th>docker镜像使用的系统</th><th></th><th></th></tr></thead><tbody><tr><td>ubuntu</td><td>都可以做镜像的系统.</td><td></td></tr><tr><td>debian</td><td>都可以做镜像的系统. bullseye ,bluster</td><td></td></tr><tr><td>centos</td><td>都可以做镜像的系统.</td><td>最大.</td></tr><tr><td>alpine</td><td>镜像非常小(命令,依赖精简) linux内核+busybox</td><td></td></tr></tbody></table></blockquote><h3 id="4）导入-导出镜像"><a href="#4）导入-导出镜像" class="headerlink" title="4）导入&#x2F;导出镜像"></a>4）导入&#x2F;导出镜像</h3><p>单个镜像操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 导出镜像[root@docker01[ ~]#docker save nginx -o &#x2F;tmp&#x2F;docker_nginx.tar.gz# 导入镜像[root@docker01[ ~]#docker load -i &#x2F;tmp&#x2F;docker_nginx.tar.gz Loaded image: nginx:latest</code></pre></div></figure><p>批量导出镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 命令docker images |awk &#39;NR&gt;1&#123;print &quot;docker save&quot;,$1&quot;:&quot;$2,&quot;-o&quot;,$1&quot;_&quot;$2&quot;.tar&quot;&#125;&#39;# 最后加 | bash 运行，如[root@docker01[ ~]#docker images |awk &#39;NR&gt;1&#123;print &quot;docker save&quot;,$1&quot;:&quot;$2,&quot;-o&quot;,$1&quot;_&quot;$2&quot;.tar&quot;&#125;&#39; | bash</code></pre></div></figure><h3 id="5）删除镜像"><a href="#5）删除镜像" class="headerlink" title="5）删除镜像"></a>5）删除镜像</h3><p>正在运行的镜像是不能删除的</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker rmi nginx:latest Error response from daemon: conflict: unable to remove repository reference &quot;nginx:latest&quot; (must force) - container 50715f7f85a3 is using its referenced image 605c77e624dd</code></pre></div></figure><h3 id="6）清理临时镜像"><a href="#6）清理临时镜像" class="headerlink" title="6）清理临时镜像"></a>6）清理临时镜像</h3><p>未来我们自定义镜像的时候会用到</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看系统中所有镜像,包含隐藏镜像[root@docker01[ ~]#docker images -aREPOSITORY   TAG             IMAGE ID       CREATED       SIZEnginx        latest          605c77e624dd   2 years ago   141MBnginx        stable-alpine   373f8d4d4c60   2 years ago   23.2MB# 清理临时镜像[root@docker01[ ~]#docker image pruneWARNING! This will remove all dangling images.Are you sure you want to continue? [y&#x2F;N] yTotal reclaimed space: 0B</code></pre></div></figure><h3 id="7）镜像打标签"><a href="#7）镜像打标签" class="headerlink" title="7）镜像打标签"></a>7）镜像打标签</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 打标签[root@docker01[ ~]#docker tag nginx nginx-my[root@docker01[ ~]#docker imagesREPOSITORY   TAG       IMAGE ID       CREATED       SIZEnginx-my     latest    605c77e624dd   2 years ago   141MBnginx        latest    605c77e624dd   2 years ago   141MB# 把标签删掉[root@docker01[ ~]#docker rmi nginx-my:latest Untagged: nginx-my:latest</code></pre></div></figure><h2 id="5-2-知识扩展：jq命令"><a href="#5-2-知识扩展：jq命令" class="headerlink" title="5.2 知识扩展：jq命令"></a>5.2 知识扩展：jq命令</h2><p>当我们使用<code>inspect</code>查看镜像的详细信息，出来的是一大串json内容，不知该从何下手，这时使用<code>jq</code>命令，可以很好的处理json格式的文件内容。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装jqyum install -y jq</code></pre></div></figure><h3 id="案例01：处理简单json数据"><a href="#案例01：处理简单json数据" class="headerlink" title="案例01：处理简单json数据"></a>案例01：处理简单json数据</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 文件内容[root@docker01[ ~]#cat &#x2F;tmp&#x2F;json.txt &#123;  &quot;name&quot;: &quot;harryYang&quot;,  &quot;age&quot;: 38,  &quot;height&quot;: 100,  &quot;weight&quot;: &quot;100kg&quot;&#125;# jq，不做处理[root@docker01[ ~]#cat &#x2F;tmp&#x2F;json.txt | jq&#123;  &quot;name&quot;: &quot;harryYang&quot;,  &quot;age&quot;: 38,  &quot;height&quot;: 100,  &quot;weight&quot;: &quot;100kg&quot;&#125;# jq，获取name[root@docker01[ ~]#cat &#x2F;tmp&#x2F;json.txt | jq .name&quot;harryYang&quot;# jq，获取age[root@docker01[ ~]#cat &#x2F;tmp&#x2F;json.txt | jq .age38# 赋值给变量[root@docker01[ ~]#name&#x3D;&#96;cat &#x2F;tmp&#x2F;json.txt |  jq .name&#96;[root@docker01[ ~]#echo $name&quot;harryYang&quot;</code></pre></div></figure><h3 id="案例02-处理复杂格式的inspect数据"><a href="#案例02-处理复杂格式的inspect数据" class="headerlink" title="案例02-处理复杂格式的inspect数据"></a>案例02-处理复杂格式的inspect数据</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01[ ~]#docker inspect nginx:stable-alpine | jq .[].Id&quot;sha256:373f8d4d4c60c0ec2ad5aefe46e4bbebfbb8e86b8cf4263f8df9730bc5d22c11&quot;[root@docker01[ ~]#docker inspect nginx:stable-alpine | jq .[].Created&quot;2021-11-16T18:22:27.763985311Z&quot;[root@docker01[ ~]#docker inspect nginx:stable-alpine | jq .[].Config.Cmd[  &quot;nginx&quot;,  &quot;-g&quot;,  &quot;daemon off;&quot;]</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day59-自动化架构-iptables防火墙</title>
    <link href="/2024/05/23/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day58-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-iptables%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <url>/2024/05/23/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day58-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-iptables%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化架构-iptables防火墙"><a href="#自动化架构-iptables防火墙" class="headerlink" title="自动化架构-iptables防火墙"></a>自动化架构-iptables防火墙</h1><p>今日内容：</p><p>​iptables防火墙</p><h1 id="一、防火墙概述"><a href="#一、防火墙概述" class="headerlink" title="一、防火墙概述"></a>一、防火墙概述</h1><h2 id="1-1-防火墙的功能"><a href="#1-1-防火墙的功能" class="headerlink" title="1.1 防火墙的功能"></a>1.1 防火墙的功能</h2><p>可以用于实现：</p><ul><li>端口封禁</li><li>IP封禁</li><li>实现NAT功能<ul><li>共享上网</li><li>端口转发、IP映射</li></ul></li></ul><h2 id="1-2-防火墙种类及使用说明"><a href="#1-2-防火墙种类及使用说明" class="headerlink" title="1.2 防火墙种类及使用说明"></a>1.2 防火墙种类及使用说明</h2><p>硬件: 整个企业入口</p><ul><li>三层路由: H3C 华为 Cisco(思科)</li><li>防火墙: 深信服,绿盟,奇安信…..</li></ul><p>软件: 开源软件 网站内部 封ip 封ip</p><ul><li>iptables 写入到Linux内核中,以后服务docker 工作在 4层(大部分)</li><li>firewalld C7</li><li>nftalbes C8</li><li>ufw (ubuntu firewall) Ubuntu</li></ul><p>云防火墙(公有云)</p><ul><li>阿里云:<ul><li>安全组 (封ip,封端口)</li><li>NAT网关(共享上网,端口映射….)</li><li>waf应用防火墙</li></ul></li><li>waf防火墙(应用防火墙,处理7层的攻击) SQL注入,等攻击.<ul><li>书写规则(描述攻击过程,关键提示,关键操作.)</li></ul></li></ul><blockquote><p>企业选型建议:  </p><p>中小企业: 使用公有云,安全组,waf防火墙,态势感知 </p><p>访问量巨大: 使用硬件防火墙,waf防火墙,硬件服务器+云服务器  </p></blockquote><h2 id="1-3-必须熟悉的名词"><a href="#1-3-必须熟悉的名词" class="headerlink" title="1.3 必须熟悉的名词"></a>1.3 必须熟悉的名词</h2><p>容器：如瓶子、罐子，存放东西</p><p>表（tables）：存放链的容器，防火墙最大概念</p><p>链（chain）：存放规则的容器</p><p>规则（policy）：准许或拒绝规则</p><table><thead><tr><th>Netfilter</th><th>表（tables）</th><th>链（chains）</th><th>规则（Policy）</th></tr></thead><tbody><tr><td>一栋楼</td><td>楼里的房子</td><td>房子里的柜子</td><td>柜子里衣服，摆放规则</td></tr></tbody></table><h2 id="1-4-iptables的执行过程（重要）"><a href="#1-4-iptables的执行过程（重要）" class="headerlink" title="1.4 iptables的执行过程（重要）"></a>1.4 iptables的执行过程（重要）</h2><p>工作流程：</p><ol><li>防火墙是层层过滤的，实际是按照配置规则的顺序<strong>从上到下，从前到后</strong>进行过滤的。</li><li>如果匹配成功规则，即明确表示是拒绝(DROP)还是接收(ACCEPT)，数据包就不再向下匹配新的规则。</li><li>如果规则中没有明确表明是阻止还是通过的，也就是没有匹配规则，向下进行匹配，直到匹配默认规则得到明确的阻止还是通过。</li><li>防火墙的默认规则是所有规则都匹配完才会匹配的。</li></ol><h2 id="1-5-表与链"><a href="#1-5-表与链" class="headerlink" title="1.5 表与链"></a>1.5 表与链</h2><h3 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1 概述"></a>1.5.1 概述</h3><p>表(table)是对功能的分类，如：</p><ul><li>防火墙功能(filter表)</li><li>共享上网,端口转发(nat表)</li></ul><p>链对数据流进行处理,需要使用不同的链，如：</p><ul><li>数据流入(INPUT)</li><li>数据流出(OUTPUT)</li></ul><p>iptables 是<strong>4表5链</strong></p><ul><li>4表: filter表 nat表 raw表 mangle表</li><li>5链: INPUT OUTPUT FORWARD PREROUTING POSTROUTING</li></ul><p>链的理解，以主机自身为准，如：</p><ul><li>INPUT，就是禁止别的主机数据包进入我</li><li>OUTPUT，禁止我的数据包出去</li></ul><h3 id="1-5-2-每个表的说明"><a href="#1-5-2-每个表的说明" class="headerlink" title="1.5 2 每个表的说明"></a>1.5 2 每个表的说明</h3><p><strong>1）filter表</strong></p><blockquote><p>企业工作场景：主机防火墙</p></blockquote><p>作用：</p><ul><li>是iptables默认的表，用于过滤</li><li>实现防火墙功能：（对数据包filter过滤）屏蔽或准许端口或IP</li></ul><p>这个表定义了三个链（chains） </p><table><thead><tr><th>filter表</th><th>作用</th></tr></thead><tbody><tr><td>INPUT</td><td>负责过滤所有目标地址是本机地址的数据包 通俗来说：就是过滤进入主机的数据包 (能否让数据包进入服务器)</td></tr><tr><td>FORWARD</td><td>路过: 负责转发流经主机的数据包。起转发的作用，和NAT关系很大，后面会详细介绍 LVS NAT模式， net.ipv4.ip_forward&#x3D;0</td></tr><tr><td>OUTPUT</td><td>处理所有源地址是本机地址的数据包 通俗的讲：就是处理从主机发出去的数据包</td></tr></tbody></table><p><strong>2）nat表</strong></p><blockquote><p>企业工作场景： </p><ol><li>用于企业路由（zebra）或网关（iptables），共享上网（POSTROUTING） </li><li>做内部外部IP地址一对一映射（dmz），硬件防火墙映射IP到内部服务器，ftp服务（PREROUTING） </li><li>WEB，单个端口的映射，直接映射80端口（PREROUTING）</li></ol></blockquote><p>作用：</p><ul><li><p>实现共享上网的功能（内网服务器上外网）</p></li><li><p>端口映射、IP映射</p></li></ul><p>这个表定义了3个链，nat功能相当于网络的acl控 制。和网络交换机acl类似</p><table><thead><tr><th>nat表</th><th>作用</th></tr></thead><tbody><tr><td>OUTPUT</td><td>和主机放出去的数据包有关，改变主机发出数据包的目的地址。</td></tr><tr><td>PREROUTING</td><td>在数据包到达防火墙时，进行路由判断之前执行的规则，作用是改变数据包的目的地址、目的端口等 就是收信时，根据规则重写收件人的地址。 例如：把公网IP：xxx.xxx.xxx.xxx映射到局域网的xx.xx.xx.xx服务器上。 如果是web服务，可以报80转换为局域网的服务器9000端口上 10.0.0.61 8080(目标端口) —-nat转换10.0.0.7 22</td></tr><tr><td>POSTROUTING</td><td>在数据包离开防火墙时进行路由判断之后执行的规则，作用改变数据包的源地址，源端口等。 写好发件人的地址，要让家人回信时能够有地址可回。 例如。默认笔记本和虚拟机都是局域网地址，在出网的时候被路由器将源地址改为了公网地址。 生产应用：局域网共享上网。</td></tr></tbody></table><p><strong>3）raw表</strong></p><p>主要用来决定是否对数据包进行状态跟踪。</p><p>对应的内核模块为：<code>iptable_raw</code>，其表内包括两个链：<code>output</code>、<code>prerouting</code>;</p><p><strong>4）mangle表</strong></p><p>主要用来修改数据包的服务类型，生存周期，为数据包设置标记，实现流量整形、策略</p><p>路由等，对应的内核模块为：<code>iptable_mangle</code>，</p><p>其表内包括五个链：<code>prerouting</code>、<code>postrouting</code>、<code>input</code>、<code>output</code>、<code>forward</code>;</p><h3 id="1-5-3-流程图"><a href="#1-5-3-流程图" class="headerlink" title="1.5.3 流程图"></a>1.5.3 流程图</h3><p><img src="/../../../img/image-20240523093136580.png" alt="image-20240523093136580"></p><h2 id="1-6-iptables的命令参数"><a href="#1-6-iptables的命令参数" class="headerlink" title="1.6 iptables的命令参数"></a>1.6 iptables的命令参数</h2><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-L</td><td>显示表中的所有规则</td></tr><tr><td>-n</td><td>不要把端口或ip反向解析为名字</td></tr><tr><td>指定表</td><td></td></tr><tr><td>-t</td><td>指定表,不指定默认是filter表</td></tr><tr><td>指定连接(加入&#x2F;追加&#x2F;删除)</td><td></td></tr><tr><td>-A</td><td>append 追加把规则写入到链的末尾.加入准许类规则 使用-A</td></tr><tr><td>-I</td><td>insert 把规则加在链的第1条 拒绝类规则放在所有规则最上面 拒绝类 -I</td></tr><tr><td>-D</td><td>delete 删除 -D INPUT 1</td></tr></tbody></table><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>指定协议 protocal tcp&#x2F;udp&#x2F;icmp&#x2F;all</td></tr><tr><td>–dport</td><td>目标端口 dest destination ⚠ 指定端口的时候加上协议 -p tcp</td></tr><tr><td>–sport</td><td>源端口 source 源</td></tr><tr><td>-s</td><td>–source 源ip ⚠ 如果只屏蔽&#x2F;准许ip,网段,不用加上协议.</td></tr><tr><td>-d</td><td>–destination 目标ip</td></tr><tr><td>-m</td><td>指定模块 multiport</td></tr><tr><td>-i</td><td>input 输入的时候 从哪个网卡进来</td></tr><tr><td>-o</td><td>ouput 输出的时候 从哪个网卡出去</td></tr></tbody></table><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-j</td><td>满足条件后的动作 : DROP(拒绝)&#x2F;ACCEPT(准许)&#x2F;REJECT(拒绝)</td></tr><tr><td>DROP REJECT拒绝 DROP 把数据丢掉 不会返回信息给用户 REJECT 拒绝 返回拒绝信息</td><td></td></tr></tbody></table><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-F flush</td><td>清除指定表中所有的规则,备份.</td></tr><tr><td>-X</td><td>删除用户自定义的链</td></tr><tr><td>-Z zero</td><td>链的计数器清零（数据包计数器与数据包字节计数器） iptables</td></tr><tr><td>-v</td><td>显示数据包,数据量</td></tr></tbody></table><table><thead><tr><th>iptables命令及选项</th><th>指定表</th><th>指定链 (插入&#x2F;追加&#x2F;删除)</th><th>ip</th><th>具体要求 (端口,ip,协议)</th><th>端口</th><th>动作</th></tr></thead><tbody><tr><td>iptables</td><td>-t filter</td><td>-A INPUT</td><td>-s</td><td>-p tcp&#x2F;udp&#x2F;icmp</td><td>–dport 目标端口</td><td>-j DROP</td></tr><tr><td></td><td></td><td>-I</td><td>-d</td><td></td><td>–sport 源端口</td><td>-j REJECT</td></tr><tr><td></td><td></td><td>-D</td><td></td><td></td><td></td><td>-j ACCEPT</td></tr></tbody></table><h1 id="二、实操"><a href="#二、实操" class="headerlink" title="二、实操"></a>二、实操</h1><h2 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h2><p>1）虚拟机准备</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">m01 10.0.0.61 172.16.1.61web01 10.0.0.7 172.16.1.7web02 10.0.0.8 172.16.1.8</code></pre></div></figure><p>2）安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#yum install -y iptables-services</code></pre></div></figure><p>主要配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#rpm -ql iptables-services# 防火墙配置文件&#x2F;etc&#x2F;sysconfig&#x2F;ip6tables&#x2F;etc&#x2F;sysconfig&#x2F;iptables# 防火墙服务的配置文件(systemctl)&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;ip6tables.service&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;iptables.service...[root@mn01[ ~]#rpm -ql iptables | grep iptables...&#x2F;usr&#x2F;sbin&#x2F;iptables# iptables命令&#x2F;usr&#x2F;sbin&#x2F;iptables-restore# 恢复&#x2F;usr&#x2F;sbin&#x2F;iptables-save# iptables规则 输出（保存）...</code></pre></div></figure><p>3）iptable模块加载到内核中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 写入文件，用久生效，如只想临时生效，执行modprobe命令即可cat &gt;&gt;&#x2F;etc&#x2F;rc.local&lt;&lt;EOFmodprobe ip_tablesmodprobe iptable_filtermodprobe iptable_natmodprobe ip_conntrackmodprobe ip_conntrack_ftpmodprobe ip_nat_ftpmodprobe ipt_stateEOF# source生效 [root@mn01[ ~]#source &#x2F;etc&#x2F;rc.local </code></pre></div></figure><p>查看内核模块，是否生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#lsmod | egrep &#39;filter|nat|ipt&#39;nf_nat_ftp             12809  0 nf_conntrack_ftp       18478  1 nf_nat_ftpiptable_nat            12875  0 nf_nat_ipv4            14115  1 iptable_natnf_nat                 26583  2 nf_nat_ftp,nf_nat_ipv4ipt_REJECT             12541  2 nf_reject_ipv4         13373  1 ipt_REJECTnf_conntrack          139264  7 nf_nat_ftp,nf_nat,xt_state,nf_nat_ipv4,xt_conntrack,nf_conntrack_ftp,nf_conntrack_ipv4iptable_filter         12810  1 ip_tables              27126  2 iptable_filter,iptable_natlibcrc32c              12644  3 xfs,nf_nat,nf_conntrack</code></pre></div></figure><p>4）启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先停止firewalld服务[root@mn01[ ~]#systemctl stop firewalld[root@mn01[ ~]#systemctl disable firewalld# 再启动iptables[root@mn01[ ~]#systemctl enable iptablesCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;basic.target.wants&#x2F;iptables.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;iptables.service.[root@mn01[ ~]#systemctl start iptables</code></pre></div></figure><p>5）查看表中的规则，默认查看filter表</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -nLChain INPUT (policy ACCEPT)target     prot opt source               destination         ACCEPT     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            state RELATED,ESTABLISHEDACCEPT     icmp --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           ACCEPT     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           ACCEPT     tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            state NEW tcp dpt:22REJECT     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            reject-with icmp-host-prohibitedChain FORWARD (policy ACCEPT)target     prot opt source               destination         REJECT     all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            reject-with icmp-host-prohibitedChain OUTPUT (policy ACCEPT)target     prot opt source               destination         </code></pre></div></figure><p>查看指定表中的规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -t nat -nLChain PREROUTING (policy ACCEPT)target     prot opt source               destination         Chain INPUT (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination         Chain POSTROUTING (policy ACCEPT)target     prot opt source               destination       </code></pre></div></figure><p><img src="/../../../img/image-20240523095135715.png" alt="image-20240523095135715"></p><h2 id="2-2-配置filter表规则"><a href="#2-2-配置filter表规则" class="headerlink" title="2.2 配置filter表规则"></a>2.2 配置filter表规则</h2><h3 id="2-2-1-备份并清空"><a href="#2-2-1-备份并清空" class="headerlink" title="2.2.1 备份并清空"></a>2.2.1 备份并清空</h3><p>正式配置之前，先备份，清空规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -F# Flush清空[root@mn01[ ~]#iptables -X# 删除用户自定义的链[root@mn01[ ~]#iptables -Z# 链的计数重置为0# 确保清空[root@mn01[ ~]#iptables -nLChain INPUT (policy ACCEPT)target     prot opt source               destination         Chain FORWARD (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination    </code></pre></div></figure><h3 id="2-2-2-禁止访问22端口"><a href="#2-2-2-禁止访问22端口" class="headerlink" title="2.2.2 禁止访问22端口"></a>2.2.2 禁止访问22端口</h3><p>配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -t  filter -A INPUT -p tcp --dport 22 -j DROP# 配置后ssh链接会断开# 查看规则# 删除规则</code></pre></div></figure><p>虚拟机上查看规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 显示序号iptables -t filter -nL --line-number</code></pre></div></figure><p><img src="/../../../img/image-20240523100757954.png" alt="image-20240523100757954"></p><p>删除规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -t filter -D INPUT 1 #根据序号删除</code></pre></div></figure><p><img src="/../../../img/image-20240523100936333.png" alt="image-20240523100936333"></p><p>删除完，又能重新ssh访问</p><h3 id="2-2-3-禁止指定IP"><a href="#2-2-3-禁止指定IP" class="headerlink" title="2.2.3 禁止指定IP"></a>2.2.3 禁止指定IP</h3><p>配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -I INPUT -s 10.0.0.7 -j DROP[root@mn01[ ~]#iptables -I INPUT -s 172.16.1.7 -j DROP# 查看[root@mn01[ ~]#iptables -nL --line-numberChain INPUT (policy ACCEPT)num  target     prot opt source               destination         1    DROP       all  --  172.16.1.7           0.0.0.0&#x2F;0           2    DROP       all  --  10.0.0.7             0.0.0.0&#x2F;0           3               all  --  10.0.0.7             0.0.0.0&#x2F;0           Chain FORWARD (policy ACCEPT)num  target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)num  target     prot opt source               destination     </code></pre></div></figure><p>封禁后ping不通、ssh也不通</p><p><img src="/../../../img/image-20240523101321910.png" alt="image-20240523101321910"></p><h3 id="2-2-4-禁止指定网段"><a href="#2-2-4-禁止指定网段" class="headerlink" title="2.2.4 禁止指定网段"></a>2.2.4 禁止指定网段</h3><p>配置，禁止10.0.0.0&#x2F;24网段访问8080端口  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -I INPUT -s 10.0.0.0&#x2F;24 -p tcp --dport 8080 -j DROP</code></pre></div></figure><blockquote><p>参数理解：</p><p>-I：配置INPUT链</p><p>-s：源网段（封禁网段）</p><p>-p：端口类型</p><p>–dport：目的端口号（本机）</p><p>-j：禁止访问</p></blockquote><h3 id="2-2-5-只允许指定网段连入"><a href="#2-2-5-只允许指定网段连入" class="headerlink" title="2.2.5 只允许指定网段连入"></a>2.2.5 只允许指定网段连入</h3><p>实现阿里云白名单功能 :默认是拒绝，开放部分端口、网段，如</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">allow 10.0.0.0&#x2F;24;deny all;</code></pre></div></figure><p>配置方法一，利用<code>!</code>排除</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -I INPUT ! -s 172.16.1.0&#x2F;24 -j DROPiptables -I INPUT ! -s 10.0.0.0&#x2F;24 -j DROP</code></pre></div></figure><p>配置方法二：修改链的默认规则，默认拒绝，再添加允许</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#修改默认规则iptables -P INPUT DROP# 再允许iptables -t filter -I INPUT -s 10.0.0.0&#x2F;24 -j ACCEPT</code></pre></div></figure><h3 id="2-2-6-指定多个端口"><a href="#2-2-6-指定多个端口" class="headerlink" title="2.2.6 指定多个端口"></a>2.2.6 指定多个端口</h3><p>如果需要封禁多个端口，一个个来比较麻烦</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 效率低iptables -I INPUT -p tcp --dport 8888 -j DROPiptables -I INPUT -p tcp --dport 9999 -j DROP</code></pre></div></figure><p>可以通过选项，一次指定多个端口</p><p><code>-m multiport -p tcp --dport 80,443  </code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -A INPUT -m multiport -p tcp --dport 80,443 -j ACCEP</code></pre></div></figure><p>如果端口是连续的，可以不加<code>-m multiport</code>选项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -I INPUT -p tcp --dport 1024:65535 -j DROP</code></pre></div></figure><h3 id="2-2-7-匹配ICMP类型"><a href="#2-2-7-匹配ICMP类型" class="headerlink" title="2.2.7 匹配ICMP类型"></a>2.2.7 匹配ICMP类型</h3><p>通过防火墙规则，控制是否可以ping通</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 精确写法iptables -I INPUT -p icmp --icmp-type 8 -j DROP# 简单写法iptables -I INPUT -p icmp -j DROP</code></pre></div></figure><blockquote><p>扩展：</p><p>也可以通过修改内核参数，来控制ping</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@m01 ~]# cat &#x2F;etc&#x2F;sysctl.conf&gt;#&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all&gt;#net网络 ipv4协议 icmp协议忽略所有&gt;net.ipv4.icmp_echo_ignore_all &#x3D; 1&gt;#生效&gt;sysctl -p</code></pre></div></figure></blockquote><h3 id="2-2-8-匹配网络状态（TCP-IP连接状态）"><a href="#2-2-8-匹配网络状态（TCP-IP连接状态）" class="headerlink" title="2.2.8 匹配网络状态（TCP&#x2F;IP连接状态）"></a>2.2.8 匹配网络状态（TCP&#x2F;IP连接状态）</h3><p><code>-m state --state</code> 状态即可</p><ul><li>NEW：已经或将启动新的连接</li><li>ESTABLISHED：已建立的连接</li><li>RELATED：正在启动的新连接</li><li>INVALID：非法或无法识别的</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT[root@mn01[ ~]#iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</code></pre></div></figure><h3 id="2-2-9-限制并发及速率"><a href="#2-2-9-限制并发及速率" class="headerlink" title="2.2.9 限制并发及速率"></a>2.2.9 限制并发及速率</h3><p><code>-m limit</code>限制模块</p><p><code>--limit</code>选项：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#每分钟只能有10个数据包，即每6秒生成一个-m limit --limit 10&#x2F;minute # 指定时间内的请求速率”n”为速率，后面为时间分别为：秒 分 时-m limit --limit n&#x2F;&#123;second&#x2F;minute&#x2F;hour&#125;:</code></pre></div></figure><p><code>--limit-burst</code>选项：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 每6秒释放工牌 给别人使用# 10个数据包前5个 1秒1个工牌 从第6个开始 每6秒 才能释放1个工牌-m limit --limit 10&#x2F;minute --limit-burst 5 </code></pre></div></figure><p>实验：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#清空iptables -F# 拒绝所有iptables -P INPUT DROP# 只允许icmp，但是限制速率iptables -I INPUT -p icmp -m limit --limit 10&#x2F;minute --limit-burst 5 -j ACCEPT</code></pre></div></figure><p>测试：用web01 ping</p><p><img src="/../../../img/image-20240523152333677.png" alt="image-20240523152333677"></p><h3 id="2-2-10-防火墙规则的保存与恢复（重要）"><a href="#2-2-10-防火墙规则的保存与恢复（重要）" class="headerlink" title="2.2.10 防火墙规则的保存与恢复（重要）"></a>2.2.10 防火墙规则的保存与恢复（重要）</h3><p><code>iptables-save</code> 进行备份,默认输出到屏幕</p><p><code>iptables-restore</code> 进行恢复，加上文件</p><h4 id="2-2-10-1-保存"><a href="#2-2-10-1-保存" class="headerlink" title="2.2.10.1 保存"></a>2.2.10.1 保存</h4><p>案例：保存配置到<code>/etc/sysconfig/iptables</code>  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查查看现在的规则[root@mn01[ ~]#iptables -nLChain INPUT (policy ACCEPT)target     prot opt source               destination         ACCEPT     icmp --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            limit: avg 10&#x2F;min burst 5Chain FORWARD (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination         # 保存[root@mn01[ ~]#iptables-save &gt;&#x2F;etc&#x2F;sysconfig&#x2F;iptables# 保存后的文件[root@mn01[ ~]#cat &#x2F;etc&#x2F;sysconfig&#x2F;iptables# Generated by iptables-save v1.4.21 on Thu May 23 15:26:57 2024*nat:PREROUTING ACCEPT [46:3292]:INPUT ACCEPT [17:1184]:OUTPUT ACCEPT [121:7862]:POSTROUTING ACCEPT [121:7862]COMMIT# Completed on Thu May 23 15:26:57 2024# Generated by iptables-save v1.4.21 on Thu May 23 15:26:57 2024*filter:INPUT ACCEPT [113:6572]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [59:5420]-A INPUT -p icmp -m limit --limit 10&#x2F;min -j ACCEPTCOMMIT# Completed on Thu May 23 15:26:57 2024</code></pre></div></figure><h4 id="2-2-10-2-恢复"><a href="#2-2-10-2-恢复" class="headerlink" title="2.2.10.2 恢复"></a>2.2.10.2 恢复</h4><p>先删除有的规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables -D INPUT 1[root@mn01[ ~]#iptables -nLChain INPUT (policy ACCEPT)target     prot opt source               destination         Chain FORWARD (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination        </code></pre></div></figure><p>再恢复</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#iptables-restore &lt;&#x2F;etc&#x2F;sysconfig&#x2F;iptables# 已复原[root@mn01[ ~]#iptables -nLChain INPUT (policy ACCEPT)target     prot opt source               destination         ACCEPT     icmp --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            limit: avg 10&#x2F;min burst 5Chain FORWARD (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination         </code></pre></div></figure><blockquote><p>补充：</p><p>重启iptables服务，也可以恢复配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;# 会自动读取&#x2F;etc&#x2F;sysconfig&#x2F;iptables内容&gt;systemctl restart iptables </code></pre></div></figure></blockquote><h3 id="2-2-11-filter表的实际生产用法"><a href="#2-2-11-filter表的实际生产用法" class="headerlink" title="2.2.11 filter表的实际生产用法"></a>2.2.11 filter表的实际生产用法</h3><p>iptables配置方式</p><ul><li>逛公园模式: 默认规则是 ACCEPT（黑名单模式）</li><li>看电影模式: 默认规则是 DROP （白名单模式）</li></ul><p>生产中建议采用<code>看电影模式</code>，在设置以下白名单</p><p>1、ssh可以连接进来</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 清空iptables -Fiptables -Xiptables -Z# 配置iptables -A INPUT -p tcp Վʔdport 22 -j ACCEPT</code></pre></div></figure><p>2、允许本机回环lo接口数据流量流出与流入  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># -i 数据进入的时候iptables -A INPUT -i lo -j ACCEPT# -o 数据流出的时候iptables -A OUTPUT -o lo -j ACCEPT</code></pre></div></figure><p>3、配置默认规则，放行80、443端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -A INPUT -m multiport -p tcp --dport 443,80 -j ACCEPT</code></pre></div></figure><p>4、允许网段访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -A INPUT -s 10.0.0.0&#x2F;24 -j ACCEPTiptables -A INPUT -s 172.16.1.0&#x2F;24 -j ACCEPT</code></pre></div></figure><p>5、保存配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables-save</code></pre></div></figure><h2 id="2-3-配置NAT表规则"><a href="#2-3-配置NAT表规则" class="headerlink" title="2.3 配置NAT表规则"></a>2.3 配置NAT表规则</h2><h3 id="2-3-1-实现共享上网🌟"><a href="#2-3-1-实现共享上网🌟" class="headerlink" title="2.3.1 实现共享上网🌟"></a>2.3.1 实现共享上网🌟</h3><h4 id="1）原理"><a href="#1）原理" class="headerlink" title="1）原理"></a>1）原理</h4><p>172.16.1.7内网服务器，通过iptables实现共享上网</p><p><img src="/../../../img/image-20240523155941222.png" alt="image-20240523155941222"></p><p>相关命令如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -t nat -A POSTROUTING -s 172.16.1.7 -j SNAT --to-source 10.0.0.61# 1. 指定nat表,配置POSTROUTING链# 2. 源ip是172.16.1.7这台主机进行共享上网,如果是多台(-s 172.16.1.0&#x2F;24)# 3. 指定使用SNAT功能,源地址转换# 4. 通过SNAT功能把数据包中的源ip地址改为防火墙公网的ip地址.(10.0.0.61)</code></pre></div></figure><blockquote><p>温馨提示：</p><p>如果公网ip不固定, -j SNAT –to-source 10.0.0.61 可以写为 -j MASQUERADE 伪装成公网ip  </p></blockquote><h4 id="2）环境准备"><a href="#2）环境准备" class="headerlink" title="2）环境准备"></a>2）环境准备</h4><p>关闭web01的公网网卡（10.0.0.7），只保留内网172网段的IP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ ~]#ifconfig ens33 down</code></pre></div></figure><h4 id="3）配置NAT共享上网"><a href="#3）配置NAT共享上网" class="headerlink" title="3）配置NAT共享上网"></a>3）配置NAT共享上网</h4><p>命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置iptablesiptables -t nat -A POSTROUTING -s 172.16.1.0&#x2F;24 -j SNAT --to-source 10.0.0.61# -- 如公网IP不固定，改用这条iptables -t nat -A POSTROUTING -s 172.16.1.0&#x2F;24 -j MASQUERADE# 开启内核转发🌟🌟echo &#39;net.ipv4.ip_forward &#x3D; 1&#39; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf# 生效sysctl -p</code></pre></div></figure><h4 id="4）web01服务器设置网关"><a href="#4）web01服务器设置网关" class="headerlink" title="4）web01服务器设置网关"></a>4）web01服务器设置网关</h4><p>将网关指向172.16.1.61，并设置DNS</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ ~]#cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens36 NMAE&#x3D;ens36DEVICE&#x3D;ens36IPADDR&#x3D;172.16.1.7PREFIX&#x3D;24ONBOOT&#x3D;yesBOOPROTO&#x3D;staticGATEWAY&#x3D;172.16.1.61# 网关DNS1&#x3D;223.5.5.5# DNS</code></pre></div></figure><h4 id="5）测试"><a href="#5）测试" class="headerlink" title="5）测试"></a>5）测试</h4><p>ping百度，虽然无10网段IP，但仍然可以通</p><p><img src="/../../../img/image-20240523161946286.png" alt="image-20240523161946286"></p><h3 id="2-3-2-实现端口转发🌟"><a href="#2-3-2-实现端口转发🌟" class="headerlink" title="2.3.2 实现端口转发🌟"></a>2.3.2 实现端口转发🌟</h3><p>端口转发常用于解决用户进来的问题，如：外部的用户访问内网的某个服务器，端口…</p><p>vmware也能设置端口映射，比如我想在真实机，通过<a href="http://127.0.0.1:9000访问到http://10.0.0.7:80，可以按图示设置端口映射">http://127.0.0.1:9000访问到http://10.0.0.7:80，可以按图示设置端口映射</a></p><p><img src="/../../../img/image-20240523163857176.png" alt="image-20240523163857176"></p><h4 id="1）原理-1"><a href="#1）原理-1" class="headerlink" title="1）原理"></a>1）原理</h4><p><img src="/../../../img/image-20240523163311287.png" alt="image-20240523163311287"></p><h4 id="2）配置"><a href="#2）配置" class="headerlink" title="2）配置"></a>2）配置</h4><p>作用：访问10.0.0.61:9000，相当于访问172.16.1.7:22</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置sysctl.conf略过# 开启系统nat模块（重要！！）iptables -t nat -A POSTROUTING -j MASQUERADE# 配置端口转发iptables -t nat -A PREROUTING -d 10.0.0.61 -p tcp --dport 388 -j DNAT --to-destination 172.16.1.7:22# 查看[root@mn01[ ~]#iptables -t nat -nLChain PREROUTING (policy ACCEPT)target     prot opt source               destination         DNAT       tcp  --  0.0.0.0&#x2F;0            10.0.0.61            tcp dpt:388 to:172.16.1.7:22Chain INPUT (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination         Chain POSTROUTING (policy ACCEPT)target     prot opt source               destination         MASQUERADE  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0      </code></pre></div></figure><h4 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a>3）测试</h4><p>在xshell本地模式中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[d:\~]$ ssh root@10.0.0.61 388# 登录进去是web01</code></pre></div></figure><p><img src="/../../../img/image-20240523173000068.png" alt="image-20240523173000068"></p><blockquote><p>记录：</p><p>首先测试失败，因为没有“开启系统nat模块”的命令</p></blockquote><h3 id="2-3-3-实现IP映射"><a href="#2-3-3-实现IP映射" class="headerlink" title="2.3.3 实现IP映射"></a>2.3.3 实现IP映射</h3><h4 id="1）配置"><a href="#1）配置" class="headerlink" title="1）配置"></a>1）配置</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -t nat -A PREROUTING -d 10.0.0.61 -j DNAT --to-destination 172.16.1.7# 查看[root@mn01[ ~]#iptables -t nat -nLChain PREROUTING (policy ACCEPT)target     prot opt source               destination         DNAT       tcp  --  0.0.0.0&#x2F;0            10.0.0.61            tcp dpt:388 to:172.16.1.7:22DNAT       all  --  0.0.0.0&#x2F;0            10.0.0.61            to:172.16.1.7Chain INPUT (policy ACCEPT)target     prot opt source               destination         Chain OUTPUT (policy ACCEPT)target     prot opt source               destination         Chain POSTROUTING (policy ACCEPT)target     prot opt source               destination         MASQUERADE  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           </code></pre></div></figure><p>测试</p><p>ssh访问10.0.0.61:22，登录到了web01，说明IP转发成功</p><p><img src="/../../../img/image-20240523173536525.png" alt="image-20240523173536525"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day57-自动化架构-shell自动化编程（六）-完结</title>
    <link href="/2024/05/22/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day57-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-6/"/>
    <url>/2024/05/22/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day57-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-6/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化架构-shell自动化编程（六）-完结"><a href="#自动化架构-shell自动化编程（六）-完结" class="headerlink" title="自动化架构-shell自动化编程（六）-完结"></a>自动化架构-shell自动化编程（六）-完结</h1><p>今日内容：</p><p>​Shell编程案例</p><h1 id="一、Shell编程基础"><a href="#一、Shell编程基础" class="headerlink" title="一、Shell编程基础"></a>一、Shell编程基础</h1><h2 id="1-0-通用函数库"><a href="#1-0-通用函数库" class="headerlink" title="1.0 通用函数库"></a>1.0 通用函数库</h2><p>后面都用得上</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell&#x2F;shell-108]#cat 01_diy_func.sh #!&#x2F;bin&#x2F;bash############################################################### File Name:01_diy_func.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################redecho() &#123;#颜色开头部分echo -ne &quot;\e[5;31m&quot;#取出要加上颜色的内容echo -n &quot;$@&quot;#颜色的结束部分echo -e &quot;\e[0m&quot;#echo -e &quot;\e[5;31m $@ \e[0m&quot;&#125;greenecho() &#123;echo -ne &quot;\e[1;32m&quot;echo -n &quot;$@&quot;echo -e &quot;\e[0m&quot;&#125;blueecho() &#123;echo -ne &quot;\e[1;34m&quot;echo -n &quot;$@&quot;echo -e &quot;\e[0m&quot;&#125;check_return_value() &#123;if [ $? -eq 0 ]thengreenecho $1 命令执行成功elseredecho $1 命令执行失败fi&#125;check_user() &#123;echo 检查用户&#125;check_num() &#123;echo 检查数字&#125;</code></pre></div></figure><h2 id="1-1-自动运行脚本"><a href="#1-1-自动运行脚本" class="headerlink" title="1.1 自动运行脚本"></a>1.1 自动运行脚本</h2><p>书写Hello world脚本并在用户登录的时候自动运行。  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashecho &quot;Hello World&quot;</code></pre></div></figure><p>追加到<code>/etc/bashrc</code>的最后面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#tail -n 1 &#x2F;etc&#x2F;bashrc bash &#x2F;server&#x2F;scripts&#x2F;devops-shell&#x2F;shell-108&#x2F;02_hello.sh</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#su root主机名：mn01ip地址：10.0.0.61 172.16.1.61 总内存：1.9G可用内存：1.6G系统负载：0.00, 0.01, 0.05Hello World</code></pre></div></figure><h2 id="1-2-备份日志"><a href="#1-2-备份日志" class="headerlink" title="1.2 备份日志"></a>1.2 备份日志</h2><p>备份日志&#x2F;var&#x2F;log下面所有内容到&#x2F;backup</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:02.backup.sh# Version:V1.0# Author:oldboy lidao996# Organization:www.oldboyedu.com# Desc:###############################################################1.varstime&#x3D;&#96;date +%F&#96;filename&#x3D;log-$&#123;time&#125;.tar.gz#2.打包日志文件，备份到&#x2F;backup中tar zcf &#x2F;backup&#x2F;$&#123;filename&#125; &#x2F;var&#x2F;log&#x2F;</code></pre></div></figure><p>备份用户手动输入的目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 可以修改方向:#1.备份任意多的目录,文件#使用方法：sh 02.backup.sh &#x2F;etc&#x2F; &#x2F;var&#x2F;log&#x2F; &#x2F;oldboy&#x2F;oldboy.txttar zcf &#x2F;backup&#x2F;$&#123;filename&#125; $@</code></pre></div></figure><h2 id="1-3-一键部署LNMP（RPM方式）"><a href="#1-3-一键部署LNMP（RPM方式）" class="headerlink" title="1.3 一键部署LNMP（RPM方式）"></a>1.3 一键部署LNMP（RPM方式）</h2><p>RPM包方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash#1. vars# 准备nginx,php,mariadb的rpm包rpmdir&#x3D;&#x2F;server&#x2F;tools&#x2F;lnmp&#x2F;#2.yum安装yum localinstall -y &#x2F;server&#x2F;tools&#x2F;lnmp&#x2F;*.rpm#如果不是软件包yum方式#配置ngx和phpyum源yum install -y nginxyum install -y phpxxxxxxxxyum install -y mariadb</code></pre></div></figure><h2 id="1-4-一键部署LNMP（yum方式）"><a href="#1-4-一键部署LNMP（yum方式）" class="headerlink" title="1.4  一键部署LNMP（yum方式）"></a>1.4  一键部署LNMP（yum方式）</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashyum install -y httpdyum install -y phpxxxxxxxxyum install -y mariadb</code></pre></div></figure><h2 id="1-5-一键部署redis"><a href="#1-5-一键部署redis" class="headerlink" title="1.5 一键部署redis"></a>1.5 一键部署redis</h2><p>yum安装方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashyum install -y redis</code></pre></div></figure><h2 id="1-6-远程其他主机安装httpd软件"><a href="#1-6-远程其他主机安装httpd软件" class="headerlink" title="1.6 远程其他主机安装httpd软件"></a>1.6 远程其他主机安装httpd软件</h2><p>使用sshpass工具自动交互密码远程其他主机安装httpd软件  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# 导入通用函数库. diy_func.sh#1.检查sshpass是否安装check_cmd() &#123;cmd&#x3D;$1rpm&#x3D;$2which $cmd &amp;&gt;&#x2F;dev&#x2F;null || &#123;redecho &quot;$cmd 命令不存在&quot;yum install -y $rpm &amp;&gt;&#x2F;dev&#x2F;null&#125;&#125;#2. 连接并安装软件ssh_cmd() &#123;pass&#x3D;1sshpass -p$pass ssh root@10.0.0.61 &quot;yum install -y httpd&quot;check_return_value sshpass&#125;# 3.main函数main() &#123;check_cmd sshpass sshpass#check_cmd ifconfig net-toolsssh_cmd&#125;# 执行mainmain</code></pre></div></figure><h2 id="1-7-查看有多少远程IP在连接本机"><a href="#1-7-查看有多少远程IP在连接本机" class="headerlink" title="1.7 查看有多少远程IP在连接本机"></a>1.7 查看有多少远程IP在连接本机</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash#检查当前有多少人远程连接这个主机的22端口.ss -ant |grep -i ESTAB|awk &#39;$4~&#x2F;:22$&#x2F;&#39; |wc -l#有多少ip连接本地的任意端口ss -ant |grep -i ESTAB |wc -lss -ant |grep -ic ESTAB#统计登录的用户数w命令统计登录用户数量</code></pre></div></figure><h2 id="1-8-统计当前-Linux-系统中可以登录计算机的账户有多少个"><a href="#1-8-统计当前-Linux-系统中可以登录计算机的账户有多少个" class="headerlink" title="1.8 统计当前 Linux 系统中可以登录计算机的账户有多少个"></a>1.8 统计当前 Linux 系统中可以登录计算机的账户有多少个</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:08_login_user.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:###############################################################分析:#可以登录:#1. 命令解释器是&#x2F;etc&#x2F;passwd &#x2F;bin&#x2F;bash#2. 密码 &#x2F;etc&#x2F;shadow 第2列不是*号,也不是包含Վʰ#思路1.##先取出1个文件的内容(满足条件的)##然后在另外一个文件过滤并判断.. diy_func.sh#1.过滤&#x2F;etc&#x2F;passwd命令解释器是&#x2F;bin&#x2F;bash的用户check_login_etc_passwd() &#123;name_list&#x3D;&#96;grep &#39;&#x2F;bin&#x2F;bash&#39; &#x2F;etc&#x2F;passwd|awk -F: &#39;&#123;print $1&#125;&#39;&#96;&#125;#2.根据这个用户去&#x2F;etc&#x2F;shadow里面过滤,如果第2列是非*或!就可以登录.check_login_etc_shadow() &#123;i&#x3D;0for name in $name_listdologin&#x3D;&#96;grep -w &quot;$&#123;name&#125;&quot; &#x2F;etc&#x2F;shadow |awk -F: &#39;&#123; if($2!~&#x2F;[*!]&#x2F;) print 0 ;else print 1 &#125;&#39;&#96;if [ $login -eq 0 ];thengreenecho &quot;$name 用户可以登录&quot;let i++fidoneblueecho &quot;可以远程登录系统的用户数量是:$i&quot;&#125;#3.mainmain() &#123;check_login_etc_passwdcheck_login_etc_shadow&#125;main</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240522163741237.png" alt="image-20240522163741237"></p><h2 id="1-9-统计-var-log-有多少个文件"><a href="#1-9-统计-var-log-有多少个文件" class="headerlink" title="1.9 统计&#x2F;var&#x2F;log 有多少个文件"></a>1.9 统计&#x2F;var&#x2F;log 有多少个文件</h2><p>需要显示这些文件名  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash#1.find 看所有层find &#x2F;var&#x2F;log -type f | wc -l# 显示文件个数find &#x2F;var&#x2F;log -type f# 显示文件名</code></pre></div></figure><h2 id="1-10-自动化部署Tengine源码包"><a href="#1-10-自动化部署Tengine源码包" class="headerlink" title="1.10 自动化部署Tengine源码包"></a>1.10 自动化部署Tengine源码包</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1. .&#x2F;configure.&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;tools&#x2F;tengine-2.3.3&#x2F; --add-module&#x3D;负载均衡状态检查模块#2.编译 make -j &#96;nproc&#96;#3、安装make install</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day56-自动化架构-shell自动化编程（五）</title>
    <link href="/2024/05/21/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day56-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-5/"/>
    <url>/2024/05/21/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day56-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-5/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化架构-shell自动化编程（五）"><a href="#自动化架构-shell自动化编程（五）" class="headerlink" title="自动化架构-shell自动化编程（五）"></a>自动化架构-shell自动化编程（五）</h1><p>今日内容：</p><ul><li>Shell编程-数组</li><li>Shell编程-Debug方法</li><li>再战三剑客</li></ul><h1 id="一、Shell编程-数组"><a href="#一、Shell编程-数组" class="headerlink" title="一、Shell编程-数组"></a>一、Shell编程-数组</h1><h2 id="1-1-数组的基本使用"><a href="#1-1-数组的基本使用" class="headerlink" title="1.1 数组的基本使用"></a>1.1 数组的基本使用</h2><h3 id="1-1-1-创建数组"><a href="#1-1-1-创建数组" class="headerlink" title="1.1.1 创建数组"></a>1.1.1 创建数组</h3><p>手动创建数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建ip_array&#x3D;(10.0.0.61 10.0.0.71 10.0.0.81)# 使用echo $&#123;ip_array[0]&#125;# 输出10.0.0.61</code></pre></div></figure><h3 id="1-1-2-输出所有元素和元素的个数"><a href="#1-1-2-输出所有元素和元素的个数" class="headerlink" title="1.1.2 输出所有元素和元素的个数"></a>1.1.2 输出所有元素和元素的个数</h3><p>输出数组中的所有值</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo $&#123;ip_array[@]&#125;echo $&#123;ip_array[*]&#125;</code></pre></div></figure><p>获取数组元素的个数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo $&#123;#ip_array[@]&#125;echo $&#123;#ip_array[*]&#125;</code></pre></div></figure><h3 id="1-1-3-数组的循环"><a href="#1-1-3-数组的循环" class="headerlink" title="1.1.3 数组的循环"></a>1.1.3 数组的循环</h3><p>用法一：推荐</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">names&#x3D;(web01 web02 db01 nfs01 backup)for n in $&#123;names[@]&#125;doping -c 1 -W 1 $ndone</code></pre></div></figure><p>用法二：了解即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">names&#x3D;(web01 web02 db01 nfs01 backup)for(( i&#x3D;0;i&lt;$&#123;#names[@]&#125;;i++ ))doping -c 1 -W 1 $&#123;names[i]&#125;done</code></pre></div></figure><h2 id="1-2-数组赋值"><a href="#1-2-数组赋值" class="headerlink" title="1.2 数组赋值"></a>1.2 数组赋值</h2><p>数组赋值方式有三种：</p><ul><li>批量赋值，array&#x3D;(ip01 ip02 ip03)</li><li>逐个元素赋值：array[0]&#x3D;ip01 array[1]&#x3D;ip02..</li><li>read命令赋值：read -p “输入数组内容：” -a array</li></ul><p>方式一赋值的案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat ip.txt10.0.0.110.0.0.210.0.0.310.0.0.410.0.0.5ip_list&#x3D;(&#96;cat ip.txt&#96;)echo $&#123;ip_list[@]&#125;10.0.0.1 10.0.0.2 10.0.0.3 10.0.0.4 10.0.0.5echo $&#123;#ip_list[@]&#125;5</code></pre></div></figure><p><img src="/../../../img/image-20240521153947786.png" alt="image-20240521153947786"></p><h2 id="1-3-数组案例"><a href="#1-3-数组案例" class="headerlink" title="1.3 数组案例"></a>1.3 数组案例</h2><p>试编写一个Shell程序，该程序能接收用户从，键盘输入的10个整数，然后求出其总和、平均值  </p><h3 id="1-3-1-实现：交互输入版"><a href="#1-3-1-实现：交互输入版" class="headerlink" title="1.3.1 实现：交互输入版"></a>1.3.1 实现：交互输入版</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:25_shuzu_sum.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################sum&#x3D;0avg&#x3D;0read -p &quot;请输入10个数字，用空格分隔: &quot; -a arrayfor i in $&#123;array[@]&#125;do        let sum+&#x3D;idoneavg&#x3D;&#96;echo &quot;scale&#x3D;2;$sum&#x2F;10&quot;|bc -l&#96;echo &quot;数字总和为: $sum&quot;echo &quot;平均值为: $avg&quot;</code></pre></div></figure><p><img src="/../../../img/image-20240521154840554.png" alt="image-20240521154840554"></p><h3 id="1-3-2-实现：文件读取版"><a href="#1-3-2-实现：文件读取版" class="headerlink" title="1.3.2 实现：文件读取版"></a>1.3.2 实现：文件读取版</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 26_shuzu_sum.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:26_shuzu_sum.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################n&#x3D;1sum&#x3D;0tmp_file&#x3D;&#x2F;server&#x2F;files&#x2F;res.txt# 保存数据while truedo        read -p &quot;请输入第$n个数字:&quot; num        ### 检查是否为数字，如果不是重新输入        [[ $num &#x3D;~ ^[0-9]+$ ]] || continue        echo $num &gt;&gt;$tmp_file        ### 检查是否输入了10个数字了，到了则退出循环        [ $n -eq 10 ] &amp;&amp; break        let n++done# 计算#可以使用whileread line形式读取文件然后计算calc&#x3D;(&#96;cat $tmp_file&#96;)for n in $&#123;calc[@]&#125;do        let sum&#x3D;sum+ndone# 输出echo &quot;数组总和为：$sum  平均值为：$((sum&#x2F;10))&quot;# 清理文件[ -f $tmp_file ] &amp;&amp; rm -f $tmp_file</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240521155453763.png" alt="image-20240521155453763"></p><h3 id="1-3-3-精简版"><a href="#1-3-3-精简版" class="headerlink" title="1.3.3 精简版"></a>1.3.3 精简版</h3><p>实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">n&#x3D;1sum&#x3D;0while truedo        # 交互输入数组        read -p &quot;请输入第$n个数字:&quot; num        # 如果不是数字，重新下一个循环        [[ $num &#x3D;~ ^[0-9]+$ ]] || continue        # 计算        let sum&#x3D;sum+num        # 如果数字有10个了，结束循环        [ $n -eq 10 ] &amp;&amp; break        let n++done# 输出echo &quot;$sum $((sum&#x2F;10))&quot;</code></pre></div></figure><p>测试<br><img src="/../../../img/image-20240521155824180.png" alt="image-20240521155824180"></p><h3 id="1-3-4-最精简版-用awk实现"><a href="#1-3-4-最精简版-用awk实现" class="headerlink" title="1.3.4 最精简版(用awk实现)"></a>1.3.4 最精简版(用awk实现)</h3><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read -p &quot;请输入数字以空格分割:&quot; num[root@mn01[ &#x2F;]#echo $num|xargs -n1|awk &#39;&#123;sum&#x3D;sum+$1&#125;END&#123;print sum,sum&#x2F;NR&#125;&#39;55 5.5</code></pre></div></figure><h1 id="二、Shell编程-Debug全流程"><a href="#二、Shell编程-Debug全流程" class="headerlink" title="二、Shell编程-Debug全流程"></a>二、Shell编程-Debug全流程</h1><p>调试方法</p><ol><li>注释法：如程序出现问题，注释多余的函数，排除、缩小范围定位问题.</li><li>输出关键变量：多用echo输出变量内容，查看过程。</li><li>开启调试模式：<code>-X</code> 大部分时候使用，显示详细的执行过程。</li><li>精确显示过程</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set -x # 显示详细信息代码set +x # 关闭显示详细信息</code></pre></div></figure><h1 id="三、再战三剑客"><a href="#三、再战三剑客" class="headerlink" title="三、再战三剑客"></a>三、再战三剑客</h1><h2 id="3-1-sed与变量"><a href="#3-1-sed与变量" class="headerlink" title="3.1 sed与变量"></a>3.1 sed与变量</h2><p>案例：sed命令中如何调用变量  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 原文件cat ip.txt10.0.0.510.0.0.610.0.0.710.0.0.810.0.0.9# sed调用变量src&#x3D;10.0.0dst&#x3D;172.16.1sed &quot;s#$src#$dst#g&quot; ip.txt# 替换后的输出172.16.1.5172.16.1.6172.16.1.7172.16.1.8172.16.1.9</code></pre></div></figure><h2 id="3-2-awk案例"><a href="#3-2-awk案例" class="headerlink" title="3.2 awk案例"></a>3.2 awk案例</h2><h3 id="3-2-1-案例01-指哪打哪"><a href="#3-2-1-案例01-指哪打哪" class="headerlink" title="3.2.1 案例01-指哪打哪"></a>3.2.1 案例01-指哪打哪</h3><p>案例：过滤出&#x2F;etc&#x2F;passwd的第2到9行的第1列和第3列  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#awk -F: &#39;NR&gt;&#x3D;2 &amp;&amp; NR&lt;&#x3D;9&#123;print $1,$3&#125;&#39; &#x2F;etc&#x2F;passwdbin 1daemon 2adm 3lp 4sync 5shutdown 6halt 7mail 8</code></pre></div></figure><h3 id="3-2-2-案例02-获取用户命令解释器"><a href="#3-2-2-案例02-获取用户命令解释器" class="headerlink" title="3.2.2 案例02-获取用户命令解释器"></a>3.2.2 案例02-获取用户命令解释器</h3><p>找到用户名等于root的行，并输出它的最后一列  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk -F: &#39;$1&#x3D;&#x3D;&quot;root&quot;&#123;print $NF&#125;&#39; &#x2F;etc&#x2F;passwd&#x2F;bin&#x2F;bash</code></pre></div></figure><h3 id="3-2-3-案例03-获取网卡文件中IP地址"><a href="#3-2-3-案例03-获取网卡文件中IP地址" class="headerlink" title="3.2.3 案例03-获取网卡文件中IP地址"></a>3.2.3 案例03-获取网卡文件中IP地址</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#awk -F&#x3D; &#39;&#x2F;IPADDR&#x2F;&#123;print $2&#125;&#39; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens3310.0.0.61</code></pre></div></figure><h2 id="3-3-awk的判断与循环"><a href="#3-3-awk的判断与循环" class="headerlink" title="3.3 awk的判断与循环"></a>3.3 awk的判断与循环</h2><h3 id="3-3-1-awk判断"><a href="#3-3-1-awk判断" class="headerlink" title="3.3.1 awk判断"></a>3.3.1 awk判断</h3><p>案例：如果系统根分区磁盘使用率大于6%，提示磁盘空间不足  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#df -h | awk &#39;$NF&#x3D;&#x3D;&quot;&#x2F;&quot; &#123;if($5&gt;&#x3D;6) print &quot;磁盘空间不足&quot;&#125;&#39;磁盘空间不足</code></pre></div></figure><p> 实际上上面的命令存在问题，awk得到的结果是<code>6%</code>，多了一个白分号</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#df -h | awk &#39;$NF&#x3D;&#x3D;&quot;&#x2F;&quot; &#123;if($5&gt;&#x3D;6) print $5&#125;&#39;6%</code></pre></div></figure><p>为什么后面比较大小没有报错呢？</p><blockquote><p>因为：awk进行统计计算的时候，如果是数字+字符，变成字符串对比。左到右一个字符一个字符对比  </p></blockquote><p>解决方法01：避免这个情况，通过awk指定分隔符，只获取数字部分即可  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#df -h | awk -F&quot;[ %]+&quot; &#39;$NF&#x3D;&#x3D;&quot;&#x2F;&quot; &#123;if($5&gt;&#x3D;6) print $5&#125;&#39;6</code></pre></div></figure><p>解决方案02：通过让这个字符串进行运算（比如+0），运算后会被转换为数字  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#df -h | awk &#39;$NF&#x3D;&#x3D;&quot;&#x2F;&quot; &#123;if($5+0&gt;&#x3D;6) print &quot;磁盘空间不足&quot;&#125;&#39;磁盘空间不足</code></pre></div></figure><h3 id="3-3-2-awk循环"><a href="#3-3-2-awk循环" class="headerlink" title="3.3.2 awk循环"></a>3.3.2 awk循环</h3><p>案例：计算1-100的总和</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#awk &#39;BEGIN&#123;for(i&#x3D;1;i&lt;&#x3D;100;i++) &#123;sum&#x3D;sum+i&#125; print sum&#125;&#39;5050</code></pre></div></figure><p>也可以分开写</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk &#39;BEGIN&#123;for(i&#x3D;1;i&lt;&#x3D;100;i++)&#123;sum&#x3D;sum+i&#125;print sum&#125;&#39;</code></pre></div></figure><p>案例02：计算任意数字的总和</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#read -p &quot;请输入数字: &quot; num请输入数字: 1 2 4 5 66[root@mn01[ &#x2F;]#echo $num1 2 4 5 66[root@mn01[ &#x2F;]#echo $num | awk &#39;&#123;for(i&#x3D;1;i&lt;&#x3D;5;i++) sum&#x3D;sum+$i; print sum&#125;&#39;78[root@mn01[ &#x2F;]#echo $num | awk &#39;&#123;for(i&#x3D;1;i&lt;&#x3D;NF;i++) sum&#x3D;sum+$i; print sum&#125;&#39;78</code></pre></div></figure><h3 id="3-3-3-awk数组"><a href="#3-3-3-awk数组" class="headerlink" title="3.3.3 awk数组"></a>3.3.3 awk数组</h3><p>awk数组专用于统计与分析。</p><ul><li>去重统计次数(sort+uniq)。</li><li>去重求和。</li></ul><p>awk数组与shell数组区别</p><ul><li>awk数组： 关联数组，下标啥都行，数字..字符串..</li><li>shell数组：普通数组，下标只能是数字，当然shell中也有关联数组.。</li></ul><p>使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#awk &#39;BEGIN&#123;array[0]&#x3D;&quot;lidao996&quot;;array[&quot;lidao&quot;]&#x3D;996;array[110]&#x3D;&quot;sos&quot; &#125;&#39;</code></pre></div></figure><p>取值</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下标方式[root@mn01[ &#x2F;]#awk &#39;BEGIN&#123;&gt; array[0]&#x3D;&quot;lidao996&quot;;&gt; array[&quot;lidao&quot;]&#x3D;996;&gt; array[110]&#x3D;&quot;sos&quot;;&gt; print array[0]&gt; &#125;&#39;# 值方式[root@mn01[ &#x2F;]#awk &#39;BEGIN&#123;&gt; array[0]&#x3D;&quot;lidao996&quot;;&gt; array[&quot;lidao&quot;]&#x3D;996;&gt; array[110]&#x3D;&quot;sos&quot;;&gt; print array[&quot;lidao&quot;]&gt; &#125;&#39;996</code></pre></div></figure><h4 id="awk专用于数组的循环"><a href="#awk专用于数组的循环" class="headerlink" title="awk专用于数组的循环"></a>awk专用于数组的循环</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk &#39;BEGIN&#123;array[0]&#x3D;&quot;lidao996&quot;;array[&quot;lidao&quot;]&#x3D;996;array[110]&#x3D;&quot;sos&quot;;for (n in array)print n,array[n]&#125;&#125;&#39;</code></pre></div></figure><h3 id="3-3-4-awk案例"><a href="#3-3-4-awk案例" class="headerlink" title="3.3.4 awk案例"></a>3.3.4 awk案例</h3><h4 id="案例1：批量赋值"><a href="#案例1：批量赋值" class="headerlink" title="案例1：批量赋值"></a>案例1：批量赋值</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;tmp&#x2F;awk-array.txtimg.oldboylinux.cn 6bbs.oldboylinux.cn 7avi.oldboylinux.cn 99mp4.oldboylinux.cn 88# 1、创建以url为下标、元素值是次数的数组。输出数组内容[root@mn01[ ~]#awk &#39;NR&gt;0&#123;array[$1]&#x3D;$2&#125;END&#123; for( url in array) print url,array[url] &#125;&#39; &#x2F;tmp&#x2F;awk-array.txtimg.oldboylinux.cn 6avi.oldboylinux.cn 99bbs.oldboylinux.cn 7mp4.oldboylinux.cn 88# 2.输出的时候，格式调整# url 次数 百分数（url次数&#x2F;总数）[root@mn01[ ~]#awk &#39;NR&gt;0&#123;array[$1]&#x3D;$2; sum&#x3D;sum+$2&#125;END&#123; for( url in array) print url,array[url]&#x2F;sum*100&quot;%&quot; &#125;&#39; &#x2F;tmp&#x2F;awk-array.txtimg.oldboylinux.cn 6 3%avi.oldboylinux.cn 99 49.5%bbs.oldboylinux.cn 7 3.5%mp4.oldboylinux.cn 88 44%</code></pre></div></figure><h4 id="案例2：去重统计次数"><a href="#案例2：去重统计次数" class="headerlink" title="案例2：去重统计次数"></a>案例2：去重统计次数</h4><p>分析文件中每个域名出现的次数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;server&#x2F;files&#x2F;url.txthttp:&#x2F;&#x2F;www.etiantian.org&#x2F;index.htmlhttp:&#x2F;&#x2F;www.etiantian.org&#x2F;1.htmlhttp:&#x2F;&#x2F;post.etiantian.org&#x2F;index.htmlhttp:&#x2F;&#x2F;mp3.etiantian.org&#x2F;index.htmlhttp:&#x2F;&#x2F;www.etiantian.org&#x2F;3.htmlhttp:&#x2F;&#x2F;post.etiantian.org&#x2F;2.html</code></pre></div></figure><p>统计重复次数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 方法一[root@mn01[ &#x2F;server&#x2F;files]#awk -F&#39;&#x2F;+&#39; &#39;&#123;url[$2]&#x3D;url[$2]+1&#125;END&#123; for(name in url )print name,url[name]&#125;&#39; url.txtmp3.etiantian.org 1www.etiantian.org 3post.etiantian.org 2# 其中url[$2]&#x3D;url[$2]+1可以简写成++[root@mn01[ &#x2F;server&#x2F;files]#awk -F&#39;&#x2F;+&#39; &#39;&#123;url[$2]++&#125;END&#123; for(name in url )print name,url[name]&#125;&#39; url.txtmp3.etiantian.org 1www.etiantian.org 3post.etiantian.org 2</code></pre></div></figure><p>统计Nginx访问日志中IP地址的访问次数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;files]#awk &#39;&#123;url[$1]++&#125;END&#123; for(name in url )print name,url[name]&#125;&#39; access.log |sort -rnk2 |head10.0.0.5 8910.0.0.51 1</code></pre></div></figure><h4 id="案例3：统计access-log中每个ip地址的流量总数"><a href="#案例3：统计access-log中每个ip地址的流量总数" class="headerlink" title="案例3：统计access.log中每个ip地址的流量总数"></a>案例3：统计access.log中每个ip地址的流量总数</h4><p>实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk &#39;&#123;liu[$1]&#x3D;liu[$1]+$10&#125; END&#123;for( ip in liu ) print ip,liu[ip]&#125;&#39; access.log |sort -rnk2|head10.0.0.5 188110.0.0.51 12</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day55-自动化架构-shell自动化编程（四）</title>
    <link href="/2024/05/18/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day55-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-4/"/>
    <url>/2024/05/18/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day55-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-4/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化架构-shell自动化编程（四）"><a href="#自动化架构-shell自动化编程（四）" class="headerlink" title="自动化架构-shell自动化编程（四）"></a>自动化架构-shell自动化编程（四）</h1><p>今日内容：</p><h1 id="一、脚本中常用的检查命令"><a href="#一、脚本中常用的检查命令" class="headerlink" title="一、脚本中常用的检查命令"></a>一、脚本中常用的检查命令</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><table><thead><tr><th>常用检查命令</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>端口</td><td>一般用于检查端口是否存在，能否正常连接</td><td>ss &#x2F; netstat</td></tr><tr><td>进程</td><td>检查进程状态、指标</td><td>ps &#x2F; top &#x2F; iotop</td></tr><tr><td>网络</td><td>检查网络连通性</td><td>ping &#x2F; iftop &#x2F; dig</td></tr><tr><td>web</td><td>http请求</td><td>curl &#x2F; wget</td></tr><tr><td>系统全能</td><td>atop(all)</td><td></td></tr></tbody></table><h2 id="1-2-端口检查"><a href="#1-2-端口检查" class="headerlink" title="1.2 端口检查"></a>1.2 端口检查</h2><h3 id="1-2-1-是否存在"><a href="#1-2-1-是否存在" class="headerlink" title="1.2.1 是否存在"></a>1.2.1 是否存在</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ss -lntup |grep 80netstat -lntup |grep 80lsof -i:80</code></pre></div></figure><h3 id="1-2-2-能否访问"><a href="#1-2-2-能否访问" class="headerlink" title="1.2.2 能否访问"></a>1.2.2 能否访问</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># telnet, -e指定逃脱字符，遇到这个字符相当于按ctrl+cecho q | telnet -eq 10.0.0.61 80Telnet escape character is &#39;q&#39;.Trying 10.0.0.61...telnet: connect to address 10.0.0.61: Connectionrefusedecho $?1# nc, -z 无io模式，用于检查端口是否连通nc -z 10.0.0.61 22echo $?0</code></pre></div></figure><h2 id="1-3-进程检查"><a href="#1-3-进程检查" class="headerlink" title="1.3 进程检查"></a>1.3 进程检查</h2><p>ps 、top</p><h2 id="1-4-网络检查"><a href="#1-4-网络检查" class="headerlink" title="1.4 网络检查"></a>1.4 网络检查</h2><p>ping<br>iftop  </p><h2 id="1-5-web与api的测试命令"><a href="#1-5-web与api的测试命令" class="headerlink" title="1.5 web与api的测试命令"></a>1.5 web与api的测试命令</h2><h3 id="1-5-1-curl"><a href="#1-5-1-curl" class="headerlink" title="1.5.1 curl"></a>1.5.1 curl</h3><p>curl: </p><ul><li>-v -L跟随跳转 </li><li>-H 修改请求头 </li><li>-I 只显示响应头</li><li>-w 按照指定格式输出 </li><li>-o 输出到指定位置的文件</li><li>-s 安静模式，一般使用管道需要加上，可以关闭下载进度显示</li></ul><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># curl获取http状态码curl -s -w &#39;%&#123;http_code&#125;\n&#39; -o &#x2F;dev&#x2F;null www.baidu.com200 # 获取响应头[root@mn01 ~]# curl -I www.baidu.comHTTP&#x2F;1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxyrevalidate, no-transform</code></pre></div></figure><p>curl 的 POST 选项</p><ul><li>输入用户名密码(ak id和secret) 获得令牌 token</li><li>通过令牌访问资源</li><li>-X 请求方法</li><li>-H 修改请求头</li><li>-d 请求报文主体</li></ul><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -s -X POST -H ContentType:application&#x2F;json-rpc 10.0.0.71&#x2F;api_jsonrpc.php -d &#39;&#123;  &quot;jsonrpc&quot;: &quot;2.0&quot;,  &quot;method&quot;: &quot;user.login&quot;,  &quot;params&quot;: &#123;    &quot;user&quot;: &quot;Admin&quot;,    &quot;password&quot;: &quot;zabbix&quot;  &#125;,  &quot;id&quot;: 1,  &quot;auth&quot;: null&#125;&#39;</code></pre></div></figure><h3 id="1-5-2-wget"><a href="#1-5-2-wget" class="headerlink" title="1.5.2 wget"></a>1.5.2 wget</h3><p>wget：</p><ul><li>-t 失败后，重复尝试次数、</li><li>-T timeout 超时时间</li><li>-q 不显示wget输出</li><li>–spider 不下载文件,仅访问.</li></ul><h2 id="1-6-全能信息"><a href="#1-6-全能信息" class="headerlink" title="1.6 全能信息"></a>1.6 全能信息</h2><p>atop的基本使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装yum install atop -y# 启动服务systemctl start atopsystemctl enable atop# 查看atop</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20240518191240137.png" alt="image-20240518191240137"></p><h2 id="1-7-案例"><a href="#1-7-案例" class="headerlink" title="1.7 案例"></a>1.7 案例</h2><h3 id="1-7-1-案例1：检查指定IP的端口能否正常访问"><a href="#1-7-1-案例1：检查指定IP的端口能否正常访问" class="headerlink" title="1.7.1 案例1：检查指定IP的端口能否正常访问"></a>1.7.1 案例1：检查指定IP的端口能否正常访问</h3><h4 id="1）用nmap实现"><a href="#1）用nmap实现" class="headerlink" title="1）用nmap实现"></a>1）用nmap实现</h4><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">#!&#x2F;bin&#x2F;bash############################################################### File Name:16_check_port.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 检查指定IP的端口能否访问############################################################### 变量url&#x3D;$1port&#x3D;$2. &#x2F;etc&#x2F;init.d&#x2F;functions# 参数检查[ $# -ne 2 ] &amp;&amp; &#123;        action &quot;请输入url端口&quot; &#x2F;bin&#x2F;false        exit 1&#125;[[ $port &#x3D;~ ^[0-9]+$ ]] || &#123;        action &quot;请输入有效的端口&quot; &#x2F;bin&#x2F;false        exit 1&#125;# 检查端口port_count&#x3D;&#96;nmap -p $port $url | grep -wc open&#96;if [ $port_count -eq 1 ];then        action &quot;$url $port 是畅通的&quot; &#x2F;bin&#x2F;trueelse        action &quot;$url $port 是不通的&quot; &#x2F;bin&#x2F;truefi</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240518195209025.png" alt="image-20240518195209025"></p><h4 id="2）用telnet实现"><a href="#2）用telnet实现" class="headerlink" title="2）用telnet实现"></a>2）用telnet实现</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:16_check_port.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 检查指定IP的端口能否访问############################################################### 变量url&#x3D;$1port&#x3D;$2. &#x2F;etc&#x2F;init.d&#x2F;functions# 参数检查[ $# -ne 2 ] &amp;&amp; &#123;        action &quot;请输入url端口&quot; &#x2F;bin&#x2F;false        exit 1&#125;[[ $port &#x3D;~ ^[0-9]+$ ]] || &#123;        action &quot;请输入有效的端口&quot; &#x2F;bin&#x2F;false        exit 1&#125;# 检查端口if nc -w 1 -z $url $port;then        action &quot;$url $port 是畅通的&quot; &#x2F;bin&#x2F;trueelse        action &quot;$url $port 是不通的&quot; &#x2F;bin&#x2F;truefi</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240518195443501.png" alt="image-20240518195443501"></p><h3 id="1-7-2-检测指定url是否可以访问"><a href="#1-7-2-检测指定url是否可以访问" class="headerlink" title="1.7.2 检测指定url是否可以访问"></a>1.7.2 检测指定url是否可以访问</h3><h4 id="1）用curl实现"><a href="#1）用curl实现" class="headerlink" title="1）用curl实现"></a>1）用curl实现</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:17_check_url.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 检测指定url是否可以访问############################################################### 1.varsurl&#x3D;$1# 2.检查输入是否是urlcheck_url() &#123;        [[ $url &#x3D;~ ^[0-9a-zA-Z.&#x2F;:]+$ ]] || &#123;                echo &quot;请输入有效的url地址&quot;                exit 1        &#125;&#125;# 3、检查url_status() &#123;        status_code&#x3D;&#96;curl -s -I $url | awk &#39;NR&#x3D;&#x3D;1&#123;print $2&#125;&#39;&#96;        [ -z &quot;$status_code&quot; ] &amp;&amp; &#123;                echo &quot;$url is failed&quot;                exit 2        &#125;        if [ $status_code -lt 400 ];then                echo &quot;$url is ok&quot;        else                echo &quot;$url is failed&quot;        fi&#125;# 4、mainmain() &#123;        check_url        url_status&#125;# 5、调用mainmain</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240518200534560.png" alt="image-20240518200534560"></p><h4 id="2）用wget实现"><a href="#2）用wget实现" class="headerlink" title="2）用wget实现"></a>2）用wget实现</h4><p>利用wget的功能：</p><ul><li>q不输出额外内容  </li><li>–spider不下载文件,仅仅访问测试.</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#wget -q --spider www.baiduasadsadsa.com[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $?4[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#wget -q --spider www.baidu.com[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $?0</code></pre></div></figure><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:17_check_url.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 检测指定url是否可以访问############################################################### 1.varsurl&#x3D;$1# 2.检查输入是否是urlcheck_url() &#123;        [[ $url &#x3D;~ ^[0-9a-zA-Z.&#x2F;:]+$ ]] || &#123;                echo &quot;请输入有效的url地址&quot;                exit 1        &#125;&#125;# 3、检查url_status() &#123;        wget -q --spider $url        if [ $? -eq 0 ];then                echo &quot;$url is ok&quot;        else                echo &quot;$url is failed&quot;        fi&#125;# 4、mainmain() &#123;        check_url        url_status&#125;# 5、调用mainmain</code></pre></div></figure><h1 id="二、Shell编程循环"><a href="#二、Shell编程循环" class="headerlink" title="二、Shell编程循环"></a>二、Shell编程循环</h1><h2 id="2-1-for循环"><a href="#2-1-for循环" class="headerlink" title="2.1 for循环"></a>2.1 for循环</h2><p>for循环分为两种格式：通用格式和C格式</p><h3 id="2-1-1-通用格式（常用）"><a href="#2-1-1-通用格式（常用）" class="headerlink" title="2.1.1 通用格式（常用）"></a>2.1.1 通用格式（常用）</h3><p>格式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for 变量 in 候补清单（列表） do命令done</code></pre></div></figure><p>候补清单可以是手动指定</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for n in 1 2 3 4 5doecho $ndone</code></pre></div></figure><p>也可以搭配着一些“特殊列表”使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for n in &#123;1..10&#125;for n in &#96;seq 10&#96;for n in &#96;ls &#x2F;etc&#96;</code></pre></div></figure><p>列表可以一次性提供多个</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for n in &#123;a..e&#125; &#96;ls &#x2F;etc&#x2F;|head -5&#96; &#96;seq 5&#96;doecho $ndone# 输出abcdeabrtadjtimealiasesaliases.dbalternatives12345</code></pre></div></figure><h3 id="2-1-2-C语言格式"><a href="#2-1-2-C语言格式" class="headerlink" title="2.1.2 C语言格式"></a>2.1.2 C语言格式</h3><p>不太常用</p><p>格式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for((i&#x3D;1;i&lt;&#x3D;10;i++))do echo $idone</code></pre></div></figure><h3 id="2-1-3-for循环案例"><a href="#2-1-3-for循环案例" class="headerlink" title="2.1.3 for循环案例"></a>2.1.3 for循环案例</h3><p>面试题：使用for循环在&#x2F;oldboy目录下通过随机小写10个字母加固定字符串oldboy批量创建10个html文件，名称例如为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apquvdpqbk_oldboy.htmlmpyogpsmwj_oldboy.htmltxynzwofgg_oldboy.htmlbmqiwhfpgv_oldboy.htmlmtrzobsprf_oldboy.htmlvjxmlflawa_oldboy.htmljhjdcjnjxc_oldboy.htmlqeztkkmewn_oldboy.htmljpvirsnjld_oldboy.htmlruscyxwxai_oldboy.html</code></pre></div></figure><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 18_for_touch_files.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:18_for_touch_files.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: for循环案例，创建10个文件##############################################################dir&#x3D;&#x2F;tmpfor n in &#123;1..10&#125;do        filename_suiji&#x3D;&#96;mkpasswd -l 10 -s 0&#96;        filename_full&#x3D;$&#123;filename_suiji&#125;_oldboy.html        cd $dir        touch $&#123;filename_full&#125;done</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240520111147412.png" alt="image-20240520111147412"></p><h3 id="2-1-4-补充：生成随机字符的方法"><a href="#2-1-4-补充：生成随机字符的方法" class="headerlink" title="2.1.4 补充：生成随机字符的方法"></a>2.1.4 补充：生成随机字符的方法</h3><h4 id="uuidgen"><a href="#uuidgen" class="headerlink" title="uuidgen"></a>uuidgen</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#uuidgen7d244527-4325-41d9-8e3f-bc227228f3f1[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#uuidgenb1e50c5d-1236-4fda-aba3-284528ab9426[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#uuidgeneb976e01-92f7-4022-a8d7-986f03431b54</code></pre></div></figure><h4 id="mkpasswd"><a href="#mkpasswd" class="headerlink" title="mkpasswd"></a>mkpasswd</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#mkpasswd -l 10 -s 0 -d 0 -C 0drsgimeuaw# 参数-l 密码长度-d 数字数量-s 特殊字符数量-C 大写字母数量-c 小写字母数量</code></pre></div></figure><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tr -cd &#39;a-z&#39; &lt;&#x2F;dev&#x2F;urandom | head -c10tr -cd &#39;a-zA-Z0-9&#39; &lt;&#x2F;dev&#x2F;urandom | head -c10# 参数-c 取反-d 删除&#x2F;dev&#x2F;urandom 字符设备，生成随机字符</code></pre></div></figure><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#date +%N |md5sumfba843f69322bac0866c5fc8a2ae77af  -# 参数%N 纳秒</code></pre></div></figure><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 原理echo $RANDOM# 生成范围0-32767的随机数字# 使用echo $((RANDOM+10000000)) | md5sum</code></pre></div></figure><h2 id="2-2-while循环"><a href="#2-2-while循环" class="headerlink" title="2.2 while循环"></a>2.2 while循环</h2><h3 id="2-2-1-通用格式"><a href="#2-2-1-通用格式" class="headerlink" title="2.2.1 通用格式"></a>2.2.1 通用格式</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">while 条件do 命令done</code></pre></div></figure><p>案例01：使用while输出1..10</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#！&#x2F;bin&#x2F;bashi&#x3D;1while [ $i -le 10 ]do echo $ilet i++done</code></pre></div></figure><p>案例02：输出1+2+3…+100的结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 19_while_sum.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:19_while_sum.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################i&#x3D;1sum&#x3D;0while [ $i -le 100 ]do        let sum&#x3D;sum+i        let i++doneecho $sum</code></pre></div></figure><h3 id="2-2-2-while死循环"><a href="#2-2-2-while死循环" class="headerlink" title="2.2.2 while死循环"></a>2.2.2 while死循环</h3><p>死循环，会一直循环下去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">while truedoecho oldboy done</code></pre></div></figure><p>案例：生成随机数字，判断数字是什么(1-100)  </p><ul><li>如果输入的数字比随机数大,提示大了</li><li>如果输入数字比随机数小,提示小了</li><li>如果等于提示恭喜</li><li>额外要求:<ul><li>用了1-3次 超越了99.99%人</li><li>用了4-6次 超越80%的人</li><li>其他 超越了70%的人</li></ul></li></ul><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:20_guess_num.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################guess_num&#x3D;$((RANDOM%100+1))i&#x3D;0check_percent() &#123;        if [ $i -le 3 ];then                echo    &quot;您超越了99.99%的人&quot;        elif [ $i -ge 4 -a $i -le 6 ];then                echo &quot;您超越了80%&quot;的人        else                echo &quot;您超越了70%&quot;的人        fi&#125;while truedo        read -p &quot;请输入您要猜测的数字: &quot; num        let i++        [[ &quot;$num&quot; &#x3D;~ ^[0-9]+$ ]] || &#123;                echo &quot;请输入数字&quot;                continue        &#125;        if [ $num -eq $guess_num ];then                echo &quot;恭喜您猜对了, 共猜测$i次&quot;                check_percent                exit 0        fi        if [ $num -gt $guess_num  ];then                echo &quot;数字过大&quot;        else                echo &quot;数字过小&quot;        fidone</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240520114549766.png" alt="image-20240520114549766"></p><h3 id="2-2-3-while循环-读取文件内容"><a href="#2-2-3-while循环-读取文件内容" class="headerlink" title="2.2.3 while循环-读取文件内容"></a>2.2.3 while循环-读取文件内容</h3><p>方式一：采用exec读取文件，然后进行while循环处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">exec&lt;FILEwhile read linedocmdecho $linedone</code></pre></div></figure><p>方式二：使用cat读取文件内容，然后通过管道进入，不适用于有变量传递场景使用  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat FILE | while read linedocmdecho $linedone</code></pre></div></figure><p>方式三：在while循环结尾done通过输入重定向来指定读取的文件（推荐） </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">while read linedocmddone&lt;FILE</code></pre></div></figure><h4 id="2-2-3-1-方式三的实现案例"><a href="#2-2-3-1-方式三的实现案例" class="headerlink" title="2.2.3.1 方式三的实现案例"></a>2.2.3.1 方式三的实现案例</h4><p>脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 21_while_read.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:21_while_read.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################file&#x3D;&#x2F;tmp&#x2F;num.txti&#x3D;0while read linedo        let sum&#x3D;sum+line        let i++done &lt;$fileecho &quot;这个文件一共有$&#123;i&#125;行&quot;echo &quot;每一行的总和为$&#123;sum&#125;&quot;</code></pre></div></figure><p>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat &#x2F;tmp&#x2F;num.txt300202005060070</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 21_while_read.sh这个文件一共有6行每一行的总和为1240</code></pre></div></figure><h4 id="2-2-3-2-方式三和方式二的区别"><a href="#2-2-3-2-方式三和方式二的区别" class="headerlink" title="2.2.3.2 方式三和方式二的区别"></a>2.2.3.2 方式三和方式二的区别</h4><p>案例</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:22_while_2vs3.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################file&#x3D;&#x2F;tmp&#x2F;ip.txti&#x3D;0j&#x3D;0#01echo &quot;方法2:while + cat&quot;cat $file |while read ipdo        echo $ip        let i++doneecho &quot;次数 $i&quot;echo &quot;&quot;#02echo &quot;方法3: while + 输入&quot;while read ipdo        echo $ip        let j++done &lt;$fileecho &quot;次数 $j&quot;</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240521111114810.png" alt="image-20240521111114810"></p><p>可见，读取同样的文件，while循环的次数显示不一样，这是为啥？</p><blockquote><p>说明（了解）：</p><ul><li>方法2在运行的时候因为管道，创建1个子shell，变量都存放在子shell中，子shell运行完成，消失了，变量也没了。</li><li>方法3运行的时候是与当前脚本在同一个shell中，所以变量都保持了，可以继续使用</li></ul></blockquote><h3 id="2-2-4-案例：while循环分析Nginx"><a href="#2-2-4-案例：while循环分析Nginx" class="headerlink" title="2.2.4 案例：while循环分析Nginx"></a>2.2.4 案例：while循环分析Nginx</h3><p>分析ngx访问日志找出访问量最高前5个ip及他们的访问次数，IP访问次数大于200，通过防火墙屏蔽ip。可用于防止DOS、DDOS攻击、CC攻击</p><blockquote><p>DOS，拒绝式服务攻击.<br>DDOS，分布式拒绝式服务攻击.<br>CC，基于http请求攻击  </p></blockquote><p>步骤：</p><ul><li>三剑客:分析ngx访问日志，访问次数最高的5个ip及访问次数，保存到文件中(res.txt)。</li><li>循环:读取res.txt文件，读取ip和次数。</li><li>判断:如果次数大于200 并且 之前没有屏蔽过(防火墙规则中没有这个ip）。</li><li>是：通过防火墙命令 iptables -t filter -I INPUT -s ip -j DROP</li><li>否：读取下一行  </li><li>一直到读取完文件</li></ul><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:23_dos.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:############################################################### 日志文件access_log&#x3D;&#x2F;server&#x2F;files&#x2F;access.logresult_file&#x3D;&#x2F;server&#x2F;files&#x2F;result.txt# 日志分析awk &#39;&#123;print $1&#125;&#39; $&#123;access_log&#125; | sort | uniq -c | sort -rn | head -5 &gt; $&#123;result_file&#125;# 进行处理while read linedo        ip_cnt&#x3D;&#96;echo $line | awk &#39;&#123;print $1&#125;&#39;&#96;        ip_addr&#x3D;&#96;echo $line | awk &#39;&#123;print $2&#125;&#39;&#96;        # 进行判断,屏蔽访问次数&gt;&#x3D;200的        if [ $ip_cnt -ge 200 -a &#96;iptables -nL | grep -wc &quot;$&#123;ip_addr&#125;&quot;&#96; -eq 0 ]        then                iptables -t filter -I INPUT -s $ip_addr -j DROP        fidone&lt;$&#123;result_file&#125;</code></pre></div></figure><blockquote><p>补充：</p><ul><li>文件的每一行的 第1列 赋值给count变量</li><li>文件的每一行的 第2列 赋值给ip变量</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;while read count ip&gt;doecho &quot;ip地址是$ip 访问次数是$count&quot;&gt;done&lt;$result_file</code></pre></div></figure></blockquote><h2 id="2-3-do-until循环"><a href="#2-3-do-until循环" class="headerlink" title="2.3 do..until循环"></a>2.3 do..until循环</h2><p>（很少用，了解即可）</p><p>无论条件是否满足，都会执行1次  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#直到型循环: 一直循环,直到条件不满足.until 条件do命令命令....done# 例如until 话费是否充足do发短信done</code></pre></div></figure><h1 id="三、shell编程-辅助"><a href="#三、shell编程-辅助" class="headerlink" title="三、shell编程-辅助"></a>三、shell编程-辅助</h1><h2 id="3-1-颜色"><a href="#3-1-颜色" class="headerlink" title="3.1 颜色"></a>3.1 颜色</h2><h3 id="3-1-1-基本使用"><a href="#3-1-1-基本使用" class="headerlink" title="3.1.1 基本使用"></a>3.1.1 基本使用</h3><p>给Linux命令行的字体加颜色：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo -e &quot;\E[1;31m红色字oldboy\E[0m&quot;</code></pre></div></figure><p><img src="/../../../img/image-20240521120939917.png" alt="image-20240521120939917"></p><p>各项参数解析：</p><ul><li><p>-e 识别转义字符</p></li><li><p>\E 或\033 —- 表示要开启这种功能</p></li><li><p>[1;31m —  [效果;颜色m  </p></li><li><p>\E[0m — 颜色设置结束</p></li></ul><h3 id="3-1-2-颜色字体效果"><a href="#3-1-2-颜色字体效果" class="headerlink" title="3.1.2 颜色字体效果"></a>3.1.2 颜色字体效果</h3><p>1表示加粗，2正常的，5表示闪烁  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo -e &quot;\E[1;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[2;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[3;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[4;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[5;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[6;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[7;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[8;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[9;31m红色字oldboy\E[0m&quot;echo -e &quot;\E[10;31m红色字oldboy\E[0m&quot;</code></pre></div></figure><p>效果，(实验这里5并没有闪，可能不同终端工具表现不同)</p><p><img src="/../../../img/image-20240521121348477.png" alt="image-20240521121348477"></p><p>案例：循环输出各种颜色的字符</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for n in &#123;30..50&#125;; do echo -e &quot;\E[1;$&#123;n&#125;moldboy\E[0m&quot; ;done</code></pre></div></figure><p><img src="/../../../img/image-20240521121601694.png" alt="image-20240521121601694"></p><h3 id="3-1-3-简化颜色选项"><a href="#3-1-3-简化颜色选项" class="headerlink" title="3.1.3 简化颜色选项"></a>3.1.3 简化颜色选项</h3><p>对于常用颜色可以写到环境变量中，这样使用起来比较方便</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建环境变量或写入脚本开头export RED&#x3D;&quot;\E[5;31m&quot;export GREEN&#x3D;&quot;\E[1;32m&quot;export BLUE&#x3D;&quot;\E[1;34m&quot;export END&#x3D;&quot;\E[0m&quot;永久使用&#x2F;etc&#x2F;profile中即可</code></pre></div></figure><p>使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#echo -e &quot;$&#123;BLUE&#125;这是想要的颜色$&#123;END&#125;&quot;这是想要的颜色[root@mn01[ &#x2F;]#echo -e &quot;$&#123;GREEN&#125;这是想要的颜色$&#123;END&#125;&quot;这是想要的颜色[root@mn01[ &#x2F;]#echo -e &quot;$&#123;RED&#125;这是想要的颜色$&#123;END&#125;&quot;这是想要的颜色</code></pre></div></figure><p><img src="/../../../img/image-20240521121833920.png" alt="image-20240521121833920"></p><p>也可以定义成函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redecho() &#123;echo -ne &quot;\e[5;31m&quot;echo -n &quot;$@&quot;echo -e &quot;\e[0m&quot;#echo -e &quot;\e[5;31m $@ \e[0m&quot;&#125;greenecho() &#123;echo -ne &quot;\e[1;32m&quot;echo -n &quot;$@&quot;echo -e &quot;\e[0m&quot;&#125;blueecho() &#123;echo -ne &quot;\e[1;34m&quot;echo -n &quot;$@&quot;echo -e &quot;\e[0m&quot;&#125;</code></pre></div></figure><h3 id="3-1-4-案例：函数方式-自定义颜色"><a href="#3-1-4-案例：函数方式-自定义颜色" class="headerlink" title="3.1.4 案例：函数方式-自定义颜色"></a>3.1.4 案例：函数方式-自定义颜色</h3><p>定义函数库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 24_color.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:24_color.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:############################################################### 定义颜色函数redecho() &#123;# 颜色开头        echo -ne &quot;\e[5;31m&quot;        # 取出要加上颜色的部分        echo -n &quot;$@&quot;        # 颜色结束        echo -e &quot;\e[0m&quot;        #echo -e &quot;\e[5;31m $@ \e[0m&quot;&#125;greenecho() &#123;        echo -ne &quot;\e[1;32m&quot;        echo -n &quot;$@&quot;        echo -e &quot;\e[0m&quot;&#125;blueecho() &#123;        echo -ne &quot;\e[1;34m&quot;        echo -n &quot;$@&quot;        echo -e &quot;\e[0m&quot;&#125;check_rc() &#123;if [ $? -eq 0 ];then        greenecho 命令执行成功else        redecho 命令执行失败fi&#125;</code></pre></div></figure><p>调用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:24_use_color.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################. &#x2F;server&#x2F;scripts&#x2F;devops-shell&#x2F;24_color.shredecho hello worldblueecho 李导996greenecho web is okhostnamecheck_rc# 故意写错hostnameacheck_rc</code></pre></div></figure><p>效果</p><p><img src="/../../../img/image-20240521122510953.png" alt="image-20240521122510953"></p><h2 id="3-2-gui（了解）"><a href="#3-2-gui（了解）" class="headerlink" title="3.2 gui（了解）"></a>3.2 gui（了解）</h2><p>gui图形功能。<br>未来建议大家使用：颜色和命令cowsay实现即可  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y dialog# dialog --功能 功能选项 窗口大小高 宽度# 框里显示命令执行内容dialog --textbox &#x2F;etc&#x2F;hostname 80 80# 框里显示指定的字符串串dialog --msgbox &quot;这是一个高大上的消息框&quot; 10 30</code></pre></div></figure><p><img src="/../../../img/image-20240521122833683.png" alt="image-20240521122833683"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day54-自动化架构-shell自动化编程（三）</title>
    <link href="/2024/05/17/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day54-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-3/"/>
    <url>/2024/05/17/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day54-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-3/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化架构-shell自动化编程（三）"><a href="#自动化架构-shell自动化编程（三）" class="headerlink" title="自动化架构-shell自动化编程（三）"></a>自动化架构-shell自动化编程（三）</h1><p>今日内容：</p><h1 id="一、Shell函数"><a href="#一、Shell函数" class="headerlink" title="一、Shell函数"></a>一、Shell函数</h1><h2 id="1-1-函数基本使用"><a href="#1-1-函数基本使用" class="headerlink" title="1.1 函数基本使用"></a>1.1 函数基本使用</h2><p>函数有三种定义方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 方式一：最完整function func() &#123;&#125;# 方式二：最精简，推荐func() &#123;&#125;# 方式三：缺少括号，不太明了function func &#123;&#125;</code></pre></div></figure><p>使用方式二定义函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 13_func_01.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:13_func_01.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:############################################################### 定义函数show() &#123;        echo &quot;这是一个函数&quot;&#125;# 调用函数show</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 13_func_01.sh这是一个函数</code></pre></div></figure><h2 id="1-2-函数传参"><a href="#1-2-函数传参" class="headerlink" title="1.2 函数传参"></a>1.2 函数传参</h2><p>函数传参与shell脚本类似，也是用<code>$</code>格式</p><table><thead><tr><th>位置参数</th><th>shell脚本中</th><th>shell函数中</th></tr></thead><tbody><tr><td>$n</td><td>脚本的第n个参数</td><td>函数的第n个参数</td></tr><tr><td>$0</td><td>脚本的名字</td><td>脚本的名字</td></tr><tr><td>$#</td><td>脚本参数的个数</td><td>函数参数的个数</td></tr><tr><td>$@ &#x2F; $*</td><td>脚本所有参数</td><td>函数所有的参数</td></tr></tbody></table><p>使用案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:14_func_parm.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:############################################################### 定义函数show() &#123;cat &lt;&lt; EOF        show 函数参数的个数: $#        show 函数的所有参数: $*        $&#123;1&#125;.com        $&#123;2&#125;.comEOF&#125;# 函数传参show $1 $2</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240517172014872.png" alt="image-20240517172014872"></p><h2 id="1-3-案例-服务管理脚本"><a href="#1-3-案例-服务管理脚本" class="headerlink" title="1.3 案例-服务管理脚本"></a>1.3 案例-服务管理脚本</h2><p>目标：</p><ul><li>书写服务管理脚本</li><li>&#x2F;server&#x2F;scripts&#x2F;xxxx {start|stop|restart|status}</li><li>sersync服务是二进制包，解压安装</li></ul><h3 id="1-3-1-需求分析"><a href="#1-3-1-需求分析" class="headerlink" title="1.3.1 需求分析"></a>1.3.1 需求分析</h3><p>需求：</p><ul><li>书写data_sync.sh脚本，用于管理sersync服务</li><li>sh data_sync.sh start|stop|restart|status</li></ul><p>分析</p><ul><li>如果用户输入的是start,则运行sersync启动的命令。</li><li>如果用户输入的是stop,则运行关闭sersync的命令。</li><li>如果用户输入的是status，则显示sersync是否运行中，pid。</li><li>如果用户输入的是restart,则运行stop的命令，然后运行start的命令。</li><li>如果用户输入的是其他的内容，则提示输入错误，提示格式</li></ul><p>提前准备sersync</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载https:&#x2F;&#x2F;gitee.com&#x2F;nutxi&#x2F;sersync&#x2F;blob&#x2F;master&#x2F;sersync2.5.4_64bit_binary_stable_final.tar.gz# 解压放到对应的文件夹[root@mn01[ &#x2F;app&#x2F;tools]#ls sersync&#x2F;confxml.xml  sersync2# 设置软链接ln -s &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;sersync2 &#x2F;usr&#x2F;bin&#x2F;sersync2</code></pre></div></figure><h3 id="1-3-2-实现"><a href="#1-3-2-实现" class="headerlink" title="1.3.2 实现"></a>1.3.2 实现</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:15_data_sync.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 服务管理脚本############################################################### 1.varschoice&#x3D;$1#2.定义函数#2.0 加入检查类函数#命令是否存在#配置文件是否存在#2.1 启动服务的函数sersync_start() &#123;        sersync2 -rdo &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;confxml.xml&#125;#2.2 关闭服务的函数sersync_stop() &#123;        sersync_pid&#x3D;&#96;ps -ef |grep sersync2|grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;        kill $sersync_pid&#125;#2.3 重启服务的函数sersync_restart() &#123;        sersync_pid&#x3D;&#96;ps -ef | grep sersync2 | grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;        kill $sersync_pid        sersync2 -rdo &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;confxml.xml&#125;#2.4 服务的状态函数sersync_status() &#123;        # 判断服务是否运行        ## 如果运行则显示 sersync is running (pid)        ## 如果没有运行显示 sersync is gualed        #检查服务的进程数量        sersync_count&#x3D;&#96;ps -ef | grep sersync2 | grep -v grep | wc -l&#96;        if [ $sersync_count -eq 0 ]        then                echo &quot;sersync is stoped&quot;        else                sersync_pid&#x3D;&#96;ps -ef | grep sersync2| grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;                echo &quot;sersync is running $&#123;sersync_pid&#125;&quot;        fi&#125;# 2.5 用户输入异常error_msg() &#123;        echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;&#125;# 3、case选择case &quot;$&#123;choice&#125;&quot; in        start) sersync_start;;        stop) sersync_stop;;        restart) sersync_restart;;        status) sersync_status;;        *) error_msgesac</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 15_data_sync.sh startset the system paramexecute：echo 50000000 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_user_watchesexecute：echo 327679 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_queued_eventsparse the command param...[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 15_data_sync.sh statussersync is running 9866[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 15_data_sync.sh restartset the system paramexecute：echo 50000000 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_user_watchesexecute：echo 327679 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_queued_events...[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 15_data_sync.sh statussersync is running 9900[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 15_data_sync.sh stop[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 15_data_sync.sh statussersync is stoped</code></pre></div></figure><h3 id="1-3-2-脚本改进"><a href="#1-3-2-脚本改进" class="headerlink" title="1.3.2 脚本改进"></a>1.3.2 脚本改进</h3><p>目前脚本只能做固定的启动、关闭、重启等操作，没有做状态判断，实际上应该是图中这样，对服务当前状态有所判断，然后再进行下一步操作。</p><p><img src="/../../../img/image-20240517175014688.png" alt="image-20240517175014688"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day53-自动化架构-shell自动化编程（二）</title>
    <link href="/2024/05/16/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-2/"/>
    <url>/2024/05/16/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-2/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化架构-shell自动化编程（二）"><a href="#自动化架构-shell自动化编程（二）" class="headerlink" title="自动化架构-shell自动化编程（二）"></a>自动化架构-shell自动化编程（二）</h1><p>今日内容：</p><ol><li>Shell数学运算</li><li>Shell逻辑判断</li></ol><h1 id="一、Shell数学运算"><a href="#一、Shell数学运算" class="headerlink" title="一、Shell数学运算"></a>一、Shell数学运算</h1><h2 id="1-1-运算符"><a href="#1-1-运算符" class="headerlink" title="1.1 运算符"></a>1.1 运算符</h2><p>常用运算符：</p><table><thead><tr><th>shell-运算符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>加法符号</td></tr><tr><td>-</td><td>减法符号</td></tr><tr><td>*</td><td>乘法符号</td></tr><tr><td>&#x2F;</td><td>除法符号</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>^或** 幂、指数</td><td>2^10&#x3D;1024 10个2相乘.</td></tr><tr><td>i&#x3D;i+1 i++</td><td>计数，计算次数</td></tr><tr><td>j&#x3D;j+5  j+&#x3D;5</td><td>求和，累加</td></tr><tr><td>&amp;&amp;</td><td>并且，前一个命令执行成功，再执行后面的命令(判断)</td></tr><tr><td>||</td><td>或者，前一个命令执行失败了，再执行后面的命令(判断)</td></tr></tbody></table><p>实验：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 随机数字对n取余，可以得到0到n-1范围内的随机数# 如：得到0-4的随机数echo $RANDOM % 5 | bc4echo $RANDOM % 5 | bc2echo $RANDOM % 5 | bc1# 检查目录是否存在ls &#x2F;etc &amp;&amp; echo 目录存在# 目录不存在则创建ls &#x2F;data || mkdir -p &#x2F;data</code></pre></div></figure><h2 id="1-2-运算方法（重要）"><a href="#1-2-运算方法（重要）" class="headerlink" title="1.2 运算方法（重要）"></a>1.2 运算方法（重要）</h2><p>常用运算方法</p><table><thead><tr><th>运算的命令&#x2F;符号</th><th>说明</th><th>应用场景</th></tr></thead><tbody><tr><td>awk</td><td>可以进行计算，带小数，可以与shell脚本进行变量传递</td><td>一般计算都可以用awk.</td></tr><tr><td>bc</td><td>带小数</td><td>一般计算都可以用bc.需要安装.</td></tr><tr><td>expr</td><td>进行计算,整数</td><td>一般用于检查输入内容是否为数字(方法之一).</td></tr><tr><td>let</td><td>进行计算,整数,变量直接使用即可</td><td>用于计算iՎҡ</td></tr><tr><td>$(())</td><td>进行计算，整数,变量直接使用即可。</td><td></td></tr><tr><td>$[]</td><td>进行计算，整数,变量直接使用即可。</td><td></td></tr></tbody></table><h3 id="1-2-1-使用awk计算（推荐）"><a href="#1-2-1-使用awk计算（推荐）" class="headerlink" title="1.2.1 使用awk计算（推荐）"></a>1.2.1 使用awk计算（推荐）</h3><blockquote><p>小数正常，10&#x2F;20正常显示0.5</p></blockquote><p>基础用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#awk &#39;BEGIN&#123;print 1&#x2F;3&#125;&#39;0.333333[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#awk &#39;BEGIN&#123;print 1&#x2F;3 * 100&#125;&#39;32.3333</code></pre></div></figure><p>在awk中使用shell变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 定义变量[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#num1&#x3D;100[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#num2&#x3D;200# 使用变量[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1&#x2F;n2&#125;&#39;0.5</code></pre></div></figure><blockquote><p>提示：</p><p>awk -v选项用于创建或修改awk中的变量。 </p><p><strong>-v是shell脚本与awk桥梁</strong></p><p>在awk中各种变量直接使用即可，不要加上$n1,如果加上了会被awk识别为取列  </p></blockquote><h3 id="1-2-2-使用bc计算"><a href="#1-2-2-使用bc计算" class="headerlink" title="1.2.2 使用bc计算"></a>1.2.2 使用bc计算</h3><blockquote><p>加上-l选项，小数正常，10&#x2F;20正常显示0.50000</p></blockquote><p>熟悉基本使用方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># -l 显示小数echo 1&#x2F;3 |bc -lecho 2^10 |bc -l</code></pre></div></figure><h3 id="1-2-3-使用expr计算"><a href="#1-2-3-使用expr计算" class="headerlink" title="1.2.3 使用expr计算"></a>1.2.3 使用expr计算</h3><blockquote><p>小数异常，10 &#x2F; 20 &#x3D; 0</p></blockquote><p>推荐用于判断变量是否是数字</p><p>用于计算坑很多，：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 不加空格报错[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#expr 1+11+1# 加空格正常[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#expr 1 + 12# 到了乘法，不加转义符也报错[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#expr 2 * 2expr: syntax error# 加了转义符，乘法正常[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#expr 2 \* 24# 除法[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#expr 2 &#x2F; 21</code></pre></div></figure><p>你以为就这些？还有个大坑！</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># $?常用来检测前一句命令是否执行正常# 我们来执行一条expr命令[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#expr 1 + 12# 看似很正常[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $?0# 再执行一条[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#expr 0 + 00# 不是吧！明明成功了，为什么返回1[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $?1</code></pre></div></figure><h4 id="案例：检测输入内容是否是数字"><a href="#案例：检测输入内容是否是数字" class="headerlink" title="案例：检测输入内容是否是数字"></a>案例：检测输入内容是否是数字</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:07_check_num.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:检测输入的内容是不是数字############################################################### 输入read -p &quot;请输入数字: &quot; num# 检测expr $num \* 0 + 1 &amp;&gt;&#x2F;dev&#x2F;null &amp;&amp; echo &quot;$num是数字&quot;expr $num \* 0 + 1 &amp;&gt;&#x2F;dev&#x2F;null || echo &quot;$num不是数字&quot;</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 07_check_num.sh请输入数字: dadsadsadadsadsa不是数字[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 07_check_num.sh请输入数字: 123123123123是数字</code></pre></div></figure><p>实现原理：expr可以判断是不是整数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#num&#x3D;rewrew# 计算失败[root@mn01[ &#x2F;]#expr $num \* 0 + 1expr: non-integer argument[root@mn01[ &#x2F;]#num&#x3D;321321# 计算成功[root@mn01[ &#x2F;]#expr $num \* 0 + 11</code></pre></div></figure><h3 id="1-2-4-使用let进行计算"><a href="#1-2-4-使用let进行计算" class="headerlink" title="1.2.4 使用let进行计算"></a>1.2.4 使用let进行计算</h3><blockquote><p>小数异常，10&#x2F;20&#x3D;0</p></blockquote><p>基本使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 定义变量[root@mn01[ &#x2F;]#n1&#x3D;666[root@mn01[ &#x2F;]#n2&#x3D;999# 可以直接使用变量[root@mn01[ &#x2F;]#let c&#x3D;n1+n2[root@mn01[ &#x2F;]#echo $c1665# 还可以进行累加[root@mn01[ &#x2F;]#let c++[root@mn01[ &#x2F;]#echo $c1666</code></pre></div></figure><h3 id="1-2-5-使用-进行计算"><a href="#1-2-5-使用-进行计算" class="headerlink" title="1.2.5 使用$(())进行计算"></a>1.2.5 使用$(())进行计算</h3><blockquote><p>小数异常，10&#x2F;20&#x3D;0</p></blockquote><p>基本使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 直接计算[root@mn01[ &#x2F;]#echo $((n1+n2))1665# 赋值给变量[root@mn01[ &#x2F;]#d&#x3D;$((n1+n2))[root@mn01[ &#x2F;]#echo $d1665</code></pre></div></figure><h3 id="1-2-6-使用-进行计算"><a href="#1-2-6-使用-进行计算" class="headerlink" title="1.2.6 使用$[]进行计算"></a>1.2.6 使用$[]进行计算</h3><blockquote><p>小数异常，10&#x2F;20&#x3D;0</p></blockquote><p>基本用法，跟$(())类似</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#echo $[n1+n2]1665[root@mn01[ &#x2F;]#d&#x3D;$[n1+n2][root@mn01[ &#x2F;]#echo $d1665</code></pre></div></figure><h2 id="1-3-运算案例"><a href="#1-3-运算案例" class="headerlink" title="1.3 运算案例"></a>1.3 运算案例</h2><h3 id="案例1：计算器"><a href="#案例1：计算器" class="headerlink" title="案例1：计算器"></a>案例1：计算器</h3><p>参数传入脚本中2个参数，进行计算，输出结果，要求</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh 11.num_calc.sh 10 20计算10-20:结果计算10+20:结果计算10*20:结果计算10&#x2F;20:结果</code></pre></div></figure><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:08_num_calc.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 计算器##############################################################num1&#x3D;$1num2&#x3D;$2# 参数判断expr $num1 \* 0 + $num2 \* 0 + 1 &amp;&gt;&#x2F;dev&#x2F;null || &#123;  echo &quot;参数错误!&quot;  echo &quot;Usage: $0 数字1 数字2&quot;  exit 1&#125;# 计算echo &quot;计算$num1 - $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 - n2&#125;&#39;&#96;&quot;echo &quot;计算$num1 + $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 + n2&#125;&#39;&#96;&quot;echo &quot;计算$num1 * $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 * n2&#125;&#39;&#96;&quot;echo &quot;计算$num1 &#x2F; $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 &#x2F; n2&#125;&#39;&#96;&quot;</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 08_num_calc.sh参数错误!Usage: 08_num_calc.sh 数字1 数字2[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 08_num_calc.sh 10 20计算10 - 20 &#x3D; -10计算10 + 20 &#x3D; 30计算10 * 20 &#x3D; 200计算10 &#x2F; 20 &#x3D; 0.5</code></pre></div></figure><h3 id="案例2：计算器改写"><a href="#案例2：计算器改写" class="headerlink" title="案例2：计算器改写"></a>案例2：计算器改写</h3><p>改成read读取参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat 08_num_calc.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:08_num_calc.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 计算器##############################################################read -p &quot;请输入数字num1 num2: &quot; num1 num2# 参数判断expr $num1 \* 0 + $num2 \* 0 + 1 &amp;&gt;&#x2F;dev&#x2F;null || &#123;  echo &quot;参数错误!&quot;  echo &quot;Usage: $0 数字1 数字2&quot;  exit 1&#125;# 计算echo &quot;计算$num1 - $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 - n2&#125;&#39;&#96;&quot;echo &quot;计算$num1 + $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 + n2&#125;&#39;&#96;&quot;echo &quot;计算$num1 * $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 * n2&#125;&#39;&#96;&quot;echo &quot;计算$num1 &#x2F; $num2 &#x3D; &#96;awk -vn1&#x3D;$num1 -vn2&#x3D;$num2 &#39;BEGIN&#123;print n1 &#x2F; n2&#125;&#39;&#96;&quot;</code></pre></div></figure><h1 id="二、Shell逻辑判断"><a href="#二、Shell逻辑判断" class="headerlink" title="二、Shell逻辑判断"></a>二、Shell逻辑判断</h1><p>逻辑判断分为：</p><ul><li>条件表达式：最基本的判断（核心）</li><li>if判断：更加灵活</li><li>case语句：适用于做选择</li></ul><h2 id="2-1-条件表达式"><a href="#2-1-条件表达式" class="headerlink" title="2.1 条件表达式"></a>2.1 条件表达式</h2><p>条件表达式，也叫条件测试语句，属于判断中的核心，if后面都在使用它</p><p>目标:</p><ul><li>熟练掌握条件表达式的格式.</li><li>熟练使用条件表达式进行判断（文件，大小，与或非）</li></ul><h3 id="2-1-1-格式"><a href="#2-1-1-格式" class="headerlink" title="2.1.1 格式"></a>2.1.1 格式</h3><p>格式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 判断指定路径是否存在且为文件[ -f &#x2F;etc&#x2F;hosts ]# 或者test -f &#x2F;etc&#x2F;hosts</code></pre></div></figure><h4 id="面试题：-和-的区别"><a href="#面试题：-和-的区别" class="headerlink" title="面试题：[]和[[]]的区别"></a>面试题：[]和[[]]的区别</h4><table><thead><tr><th>含义与特点</th><th>test或[]</th><th>[[]]或(())</th></tr></thead><tbody><tr><td>共同点</td><td>都可以用于判断</td><td>都可以用于判断</td></tr><tr><td>区别1</td><td>不支持正则</td><td>[[]]支持正则</td></tr><tr><td>区别2</td><td>表示逻辑关系(与或非)符号不同 -a -o !  -gt</td><td>[[ ]] &amp;&amp; || ! &gt; &lt; &lt;&#x3D; &gt;&#x3D;</td></tr><tr><td>应用场景</td><td>常见判断</td><td>使用正则[[]]<br/>进行运算(())</td></tr></tbody></table><h3 id="2-1-2-判断文件"><a href="#2-1-2-判断文件" class="headerlink" title="2.1.2 判断文件"></a>2.1.2 判断文件</h3><p>常用如下</p><table><thead><tr><th>条件表达式</th><th>说明</th></tr></thead><tbody><tr><td><strong>-f</strong></td><td>判断指定路径是否存在且为文件，是文件，返回true</td></tr><tr><td><strong>-d</strong></td><td>判断指定路径是否存在且为文件夹，是文件夹，返回true</td></tr><tr><td>-x</td><td>判断指定路径是否存在且具有可执行权限</td></tr><tr><td>-s</td><td>判断指定文件是否存在且有内容(大小&gt;0)，非空为真</td></tr><tr><td>-r</td><td>是否具有读权限</td></tr><tr><td>-w</td><td>是否具有写权限</td></tr><tr><td>-nt</td><td>newer than 对比两个文件修改时间，是否更新</td></tr><tr><td>-ot</td><td>older than 对比两个文件修改时间，是否更老</td></tr><tr><td>-L</td><td>是否是软连接</td></tr><tr><td>-e</td><td>是否存在（任何文件类型）</td></tr></tbody></table><h4 id="检测：文件是否存在"><a href="#检测：文件是否存在" class="headerlink" title="检测：文件是否存在"></a>检测：文件是否存在</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ -f &#x2F;etc&#x2F;hosts ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;[ -f &#x2F;etchosts ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;test -f &#x2F;etchosts &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;</code></pre></div></figure><h4 id="检测：目录是否存在"><a href="#检测：目录是否存在" class="headerlink" title="检测：目录是否存在"></a>检测：目录是否存在</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ -d &#x2F;etc&#x2F; ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;成立[ -d &#x2F;etc&#x2F;hosts ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;失败</code></pre></div></figure><h4 id="检测：是否有执行权限"><a href="#检测：是否有执行权限" class="headerlink" title="检测：是否有执行权限"></a>检测：是否有执行权限</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 检查&#x2F;etc&#x2F;rc.d&#x2F;rc.local是否有执行权限.[ -x &#x2F;etc&#x2F;rc.d&#x2F;rc.local ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;失败# 在脚本中的使用[ -x &#x2F;sbin&#x2F;ip ] || exit 1# ip命令是否有执行权限，如果没有则退出</code></pre></div></figure><h4 id="检测：文件是否有内容"><a href="#检测：文件是否有内容" class="headerlink" title="检测：文件是否有内容"></a>检测：文件是否有内容</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建空文件[root@mn01[ &#x2F;tmp]#&gt;test.sh# 有内容为真（&gt;0），没有内容为假(0)[root@mn01[ &#x2F;tmp]#[ -s test.sh ] &amp;&amp; echo &quot;有内容&quot; || echo &quot;没内容&quot;没内容</code></pre></div></figure><h3 id="2-1-3-对比字符串"><a href="#2-1-3-对比字符串" class="headerlink" title="2.1.3 对比字符串"></a>2.1.3 对比字符串</h3><p>用于对比两个字符串的内容</p><table><thead><tr><th>对比选项</th><th>说明</th></tr></thead><tbody><tr><td>“str1” &#x3D; “str2”</td><td>str1是否等于str2，相等为真</td></tr><tr><td>“str1” !&#x3D; “str2”</td><td>str1是否不等于str2，不相等为真</td></tr><tr><td>-z “str”</td><td>zero 检查str字符串是否是空的，空为真</td></tr><tr><td>-n “str”</td><td>no zero 检查str字符串是否不是空的，非空（有内容）为真</td></tr></tbody></table><h4 id="对比两字符串是否相等"><a href="#对比两字符串是否相等" class="headerlink" title="对比两字符串是否相等"></a>对比两字符串是否相等</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">input&#x3D;start[ &quot;$input&quot; &#x3D; &quot;start&quot; ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;成立</code></pre></div></figure><p>应用：判断程序是否是Root执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ &quot;$UID&quot; !&#x3D; &quot;0&quot; ] &amp;&amp; exit 4</code></pre></div></figure><p>企业级小技巧：在进行字符串比较的时候，变量尾巴加个x，防止变量为空，造成匹配&#x2F;执行失败</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 定义变量str1&#x3D;qwerstr2&#x3D;asdf# 对比字符串，加x[ &quot;$&#123;str1&#125;x&quot; &#x3D; &quot;$&#123;str2&#125;x&quot; ] &amp;&amp; echo &quot;成立&quot; || echo &quot;失败&quot;失败</code></pre></div></figure><h4 id="检查字符串是否为空"><a href="#检查字符串是否为空" class="headerlink" title="检查字符串是否为空"></a>检查字符串是否为空</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 字符串有内容[root@mn01[ &#x2F;tmp]#echo $str2test# 判断是否为空[root@mn01[ &#x2F;tmp]#[ -z &quot;$str2&quot; ] &amp;&amp; echo &quot;变量为空&quot; || echo &quot;变量非空&quot;变量非空# 判断是否为非空[root@mn01[ &#x2F;tmp]#[ -n &quot;$str2&quot; ] &amp;&amp; echo &quot;变量非空&quot; || echo &quot;变量为空&quot;变量非空</code></pre></div></figure><h3 id="2-1-4-比大小"><a href="#2-1-4-比大小" class="headerlink" title="2.1.4 比大小"></a>2.1.4 比大小</h3><p>常用：</p><ul><li>-eq：equal 等于</li><li>-gt：greater than 大于</li><li>-lt：less than 小于</li></ul><table><thead><tr><th>比大小（整数）</th><th>[]</th><th>[[]]</th></tr></thead><tbody><tr><td>大于</td><td>-gt</td><td>&gt;</td></tr><tr><td>大于等于</td><td>-ge</td><td>&gt;&#x3D;</td></tr><tr><td>小于</td><td>-lt</td><td>&lt;</td></tr><tr><td>小于等于</td><td>-le</td><td>&lt;&#x3D;</td></tr><tr><td>等于</td><td>-eq</td><td>&#x3D;&#x3D;</td></tr><tr><td>不等于</td><td>-ne</td><td>!&#x3D;</td></tr></tbody></table><blockquote><p>不支持小数对比，仅支持整数</p></blockquote><h4 id="比较"><a href="#比较" class="headerlink" title="[]比较"></a>[]比较</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ 666 -gt 1 ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;成立[ 0 -gt -1 ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;成立[ 0 -gt -1000 ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;成立[ 0 -gt 0.5 ] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;-bash: [: 0.5: 期待整数表达式失败</code></pre></div></figure><h4 id="比较-1"><a href="#比较-1" class="headerlink" title="[[]]比较"></a>[[]]比较</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[[ 60 &gt; 6 ]] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;成立</code></pre></div></figure><blockquote><p>注意：</p><p>不推荐使用&gt;&#x3D;这种格式，对比的时候会有语法问题</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[[ 6 &gt;&#x3D; 6 ]] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;&gt;-bash: 条件表达式中有语法错误&gt;-bash: &#96;6&#39; 附近有语法错误</code></pre></div></figure><p>这里面也可以用 -gt -lt …….</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@mn01[ &#x2F;tmp]#[[ 6 -ge 6 ]] &amp;&amp; echo &quot;成立 &quot; || echo &quot;失败&quot;&gt;成立</code></pre></div></figure></blockquote><h3 id="2-1-5-逻辑判断"><a href="#2-1-5-逻辑判断" class="headerlink" title="2.1.5 逻辑判断"></a>2.1.5 逻辑判断</h3><p>与、或、非</p><table><thead><tr><th>逻辑判断</th><th>[]</th><th>[[]]</th></tr></thead><tbody><tr><td>与</td><td>-a  (and)</td><td>&amp;&amp;</td></tr><tr><td>或</td><td>-o (or)</td><td>||</td></tr><tr><td>非</td><td>!</td><td>!</td></tr></tbody></table><p>基本使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sex&#x3D;nvstate&#x3D;china[ &quot;$sex&quot; &#x3D; &quot;nv&quot; -a &quot;$guo&quot; &#x3D; &quot;china&quot; ] &amp;&amp; echo 肯定能成 || echo 不一定，还需努力肯定能成</code></pre></div></figure><h3 id="2-1-6-正则表达式"><a href="#2-1-6-正则表达式" class="headerlink" title="2.1.6 正则表达式"></a>2.1.6 正则表达式</h3><p>初步使用正则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 变量中只要有0-9的数字就行num&#x3D;666[[ $num &#x3D;~ [0-9] ]] &amp;&amp; echo 成立 || echo 失败成立num&#x3D;lidao996[[ $num &#x3D;~ [0-9] ]] &amp;&amp; echo 成立 || echo 失败成立 # 开头结尾中间全是数字, 连续数字[[ $num &#x3D;~ ^[0-9]+$ ]] &amp;&amp; echo 成立 || echo 失败失败 num&#x3D;666[[ $num &#x3D;~ ^[0-9]+$ ]] &amp;&amp; echo 成立 || echo 失败成立</code></pre></div></figure><h4 id="案例：优化计算器脚本"><a href="#案例：优化计算器脚本" class="headerlink" title="案例：优化计算器脚本"></a>案例：优化计算器脚本</h4><p>加入正则判断参数是否为数字</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 支持负数的正则&quot;\$num1&quot; &#x3D;~ ^-?[0-9]+$# 判断小数正则 ^-?[0-9]+\.?[0-9]+$</code></pre></div></figure><p><img src="/../../../img/image-20240517141734924.png" alt="image-20240517141734924"></p><h2 id="2-2-if判断"><a href="#2-2-if判断" class="headerlink" title="2.2 if判断"></a>2.2 if判断</h2><p>应用:if一般与条件表达式一起使用，也可以直接加上命令.</p><p>目标:</p><ul><li>if判断适用于更加复杂的判断与检查</li><li>if判断语句的格式</li></ul><h3 id="2-2-1-单分支判断，if…then"><a href="#2-2-1-单分支判断，if…then" class="headerlink" title="2.2.1 单分支判断，if…then"></a>2.2.1 单分支判断，if…then</h3><p>语法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if 条件;then  满足条件后执行的内容。fi# 或者if 条件then  满足条件后执行的内容。fi</code></pre></div></figure><p>基本使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ $# -eq 2 ] Վҗ &#123;echo &quot;必须要2个数字&quot;exit 1&#125;# 或者if [ $# -ne 2 ];thenecho &quot;脚本必须要2个参数&quot;exit 1fi</code></pre></div></figure><h3 id="2-2-2-双分支判断，if-then-else"><a href="#2-2-2-双分支判断，if-then-else" class="headerlink" title="2.2.2 双分支判断，if..then..else"></a>2.2.2 双分支判断，if..then..else</h3><p>语法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if 条件;then    满足条件后执行的内容。else  不满足条件执行的内容。fi</code></pre></div></figure><p>案例：检查根分区磁盘空间使用率</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 09_disk_check.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:08_disk_check.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 检查根分区磁盘使用率############################################################### 使用率&gt;&#x3D;97%报警error&#x3D;97# 查询现在的使用率， -w 强匹配root_usage&#x3D;&#96;df -h | grep -w &#39;&#x2F;&#39; | awk -F &#39;[ %]+&#39; &#39;&#123;print $(NF - 1)&#125;&#39;&#96;# 判断if [ $root_usage -ge $error ];then        echo &quot;磁盘空间不足，请尽快删除无用数据&quot;else        echo &quot;磁盘空间正常&quot;fi</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 09_disk_check.sh磁盘空间正常</code></pre></div></figure><p><img src="/../../../img/image-20240517143023302.png" alt="image-20240517143023303"></p><h3 id="2-2-3-多分支判断"><a href="#2-2-3-多分支判断" class="headerlink" title="2.2.3 多分支判断"></a>2.2.3 多分支判断</h3><p>语法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if 条件;then满足条件后执行的内容。elif 条件;then #else if满足elif条件，执行的内容。elif 条件;then满足elif条件，执行的内容。else不满足条件执行的内容。fi</code></pre></div></figure><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if [ $num1 -gt $num2 ] ;thenecho &quot;$num1 大于 $num2&quot;elif [ $num1 -lt $num2 ] ;thenecho &quot;$num1 小于 $num2&quot;elseecho &quot;$num1 等于 $num2&quot;fi</code></pre></div></figure><h3 id="2-2-4-案例-输出指定用户的信息"><a href="#2-2-4-案例-输出指定用户的信息" class="headerlink" title="2.2.4 案例-输出指定用户的信息"></a>2.2.4 案例-输出指定用户的信息</h3><blockquote><p>温馨提示：这个脚本未来可以用于做安全检查  </p></blockquote><p>步骤:</p><ul><li>执行脚本输入用户名(参数&#x2F;read)</li><li>判断用户是否存在,如果不存在则提示用户不存在,退出脚本.</li><li>如果用户存在输出用户的信息  <ul><li>是否可以登录(命令解释器)</li><li>uid,gid(过滤)</li><li>用户家目录</li><li>最近1次登录情况</li></ul></li></ul><p>输出样式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">用户名: $user是否可以登录: $if_login用户UID,GID: $user_ids用户家目录: $user_homedir最近的登录情况: $user_login_info</code></pre></div></figure><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:10_check_user.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 检查用户是否存在############################################################### 1、输入用户名read -p &quot;请输入用户名&quot; user# 2、查寻用户## 变量不能为空[ &quot;&#123;user&#125;x&quot; &#x3D; &quot;x&quot; ] &amp;&amp; &#123;        echo &quot;输入为空，错误！脚本退出&quot;        exit 1&#125;## 查询是否存在id $user &amp;&gt; &#x2F;dev&#x2F;nullif [ $? -ne 0 ];then        echo &quot;用户$&#123;user&#125;不存在&quot;        exit 1fi## 如存在, 查询信息user_shell&#x3D;&#96;awk -F: -vname&#x3D;$user &#39;$1&#x3D;&#x3D;name&#123;print $NF&#125;&#39; &#x2F;etc&#x2F;passwd&#96;if [ &quot;$user_shell&quot; &#x3D; &quot;&#x2F;bin&#x2F;bash&quot; ];then        if_login&#x3D;&quot;可以登录&quot;else        if_login&#x3D;&quot;无法登录&quot;fi## uid、gid、家目录user_ids&#x3D;&#96;awk -F: -vname&#x3D;$user &#39;$1&#x3D;&#x3D;name&#123;print$3,$4&#125;&#39; &#x2F;etc&#x2F;passwd&#96;user_homedir&#x3D;&#96;awk -F: -vname&#x3D;$user &#39;$1&#x3D;&#x3D;name&#123;print $6&#125;&#39; &#x2F;etc&#x2F;passwd&#96;## 登录user_login_info&#x3D;&#96;lastlog |awk -vname&#x3D;$user &#39;$1&#x3D;&#x3D;name&#39;&#96;#3、输出cat &lt;&lt;EOF  用户名: $user  是否可以登录: $if_login  用户UID,GID: $user_ids  用户家目录: $user_homedir  最近的登录情况: $user_login_infoEOF</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240517144531642.png" alt="image-20240517144531642"></p><h2 id="2-3-case语句"><a href="#2-3-case语句" class="headerlink" title="2.3 case语句"></a>2.3 case语句</h2><p>条件分支语句，一般用于实现有多种选择的脚本。</p><ul><li>这个功能用if也能实现，不过使用case语句会更加清晰直观</li><li>如服务的状态：start|stop|restart|status</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">case &quot;变量&quot; in start)echo &quot;start&quot;;;stop)echo &quot;start&quot;;;restart)echo &quot;start&quot;;;*)# 默认echo &quot;Error&quot;esac</code></pre></div></figure><blockquote><p>补充：</p><p>case的一个选项可以放多种组合，比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;case &quot;&quot;$var&quot; inyes|y|Y|Yes|YES  echo &quot;yes!!&quot;;;</code></pre></div></figure></blockquote><h3 id="2-2-1-案例1-某会所菜单展示"><a href="#2-2-1-案例1-某会所菜单展示" class="headerlink" title="2.2.1 案例1-某会所菜单展示"></a>2.2.1 案例1-某会所菜单展示</h3><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:11_huisuo.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:###############################################################1.输出提示cat&lt;&lt;EOF##############olding私人高级会所#########################################套餐############################输入1,选择 138套餐) 吃饱套餐输入2,选择 443套餐) 吃饱喝足套餐输入3,选择 888套餐) 吃喝拉撒套餐输入4,选择 1688套餐) 你想干啥就干啥套餐输入其他内容,退出EOF# 2.varsread -p &quot;请输入你的选择：&quot; num# 3、判断case &quot;$num&quot; in        1)      echo &quot;138套餐) 吃饱套餐&quot; ;;        2)      echo &quot;443套餐) 吃饱喝足套餐&quot;;;        3)      echo &quot;888套餐) 吃喝拉撒套餐&quot;;;        4)      echo &quot;1688套餐) 你想干啥就干啥套餐&quot;;;        tomcat) echo &quot;8080套餐) 恭喜你获得隐藏套餐 不做人套餐&quot;;;        oldgirl) echo &quot;8443套餐) 恭喜你获得隐藏套餐 老板娘套餐&quot;;;        *)                echo&quot;退出&quot;                exit 1esac</code></pre></div></figure><h3 id="判断用户输入yes还是no"><a href="#判断用户输入yes还是no" class="headerlink" title="判断用户输入yes还是no"></a>判断用户输入yes还是no</h3><p>实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 12_yesorno.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:12_yesorno.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################read -p &quot;请输入yes或者no：&quot; varcase &quot;$var&quot; in        yes|y|Y|YES|Yes)  echo &quot;Yes!!&quot;;;        no|n|N|NO|No) echo &quot;No!!!&quot;;;        *)                echo &quot;Error!&quot;                exit 1esac</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>day52-自动化架构-shell自动化编程（一）</title>
    <link href="/2024/05/15/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day52-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-1/"/>
    <url>/2024/05/15/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/03_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84/day52-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%B6%E6%9E%84-shell%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B-1/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化架构-shell自动化编程（一）"><a href="#自动化架构-shell自动化编程（一）" class="headerlink" title="自动化架构-shell自动化编程（一）"></a>自动化架构-shell自动化编程（一）</h1><p>今日内容：</p><ol><li>课程内容概览</li><li>Shell编程概述</li><li>Shell语言分类</li><li>Shell编程环境准备</li><li>Shell脚本的执行方式</li><li>Shell变量（重要）</li></ol><p>目标：</p><ul><li>能够书写超过100行的脚本: <ul><li>系统巡检，系统加固，系统优化(初始化)，ngx优化，tomcat优化.</li></ul></li><li>总计完成书读写5000行脚本(读写).</li></ul><h1 id="一、课程内容"><a href="#一、课程内容" class="headerlink" title="一、课程内容"></a>一、课程内容</h1><ol><li>Shell概述，编程语言</li><li>Shell环境准备</li><li>Shell语法：变量，判断，循环，函数，数组.</li><li>Shell与三剑客进阶.</li><li>实际案例与项目</li></ol><h1 id="二、Shell编程概述"><a href="#二、Shell编程概述" class="headerlink" title="二、Shell编程概述"></a>二、Shell编程概述</h1><p>常见命令解释器</p><table><thead><tr><th>命令解释器</th><th>说明</th></tr></thead><tbody><tr><td>bash</td><td>目前应用最广泛一款命令解释器，红帽系列(默认),Debian,Ubuntu, BASH全称： Bourne-Again SHell</td></tr><tr><td>dash</td><td>一般debian&#x2F;ubuntu系统默认的，运行脚本推荐使用bash，如 <code>bash lidao.sh</code></td></tr><tr><td>csh,tcsh</td><td>一些unix系统使用</td></tr><tr><td>zsh</td><td>功能更多，支持更多的插件，可以更好看</td></tr></tbody></table><blockquote><p>注意：</p><p>shell脚本(.bash .sh),运行在ubuntu中的时候,不推荐使用sh运行，推荐使用bash运行  </p></blockquote><h1 id="三、编程语言分类"><a href="#三、编程语言分类" class="headerlink" title="三、编程语言分类"></a>三、编程语言分类</h1><p>分为解析型和编译型</p><table><thead><tr><th>编程语言分类</th><th>说明</th></tr></thead><tbody><tr><td>解析型：直接解析类</td><td>shell，python，php， 书写的代码，可以通过对应的解释器直接运行。</td></tr><tr><td>编译型：需要编译后运行</td><td>C，C++，Java(maven)，Golang. 下载好源代码，必须要进行编译生成可以运行的命令。</td></tr></tbody></table><h1 id="四、Shell编程环境准备"><a href="#四、Shell编程环境准备" class="headerlink" title="四、Shell编程环境准备"></a>四、Shell编程环境准备</h1><h2 id="4-1-主机环境"><a href="#4-1-主机环境" class="headerlink" title="4.1 主机环境"></a>4.1 主机环境</h2><table><thead><tr><th>环境</th><th></th><th></th></tr></thead><tbody><tr><td>主机</td><td>m01 oldboy-devops-shell</td><td>10.0.0.61&#x2F;172.16.1.61</td></tr><tr><td>代码目录</td><td>&#x2F;server&#x2F;scripts&#x2F;devops-shell&#x2F;</td><td></td></tr><tr><td>编程环境</td><td>vim&#x2F;sublime…..&#x2F;编程环境IDE</td><td>这里选择VIM或sublime即可。</td></tr><tr><td>vim配置</td><td>自动添加说明信息</td><td>创建.sh或.bash，自动添加信息</td></tr></tbody></table><h2 id="4-2-vim设置"><a href="#4-2-vim设置" class="headerlink" title="4.2 vim设置"></a>4.2 vim设置</h2><p>通过vimrc文件，达到控制vim创建、编辑文件的动作</p><p>修改当前用户：~&#x2F;.vimrc</p><p>修改所有用户：&#x2F;etc&#x2F;vimrc</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 加到文件最后面&quot;添加设置&quot;set ignorecase  autocmd BufNewFile *.py,*.cc,*.sh,*.java exec &quot;:call SetTitle()&quot;func SetTitle()if expand(&quot;%:e&quot;) &#x3D;&#x3D; &#39;sh&#39;  call setline(1, &quot;#!&#x2F;bin&#x2F;bash&quot;)  call setline(2,&quot;##############################################################&quot;)  call setline(3, &quot;# File Name:&quot;.expand(&quot;%&quot;))  call setline(4, &quot;# Version:V1.0&quot;)  call setline(5, &quot;# Author:Haris Gong&quot;)  call setline(6, &quot;# Organization:gsproj.github.io&quot;)  call setline(7, &quot;# Desc:&quot;)  call setline(8,&quot;##############################################################&quot;)endifendfunc</code></pre></div></figure><p>实现效果：编辑文件的时候会自动加上头部信息</p><p><img src="/../../../img/image-20240515193051950.png" alt="image-20240515193051950"></p><h1 id="五、Shell脚本的执行方式"><a href="#五、Shell脚本的执行方式" class="headerlink" title="五、Shell脚本的执行方式"></a>五、Shell脚本的执行方式</h1><p>分为四种方式：</p><ul><li>通过sh或bash<ul><li>最常用</li></ul></li><li>通过<code>.</code>或者source<ul><li>常用于加载&#x2F;生效配置文件、环境变量</li><li>可以实现include的功能，把其他脚本引入到当前脚本中</li></ul></li><li>通过相对&#x2F;绝对路径<ul><li>需要需要加上执行权限才能用</li></ul></li><li>输入重定向符号，如<code>sh &lt;01.show-v3.sh  </code><ul><li>不推荐使用</li></ul></li></ul><blockquote><p>补充：<code>#!</code>符号的含义</p><p>并非注释的意思，写在脚本开头，用于指定脚本默认的命令解释器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;# 默认bash解释器&gt;#!&#x2F;bin&#x2F;bash&gt;# 默认python解释器&gt;#!&#x2F;usr&#x2F;bin&#x2F;python2 或 #!&#x2F;usr&#x2F;bin&#x2F;env python2</code></pre></div></figure></blockquote><h1 id="六、Shell变量（重要）"><a href="#六、Shell变量（重要）" class="headerlink" title="六、Shell变量（重要）"></a>六、Shell变量（重要）</h1><h2 id="6-1-变量分类"><a href="#6-1-变量分类" class="headerlink" title="6.1 变量分类"></a>6.1 变量分类</h2><p>shell变量分为三种：</p><table><thead><tr><th>分类</th><th>说明</th><th>要求</th></tr></thead><tbody><tr><td>普通变量 (局部变量)</td><td>我们在脚本中通过 <code>oldboy=xxxx </code>形式创建就是普通变量.</td><td>常用,必会.</td></tr><tr><td>环境变量（全局变量）</td><td>一般都是系统创建,PATH,PS1…</td><td>掌握几个常用的环境变量及含义</td></tr><tr><td>特殊变量 ⭐⭐⭐</td><td>shell脚本,命令,各种方面.</td><td>shell编程核心</td></tr></tbody></table><h3 id="6-1-1-普通变量"><a href="#6-1-1-普通变量" class="headerlink" title="6.1.1 普通变量"></a>6.1.1 普通变量</h3><p>定义和使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 定义普通变量day&#x3D;sat# 使用echo $&#123;day&#125;# 输出satecho $day# 输出sat</code></pre></div></figure><blockquote><p>提示：</p><p><code>$</code>与<code>$&#123;&#125;</code>一致,可以用于取值  </p></blockquote><h3 id="6-1-2-环境变量"><a href="#6-1-2-环境变量" class="headerlink" title="6.1.2 环境变量"></a>6.1.2 环境变量</h3><p>环境变量的特性：</p><ul><li>是全局变量</li><li>大部分是系统定义的，我们一般就是修改</li></ul><h4 id="1）查看环境变量的三个命令"><a href="#1）查看环境变量的三个命令" class="headerlink" title="1）查看环境变量的三个命令"></a>1）查看环境变量的三个命令</h4><ul><li>env</li><li>export</li><li>declare</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如：[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#envXDG_SESSION_ID&#x3D;1HOSTNAME&#x3D;mn01SELINUX_ROLE_REQUESTED&#x3D;TERM&#x3D;xtermSHELL&#x3D;&#x2F;bin&#x2F;bashHISTSIZE&#x3D;1000SSH_CLIENT&#x3D;10.0.0.1 53251 22SELINUX_USE_CURRENT_RANGE&#x3D;SSH_TTY&#x3D;&#x2F;dev&#x2F;pts&#x2F;0USER&#x3D;root</code></pre></div></figure><h4 id="2）常用环境变量"><a href="#2）常用环境变量" class="headerlink" title="2）常用环境变量"></a>2）常用环境变量</h4><table><thead><tr><th>环境变量名字</th><th>重要程 度</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>PATH</td><td>5</td><td>记录命令位置的环境变量,运行命令的时候bash会在PATH的 路径中查找</td><td>通过二进制包或编译安装软件, 增加新的命令路径</td></tr><tr><td>LANG</td><td>5</td><td>※※※※※ 系统语言与字符集 Language 中文 LANG&#x3D;zh_CN.UTF8 LANG&#x3D;en_US.UTF8</td><td>修改语言字符集</td></tr><tr><td>PS1</td><td>2</td><td>※※ 命令行格式</td><td>修改命令行格式,生产环境不推 荐修改.</td></tr><tr><td>UID或EUID</td><td>1</td><td>用户的uid,用于判断当前用户是否为root</td><td>用于脚本判断用户是否root.</td></tr><tr><td>HOSTNAME</td><td>1</td><td>主机名</td><td></td></tr><tr><td>HISTSIZE</td><td>❤❤</td><td>※ history 命令记录最多多条指令, 生产环境尽量少</td><td>未来安全优化配置</td></tr><tr><td>HISTFILESIZE</td><td>❤❤</td><td>※ history 历史记录文件的大小 ~&#x2F;.bash_history 生 产环境尽量少</td><td>未来安全优化配置</td></tr><tr><td>HISTCONTROL</td><td>❤❤</td><td>※ 控制历史命令记录或不记录哪些内容 生产环境 ignorespace 以空格开头的命令 不记录</td><td>未来安全优化配置</td></tr><tr><td>HISTFILE</td><td>❤❤</td><td>※ 指定历史命令的记录文件的名字和位置.默认当前用户家目 录 .bash_history</td><td>未来安全优化配置 或 手写跳 板机&#x2F;行为审计</td></tr><tr><td>PROMPT_COMMAND</td><td>❤❤</td><td>存放命令,命令行执行命令后会运行这个变量的内容,用于实现 行为审计(记录用户操作)</td><td>手写跳板机&#x2F;行为审计</td></tr><tr><td>IFS</td><td>类似于awk -F 指定分隔符(指定每一列的分隔符)</td><td>一般与循环配合读取文件内容</td><td></td></tr><tr><td>TMOUT</td><td>❤❤</td><td>超时自动退出时间</td><td>未来安全优化配置</td></tr></tbody></table><h4 id="3）修改环境变量"><a href="#3）修改环境变量" class="headerlink" title="3）修改环境变量"></a>3）修改环境变量</h4><p>案例：把当前系统语言改为中文，字符集改为UTF-8</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改环境变量export LANG&#x3D;zh_CN.UTF-8# 永久的就是写入到 &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile# 查看是否修改env |grep LANGLANG&#x3D;zh_CN.UTF-8</code></pre></div></figure><h4 id="4）环境变量相关文件及目录"><a href="#4）环境变量相关文件及目录" class="headerlink" title="4）环境变量相关文件及目录"></a>4）环境变量相关文件及目录</h4><table><thead><tr><th>文件或目录</th><th>应用场景</th><th></th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;profile</td><td>全局生效(国法) 存放函数，环境变量。存放别名</td><td></td></tr><tr><td>&#x2F;etc&#x2F;bashrc</td><td>全局生效(国法) 存放别名。</td><td></td></tr><tr><td>~&#x2F;.bashrc</td><td>家规（局部生效）</td><td></td></tr><tr><td>~&#x2F;.bash_profile</td><td>家规（局部生效）</td><td></td></tr><tr><td>&#x2F;etc&#x2F;profile.d&#x2F;</td><td>目录，每个用户登录的时候（远程连接与su切换），加载目录下面.sh结尾 的文件.</td><td>设置一些登录登录后提示,变 化</td></tr></tbody></table><h4 id="5）案例"><a href="#5）案例" class="headerlink" title="5）案例"></a>5）案例</h4><p>书写脚本，每次用户登录后显示系统的基本信息</p><p>要求显示的内容与格式：</p><ul><li>主机名:m01-shell</li><li>ip地址:10.0.0.61 172.16.1.61</li><li>总计内存:1.9G</li><li>可用内存:1.5G</li><li>系统负载:0.32, 0.23, 0.25</li></ul><p>获取指标的命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">主机名: hostnameip地址: hostname -I内存总数：free -h |awk &#39;NR&#x3D;&#x3D;2&#123;print $2&#125;&#39;可用内存: free -h |awk &#39;NR&#x3D;&#x3D;2&#123;print $NF&#125;&#39;系统负载：uptime |sed &#39;s#^.*age: ##g&#39;系统负载：uptime |awk &#39;&#123;print $(NF-2),$(NF-1),$NF&#125;&#39;</code></pre></div></figure><p>脚本实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:02_sys_login_info.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 用户登录系统后显示的基本信息##############################################################sys_hostname&#x3D;&#96;hostname&#96;sys_ip_addrs&#x3D;&#96;hostname -I&#96;sys_mem_total&#x3D;&#96;free -h | awk &#39;NR&#x3D;&#x3D;2&#123;print $2&#125;&#39;&#96;sys_mem_free&#x3D;&#96;free -h | awk &#39;NR&#x3D;&#x3D;2&#123;print $NF&#125;&#39;&#96;sys_load&#x3D;&#96;uptime | awk &#39;&#123;print $(NF-2),$(NF-1),$NF&#125;&#39;&#96;cat &lt;&lt;EOF主机名：$sys_hostnameip地址：$sys_ip_addrs总内存：$sys_mem_total可用内存：$sys_mem_free系统负载：$sys_loadEOF</code></pre></div></figure><p>自动执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 软连接ln -s &#x2F;server&#x2F;scripts&#x2F;devops-shell&#x2F;02_sys_login_info.sh  &#x2F;etc&#x2F;profile.d&#x2F;02_sys_login_info.sh# 增加执行权限chmod +x .&#x2F;02_sys_login_info.sh</code></pre></div></figure><p>测试重新登录</p><p><img src="/../../../img/image-20240516104057984.png" alt="image-20240516104057984"></p><blockquote><p>提示：脚本的小bug:希望只有登录后提示，切换用户的时候不要提示。  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;# 判断两个变量是否存在即可,存在表示远程登录.不存在就切换用户&gt;SSH_CLIENT&#x3D;10.0.0.1 3399 22&gt;SSH_TTY&#x3D;&#x2F;dev&#x2F;pts&#x2F;0</code></pre></div></figure></blockquote><h4 id="6）环境变量文件的加载顺序"><a href="#6）环境变量文件的加载顺序" class="headerlink" title="6）环境变量文件的加载顺序"></a>6）环境变量文件的加载顺序</h4><p><img src="/../../../img/image-20240516105105049.png" alt="image-20240516105105049"></p><h3 id="6-1-3-特殊变量"><a href="#6-1-3-特殊变量" class="headerlink" title="6.1.3 特殊变量"></a>6.1.3 特殊变量</h3><p>linux shell编程中有各种各样的特殊变量,方便对参数,命令结果,进行判断与对比</p><ul><li>位置相关的特殊变量：重要</li><li>状态相关的特殊变量：重要</li><li>变量子串</li><li>变量扩展</li></ul><h4 id="6-1-3-4-特殊变量-位置变量"><a href="#6-1-3-4-特殊变量-位置变量" class="headerlink" title="6.1.3.4 特殊变量-位置变量"></a>6.1.3.4 特殊变量-位置变量</h4><table><thead><tr><th>位置的特殊变量</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>$n(数字)</td><td>脚本的第n个参数</td><td>命令行与脚本内部桥梁.</td></tr><tr><td>$0</td><td>脚本的名字</td><td>用于输出脚本的格式或帮助的时候。用于错误提示输出帮 助。</td></tr><tr><td>$#</td><td>脚本参数的个数</td><td>一般与判断结合，检查脚本参数个数。</td></tr><tr><td>$@</td><td>取出脚本所有参数 ($1,$2,$3,$4….$n)。</td><td>数组中或循环中。</td></tr><tr><td>$*</td><td>取出脚本所有参数 ($1,$2,$3,$4….$n)。</td><td>数组中或循环中。</td></tr></tbody></table><p>如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:03_post_param.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 位置变量基本使用##############################################################echo &quot;脚本名是：$0&quot;echo &quot;总共有$#个参数&quot;echo &quot;第一个参数是：$1&quot;echo &quot;第二个参数是：$2&quot;echo &quot;第三个参数是：$3&quot;# 循环输出for i in $*# 或者$@doecho $idone</code></pre></div></figure><p>执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 03_post_param.sh aa bb cc脚本名是：03_post_param.sh总共有3个参数第一个参数是：aa第二个参数是：bb第三个参数是：ccaabbcc</code></pre></div></figure><h5 id="1）案例01-查询用户"><a href="#1）案例01-查询用户" class="headerlink" title="1）案例01-查询用户"></a>1）案例01-查询用户</h5><p>执行脚本，输入用户名，判断用户是否存在</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:04_check_user.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc: 检查用户是否存在 bash 04_check_user.sh username##############################################################if (( $# &#x3D;&#x3D; 0 ));then  echo &quot;Error! 请输出参数&quot;  exitfiecho &quot;正在查询用户...&quot;id $1</code></pre></div></figure><p>执行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 04_check_user.shError! 请输出参数[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 04_check_user.sh gs正在查询用户...id: gs: no such user[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 04_check_user.sh root正在查询用户...uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</code></pre></div></figure><blockquote><p>注意：如果<code>$n &gt; 9</code>怎么办？</p><p>大于9后,<code>$10</code>会表示为<code>$1 + 0</code> 第1个参数+0</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;# 错误的用法&gt;$10 # 参数aa, 输出aa0&gt;# 正确的用法&gt;$&#123;10&#125;  # 获取第十个参数</code></pre></div></figure></blockquote><h5 id="2）案例02-和-的区别"><a href="#2）案例02-和-的区别" class="headerlink" title="2）案例02-$*和$@的区别"></a>2）案例02-<code>$*</code>和<code>$@</code>的区别</h5><table><thead><tr><th>符号</th><th>共同点</th><th>区别</th></tr></thead><tbody><tr><td>$@</td><td>取出脚本所有的参数</td><td>加上双引号，识别为独立参数</td></tr><tr><td>$*</td><td>取出脚本所有的参数</td><td>加上双引号，所有参数合并为1个参数</td></tr></tbody></table><p>演示结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#set &quot;test&quot; aa bb cc[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#for i in &quot;$@&quot;; do echo $i; donetestaabbcc[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#for i in &quot;$*&quot;; do echo $i; donetest aa bb cc</code></pre></div></figure><h5 id="3）位置变量小结"><a href="#3）位置变量小结" class="headerlink" title="3）位置变量小结"></a>3）位置变量小结</h5><table><thead><tr><th>位置的特殊变量</th><th>重要</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>$n(数字)</td><td>❤❤❤❤❤</td><td>脚本的第n个参数</td><td>使用最多,命令行与脚本内部桥梁.</td></tr><tr><td>$0</td><td>❤❤❤❤</td><td>脚本的名字</td><td>用于输出脚本的格式或帮助的时候。用于错误提示输出帮助。</td></tr><tr><td>$#</td><td>❤</td><td>脚本参数的个数</td><td>一般与判断结合，检查脚本参数个数。</td></tr><tr><td>$@</td><td>❤</td><td>取出脚本所有参数。</td><td>数组中或循环中</td></tr><tr><td>$*</td><td>❤</td><td>取出脚本所有参数。</td><td>数组中或循环中</td></tr></tbody></table><h4 id="6-1-3-5-特殊变量-状态变量"><a href="#6-1-3-5-特殊变量-状态变量" class="headerlink" title="6.1.3.5 特殊变量-状态变量"></a>6.1.3.5 特殊变量-状态变量</h4><table><thead><tr><th>状态的特 殊符号</th><th>重要</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>$?</td><td>❤❤❤ ❤❤</td><td>上一个命令、脚本的返回值，0表示正确，非0即错误.</td><td>一般与判断检查命令</td></tr><tr><td>$$</td><td></td><td>当前脚本的pid</td><td>一般写在脚本中获取 脚本pid</td></tr><tr><td>$!</td><td></td><td>上一个脚本&#x2F;命令（持续运行）的pid</td><td></td></tr><tr><td>$_</td><td></td><td>上一个命令的最后一参数，其实下划线是个环境变量，记录了上一个命令、脚本的 最后一个参数. 使用esc+ .(点)</td><td></td></tr></tbody></table><p>如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 执行命令[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo &quot;123456&quot;123456# 判断执行成功返回0[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $?0# 判断执行不成功，返回非0[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#eeds &quot;123456&quot;-bash: eeds: command not found[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $?127</code></pre></div></figure><h4 id="6-1-3-6-特殊变量-变量子串"><a href="#6-1-3-6-特殊变量-变量子串" class="headerlink" title="6.1.3.6 特殊变量-变量子串"></a>6.1.3.6 特殊变量-变量子串</h4><p>作用：</p><ul><li>用于对变量处理</li><li>统计变量中字符串数量，对变量内容进行替换，删除。。</li></ul><p>应用：可以不用,如果使用效率高，格局打开  </p><table><thead><tr><th>变量子串 parameter表示变量名字</th><th>含义</th></tr></thead><tbody><tr><td><strong>基础</strong></td><td></td></tr><tr><td><code>$&#123;parameter&#125; $para</code></td><td>变量取值</td></tr><tr><td><code>$&#123;#parameter&#125;</code></td><td>统计字符长度（变量中有多少个字符）</td></tr><tr><td><strong>删除（开头，结尾）</strong></td><td>word表示要删除的内容</td></tr><tr><td><code>$&#123;parameter#word&#125;</code></td><td>从变量左边开始删除，按照最短匹配删除</td></tr><tr><td><code>$&#123;parameter##word&#125;</code></td><td>从变量左边开始删除，按照最长匹配删除</td></tr><tr><td><code>$&#123;parameter%word&#125;</code></td><td>从变量右边开始删除，按照最短匹配删除</td></tr><tr><td><code>$&#123;parameter%%word&#125;</code></td><td>从变量右边开始删除，按照最长匹配删除</td></tr><tr><td><strong>截取（切片) 类似于 cut -c</strong></td><td></td></tr><tr><td><code>$&#123;var:5&#125;</code></td><td>截取从下标5开始往后的字符</td></tr><tr><td><code>$&#123;var:5:2&#125;</code></td><td>从下标是5字符开始向后截取2个字符</td></tr><tr><td><strong>替换 阉割版的sed</strong></td><td></td></tr><tr><td><code>$&#123;para/word/replace&#125;</code></td><td>把word替换为replace 仅替换第1个</td></tr><tr><td><code>$&#123;para/word/replace&#125;</code></td><td>把word替换为replace 替换全部</td></tr></tbody></table><h5 id="1）统计字符串长度"><a href="#1）统计字符串长度" class="headerlink" title="1）统计字符串长度"></a>1）统计字符串长度</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#str&#x3D;&quot;good morning&quot;[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;#str&#125;12</code></pre></div></figure><h5 id="2）删除变量中的内容（仅影响输出）"><a href="#2）删除变量中的内容（仅影响输出）" class="headerlink" title="2）删除变量中的内容（仅影响输出）"></a>2）删除变量中的内容（仅影响输出）</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#str&#x3D;&quot;helloworld&quot;[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str#he&#125;lloworld[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str#ow&#125;helloworld[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str#o&#125;helloworld[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str#hello&#125;world[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str#*o&#125;world[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str##*o&#125;rld[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str#*l&#125;loworld[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;str##*l&#125;d</code></pre></div></figure><p>巧用，取文件名和路径名</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#dir&#x3D;&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33# 取文件名[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;dir##*&#x2F;&#125;ifcfg-ens33# 取路径名[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;dir%&#x2F;*&#125;&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts</code></pre></div></figure><blockquote><p>提示：</p><p>也可用dirname和basename命令来获取</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#dirname $dir&gt;&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&gt;[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#basename $dir&gt;ifcfg-ens33</code></pre></div></figure></blockquote><h5 id="3）截取（切片）"><a href="#3）截取（切片）" class="headerlink" title="3）截取（切片）"></a>3）截取（切片）</h5><table><thead><tr><th>var&#x3D;oldboy拆分</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>切片的时候，每个字符都有个位置，从0开始</td><td>o</td><td>l</td><td>d</td><td>b</td><td>o</td><td>y</td></tr><tr><td></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var&#x3D;oldboyecho $&#123;var:3&#125;# 3、4、5boyecho $&#123;var:3:2&#125;# 截取3、4bo</code></pre></div></figure><h5 id="4）替换"><a href="#4）替换" class="headerlink" title="4）替换"></a>4）替换</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#var&#x3D;oldboylidao996# &#x2F;替换一个[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;var&#x2F;o&#x2F;-&#125;-ldboylidao996# &#x2F;&#x2F;替换全部[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#echo $&#123;var&#x2F;&#x2F;o&#x2F;-&#125;-ldb-ylida-996</code></pre></div></figure><h5 id="5）案例-面试题"><a href="#5）案例-面试题" class="headerlink" title="5）案例-面试题"></a>5）案例-面试题</h5><p>I am oldboy teacher welcome to oldboy training class.</p><p>要求：bash for 循环打印这句话中字母书不大于6的单词  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash############################################################### File Name:05_count_word.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################str&#x3D;&quot;I am oldboy teacher welcome to oldboy training class.&quot;# 去掉.号str_del&#x3D;&#96;echo $str | sed &#39;s#\.##g&#39;&#96;# 循环for word in $&#123;str_del&#125;do  if [ $&#123;#word&#125; -le 6 ]; then    echo &quot;单词字符&lt;&#x3D;6: $&#123;word&#125;&quot;  fidone</code></pre></div></figure><p>执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 05_count_word.sh单词字符&lt;&#x3D;6: I单词字符&lt;&#x3D;6: am单词字符&lt;&#x3D;6: oldboy单词字符&lt;&#x3D;6: to单词字符&lt;&#x3D;6: oldboy单词字符&lt;&#x3D;6: class</code></pre></div></figure><blockquote><p>if各种判断条件：</p><p># eq 等于<br># ne 不等于<br># lt less than 小于<br># le less equal  小于等于<br># gt great than 大于<br># ge great equal 大于等于 </p></blockquote><p>改用awk实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db02[ &#x2F;]#echo $str | sed &#39;s#\.##g&#39; | xargs -n1 | awk -F &quot;[ .]&quot; &#39;length($1) &lt;&#x3D; 6&#39;Iamoldboytooldboyclass# 或者[root@db02[ &#x2F;]#echo $str | awk -F&quot;[ .]&quot; -vRS&#x3D;&quot;[ .]&quot; &#39;length()&lt;&#x3D;6&#39;Iamoldboytooldboyclass</code></pre></div></figure><h4 id="6-1-3-7-特殊变量-变量扩展（设置默认值）"><a href="#6-1-3-7-特殊变量-变量扩展（设置默认值）" class="headerlink" title="6.1.3.7 特殊变量-变量扩展（设置默认值）"></a>6.1.3.7 特殊变量-变量扩展（设置默认值）</h4><p>给变量设置默认值</p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td><code>$&#123;parameter:-word&#125;</code></td><td>变量parameter没定义或为空，把word作为默认值,不修改变量内容（仅输出）</td></tr><tr><td><code>$&#123;parameter:=word&#125;</code></td><td>变量parameter没定义或为空，把word作为默认值，修改变量内容</td></tr><tr><td><code>$&#123;parameter:?word&#125;</code></td><td>变量parameter没定义或为空，显示word,错误输出</td></tr><tr><td><code>$&#123;parameter:+word&#125;</code></td><td>变量parameter没定义或为空，则啥也不做，如有内容则把word替换变量内容（仅输出）</td></tr></tbody></table><p>实验：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 没定义，没赋值[root@mn01[ &#x2F;]#echo $name# 默认值，仅输出[root@mn01[ &#x2F;]#echo $&#123;name:-xiaoming&#125;xiaoming# 变量值未改[root@mn01[ &#x2F;]#echo $name# 默认值，错误输出[root@mn01[ &#x2F;]#echo $&#123;name:?xiaohuang&#125;-bash: name: xiaohuang# 默认值，赋值，并输出[root@mn01[ &#x2F;]#echo $&#123;name:&#x3D;xiaohuang&#125;xiaohuang# 变量值已修改[root@mn01[ &#x2F;]#echo $namexiaohuang# 有变量值，则改为默认值，仅输出[root@mn01[ &#x2F;]#echo $&#123;name:+test&#125;test# 变量值未改[root@mn01[ &#x2F;]#echo $namexiaohuang</code></pre></div></figure><h4 id="6-1-3-8-特殊变量小节"><a href="#6-1-3-8-特殊变量小节" class="headerlink" title="6.1.3.8 特殊变量小节"></a>6.1.3.8 特殊变量小节</h4><p>为了shell编程增光添彩，整体要认识。  </p><table><thead><tr><th>常用特殊变量</th><th>必会</th><th>了解</th></tr></thead><tbody><tr><td>位置变量</td><td>$n $0 $#</td><td>$@ $*</td></tr><tr><td>状态变量</td><td>$?</td><td>$$ $_ $!</td></tr><tr><td>变量子串</td><td>统计字符长度：<code>$&#123;#parameter&#125;</code> <br>替换字符：<code>$&#123;para/lidao/oldboy&#125;</code></td><td>除了前面的 <code>$&#123;para#xxx&#125;</code></td></tr><tr><td>变量扩展（变量默认值）</td><td>无</td><td><code>$&#123;para:-word&#125;</code></td></tr></tbody></table><h2 id="6-2-变量赋值"><a href="#6-2-变量赋值" class="headerlink" title="6.2 变量赋值"></a>6.2 变量赋值</h2><h3 id="6-2-1-变量赋值语句"><a href="#6-2-1-变量赋值语句" class="headerlink" title="6.2.1 变量赋值语句"></a>6.2.1 变量赋值语句</h3><p>向变量中写入内容。  </p><table><thead><tr><th>赋值方法</th><th>格式</th><th>应用场景</th></tr></thead><tbody><tr><td>直接赋值</td><td>oldboy&#x3D;lidao996</td><td>大部分时候使用</td></tr><tr><td>命令结果赋值</td><td>hostname&#x3D;&#96;&#96;</td><td>获取命令的结果 &#96;&#96; 或$()</td></tr><tr><td>脚本传参(通过脚本命令行传参进行赋 值)</td><td>user_name&#x3D;$1 脚本的第1个参 数</td><td>一般用于命令行内容传入脚本中. 不想设置太多交 互.</td></tr><tr><td>read交互式赋值</td><td>通过read命令实现</td><td>与用户有个交互过程.</td></tr><tr><td>读取文件内容赋值给变量</td><td>未来循环中说</td><td>脚本读取文件的时候使用.</td></tr></tbody></table><h4 id="1）通过read方式获取"><a href="#1）通过read方式获取" class="headerlink" title="1）通过read方式获取"></a>1）通过read方式获取</h4><table><thead><tr><th>read通过交互式的方式进行赋值</th><th></th></tr></thead><tbody><tr><td>-p</td><td>交互的时候提示信息。</td></tr><tr><td>-t</td><td>超过这个时间没有操作，则自动退出.</td></tr><tr><td>-s</td><td>不显示用户的输入.记录密码才用.</td></tr></tbody></table><p>实验：</p><p>基本用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#read -p &quot;请输入密码: &quot; pass请输入密码: 34567[root@mn01[ &#x2F;]#echo $pass34567</code></pre></div></figure><p>不显示用户输入</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#read -s -p &quot;请输入密码: &quot; pass请输入密码: [root@mn01[ &#x2F;]#echo $pass123456</code></pre></div></figure><p>同时两个变量赋值</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;]#read -p &quot;请输入两个参数: &quot; num1 num2请输入两个参数: koko1 koko2[root@mn01[ &#x2F;]#echo $num1 $num2koko1 koko2</code></pre></div></figure><h4 id="2）案例"><a href="#2）案例" class="headerlink" title="2）案例"></a>2）案例</h4><p>用户输入一个字符串，然后进行显示</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#cat 06_show_pass.sh#!&#x2F;bin&#x2F;bash############################################################### File Name:06_show_pass.sh# Version:V1.0# Author:Haris Gong# Organization:gsproj.github.io# Desc:##############################################################read -s -p &quot;请输入密码:&quot; passpass_rev&#x3D;&#96;echo $pass |rev&#96;echo &quot;正在猜测你的密码.....&quot;echo &quot;马上破解成功&quot;echo &quot;$pass_rev&quot;</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;devops-shell]#bash 06_show_pass.sh请输入密码:正在猜测你的密码.....马上破解成功987654# 输入的456789，反转了</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络-ACL</title>
    <link href="/2024/05/13/08_%E7%BD%91%E7%BB%9C/ACL/"/>
    <url>/2024/05/13/08_%E7%BD%91%E7%BB%9C/ACL/</url>
    
    <content type="html"><![CDATA[<h1 id="ACL-访问控制列表"><a href="#ACL-访问控制列表" class="headerlink" title="ACL 访问控制列表"></a>ACL 访问控制列表</h1><h1 id="一、作用："><a href="#一、作用：" class="headerlink" title="一、作用："></a>一、作用：</h1><p>允许或拒绝某些流量来访问或者经过我</p><p>过滤+抓取路由</p><h1 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h1><p> 1.标准的ACL</p><p>2.扩展的ACL</p><p>3.命名的ACL</p><p>4.基于时间的ACL</p><h1 id="三、详解"><a href="#三、详解" class="headerlink" title="三、详解"></a>三、详解</h1><p>标准的ACL</p><ul><li>编号为：1-99、1300-1999</li><li>只检测源IP地址</li><li>尽量靠近目标</li><li>默认有一条拒绝所有</li></ul><p>扩展的ACL</p><ul><li><p>编号为：100-199，2000-2699</p></li><li><p>检查SIP（源IP）、DIP（目标IP）、SP（源端口）、DP（目的端口）、协议号（如ICMP）</p></li><li><p>尽量靠近源目标</p></li><li><p>默认拒绝所有</p></li></ul><p>命名的ACL</p><ul><li>标准&#x2F;扩展ACL有个致命的缺点 1000条删掉其中一条，其余999条也没了</li><li>命名的ACL的好处，删掉一条就一条，其余不动</li></ul><p>基于时间的ACL</p><ul><li>限定几点到几点可以上网</li></ul><h1 id="四、实验拓扑"><a href="#四、实验拓扑" class="headerlink" title="四、实验拓扑"></a>四、实验拓扑</h1><p>拓扑图：</p><h1 id="五、配置命令"><a href="#五、配置命令" class="headerlink" title="五、配置命令"></a><img src="/../../img/clip_image002-1715574276005.jpg" alt="img">五、配置命令</h1><h2 id="5-1-常规配置："><a href="#5-1-常规配置：" class="headerlink" title="5.1 常规配置："></a>5.1 常规配置：</h2><p>PC1配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PC1(config)#no ip routing &#x2F;&#x2F;关闭PC路由功能PC1(config)#int f0&#x2F;0 PC1(config-if)#ip add 192.168.1.1 255.255.255.0 &#x2F;&#x2F;配置端口IP地址和子网掩码PC1(config-if)#no shu &#x2F;&#x2F;端口不关闭PC1(config-if)#exit</code></pre></div></figure><p>PC2配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PC2(config)#no ip routingPC2(config)#int f0&#x2F;0PC2(config-if)#ip add 192.168.2.1 255.255.255.0PC2(config-if)#no shuPC2(config-if)#exit</code></pre></div></figure><p>SW1配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SW1(config)#int f0&#x2F;0SW1(config-if)#no switchport &#x2F;&#x2F;关闭交换机功能，思科私有SW1(config-if)#ip add 172.16.1.2 255.255.255.0 &#x2F;&#x2F;配置IP地址和子网掩码SW1(config-if)#no shuSW1(config-if)#endSW1#vlan database &#x2F;&#x2F;进入配置vlanSW1(vlan)#vlan 10  SW1(vlan)#vlan 20 &#x2F;&#x2F;划分vlanSW1(vlan)#exitSW1(config)#int f0&#x2F;1SW1(config-if)#switchport mode access SW1(config-if)#switchport access vlan 10 &#x2F;&#x2F;将f0&#x2F;1分入vlan10SW1(config-if)#exitSW1(config)#int f0&#x2F;2SW1(config-if)#switchport mode access SW1(config-if)#switchport access vlan 20 &#x2F;&#x2F;将f0&#x2F;2分入vlan20SW1(config-if)#exitSW1(config)#int vlan 10SW1(config-if)#ip add 192.168.1.254 255.255.255.0 &#x2F;&#x2F;配置vlan10 网关SW1(config-if)#no shuSW1(config-if)#exitSW1(config)#int vlan 20SW1(config-if)#ip add 192.168.2.254 255.255.255.0 &#x2F;&#x2F;配置vlan20 网关SW1(config-if)#no shuSW1(config-if)#exitSW1(config)#ip route 0.0.0.0 0.0.0.0 172.16.1.1 &#x2F;&#x2F;实现路由</code></pre></div></figure><p>R1配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">R1(config)#int f1&#x2F;0R1(config-if)#ip add 12.1.1.1 255.255.255.0R1(config-if)#no shR1(config-if)#exitR1(config)#int f0&#x2F;0R1(config-if)#ip add 172.16.1.1 255.255.255.0R1(config-if)#no shuR1(config-if)#exitR1(config)#ip route 4.4.4.0 255.255.255.0 12.1.1.2R1(config)#ip route 192.168.1.0 255.255.255.0 172.16.1.2R1(config)#ip route 192.168.2.0 255.255.255.0 172.16.1.2 &#x2F;&#x2F;实现路由R1(config)#line vty 0 4 &#x2F;&#x2F;配置端口0-4R1(config-line)#privilege level 15 &#x2F;&#x2F;允许最高等级R1(config-line)#no login &#x2F;&#x2F;不用登录R1(config-line)#exit</code></pre></div></figure><p>R4配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">R4(config)#int f0&#x2F;0R4(config-if)#ip add 12.1.1.2 255.255.255.0R4(config-if)#no shuR4(config)#int loo0R4(config-if)#ip add 4.4.4.4 255.255.255.0R4(config-if)#no shuR4(config-if)#exitR4(config)#ip route 0.0.0.0 0.0.0.0 12.1.1.1R4(config)#line vty 0 4 &#x2F;&#x2F;配置端口0-4R4(config-line)#privilege level 15 &#x2F;允许最高等级R4(config-line)#no login &#x2F;不用登录</code></pre></div></figure><h2 id="5-2-标准ACL配置："><a href="#5-2-标准ACL配置：" class="headerlink" title="5.2 标准ACL配置："></a>5.2 标准ACL配置：</h2><p>（以禁止PC1【192.168.1.1】连接R4为例）</p><p>效果：pc1 ping R4的12.1.1.2和4.4.4.4不通，pc2能通</p><p>R4配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">R4(config)#access-list 10 deny 192.168.1.1 &#x2F;&#x2F;ACL 10 拒绝192.168.1.1R4(config)#access-list 10 permit any &#x2F;&#x2F;允许所有R4(config)#int f0&#x2F;0R4(config-if)#ip access-group 10 in &#x2F;&#x2F;为端口配置ACL</code></pre></div></figure><h2 id="5-3-扩展型ACL"><a href="#5-3-扩展型ACL" class="headerlink" title="5.3 扩展型ACL"></a>5.3 扩展型ACL</h2><p>（以禁止PC2【192.168.2.1】访问R4的HTTP和TELNET服务为例）</p><p>效果：PC2仅能PING通R4，但是telnet R4会失败，PC1既能PING通，又能telnet控制</p><p>R1配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">R1(config)#access-list 100 deny tcp 192.168.2.0 0.0.0.255 host 12.1.1.2 eq 80R1(config)#access-list 100 deny tcp 192.168.2.0 0.0.0.255 host 12.1.1.2 eq 23R1(config)#access-list 100 deny tcp 192.168.2.0 0.0.0.255 host 4.4.4.4 eq 23 R1(config)#access-list 100 deny tcp 192.168.2.0 0.0.0.255 host 4.4.4.4 eq 80 &#x2F;&#x2F;ACL100拒绝tcp协议中的HTTP和TELNET服务R1(config)#access-list 100 permit ip any any &#x2F;&#x2F;允许所有R1(config)#int f1&#x2F;0R1(config-if)#ip access-group 100 out &#x2F;&#x2F;为端口配置上ACL100</code></pre></div></figure><h2 id="5-4-命名的ACL"><a href="#5-4-命名的ACL" class="headerlink" title="5.4 命名的ACL"></a>5.4 命名的ACL</h2><p>（将上面两种实验用命名的ACL再做一次）</p><h3 id="5-4-1-命名的-标准ACL配置"><a href="#5-4-1-命名的-标准ACL配置" class="headerlink" title="5.4.1 命名的-标准ACL配置"></a>5.4.1 命名的-标准ACL配置</h3><p>【这好像是并不是标准ACL，不知道怎么做了】</p><p>R4配置命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">R4(config)#ip access-list extended gs &#x2F;&#x2F;命名ACL，并进入配置R4(config-ext-nacl)#deny ip 192.168.1.0 0.0.0.255 host 12.1.1.2 R4(config-ext-nacl)#permit ip any anyR4(config-ext-nacl)#exitR4(config)#int f0&#x2F;0R4(config-if)#ip access-group gs in &#x2F;&#x2F;为端口配置ACL，进来</code></pre></div></figure><h3 id="5-4-2-命名的-扩展ACL的配置"><a href="#5-4-2-命名的-扩展ACL的配置" class="headerlink" title="5.4.2 命名的-扩展ACL的配置"></a>5.4.2 命名的-扩展ACL的配置</h3><p>R1配置命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">R1(config)#ip access-list extended gs &#x2F;&#x2F;命名ACL，并进入配置R1(config-ext-nacl)#deny tcp 192.168.2.0 0.0.0.255 host 12.1.1.2 eq 80R1(config-ext-nacl)#deny tcp 192.168.2.0 0.0.0.255 host 12.1.1.2 eq 23R1(config-ext-nacl)#deny tcp 192.168.2.0 0.0.0.255 host 4.4.4.4 eq 23 R1(config-ext-nacl)#deny tcp 192.168.2.0 0.0.0.255 host 4.4.4.4 eq 80&#x2F;&#x2F;ACL100拒绝tcp协议中的HTTP和TELNET服务R1(config-ext-nacl)#permit ip any any &#x2F;&#x2F;允许所有R1(config-ext-nacl)#exitR1(config)#int f1&#x2F;0R1(config-if)#ip access-group gs out &#x2F;&#x2F;为端口配置ACL，出去R1(config-if)#exitR1(config)#end</code></pre></div></figure><h3 id="5-4-5-基于时间的ACL"><a href="#5-4-5-基于时间的ACL" class="headerlink" title="5.4.5 基于时间的ACL"></a>5.4.5 基于时间的ACL</h3><p>基于时间的（扩展ACL）</p><p>R1配置命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">R1(config)#time-range sj &#x2F;&#x2F;命名时间范围并进入设置R1(config-time-range)#periodic weekdays 8:00 to 18:00 &#x2F;&#x2F;配置工作日和时间点R1(config-time-range)#exitR1(config)#ip access-list extended gs R1(config)#access-list 100 permit ip any any time-range sj &#x2F;&#x2F;为ACL配置时间范围</code></pre></div></figure><h2 id="5-5-时间设置和查看"><a href="#5-5-时间设置和查看" class="headerlink" title="5.5 时间设置和查看"></a>5.5 时间设置和查看</h2><p>时间设置命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set clock</code></pre></div></figure><p>时间查看命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh clock</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-Web集群-Tomcat(二)</title>
    <link href="/2024/05/13/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/19-web%E9%9B%86%E7%BE%A4-Tomcat-2-%E5%AE%8C%E7%BB%93/"/>
    <url>/2024/05/13/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/19-web%E9%9B%86%E7%BE%A4-Tomcat-2-%E5%AE%8C%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Tomcat（二）完结"><a href="#Web集群-Tomcat（二）完结" class="headerlink" title="Web集群-Tomcat（二）完结"></a>Web集群-Tomcat（二）完结</h1><p>今日内容：</p><ul><li>JAVA故障案例</li><li>Tomcat前后端分析项目</li><li>Tomcat集群总结</li></ul><h1 id="一、Java故障案例"><a href="#一、Java故障案例" class="headerlink" title="一、Java故障案例"></a>一、Java故障案例</h1><h2 id="1-1-Java状态监控"><a href="#1-1-Java状态监控" class="headerlink" title="1.1 Java状态监控"></a>1.1 Java状态监控</h2><p>常用：jps、jstack、jmap</p><h3 id="1-1-1-监控命令"><a href="#1-1-1-监控命令" class="headerlink" title="1.1.1 监控命令"></a>1.1.1 监控命令</h3><h4 id="a）查看java进程–jps"><a href="#a）查看java进程–jps" class="headerlink" title="a）查看java进程–jps"></a>a）查看java进程–jps</h4><p>java ps 命令，只显示java进程.。类似于 ps -ef |grep java </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jps -lvm | grep tomcat-8081</code></pre></div></figure><h4 id="b）查看java进程信息–jstack"><a href="#b）查看java进程信息–jstack" class="headerlink" title="b）查看java进程信息–jstack"></a>b）查看java进程信息–jstack</h4><p>jstack查看java进程内部信息，线程信息。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先过滤出java进程的pidjps -lvm | grep java13476 org.apache.catalina.startup.Bootstrap...# 查看java进程的线程信息jstack 13476# 查看java线程状态jstack 1786 |grep -i state</code></pre></div></figure><p>进程状态分为：</p><ul><li>新建状态New；</li><li>就绪状态Runnable；</li><li>运行状态Running；</li><li>阻塞状态Blocked；</li><li>死亡状态Dead</li></ul><h4 id="c）查看jvm信息–jmap"><a href="#c）查看jvm信息–jmap" class="headerlink" title="c）查看jvm信息–jmap"></a>c）查看jvm信息–jmap</h4><p>jmap查看或导出jvm信息。</p><p>导出jvm内存使用使用情况</p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jmap -heap 13476</code></pre></div></figure><p>导出jvm内存镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat]#jmap -dump:format&#x3D;b,file&#x3D;8081.hprof 13476Dumping heap to &#x2F;app&#x2F;tools&#x2F;apache-tomcat-9.0.89&#x2F;8081.hprof ...Heap dump file created</code></pre></div></figure><blockquote><p>注意：生产环境该文件较大</p></blockquote><h4 id="d）mat分析工具"><a href="#d）mat分析工具" class="headerlink" title="d）mat分析工具"></a>d）mat分析工具</h4><p>用于分析jvm的内存映像文件的工具，全称MemoryAnalyzer Tool   </p><p>下载地址:<a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a>  </p><p>图示：</p><p><img src="/../../../img/image-20240515112657333.png" alt="image-20240515112657333"></p><h3 id="1-1-2-监控脚本"><a href="#1-1-2-监控脚本" class="headerlink" title="1.1.2 监控脚本"></a>1.1.2 监控脚本</h3><p><code>show-busy-java-thread.sh</code> 脚本：显示当前环境中，所有繁忙的java线程。 以百分数显示使用率最高的前几个线程.  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# @Function# Find out the highest cpu consumed threads of java, and print the stack of these threads.## @Usage#   $ .&#x2F;show-busy-java-threads.sh## @author Jerry Leereadonly PROG&#x3D;&#96;basename $0&#96;readonly -a COMMAND_LINE&#x3D;(&quot;$0&quot; &quot;$@&quot;)usage() &#123;    cat &lt;&lt;EOFUsage: $&#123;PROG&#125; [OPTION]...Find out the highest cpu consumed threads of java, and print the stack of these threads.Example: $&#123;PROG&#125; -c 10Options:    -p, --pid       find out the highest cpu consumed threads from the specifed java process,                    default from all java process.    -c, --count     set the thread count to show, default is 5    -h, --help      display this help and exitEOF    exit $1&#125;readonly ARGS&#x3D;&#96;getopt -n &quot;$PROG&quot; -a -o c:p:h -l count:,pid:,help -- &quot;$@&quot;&#96;[ $? -ne 0 ] &amp;&amp; usage 1eval set -- &quot;$&#123;ARGS&#125;&quot;while true; do    case &quot;$1&quot; in    -c|--count)        count&#x3D;&quot;$2&quot;        shift 2        ;;    -p|--pid)        pid&#x3D;&quot;$2&quot;        shift 2        ;;    -h|--help)        usage        ;;    --)        shift        break        ;;    esacdonecount&#x3D;$&#123;count:-5&#125;redEcho() &#123;    [ -c &#x2F;dev&#x2F;stdout ] &amp;&amp; &#123;        # if stdout is console, turn on color output.        echo -ne &quot;\033[1;31m&quot;        echo -n &quot;$@&quot;        echo -e &quot;\033[0m&quot;    &#125; || echo &quot;$@&quot;&#125;yellowEcho() &#123;    [ -c &#x2F;dev&#x2F;stdout ] &amp;&amp; &#123;        # if stdout is console, turn on color output.        echo -ne &quot;\033[1;33m&quot;        echo -n &quot;$@&quot;        echo -e &quot;\033[0m&quot;    &#125; || echo &quot;$@&quot;&#125;blueEcho() &#123;    [ -c &#x2F;dev&#x2F;stdout ] &amp;&amp; &#123;        # if stdout is console, turn on color output.        echo -ne &quot;\033[1;36m&quot;        echo -n &quot;$@&quot;        echo -e &quot;\033[0m&quot;    &#125; || echo &quot;$@&quot;&#125;# Check the existence of jstack command!if ! which jstack &amp;&gt; &#x2F;dev&#x2F;null; then    [ -z &quot;$JAVA_HOME&quot; ] &amp;&amp; &#123;        redEcho &quot;Error: jstack not found on PATH!&quot;        exit 1    &#125;    ! [ -f &quot;$JAVA_HOME&#x2F;bin&#x2F;jstack&quot; ] &amp;&amp; &#123;        redEcho &quot;Error: jstack not found on PATH and $JAVA_HOME&#x2F;bin&#x2F;jstack file does NOT exists!&quot;        exit 1    &#125;    ! [ -x &quot;$JAVA_HOME&#x2F;bin&#x2F;jstack&quot; ] &amp;&amp; &#123;        redEcho &quot;Error: jstack not found on PATH and $JAVA_HOME&#x2F;bin&#x2F;jstack is NOT executalbe!&quot;        exit 1    &#125;    export PATH&#x3D;&quot;$JAVA_HOME&#x2F;bin:$PATH&quot;fireadonly uuid&#x3D;&#96;date +%s&#96;_$&#123;RANDOM&#125;_$$cleanupWhenExit() &#123;    rm &#x2F;tmp&#x2F;$&#123;uuid&#125;_* &amp;&gt; &#x2F;dev&#x2F;null&#125;trap &quot;cleanupWhenExit&quot; EXITprintStackOfThread() &#123;    local line    local count&#x3D;1    while IFS&#x3D;&quot; &quot; read -a line ; do        local pid&#x3D;$&#123;line[0]&#125;        local threadId&#x3D;$&#123;line[1]&#125;        local threadId0x&#x3D;&#96;printf %x $&#123;threadId&#125;&#96;        local user&#x3D;$&#123;line[2]&#125;        local pcpu&#x3D;$&#123;line[4]&#125;        local jstackFile&#x3D;&#x2F;tmp&#x2F;$&#123;uuid&#125;_$&#123;pid&#125;        [ ! -f &quot;$&#123;jstackFile&#125;&quot; ] &amp;&amp; &#123;            &#123;                if [ &quot;$&#123;user&#125;&quot; &#x3D;&#x3D; &quot;$&#123;USER&#125;&quot; ]; then                    jstack $&#123;pid&#125; &gt; $&#123;jstackFile&#125;                else                    if [ $UID &#x3D;&#x3D; 0 ]; then                        sudo -u $&#123;user&#125; jstack $&#123;pid&#125; &gt; $&#123;jstackFile&#125;                    else                        redEcho &quot;[$((count++))] Fail to jstack Busy($&#123;pcpu&#125;%) thread($&#123;threadId&#125;&#x2F;0x$&#123;threadId0x&#125;) stack of java process($&#123;pid&#125;) under user($&#123;user&#125;).&quot;                        redEcho &quot;User of java process($user) is not current user($USER), need sudo to run again:&quot;                        yellowEcho &quot;    sudo $&#123;COMMAND_LINE[@]&#125;&quot;                        echo                        continue                    fi                fi            &#125; || &#123;                redEcho &quot;[$((count++))] Fail to jstack Busy($&#123;pcpu&#125;%) thread($&#123;threadId&#125;&#x2F;0x$&#123;threadId0x&#125;) stack of java process($&#123;pid&#125;) under user($&#123;user&#125;).&quot;                echo                rm $&#123;jstackFile&#125;                continue            &#125;        &#125;        blueEcho &quot;[$((count++))] Busy($&#123;pcpu&#125;%) thread($&#123;threadId&#125;&#x2F;0x$&#123;threadId0x&#125;) stack of java process($&#123;pid&#125;) under user($&#123;user&#125;):&quot;        sed &quot;&#x2F;nid&#x3D;0x$&#123;threadId0x&#125; &#x2F;,&#x2F;^$&#x2F;p&quot; -n $&#123;jstackFile&#125;    done&#125;ps -Leo pid,lwp,user,comm,pcpu --no-headers | &#123;    [ -z &quot;$&#123;pid&#125;&quot; ] &amp;&amp;    awk &#39;$4&#x3D;&#x3D;&quot;java&quot;&#123;print $0&#125;&#39; ||    awk -v &quot;pid&#x3D;$&#123;pid&#125;&quot; &#39;$1&#x3D;&#x3D;pid,$4&#x3D;&#x3D;&quot;java&quot;&#123;print $0&#125;&#39;&#125; | sort -k5 -r -n | head --lines &quot;$&#123;count&#125;&quot; | printStackOfThread</code></pre></div></figure><p>执行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools&#x2F;jdk&#x2F;bin]#.&#x2F;show-busy-java-threads.sh[1] Busy(0.0%) thread(13477&#x2F;0x34a5) stack of java process(13476) under user(root):&quot;main&quot; #1 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007f892000a800 nid&#x3D;0x34a5 runnable [0x00007f892907b000]   java.lang.Thread.State: RUNNABLE        at java.net.PlainSocketImpl.socketAccept(Native Method)        at ...</code></pre></div></figure><h2 id="1-2-java应用负载高的故障案例"><a href="#1-2-java应用负载高的故障案例" class="headerlink" title="1.2 java应用负载高的故障案例"></a>1.2 java应用负载高的故障案例</h2><p>排坑指南：</p><p><img src="/../../../img/image-20240515113423257.png" alt="image-20240515113423257"></p><p>排查流程：</p><table><thead><tr><th>排查流程</th><th>涉及命令</th></tr></thead><tbody><tr><td>1、通过监控服务发现系统负载高</td><td>zbx,prometheus</td></tr><tr><td>2、登录到对应的节点,通过命令检查系统负载是否高</td><td>w,uptime,top,lscpu</td></tr><tr><td>3、真的高,定位什么导致的系统负载高</td><td>top,ps aux,iotop,vmstat</td></tr><tr><td>4、找出原因并且找出对应的进程,需要根据进程找服务相关的<strong>日志</strong></td><td>查看日志信息</td></tr><tr><td>5、java进程查看进程中的线程信息</td><td>jps,jstack</td></tr><tr><td>6、导出jvm信息,通过mat工具进行分析,分析出什么原因导致的故障</td><td>jmap,mat</td></tr></tbody></table><h1 id="二、JAVA会话共享方案"><a href="#二、JAVA会话共享方案" class="headerlink" title="二、JAVA会话共享方案"></a>二、JAVA会话共享方案</h1><table><thead><tr><th>会话共享方案</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>1、单机部署</td><td>如果只是单个应用，不用考虑会话共享的问题</td><td></td></tr><tr><td>2、session复制功能</td><td>tomcat进行配置后可以把session信息赋值给其他节点</td><td>适用于集群节点较少的，比如4个以内</td></tr><tr><td>3、通过插件实现，如存放在redis中</td><td>tomcat通过插件，把用户会话保存在redis中<br/>tomcat-cluster-session-manager</td><td>需要插件,进行配置,代码支持</td></tr><tr><td>4、通过代码指定session位置</td><td>修改代码增加功能，依赖性强</td><td>需要修改代码，实现与3类似的功能</td></tr><tr><td>5、使用其他方式替代会话</td><td>oath认证，token认证</td><td>代码级别的修改</td></tr></tbody></table><h1 id="三、Tomcat配置Https"><a href="#三、Tomcat配置Https" class="headerlink" title="三、Tomcat配置Https"></a>三、Tomcat配置Https</h1><blockquote><p>应用建议:</p><ul><li>tomcat可以支持https，可以在tomcat中配置https证书.</li><li>未来可以在nginx中配置证书加密，tomcat未加密</li></ul></blockquote><h2 id="3-1-参考案例"><a href="#3-1-参考案例" class="headerlink" title="3.1 参考案例"></a>3.1 参考案例</h2><p>tomcat建议用pfx证书，如阿里云下载证书页面</p><p><img src="/../../../img/image-20240515122720529.png" alt="image-20240515122720529"></p><p>下载后的证书文件：</p><p><img src="/../../../img/image-20240515122650828.png" alt="image-20240515122650828"></p><p>tomcat的配置文件（参考）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;conf]#cat server.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;Server port&#x3D;&quot;8005&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;  &lt;Listener className&#x3D;&quot;org.apache.catalina.startup.VersionLoggerListener&quot; &#x2F;&gt; &lt;Listener className&#x3D;&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine&#x3D;&quot;on&quot; &#x2F;&gt;  &lt;Listener className&#x3D;&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; &#x2F;&gt;  &lt;Listener className&#x3D;&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; &#x2F;&gt;  &lt;Listener className&#x3D;&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; &#x2F;&gt;  &lt;GlobalNamingResources&gt;    &lt;Resource name&#x3D;&quot;UserDatabase&quot; auth&#x3D;&quot;Container&quot;              type&#x3D;&quot;org.apache.catalina.UserDatabase&quot;              description&#x3D;&quot;User database that can be updated and saved&quot;              factory&#x3D;&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;              pathname&#x3D;&quot;conf&#x2F;tomcat-users.xml&quot; &#x2F;&gt;  &lt;&#x2F;GlobalNamingResources&gt;  &lt;Service name&#x3D;&quot;Catalina&quot;&gt;    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;               connectionTimeout&#x3D;&quot;20000&quot;               redirectPort&#x3D;&quot;8443&quot;               maxParameterCount&#x3D;&quot;1000&quot;               &#x2F;&gt;    &lt;!-- 新增443跳转  --&gt;    &lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;               SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;               keystoreFile&#x3D;&quot;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;cert&#x2F;ssl.oldboylinux.cn.pfx&quot;               keystoreType&#x3D;&quot;PKCS12&quot;               keystorePass&#x3D;&quot;AGrnHD9j&quot;               clientAuth&#x3D;&quot;false&quot;               SSLProtocol&#x3D;&quot;TLSv1.1+TLSv1.2+TLSv1.3&quot;               ciphers&#x3D;&quot;TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256&quot;&#x2F;&gt;    &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;      &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;        &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;               resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;      &lt;&#x2F;Realm&gt;      &lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;            unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;        &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b &quot;% &#123;Referer&#125;i&quot; &quot;%&#123;User-Agent&#125;i&quot; &quot;% &#123;X-Forwarded-For&#125;i&quot;&quot; &#x2F;&gt;      &lt;&#x2F;Host&gt;    &lt;&#x2F;Engine&gt;  &lt;&#x2F;Service&gt;&lt;&#x2F;Server&gt;</code></pre></div></figure><p>如果是其他格式的证书，如JKS，配置要改变</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keystoreFile&#x3D;&quot;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;cert&#x2F;ssl.oldboylinux.cn.jks&quot;# keystoreType&#x3D;&quot;PKCS12&quot; #删除这一行keystorePass&#x3D;&quot;AGrnHD9j&quot; #密码</code></pre></div></figure><h2 id="3-2-部署自己的网站"><a href="#3-2-部署自己的网站" class="headerlink" title="3.2 部署自己的网站"></a>3.2 部署自己的网站</h2><h3 id="3-2-1-证书转换"><a href="#3-2-1-证书转换" class="headerlink" title="3.2.1 证书转换"></a>3.2.1 证书转换</h3><p>我的网站下载的证书只有三个文件，不是pfx（p12）格式的</p><p><img src="/../../../img/image-20240515125222343.png" alt="image-20240515125222343"></p><p>需要使用工具转换成p12格式，转换得到<code>gsblog.work.gd.pfx</code>文件</p><blockquote><p>工具下载地址：</p><p><a href="https://files.cnblogs.com/files/evemen/wosigncode.zip?t=1675735802">https://files.cnblogs.com/files/evemen/wosigncode.zip?t=1675735802</a></p></blockquote><p><img src="/../../../img/image-20240515125312960.png" alt="image-20240515125312960"></p><h3 id="3-2-2-配置HTTPS"><a href="#3-2-2-配置HTTPS" class="headerlink" title="3.2.2 配置HTTPS"></a>3.2.2 配置HTTPS</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 上传pfx文件[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;ssl_keys]#lsgsblog.work.gd.pfx# 修改配置文件server.xmlkeystoreFile&#x3D;&quot;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;ssl_keys&#x2F;gsblog.work.gd.pfx&quot;keystorePass&#x3D;&quot;redhat123&quot;# 重启服务systemctl restart tomcat# 查看8443端口是否开启[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;ssl_keys]#ss -lntup | grep javatcp    LISTEN     0      100    [::]:8080               [::]:*         ...tcp    LISTEN     0      100    [::]:8443               [::]:*                   users:((&quot;java&quot;,pid&#x3D;29129,fd&#x3D;63))...</code></pre></div></figure><p>测试访问：<a href="https://gsblog.work.gd:8443/">https://gsblog.work.gd:8443</a></p><p><img src="/../../../img/image-20240515125450602.png" alt="image-20240515125450602"></p><h3 id="3-2-3-tomcat实现8080跳转8443"><a href="#3-2-3-tomcat实现8080跳转8443" class="headerlink" title="3.2.3 tomcat实现8080跳转8443"></a>3.2.3 tomcat实现8080跳转8443</h3><blockquote><p>未来端口转发建议用nginx来实现</p></blockquote><p>tomcat的配置如下（了解）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># web.xml文件，在&lt;&#x2F;welcome-file-list&gt;后添加内容    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;&#x2F;welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;&#x2F;welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;    &lt;&#x2F;welcome-file-list&gt;    # 添加    &lt;login-config&gt;      &lt;!-- Authorization setting for SSL --&gt;      &lt;auth-method&gt;CLIENT-CERT&lt;&#x2F;auth-method&gt;      &lt;realm-name&gt;Client Cert Users-only Area&lt;&#x2F;realm-name&gt;    &lt;&#x2F;login-config&gt;    &lt;security-constraint&gt;      &lt;!-- Authorization setting for SSL --&gt;      &lt;web-resource-collection &gt;        &lt;web-resource-name&gt;ssl&lt;&#x2F;web-resource-name&gt;        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;      &lt;&#x2F;web-resource-collection&gt;      &lt;user-data-constraint&gt;        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;&#x2F;transport-guarantee&gt;      &lt;&#x2F;user-data-constraint&gt;    &lt;&#x2F;security-constraint&gt;</code></pre></div></figure><p>测试：<a href="http://gsblog.work.gd:8080/">http://gsblog.work.gd:8080</a></p><p>自动跳转到：<a href="https://gsblog.work.gd:8443/">https://gsblog.work.gd:8443</a></p><h1 id="四、Tomcat优化（TODO-就业前讲解）"><a href="#四、Tomcat优化（TODO-就业前讲解）" class="headerlink" title="四、Tomcat优化（TODO 就业前讲解）"></a>四、Tomcat优化（TODO 就业前讲解）</h1><h1 id="五、JAVA前后端分离项目"><a href="#五、JAVA前后端分离项目" class="headerlink" title="五、JAVA前后端分离项目"></a>五、JAVA前后端分离项目</h1><p>动静分离和前后端分离的概念</p><ul><li><p>动静分离</p><ul><li>所有代码在一起，动态的，静态的….叫未分离</li><li>代码分开，叫动静分离</li></ul></li><li><p>前后端分离：一般前后端通过API接口的进行连接，即：前端 + API接口 + 后端</p><ul><li><p>提取出静态（前端）和动态（后端）资源</p><ul><li>前端(html,css,js)，静态资源</li><li>后端:(Java,PHP,Python,Golang…) 连接使用数据库，实现动态功能</li></ul></li><li><p>API应用程序接口: 开发人员书写好的,可以直接调用的代码.使用的人员不需要关注功能是如何实现的，只需要关注如何调用接口即可.</p></li><li><p>API接口在各种服务中广泛存在。</p></li></ul></li></ul><p>比如获取天气预报的API</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl &quot;http:&#x2F;&#x2F;v1.yiketianqi.com&#x2F;api?unescape&#x3D;1&amp;version&#x3D;v63&amp;appid&#x3D;56996592&amp;appsecret&#x3D;d8Ghq2mv&amp;cityid&#x3D;101120201https:&#x2F;&#x2F;v1.yiketianqi.com&#x2F;api?unescape&#x3D;1&amp;version&#x3D;v63&amp;appid&#x3D;56996592&amp;appsecret&#x3D;d8Ghq2mv&amp;city&#x3D;%E9%9D%92%E5%B2%9B&quot;</code></pre></div></figure><h2 id="5-1-前后端的部署方式"><a href="#5-1-前后端的部署方式" class="headerlink" title="5.1 前后端的部署方式"></a>5.1 前后端的部署方式</h2><p>前后端分离部署的方式</p><ul><li>前端代码：nodejs环境编译 –&gt; 静态资源(html,css,js) –&gt; nginx中。</li><li>后端代码：java代码，通过maven&#x2F;gradle编译 –&gt; war包&#x2F;jar包，运行。</li></ul><h2 id="5-2-考试系统项目"><a href="#5-2-考试系统项目" class="headerlink" title="5.2 考试系统项目"></a>5.2 考试系统项目</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>环境准备</p><table><thead><tr><th>主机</th><th>环境</th><th>IP</th></tr></thead><tbody><tr><td>web03</td><td>前端ngx + 后端jdk</td><td>10.0.0.9</td></tr><tr><td>db02</td><td>数据库 mysql 8.0 二进制方法安装 &#x2F;app&#x2F;tools&#x2F;mysql&#x2F; <br/>数据目录&#x2F;app&#x2F;data&#x2F;3306&#x2F;</td><td>10.0.0.52</td></tr></tbody></table><h3 id="5-2-2-数据库部署"><a href="#5-2-2-数据库部署" class="headerlink" title="5.2.2 数据库部署"></a>5.2.2 数据库部署</h3><blockquote><p>db02 — 10.0.0.52 操作</p></blockquote><p>步骤总览：</p><ol><li>下载并解压</li><li>配置Mysql</li><li>初始化Mysql</li><li>创建库、创建用户</li><li>导入数据库表与数据(sql文件)</li></ol><h4 id="1、下载并解压"><a href="#1、下载并解压" class="headerlink" title="1、下载并解压"></a>1、下载并解压</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载wget https:&#x2F;&#x2F;cdn.mysql.com&#x2F;&#x2F;Downloads&#x2F;MySQL-8.0&#x2F;mysql-8.0.37-linux-glibc2.12-x86_64.tar.xz# 创建目录，解压进去mkdir -p &#x2F;app&#x2F;tools&#x2F; &#x2F;app&#x2F;data&#x2F;3306&#x2F;tar -xf mysql-8.0.37-linux-glibc2.12-x86_64.tar.xz -C &#x2F;app&#x2F;tools&#x2F;# 创建软连接ln -s &#x2F;app&#x2F;tools&#x2F;mysql-8.0.37-linux-glibc2.12-x86_64&#x2F; &#x2F;app&#x2F;tools&#x2F;mysql# 安装依赖库yum install ncurses ncurses-devel libaio-devel openssl openssl-devel -y</code></pre></div></figure><h4 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加mysql用户和组useradd -s &#x2F;sbin&#x2F;nologin -M mysql# 设置配置文件cat&gt;&#x2F;etc&#x2F;my.cnf&lt;&lt;&#39;EOF&#39;[mysqld]## 用户user&#x3D;mysql## 安装目录basedir&#x3D;&#x2F;app&#x2F;tools&#x2F;mysql&#x2F;## 数据目录datadir&#x3D;&#x2F;app&#x2F;data&#x2F;3306&#x2F;port&#x3D;3306socket&#x3D;&#x2F;tmp&#x2F;mysql.sock[client]socket&#x3D;&#x2F;tmp&#x2F;mysql.sockEOF# 查看[root@db02[ ~]#cat &#x2F;etc&#x2F;my.cnf[mysqld]## 用户user&#x3D;mysql## 安装目录basedir&#x3D;&#x2F;app&#x2F;tools&#x2F;mysql&#x2F;## 数据目录datadir&#x3D;&#x2F;app&#x2F;data&#x2F;3306&#x2F;port&#x3D;3306socket&#x3D;&#x2F;tmp&#x2F;mysql.sock[client]socket&#x3D;&#x2F;tmp&#x2F;mysql.sock# 修改配置文件和目录的所有者chown mysql.mysql &#x2F;etc&#x2F;my.cnfchown -R mysql.mysql &#x2F;app&#x2F;data&#x2F;3306&#x2F;# mysql环境变量echo &quot;export PATH&#x3D;&#x2F;app&#x2F;tools&#x2F;mysql&#x2F;bin:$PATH&quot; &gt;&gt; &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile# 检查[root@db02[ ~]#mysql -Vmysql  Ver 8.0.37 for Linux on x86_64 (MySQL Community Server - GPL)</code></pre></div></figure><h4 id="3、初始化数据库"><a href="#3、初始化数据库" class="headerlink" title="3、初始化数据库"></a>3、初始化数据库</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 初始化数据库mysqld --initialize-insecure --user&#x3D;mysql --basedir&#x3D;&#x2F;app&#x2F;tools&#x2F;mysql --datadir&#x3D;&#x2F;app&#x2F;data&#x2F;3306&#x2F;# 拷贝准备好的启动管理文件cp &#x2F;app&#x2F;tools&#x2F;mysql&#x2F;support-files&#x2F;mysql.server  &#x2F;etc&#x2F;init.d&#x2F;mysqldchmod +x &#x2F;etc&#x2F;init.d&#x2F;mysqld# 启动服务systemctl enable mysqldsystemctl start mysqld# 查看状态systemctl status mysqld</code></pre></div></figure><h4 id="4、创建库和用户"><a href="#4、创建库和用户" class="headerlink" title="4、创建库和用户"></a>4、创建库和用户</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 登录Mysqlmysql -uroot -p# 创建库&gt;create database exam charset utf8mb4;# 创建用户create user exam@&#39;172.16.1.%&#39; identified with mysql_native_password by &#39;redhat123&#39;;# 授权访问grant all on exam.* to exam@&#39;172.16.1.%&#39;;# 测试mysql -uexam -p -h 172.16.1.52</code></pre></div></figure><h4 id="5、导入数据"><a href="#5、导入数据" class="headerlink" title="5、导入数据"></a>5、导入数据</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压事先准备的好的数据文件[root@db02[ ~]#unzip xzs-sql-v3.9.0.zipArchive:  xzs-sql-v3.9.0.zip  inflating: xzs-mysql.sql  inflating: xzs-postgresql.sql[root@db02[ ~]#lsanaconda-ks.cfg  xzs-postgresql.sqlxzs-mysql.sql    xzs-sql-v3.9.0.zip# 导入[root@db02[ ~]#mysql exam &lt;xzs-mysql.sql</code></pre></div></figure><h3 id="5-2-3-部署后端"><a href="#5-2-3-部署后端" class="headerlink" title="5.2.3 部署后端"></a>5.2.3 部署后端</h3><blockquote><p>web03 — 10.0.0.9操作</p></blockquote><h4 id="1、jar包部署"><a href="#1、jar包部署" class="headerlink" title="1、jar包部署"></a>1、jar包部署</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建前后端文件夹mkdir -p &#x2F;app&#x2F;code&#x2F;exam&#x2F;&#123;front,backend&#125;# jar包部署命令，测试cd &#x2F;app&#x2F;code&#x2F;exam&#x2F;backend&#x2F;java -Duser.timezone&#x3D;Asia&#x2F;Shanghai -jar -Dspring.profiles.active&#x3D;prod xzs-3.9.0.jar# 参数说明-Dspring.profiles.active&#x3D;prod jar包目录同层的配置文件：application-prod.yml application.yml# 修改配置文件[root@web03[ &#x2F;app&#x2F;code&#x2F;exam&#x2F;backend]#cat application-prod.ymllogging:  path: &#x2F;usr&#x2F;log&#x2F;xzs&#x2F;spring:  datasource:    url: jdbc:mysql:&#x2F;&#x2F;172.16.1.52:3306&#x2F;exam?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;characterEncoding&#x3D;utf8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;allowPublicKeyRetrieval&#x3D;true&amp;allowMultiQueries&#x3D;true    username: exam    password: redhat123    driver-class-name: com.mysql.cj.jdbc.Driver# nohub后台运行jar包nohup java -Duser.timezone&#x3D;Asia&#x2F;Shanghai -jar -Dspring.profiles.active&#x3D;prod xzs-3.9.0.jar &gt; start1.log 2&gt;&amp;1 &amp;</code></pre></div></figure><h4 id="2、测试访问"><a href="#2、测试访问" class="headerlink" title="2、测试访问"></a>2、测试访问</h4><p><a href="http://10.0.0.9:8000/student">http://10.0.0.9:8000/student</a>   student  123456<br><a href="http://10.0.0.9:8000/admin">http://10.0.0.9:8000/admin</a>     admin  123456  </p><p><img src="/../../../img/image-20240515161125407.png" alt="image-20240515161125407"></p><p><img src="/../../../img/image-20240515161147901.png" alt="image-20240515161147901"></p><p>要能正常登陆，说明数据库连接没问题</p><p><img src="/../../../img/image-20240515161206695.png" alt="image-20240515161206695"></p><h3 id="5-2-4-部署前端"><a href="#5-2-4-部署前端" class="headerlink" title="5.2.4 部署前端"></a>5.2.4 部署前端</h3><h4 id="1、部署前端代码"><a href="#1、部署前端代码" class="headerlink" title="1、部署前端代码"></a>1、部署前端代码</h4><blockquote><p>提前准备：exam-web-前端.zip</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压，提取出对应的文件夹，放到front目录中[root@web03[ &#x2F;app&#x2F;code&#x2F;exam&#x2F;front]#lsadmin  exam-web-前端.zip  student</code></pre></div></figure><h4 id="2、修改nginx配置"><a href="#2、修改nginx配置" class="headerlink" title="2、修改nginx配置"></a>2、修改nginx配置</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># admin端转发server &#123;  listen 80;  server_name admin.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;exam&#x2F;front&#x2F;admin&#x2F;;  location &#x2F; &#123;    index index.html;  &#125;  location &#x2F;api&#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;localhost:8000;  &#125;&#125;# student端转发server &#123;  listen 80;  server_name stu.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;exam&#x2F;front&#x2F;student&#x2F;;  location &#x2F; &#123;  index index.html;  &#125;  location &#x2F;api&#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;localhost:8000;  &#125;&#125;# 重启nginxnginx -tsystemctl restart nginx</code></pre></div></figure><h4 id="2、测试访问-1"><a href="#2、测试访问-1" class="headerlink" title="2、测试访问"></a>2、测试访问</h4><p><a href="http://stu.oldboylinux.cn/">http://stu.oldboylinux.cn</a>   student  123456<br><a href="http://admin.oldboylinux.cn/">http://admin.oldboylinux.cn</a>     admin  123456  </p><p><img src="/../../../img/image-20240515162611606.png" alt="image-20240515162611606"></p><p><img src="/../../../img/image-20240515162625522.png" alt="image-20240515162625522"></p><h2 id="5-3-前后端分离总结"><a href="#5-3-前后端分离总结" class="headerlink" title="5.3 前后端分离总结"></a>5.3 前后端分离总结</h2><p><img src="/../../../img/image-20240515162210381.png" alt="image-20240515162210381"></p><p><img src="/../../../img/image-20240515162230057.png" alt="image-20240515162230057"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-Web集群-Tomcat(一)</title>
    <link href="/2024/05/11/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/18-web%E9%9B%86%E7%BE%A4-Tomcat-1/"/>
    <url>/2024/05/11/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/18-web%E9%9B%86%E7%BE%A4-Tomcat-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Tomcat（一）"><a href="#Web集群-Tomcat（一）" class="headerlink" title="Web集群-Tomcat（一）"></a>Web集群-Tomcat（一）</h1><p>今日内容：</p><ul><li>JAVA容器介绍</li><li>JAVA环境介绍</li><li>Tomcat上手</li></ul><h1 id="一、JAVA容器"><a href="#一、JAVA容器" class="headerlink" title="一、JAVA容器"></a>一、JAVA容器</h1><p>什么是java容器？</p><ul><li>用于存放java代码的环境，就叫java容器</li><li>web中间件，很多就是java容器，见下表</li></ul><table><thead><tr><th>java容器</th><th></th></tr></thead><tbody><tr><td>Tomcat</td><td>最常用，较重，功能完善.</td></tr><tr><td>Jetty</td><td>轻量，功能较少.</td></tr><tr><td>Weblogic</td><td>用于Oracle数据库环境使用，Weblogic属于甲骨文．</td></tr><tr><td>东方通</td><td>国产java容器</td></tr></tbody></table><h1 id="二、JAVA环境"><a href="#二、JAVA环境" class="headerlink" title="二、JAVA环境"></a>二、JAVA环境</h1><p>JAVA环境分为三部分：</p><ul><li>JVM: java 虚拟机，运行java代码的地方.</li><li>JRE: java Runtime Enviroment，java运行环境 。提供jvm环境，java命令。</li><li>JDK: Java Development Kit，java开发环境 , jvm+jre+额外功能</li></ul><p>图示如下：</p><p><img src="/../../../img/image-20240511160105925.png" alt="image-20240511160105925"></p><blockquote><p>提示：</p><p>未来部署JDK即可，主要版本JDK1.8 或称 JDK8</p><p>JDK - ORACLE所有，未授权仅允许个人研究</p><p>OPenJDK - 开源，允许商用</p></blockquote><h1 id="三、Tomcat极速上手"><a href="#三、Tomcat极速上手" class="headerlink" title="三、Tomcat极速上手"></a>三、Tomcat极速上手</h1><h2 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h2><table><thead><tr><th>环境</th><th></th><th></th></tr></thead><tbody><tr><td>web03</td><td>10.0.0.9&#x2F;172.16.1.9</td><td>tomcat</td></tr><tr><td>web04</td><td>10.0.0.10&#x2F;172.16.1.10</td><td>tomcat</td></tr><tr><td>db01</td><td>10.0.0.51&#x2F;172.16.1.51</td><td></td></tr></tbody></table><h2 id="3-2-部署JDK"><a href="#3-2-部署JDK" class="headerlink" title="3.2 部署JDK"></a>3.2 部署JDK</h2><p>版本：JDK-8u411</p><p>下载：<a href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a></p><p>部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压tar -vxf jdk-8u411-linux-x64.tar.gz -C &#x2F;app&#x2F;tools&#x2F;# 创建软连接ln -s &#x2F;app&#x2F;tools&#x2F;jdk1.8.0_411&#x2F; &#x2F;app&#x2F;tools&#x2F;jdk# 配置JAVA环境变量[root@web03[ &#x2F;app&#x2F;tools]#tail -n 4 &#x2F;etc&#x2F;profile# JDK环境export JAVA_HOME&#x3D;&#x2F;app&#x2F;tools&#x2F;jdkexport PATH&#x3D;$JAVA_HOME&#x2F;bin:$JAVA_HOME&#x2F;jre&#x2F;bin:$PATHexport CLASSPATH&#x3D;.$CLASSPATH:$JAVA_HOME&#x2F;lib:$JAVA_HOME&#x2F;jre&#x2F;lib:$JAVA_HOME&#x2F;lib&#x2F;tools.jar# 生效source &#x2F;etc&#x2F;profile# 测试java命令[root@web03[ &#x2F;app&#x2F;tools]#java -versionjava version &quot;1.8.0_411&quot;Java(TM) SE Runtime Environment (build 1.8.0_411-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.411-b09, mixed mode)[root@web03[ &#x2F;app&#x2F;tools]#which java&#x2F;app&#x2F;tools&#x2F;jdk&#x2F;bin&#x2F;java</code></pre></div></figure><h2 id="3-3-部署Tomcat"><a href="#3-3-部署Tomcat" class="headerlink" title="3.3 部署Tomcat"></a>3.3 部署Tomcat</h2><p>版本：9.0.89</p><p>下载：<a href="https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.89/bin/apache-tomcat-9.0.89.tar.gz">https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.89/bin/apache-tomcat-9.0.89.tar.gz</a></p><p>部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -vxf apache-tomcat-9.0.89.tar.gz -C &#x2F;app&#x2F;tools&#x2F;ln -s &#x2F;app&#x2F;tools&#x2F;apache-tomcat-9.0.89 &#x2F;app&#x2F;tools&#x2F;tomcat# 测试[root@web03[ &#x2F;app&#x2F;tools]#tomcat&#x2F;bin&#x2F;version.shUsing CATALINA_BASE:   &#x2F;app&#x2F;tools&#x2F;tomcatUsing CATALINA_HOME:   &#x2F;app&#x2F;tools&#x2F;tomcatUsing CATALINA_TMPDIR: &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;tempUsing JRE_HOME:        &#x2F;app&#x2F;tools&#x2F;jdkUsing CLASSPATH:       &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;bootstrap.jar:&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;tomcat-juli.jarUsing CATALINA_OPTS:Server version: Apache Tomcat&#x2F;9.0.89Server built:   May 3 2024 20:22:11 UTCServer number:  9.0.89.0OS Name:        LinuxOS Version:     3.10.0-1160.el7.x86_64Architecture:   amd64JVM Version:    1.8.0_411-b09JVM Vendor:     Oracle Corporation</code></pre></div></figure><p>启动Tomcat</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动[root@web03[ &#x2F;app&#x2F;tools]#tomcat&#x2F;bin&#x2F;startup.shUsing CATALINA_BASE:   &#x2F;app&#x2F;tools&#x2F;tomcatUsing CATALINA_HOME:   &#x2F;app&#x2F;tools&#x2F;tomcatUsing CATALINA_TMPDIR: &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;tempUsing JRE_HOME:        &#x2F;app&#x2F;tools&#x2F;jdkUsing CLASSPATH:       &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;bootstrap.jar:&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;tomcat-juli.jarUsing CATALINA_OPTS:Tomcat started.# 查看进程信息, 默认在8080端口监听[root@web03[ &#x2F;app&#x2F;tools]#ss -lntup | grep javatcp    LISTEN     0      100    [::]:8080               [::]:*                   users:((&quot;java&quot;,pid&#x3D;2585,fd&#x3D;57))tcp    LISTEN     0      1        [::ffff:127.0.0.1]:8005               [::]:*                   users:((&quot;java&quot;,pid&#x3D;2585,fd&#x3D;65))[root@web03[ &#x2F;app&#x2F;tools]#ps -ef | grep javaroot       2585      1  9 16:27 pts&#x2F;0    00:00:02 &#x2F;app&#x2F;tools&#x2F;jdk&#x2F;bin&#x2F;java -Djava.util.logging.config.file&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;conf&#x2F;logging.properties -Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize&#x3D;2048 -Djava.protocol.handler.pkgs&#x3D;org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK&#x3D;0027 -Dignore.endorsed.dirs&#x3D; -classpath &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;bootstrap.jar:&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;tomcat-juli.jar -Dcatalina.base&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat -Dcatalina.home&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat -Djava.io.tmpdir&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;temp org.apache.catalina.startup.Bootstrap startroot       2628   2312  0 16:27 pts&#x2F;0    00:00:00 grep --color&#x3D;auto java</code></pre></div></figure><p>测试访问：<a href="http://10.0.0.9:8080/">http://10.0.0.9:8080/</a></p><p><img src="/../../../img/image-20240511163252296.png" alt="image-20240511163252296"></p><h1 id="四、Tomcat目录结构"><a href="#四、Tomcat目录结构" class="headerlink" title="四、Tomcat目录结构"></a>四、Tomcat目录结构</h1><h2 id="4-1-目录概述"><a href="#4-1-目录概述" class="headerlink" title="4.1 目录概述"></a>4.1 目录概述</h2><p>Tomcat下有如下目录：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools]#ll tomcat&#x2F;total 132drwxr-x---. 2 root root  4096 May 11 16:25 bin-rw-r-----. 1 root root 20913 May  4 04:22 BUILDING.txtdrwx------. 3 root root   254 May 11 16:27 conf-rw-r-----. 1 root root  6210 May  4 04:22 CONTRIBUTING.mddrwxr-x---. 2 root root  4096 May 11 16:25 lib-rw-r-----. 1 root root 57092 May  4 04:22 LICENSEdrwxr-x---. 2 root root   197 May 11 16:27 logs-rw-r-----. 1 root root  2333 May  4 04:22 NOTICE-rw-r-----. 1 root root  3283 May  4 04:22 README.md-rw-r-----. 1 root root  6901 May  4 04:22 RELEASE-NOTES-rw-r-----. 1 root root 16505 May  4 04:22 RUNNING.txtdrwxr-x---. 2 root root    30 May 11 16:25 tempdrwxr-x---. 7 root root    81 May  4 04:22 webappsdrwxr-x---. 3 root root    22 May 11 16:27 work</code></pre></div></figure><p>重要目录的概述如下</p><table><thead><tr><th>目录</th><th></th></tr></thead><tbody><tr><td>bin</td><td>存放tomcat管理命令</td></tr><tr><td>conf</td><td>tomcat配置文件</td></tr><tr><td>lib</td><td>依赖与库文件,插件文件</td></tr><tr><td>logs</td><td>日志目录</td></tr><tr><td>webapps</td><td>站点目录</td></tr><tr><td>work</td><td>tomcat运行java代码的存放代码的目录</td></tr></tbody></table><h2 id="4-2-bin目录"><a href="#4-2-bin目录" class="headerlink" title="4.2 bin目录"></a>4.2 bin目录</h2><p>核心文件：</p><table><thead><tr><th>bin目录</th><th></th></tr></thead><tbody><tr><td>startup.sh</td><td>启动脚本</td></tr><tr><td>shutdown.sh</td><td>关闭脚本</td></tr><tr><td>catalina.sh</td><td>核心脚本,配置tomcat优化,jvm优化</td></tr></tbody></table><h2 id="4-3-conf目录"><a href="#4-3-conf目录" class="headerlink" title="4.3 conf目录"></a>4.3 conf目录</h2><p>核心文件</p><table><thead><tr><th>conf配置文件</th><th>说明</th></tr></thead><tbody><tr><td>server.xml</td><td>tomcat配置文件</td></tr><tr><td>web.xml</td><td>配置文件,辅助配置</td></tr></tbody></table><h2 id="4-4-logs目录"><a href="#4-4-logs目录" class="headerlink" title="4.4 logs目录"></a>4.4 logs目录</h2><table><thead><tr><th>logs目录</th><th></th></tr></thead><tbody><tr><td>catalina.out</td><td>tomcat应用日志,启动过程,关闭,错误信息 <br/><strong>核心找</strong>：startup启动用时,错误提示:error,failed,exception</td></tr><tr><td>catalina.2022-09-15.log</td><td>catalina.out的切割日志.按照每天进行切割.</td></tr><tr><td>localhost_access_log.2022-09-15.txt</td><td>访问日志,未来可以重新定义名字和内容</td></tr></tbody></table><h2 id="4-5-webapps目录"><a href="#4-5-webapps目录" class="headerlink" title="4.5 webapps目录"></a>4.5 webapps目录</h2><p>站点目录<br>war包，自动解压，自动部署  </p><h1 id="五、Tomcat日常管理与访问"><a href="#五、Tomcat日常管理与访问" class="headerlink" title="五、Tomcat日常管理与访问"></a>五、Tomcat日常管理与访问</h1><h2 id="5-1-日常启动与维护"><a href="#5-1-日常启动与维护" class="headerlink" title="5.1 日常启动与维护"></a>5.1 日常启动与维护</h2><p>启动tomcat查看日志</p><p><img src="/../../../img/image-20240511163938313.png" alt="image-20240511163938313"></p><p>浏览器测试访问：<a href="http://10.0.0.9:8080/">http://10.0.0.9:8080/</a>  </p><h2 id="5-2-systemctl管理配置文件介绍"><a href="#5-2-systemctl管理配置文件介绍" class="headerlink" title="5.2 systemctl管理配置文件介绍"></a>5.2 systemctl管理配置文件介绍</h2><p>如果纯靠手动执行<code>startup.sh</code>脚本来维护tomcat，有些费时费力，可以把这些工作写成systemctl服务，用服务来自动管理。</p><p>服务管理指令存放：<code>/usr/lib/systemd/system/xxxx.service</code>，</p><p>分为3个部分：Unit、Service、Install</p><p>修改或设置systemctl配置要进行重新加载配置  </p><p>比如sshd服务的配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools]#cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;sshd.service[Unit]Description&#x3D;OpenSSH server daemonDocumentation&#x3D;man:sshd(8) man:sshd_config(5)After&#x3D;network.target sshd-keygen.serviceWants&#x3D;sshd-keygen.service[Service]Type&#x3D;notifyEnvironmentFile&#x3D;&#x2F;etc&#x2F;sysconfig&#x2F;sshdExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;sshd -D $OPTIONSExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPIDKillMode&#x3D;processRestart&#x3D;on-failureRestartSec&#x3D;42s[Install]WantedBy&#x3D;multi-user.target</code></pre></div></figure><p>各项解释如下：</p><table><thead><tr><th>配置文件结构</th><th></th></tr></thead><tbody><tr><td><strong><font color=red>[Unit]</font></strong></td><td>指定注释信息,依赖(先后顺序)</td></tr><tr><td>Description</td><td>说明与注释</td></tr><tr><td>After</td><td>在这里指定的服务之后运行. network.target</td></tr><tr><td><strong><font color=red>[Service]</font></strong></td><td>用于指定服务开启命令,关闭命令,重启命令.</td></tr><tr><td>Type&#x3D;notify</td><td>指定类型 simple 或forking即可</td></tr><tr><td>ExecStart</td><td>服务启动命令</td></tr><tr><td>ExecStop</td><td>服务关闭命令</td></tr><tr><td>ExecReload</td><td>重启命令</td></tr><tr><td>EnvironmentFile</td><td>配置环境变量的文件(一般对于编译安装,二进制安装需要加上)</td></tr><tr><td><strong><font color=red>[Install]</font></strong></td><td>内容固定,用于指定运行级别.</td></tr><tr><td>WantedBy&#x3D;multi-user.target</td><td>运行级别,一般都是多用户模式.</td></tr></tbody></table><h2 id="5-3-创建systemctl文件"><a href="#5-3-创建systemctl文件" class="headerlink" title="5.3 创建systemctl文件"></a>5.3 创建systemctl文件</h2><p>创建环境变量文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;etc&#x2F;sysconfig]#cat &#x2F;etc&#x2F;sysconfig&#x2F;tomcatJAVA_HOME&#x3D;&#x2F;app&#x2F;tools&#x2F;jdkPATH&#x3D;$JAVA_HOME&#x2F;bin:$JAVA_HOME&#x2F;jre&#x2F;bin:&#x2F;usr&#x2F;bin&#x2F;:&#x2F;usr&#x2F;sbin&#x2F;:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;:&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;CLASSPATH&#x3D;.$CLASSPATH:$JAVA_HOME&#x2F;lib:$JAVA_HOME&#x2F;jre&#x2F;lib:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</code></pre></div></figure><p>创建tomcat systemctl文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system]#cat tomcat.service[Unit]Description&#x3D;Tomcat java web containerAfter&#x3D;network.target[Service]Type&#x3D;forkingEnvironmentFile&#x3D;&#x2F;etc&#x2F;sysconfig&#x2F;tomcatExecStart&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;startup.shExecStop&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;shutdown.shExecReload&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;shutdown.sh &amp;&amp; sleep 1 &amp;&amp; &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;startup.sh[Install]WantedBy&#x3D;multi-user.target</code></pre></div></figure><p>重新加载配置（重要，不能忘记！！）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system]#systemctl enable tomcat.serviceCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;tomcat.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;tomcat.service.[root@web03[ &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system]#systemctl start tomcat.service[root@web03[ &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system]#systemctl status tomcat.service● tomcat.service - Tomcat java web container   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;tomcat.service; enabled; vendor preset: disabled)   Active: inactive (dead) since Sat 2024-05-11 16:52:52 CST; 637ms ago  Process: 2956 ExecStop&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;shutdown.sh (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)  Process: 2931 ExecStart&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;startup.sh (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Main PID: 2939 (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)May 11 16:52:49 web03 systemd[1]: Starting Tomcat java web container...May 11 16:52:49 web03 startup.sh[2931]: Tomcat started.May 11 16:52:49 web03 systemd[1]: Started Tomcat java web container.</code></pre></div></figure><h2 id="5-4-运行站点代码"><a href="#5-4-运行站点代码" class="headerlink" title="5.4 运行站点代码"></a>5.4 运行站点代码</h2><p>开发写的JAVA源代码不能直接部署在Tomcat中，需要对源代码进行编译，生成war包或者jar包</p><table><thead><tr><th>分类</th><th>说明</th><th>应用场景</th></tr></thead><tbody><tr><td>war包</td><td>需要放在java容器中运行<br/>比如放到tomcat的webapps目录下.<br/>(tomcat会自动加载与运行 war包内容)</td><td>功能复杂</td></tr><tr><td>jar包</td><td>不需要java容器，内置tomcat<br/>只需要jdk ，通过<code> java -jar xxx.jar</code> 运行</td><td></td></tr></tbody></table><h3 id="5-4-1-运行war包案例"><a href="#5-4-1-运行war包案例" class="headerlink" title="5.4.1 运行war包案例"></a>5.4.1 运行war包案例</h3><p>上传memtest.war包，放在webapps目录，然后访问即可</p>  <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps]#lsdocs  examples  host-manager  manager  memtest.war  ROOT</code></pre></div></figure><p>测试访问：<a href="http://10.0.0.9:8080/memtest/meminfo.jsp">http://10.0.0.9:8080/memtest/meminfo.jsp</a></p><p><img src="/../../../img/image-20240511170000316.png" alt="image-20240511170000316"></p><h3 id="5-4-2-运行jar包案例"><a href="#5-4-2-运行jar包案例" class="headerlink" title="5.4.2 运行jar包案例"></a>5.4.2 运行jar包案例</h3><blockquote><p>JAR包如果内置了Tomcat，直接指定端口运行即可</p></blockquote><p>下载程序包：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;file.nginxwebui.cn&#x2F;nginxWebUI-3.4.0.jar</code></pre></div></figure><p>部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup java -jar -Dfile.encoding&#x3D;UTF-8 &#x2F;home&#x2F;nginxWebUI&#x2F;nginxWebUI-4.0.8.jar --server.port&#x3D;8081 --project.home&#x3D;&#x2F;home&#x2F;nginxWebUI&#x2F; &gt; &#x2F;dev&#x2F;null &amp;</code></pre></div></figure><p>参数说明</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>–server.port</td><td>占用端口</td></tr><tr><td>–project.home</td><td>项目配置文件目录，存放数据库文件，证书文件，<br/>日志等</td></tr><tr><td>&amp;</td><td>项目后台运行</td></tr></tbody></table><p>测试访问：<a href="http://10.0.0.9:8081/adminPage/login">http://10.0.0.9:8081/adminPage/login</a></p><p><img src="/../../../img/image-20240511171222761.png" alt="image-20240511171222761"></p><h2 id="5-6-Tomcat管理端（熟悉即可）"><a href="#5-6-Tomcat管理端（熟悉即可）" class="headerlink" title="5.6 Tomcat管理端（熟悉即可）"></a>5.6 Tomcat管理端（熟悉即可）</h2><p>tomcat管理端：</p><ul><li>用于web页面管理与查看tomcat信息的功能。</li><li>未来对tomcat进行调优的时候需要关闭。</li></ul><p>开启管理端的方法：</p><ol><li>修改配置文件tomcat-users.xml</li><li>修改安全配置，默认只能127访问，去掉此限制</li></ol><p>修改配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;conf]#cat tomcat-users.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;tomcat-users xmlns&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml&quot;              xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;              xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml tomcat-users.xsd&quot;              version&#x3D;&quot;1.0&quot;&gt;&lt;!-- 添加  --&gt;&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;&lt;user username&#x3D;&quot;lidao996&quot; password&#x3D;&quot;1&quot; roles&#x3D;&quot;manager-gui,admin-gui&quot;&#x2F;&gt;&lt;&#x2F;tomcat-users&gt;</code></pre></div></figure><p>去掉只能127网段访问的限制，否则10网段访问将报403错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i &#39;s#127#\\d+#g&#39; .&#x2F;host-manager&#x2F;META-INF&#x2F;context.xml .&#x2F;host-manager&#x2F;WEB-INF&#x2F;manager.xml  .&#x2F;manager&#x2F;META-INF&#x2F;context.xml</code></pre></div></figure><p>重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart tomcat</code></pre></div></figure><p>测试访问：<a href="http://10.0.0.9:8080/manager/status">http://10.0.0.9:8080/manager/status</a></p><p><img src="/../../../img/image-20240513103228645.png" alt="image-20240513103228645"></p><p>输入配置的账号密码，成功进入</p><p><img src="/../../../img/image-20240513103255698.png" alt="image-20240513103255698"></p><h1 id="六、Tomcat集群"><a href="#六、Tomcat集群" class="headerlink" title="六、Tomcat集群"></a>六、Tomcat集群</h1><h2 id="6-1-Tomcat配置文件详解"><a href="#6-1-Tomcat配置文件详解" class="headerlink" title="6.1 Tomcat配置文件详解"></a>6.1 Tomcat配置文件详解</h2><p>主配置文件：<code>conf/server.xml</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 8085 shutdown端口，连接这个端口输入shutdown字符，就可以关闭tomcat --&gt;&lt;Server port&#x3D;&quot;8005&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;&lt;!-- 管理端认证功能 --&gt;&lt;GlobalNamingResources&gt;    &lt;Resource name&#x3D;&quot;UserDatabase&quot; auth&#x3D;&quot;Container&quot;              type&#x3D;&quot;org.apache.catalina.UserDatabase&quot;              description&#x3D;&quot;User database that can be updated and saved&quot;              factory&#x3D;&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;              pathname&#x3D;&quot;conf&#x2F;tomcat-users.xml&quot; &#x2F;&gt;  &lt;&#x2F;GlobalNamingResources&gt;&lt;!-- 8080端口 处理用户Http请求 --&gt; &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;               connectionTimeout&#x3D;&quot;20000&quot;               redirectPort&#x3D;&quot;8443&quot;               maxParameterCount&#x3D;&quot;1000&quot;               &#x2F;&gt;&lt;!--  Engine部署，指定默认的虚拟主机，这里指定localhost为默认虚拟主机 --&gt;&lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;&lt;!-- Host部分，虚拟主机的配置, name就是域名 --&gt;&lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;            unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;        &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;      &lt;&#x2F;Host&gt;&lt;!-- 日志记录部分 --&gt;            &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</code></pre></div></figure><p>Tomcat配置于nginx配置的对比</p><table><thead><tr><th>tomcat</th><th>ngx</th><th></th></tr></thead><tbody><tr><td>虚拟主机</td><td>Host部分</td><td>server {}</td></tr><tr><td>域名</td><td>name&#x3D;”域名”</td><td>server_name java.oldboylinux.cn;</td></tr><tr><td>端口</td><td>Connector部分 port&#x3D;”8080”</td><td>listen 80;</td></tr><tr><td>站点目录</td><td>appBase&#x3D;”webapps”</td><td>root &#x2F;app&#x2F;code&#x2F;blog;</td></tr><tr><td>自动解压</td><td>unpackWARs&#x3D;”true”</td><td>无</td></tr><tr><td>自动部署</td><td>autoDeploy&#x3D;”true” 加载到jvm中</td><td>无</td></tr><tr><td>日志目录</td><td>&lt;Valve 部分 日志目录 directory&#x3D;”logs”</td><td>access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main;</td></tr><tr><td>日志名字</td><td>&lt;Valve 部分前半部分prefix&#x3D;”localhost_access_log” 后半部分suffix&#x3D;”.txt”</td><td>access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main;</td></tr><tr><td>日志格式</td><td>&lt;Valve 部分pattern&#x3D;”%h %l %u %t “%r” %s %b”</td><td>log_format main …………….;</td></tr></tbody></table><h2 id="6-2-tomcat访问日志格式"><a href="#6-2-tomcat访问日志格式" class="headerlink" title="6.2 tomcat访问日志格式"></a>6.2 tomcat访问日志格式</h2><p>说明</p><table><thead><tr><th>说明</th><th>tomcat</th><th>nginx</th></tr></thead><tbody><tr><td>定义访问日志的格式</td><td>Host部分的pattern定义</td><td>http区域 log_format部分</td></tr><tr><td>客户端ip地址</td><td>%h</td><td>$remote_addr</td></tr><tr><td>访问的时间</td><td>%t</td><td>$local_time</td></tr><tr><td>请求起始行</td><td>%r</td><td>$request</td></tr><tr><td>状态码</td><td>%s</td><td>$status</td></tr><tr><td>大小</td><td>%b</td><td>$body_bytes_sent</td></tr><tr><td>从哪里跳转来的(用户如何访问网站)</td><td>%{Referer}i</td><td>$http_referer</td></tr><tr><td>客户端类型,浏览器</td><td>%{User-Agent}i</td><td>$http_user_agent</td></tr><tr><td>XFF头记录</td><td>%{X-Forwarded-For}i</td><td>$http_x_forwarded_for</td></tr></tbody></table><p>建议配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b &quot;% &#123;Referer&#125;i&quot; &quot;%&#123;User-Agent&#125;i&quot; &quot;% &#123;X-Forwarded-For&#125;i&quot;&quot; &#x2F;&gt;</code></pre></div></figure><blockquote><p>其中<code>&amp;quot;</code>表示双引号</p></blockquote><h2 id="6-3-Tomcat与用户请求"><a href="#6-3-Tomcat与用户请求" class="headerlink" title="6.3 Tomcat与用户请求"></a>6.3 Tomcat与用户请求</h2><p>请求流程：</p><ol><li>请求与8080端口连接</li><li>域名与Host部分的Name进行匹配<ol><li>匹配成功：使用对应虚拟主机</li><li>匹配失败：使用Engine中定义的default默认虚拟主机</li></ol></li></ol><blockquote><p>Tomcat可以处理静态与动态的请求：</p><ul><li>处理静态的效率较低，擅长动态</li></ul></blockquote><h2 id="6-4-案例-部署zrlog应用"><a href="#6-4-案例-部署zrlog应用" class="headerlink" title="6.4 案例-部署zrlog应用"></a>6.4 案例-部署zrlog应用</h2><p>步骤：</p><ul><li>准备站点war文件</li><li>创建数据库、用户</li><li>修改Tomcat配置</li></ul><p>1、代码准备：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 上传zrlog的war包到webapps文件夹中[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps]#mv &#x2F;root&#x2F;zrlog-2.2.1-efbe9f9-release.war zrlog.war</code></pre></div></figure><p>2、创建数据库、用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建数据库MariaDB [(none)]&gt; create database zrlog;Query OK, 1 row affected (0.00 sec)# 创建对应用户MariaDB [(none)]&gt; grant all on zrlog.* to &#39;zrlog&#39;@&#39;172.16.1.%&#39; identified by &#39;redhat123&#39;;Query OK, 0 rows affected (0.00 sec)# 查看MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || wordpress          || zrlog              |+--------------------+5 rows in set (0.01 sec)MariaDB [(none)]&gt; select user,host from mysql.user;+------------+------------+| user       | host       |+------------+------------+| root       | 127.0.0.1  || phpmyadmin | 172.16.1.% || wordpress  | 172.16.1.% || wp         | 172.16.1.% || zrlog      | 172.16.1.% || root       | ::1        || root       | localhost  || wordpress  | localhost  |+------------+------------+8 rows in set (0.00 sec)</code></pre></div></figure><p>测试访问：</p><blockquote><p>以上配置并没有未站点配置域名，zrlog.olboy这个域名是通过配置hosts解析设置的，只是为方便站点理解</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;10.0.0.9 zrlog.oldboylinux.cn</code></pre></div></figure></blockquote><p>前台：<a href="http://zrlog.oldboylinux.cn:8080/zrlog/">http://zrlog.oldboylinux.cn:8080/zrlog/</a></p><p><img src="/../../../img/image-20240513114215670.png" alt="image-20240513114215670"></p><p><img src="/../../../img/image-20240513114343742.png" alt="image-20240513114343742"></p><p>后台管理：<a href="http://zrlog.oldboylinux.cn:8080/zrlog/admin/">http://zrlog.oldboylinux.cn:8080/zrlog/admin/</a>  </p><p><img src="/../../../img/image-20240513114715123.png" alt="image-20240513114715123"></p><h2 id="6-5-Tomcat的ROOT文件夹"><a href="#6-5-Tomcat的ROOT文件夹" class="headerlink" title="6.5 Tomcat的ROOT文件夹"></a>6.5 Tomcat的ROOT文件夹</h2><p>实现目标：想直接访问到网站，而不是加上网站路径</p><p>比如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 现在访问zrloghttp:&#x2F;&#x2F;zrlog.oldboylinux.cn:8080&#x2F;zrlog&#x2F;# 我想要的http:&#x2F;&#x2F;zrlog.oldboylinux.cn:8080</code></pre></div></figure><p>原理：当访问站点不加上路径时，会直接访问ROOT下面的内容</p><p>实现直接访问zrlog：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先删除原有的ROOT文件夹（重命名也可以）mv ROOT ROOT.old# 把zrlog.war该名称ROOT.war mv zrlog.war ROOT.war# 会新部署生成ROOT文件夹，老的zrlog可以删了rm zrlog -fr# 查看[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps]#lsdocs  examples  host-manager  manager  memtest  memtest.war  ROOT  ROOT.old  ROOT.war </code></pre></div></figure><p>测试访问：<a href="http://zrlog.oldboylinux.cn:8080/">http://zrlog.oldboylinux.cn:8080/</a></p><p>直接跳到zrlog的安装界面，说明成功</p><p><img src="/../../../img/image-20240513134404186.png" alt="image-20240513134404186"></p><blockquote><p>补充：</p><p>如果zrlog已经配置完了，后续如何修改数据库的地址？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;webapps]#cat ROOT&#x2F;WEB-INF&#x2F;db.properties&gt;#This is a database configuration file&gt;#Mon May 13 13:44:21 CST 2024&gt;driverClass&#x3D;com.mysql.cj.jdbc.Driver&gt;user&#x3D;zrlog&gt;password&#x3D;redhat123&gt;jdbcUrl&#x3D;jdbc\:mysql\:&#x2F;&#x2F;172.16.1.51\:3306&#x2F;zrlog?characterEncoding\&#x3D;UTF-8&amp;allowPublicKeyRetrieval\&#x3D;true&amp;useSSL\&#x3D;false&amp;serverTimezone\&#x3D;GMT</code></pre></div></figure></blockquote><h2 id="6-6-Tomcat接入Nginx"><a href="#6-6-Tomcat接入Nginx" class="headerlink" title="6.6 Tomcat接入Nginx"></a>6.6 Tomcat接入Nginx</h2><p>Tomca接入Nginx，其原理是</p><p>用户 –访问—&gt; nginx —转发—&gt; Tomcat</p><p>Nginx虚拟主机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat zrlog.oldboylinux.cn.confserver &#123;  listen 80;  server_name zrlog.oldboylinux.cn;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;zrlog-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;zrlog-access.log main;  # location转发  location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;    proxy_set_header Host $http_host;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &#125;&#125;</code></pre></div></figure><p>设置Hosts，测试访问：<a href="http://zrlog.oldboylinux.cn/%EF%BC%8C%E8%BD%AC%E5%8F%91%E6%88%90%E5%8A%9F">http://zrlog.oldboylinux.cn/，转发成功</a></p><p><img src="/../../../img/image-20240513140124888.png" alt="image-20240513140124888"></p><h2 id="6-7-Tomcat-Ngx动静分离"><a href="#6-7-Tomcat-Ngx动静分离" class="headerlink" title="6.7  Tomcat + Ngx动静分离"></a>6.7  Tomcat + Ngx动静分离</h2><p>什么是动静分离：</p><ul><li>动态资源和静态资源都单独存放</li><li>如果需要访问静态资源，Nginx直接返回</li><li>如果需要访问动态资源，Nginx再转发给Tomcat处理</li></ul><blockquote><p>前提：需要开发拆分代码，把静态资源拆分出来单独存放.  </p></blockquote><p>图示：没有动静分离，Ngx一股脑全抛给Tomcat</p><p><img src="/../../../img/image-20240513140438636.png" alt="image-20240513140438636"></p><p>图示：有动静分离，Nginx处理静态资源，Tomcat处理动态资源</p><p><img src="/../../../img/image-20240513140505383.png" alt="image-20240513140505383"></p><h2 id="6-8-Tomcat创建多个实例"><a href="#6-8-Tomcat创建多个实例" class="headerlink" title="6.8 Tomcat创建多个实例"></a>6.8 Tomcat创建多个实例</h2><p>目标：在同一台Linux主机上运行多个Tomcat实例</p><p>原因：可以充分利用服务器资源</p><p>步骤：</p><ul><li>创建多个tomcat目录</li><li>配置文件端口8080，8005，改掉防止冲突</li><li>启动</li></ul><p>创建多个Tomcat目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar xf apache-tomcat-9.0.65.tar.gzcp -r apache-tomcat-9.0.65 tomcat-8081cp -r apache-tomcat-9.0.65 tomcat-8082mv tomcat-808* &#x2F;app&#x2F;tools&#x2F;</code></pre></div></figure><p>修改配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i &#39;s#8005#8006#g&#39; tomcat-8081&#x2F;conf&#x2F;server.xmlsed -i &#39;s#8080#8081#g&#39; tomcat-8081&#x2F;conf&#x2F;server.xmlsed -i &#39;s#8005#8007#g&#39; tomcat-8082&#x2F;conf&#x2F;server.xmlsed -i &#39;s#8080#8082#g&#39; tomcat-8082&#x2F;conf&#x2F;server.xml</code></pre></div></figure><p>手动启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">echo java oldboylinux 8081 &gt;&#x2F;app&#x2F;tools&#x2F;tomcat-8081&#x2F;webapps&#x2F;ROOT&#x2F;lidaojspecho java oldboylinux 8082 &gt;&#x2F;app&#x2F;tools&#x2F;tomcat-8082&#x2F;webapps&#x2F;ROOT&#x2F;lidao.jsp</code></pre></div></figure><p>测试访问</p><blockquote><p>建议：</p><p>未来生产上，可以直接把tomcat+应用整体打包，使用的时候直接解压即可  </p></blockquote><h2 id="6-9-监控功能"><a href="#6-9-监控功能" class="headerlink" title="6.9 监控功能"></a>6.9 监控功能</h2><h3 id="6-9-1-监控概述"><a href="#6-9-1-监控概述" class="headerlink" title="6.9.1 监控概述"></a>6.9.1 监控概述</h3><p>作用：</p><ul><li>通过各种监控工具(Zabbix&#x2F;Grafana&#x2F;Prometheus&#x2F;….)来监控Tomcat&#x2F;java.</li><li>需要我们开启java远程监控功能(JMX remote)</li></ul><h3 id="6-9-2-配置步骤"><a href="#6-9-2-配置步骤" class="headerlink" title="6.9.2 配置步骤"></a>6.9.2 配置步骤</h3><p>tomcat配置中修改tomcat启动的选项，开启jmx远程监控功能。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 备份文件[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat]#cp bin&#x2F;catalina.sh bin&#x2F;catalina.sh.bak# 编辑catalina.sh，125行之后加# 从tomcat 8.5开始 配置的每一行要通过\进行续行CATALINA_OPTS&#x3D;&quot;$CATALINA_OPTS \ -Dcom.sun.management.jmxremote \ -Dcom.sun.management.jmxremote.port&#x3D;12345 \ -Dcom.sun.management.jmxremote.authenticate&#x3D;false \ -Dcom.sun.management.jmxremote.ssl&#x3D;false \ -Djava.rmi.server.hostname&#x3D;10.0.0.9&quot; \ # 重启tomcat生效systemctl restart tomcat</code></pre></div></figure><p>选项说明</p><table><thead><tr><th>开启远程监控功能选项</th><th></th><th></th></tr></thead><tbody><tr><td>-Dcom.sun.management.jmxremote</td><td>开启远程监控功能</td><td></td></tr><tr><td>-Dcom.sun.management.jmxremote.port&#x3D;12345</td><td>指定端口</td><td></td></tr><tr><td>-Dcom.sun.management.jmxremote.authenticate&#x3D;false</td><td>关闭认证功能</td><td></td></tr><tr><td>-Dcom.sun.management.jmxremote.ssl&#x3D;false</td><td>关闭ssl加密功能</td><td></td></tr><tr><td>-Djava.rmi.server.hostname&#x3D;10.0.0.9</td><td>写上本地网卡的ip,监听的地址.</td><td>未来需要修改的.</td></tr></tbody></table><h3 id="6-9-3-验证"><a href="#6-9-3-验证" class="headerlink" title="6.9.3 验证"></a>6.9.3 验证</h3><p>配置完监控后，Tomcat的java进程有什么改变？</p><ul><li>可以看到tomcat配置的监控信息</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web03[ &#x2F;app&#x2F;tools&#x2F;tomcat]#ps -ef | grep javaroot      13476      1  2 14:19 ?        00:00:05 &#x2F;app&#x2F;tools&#x2F;jdk&#x2F;bin&#x2F;java -Djava.util.logging.config.file&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;conf&#x2F;logging.properties -Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize&#x3D;2048 -Djava.protocol.handler.pkgs&#x3D;org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK&#x3D;0027 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port&#x3D;12345 -Dcom.sun.management.jmxremote.authenticate&#x3D;false -Dcom.sun.management.jmxremote.ssl&#x3D;false -Djava.rmi.server.hostname&#x3D;10.0.0.9 -Dignore.endorsed.dirs&#x3D; -classpath &#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;bootstrap.jar:&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;bin&#x2F;tomcat-juli.jar -Dcatalina.base&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat -Dcatalina.home&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat -Djava.io.tmpdir&#x3D;&#x2F;app&#x2F;tools&#x2F;tomcat&#x2F;temp org.apache.catalina.startup.Bootstrap start</code></pre></div></figure><p>在windows下，通过JDK连接tomcat，模拟监控软件连接</p><blockquote><p>C:\Program Files\Java\jdk1.8.0_201\bin\jconsole.exe  </p></blockquote><p>执行：</p><p><img src="/../../../img/image-20240513142656034.png" alt="image-20240513142656034"></p><p>选择不安全连接</p><p><img src="/../../../img/image-20240513142716314.png" alt="image-20240513142716314"></p><p>连接成功</p><p><img src="/../../../img/image-20240513142730577.png" alt="image-20240513142730577"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-Web集群-Nginx(七)</title>
    <link href="/2024/05/10/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/17-web%E9%9B%86%E7%BE%A4-Nginx-7-%E5%AE%8C%E7%BB%93/"/>
    <url>/2024/05/10/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/17-web%E9%9B%86%E7%BE%A4-Nginx-7-%E5%AE%8C%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Nginx（七）完结"><a href="#Web集群-Nginx（七）完结" class="headerlink" title="Web集群-Nginx（七）完结"></a>Web集群-Nginx（七）完结</h1><p>今日内容：</p><ul><li>高可用服务，keepalived</li><li>数据加密服务，https</li></ul><h1 id="一、HA高可用服务"><a href="#一、HA高可用服务" class="headerlink" title="一、HA高可用服务"></a>一、HA高可用服务</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>HA高可用的英文全称（HighAvailablity），学习使用软件keepalived实现，</p><p>它的实现机制：</p><ul><li>多台服务器组成高可用集群，生成虚拟IP（Virtual IP）</li><li>dns解析到这个VIP地址即可</li></ul><p>高可用软件的选型：</p><table><thead><tr><th>选型</th><th>说明</th></tr></thead><tbody><tr><td>keepalived</td><td>主给备定期发数据包，判定是否活着<br> 高可用软件，负载使用，一般不涉及数据服务。</td></tr><tr><td>heartbeat</td><td>通过心跳判定<br/>高可用软件，涉及数据库，存储数据相关可以用。 heartbeat + drbd</td></tr><tr><td>商业高可用软件</td><td>RoseHA…略….</td></tr></tbody></table><h2 id="1-2-keepalived原理"><a href="#1-2-keepalived原理" class="headerlink" title="1.2 keepalived原理"></a>1.2 keepalived原理</h2><p>实现原理：</p><ul><li>keepalived是基于VRRP协议实现高可用.</li><li>VRRP虚拟路由器冗余协议，最开始是给网络设备实现高可用。</li><li>分为主、备，一般是2个节点。主备之间通过vrrp协议发送数据包沟通.</li><li>主给备定期发送数据包，备收到数据包表示主还活着，备无法收到数据包，表示主挂了，备胎转正了，接管用户请求流量.</li><li>vrrp协议使用组播的ip：224.xx.xx.xx</li></ul><h2 id="1-3-极速上手"><a href="#1-3-极速上手" class="headerlink" title="1.3 极速上手"></a>1.3 极速上手</h2><table><thead><tr><th>高可用环境准备</th><th>需要安装的服务</th><th>ip</th></tr></thead><tbody><tr><td>lb01</td><td>nginx + keepalived</td><td>10.0.0.5</td></tr><tr><td>lb02</td><td>nginx + keepalived</td><td>10.0.0.6</td></tr></tbody></table><p>部署服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># nginx repo[root@lb01[ &#x2F;var&#x2F;run]#cat &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo[nginx-stable]name&#x3D;nginx stable repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;gpgcheck&#x3D;1enabled&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.keymodule_hotfixes&#x3D;true# 安装nginx和keepalived[root@lb02[ ~]#yum install -y nginx keepalived# 启动服务systemctl enable --now keepalivedsystemctl enable --now nginx</code></pre></div></figure><p>keepalived配置文件<code>/etc/keepalived/keepalived.conf</code>，分为三部分</p><table><thead><tr><th>配置文件结构</th><th>说明</th></tr></thead><tbody><tr><td>global_defs</td><td>全局定义部分</td></tr><tr><td>vrrp_instance ⭐ ⭐ ⭐ ⭐ ⭐</td><td>vrrp协议配置,vip,主备,网卡….经常改动部分.</td></tr><tr><td>用于管理与配置lvs的部分</td><td>virtual_server部分 用于管理控制lvs的.(lvs再说)</td></tr></tbody></table><p>lb01配置如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;keepalived]#cat keepalived.conf! Configuration File for keepalived! 全局定义部分global_defs &#123;  ! 每一个keepalived的名字，当前网络中唯一  router_id lb01&#125;! vrrp实例配置部分vrrp_instance vip_3 &#123;! vrrp实例名称  state MASTER! 设置在一对主备之间使用的名字，备为BACKUP  interface ens33! 指定网卡  virtual_router_id 51! 一对主备之间的id号，统一即可  priority 100! 优先级，数字越大，优先级越高，建议备50，相差50  advert_int 1! 心跳间隔，多久发一次vrrp数据  authentication &#123;! 授权认证，保持默认即可    auth_type PASS    auth_pass 1111  &#125;  virtual_ipaddress &#123;! 设置Vip ※※※    10.0.0.3 dev ens33 label ens33:0  &#125;&#125;</code></pre></div></figure><p>lb02配置对比：</p><p><img src="/../../../img/image-20240510165558192.png" alt="image-20240510165558192"></p><p>测试：</p><p>hosts设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">10.0.0.3 blog.oldboylinux.cn</code></pre></div></figure><p>此时10.0.0.5为主，有10.0.0.3的VIP，另一台为备，没有VIP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># lb01 - IP信息[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#ip add...2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link&#x2F;ether 00:0c:29:8e:c3:71 brd ff:ff:ff:ff:ff:ff    inet 10.0.0.5&#x2F;24 brd 10.0.0.255 scope global noprefixroute ens33       valid_lft forever preferred_lft forever    inet 10.0.0.3&#x2F;32 scope global ens33:0...# lb01 - keepalived服务状态[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl status keepalivedkeepalived.service - LVS and VRRP High Availability Monitor   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;keepalived.service; enabled; vendor preset: disabled)...May 10 22:24:22 lb01 Keepalived_vrrp[26784]: Sending gratuitous ARP on ens33 for 10.0.0.3...# lb02 - IP信息[root@lb02[ &#x2F;etc&#x2F;nginx]#ip add...2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link&#x2F;ether 00:0c:29:7a:5a:37 brd ff:ff:ff:ff:ff:ff    inet 10.0.0.6&#x2F;24 brd 10.0.0.255 scope global noprefixroute ens33       valid_lft forever preferred_lft forever...# lb02 - keepalived服务状态[root@lb02[ &#x2F;etc&#x2F;nginx]#systemctl status keepalived● keepalived.service - LVS and VRRP High Availability Monitor   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;keepalived.service; enabled; vendor preset: disabled)...May 10 22:24:21 lb02 Keepalived_vrrp[20206]: VRRP_Instance(vip_3) Entering BACKUP STATEMay 10 22:24:21 lb02 Keepalived_vrrp[20206]: VRRP_Instance(vip_3) removing protocol VIPs....</code></pre></div></figure><p>测试网站访问正常（走10.0.0.3 —&gt; 10.0.0.5）</p><p><img src="/../../../img/image-20240510223153695.png" alt="image-20240510223153695"></p><p>抓包信息：</p><p><img src="/../../../img/image-20240510223914266.png" alt="image-20240510223914266"></p><p>关闭lb01的服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop nginx keepalived</code></pre></div></figure><p>测试网站仍可正常访问（走10.0.0.3 —&gt; 10.0.0.6），此时备机转正，拥有VIP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># lb02转正，拥有VIP[root@lb02[ &#x2F;etc&#x2F;nginx]#ip add...2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link&#x2F;ether 00:0c:29:7a:5a:37 brd ff:ff:ff:ff:ff:ff    inet 10.0.0.6&#x2F;24 brd 10.0.0.255 scope global noprefixroute ens33       valid_lft forever preferred_lft forever    inet 10.0.0.3&#x2F;32 scope global ens33:0       valid_lft forever preferred_lft forever...# keepalived状态[root@lb02[ &#x2F;etc&#x2F;nginx]#systemctl status keepalived● keepalived.service - LVS and VRRP High Availability Monitor   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;keepalived.service; enabled; vendor preset: disabled)   Active: active (running) since Fri 2024-05-10 22:22:45 CST; 10min ...May 10 22:33:32 lb02 Keepalived_vrrp[20206]: Sending gratuitous ARP on ens33 for 10.0.0.3...</code></pre></div></figure><p>抓包信息</p><p><img src="/../../../img/image-20240510223924312.png" alt="image-20240510223924312"></p><p>重启lb01的服务后，主回归正常</p><h2 id="1-4-keepalived的问题"><a href="#1-4-keepalived的问题" class="headerlink" title="1.4 keepalived的问题"></a>1.4 keepalived的问题</h2><h3 id="1-4-1-脑裂故障（重要）"><a href="#1-4-1-脑裂故障（重要）" class="headerlink" title="1.4.1 脑裂故障（重要）"></a>1.4.1 脑裂故障（重要）</h3><p>故障现象：主备都有vip.</p><p>原因:</p><ul><li>备认为主挂了，接管资源生成VIP，实际上主并没有挂，仍有VIP。</li><li>有很多原因可以导致脑裂：<ul><li>开启防火墙</li><li>selinux</li><li>keepalived配异常</li><li>物理线路异常等</li></ul></li></ul><p>解决方法:</p><ul><li>监控(备节点监控)，只要备节点有vip就告警。</li><li>更狠一点监控备节点只要有vip，远程控制主节点，只要备节点认为主挂了，那就让他真的挂了</li></ul><h3 id="1-4-2-keepalived基于主机的高可用软件"><a href="#1-4-2-keepalived基于主机的高可用软件" class="headerlink" title="1.4.2 keepalived基于主机的高可用软件"></a>1.4.2 keepalived基于主机的高可用软件</h3><p>问题现象：</p><ul><li>虽然现在测试keepalived生效了</li><li>但是实际上是**<font color=red>基于手动关闭lb01的keepalived服务</font>**实现的</li><li>像这种情况只会在主机挂了、网络断开后才会进行主备切换</li><li>如果仅是lb01的Nginx服务挂了，并不会触发keepalived的主备机制</li><li>这并不符合生产环境的要求。</li></ul><p>目标：</p><ul><li>某个服务关闭了，keepalived就进行主备切换</li><li>这里以nginx服务为例</li></ul><p>项目步骤：</p><ul><li>书写脚本，过滤服务进程数，端口数量，检查是否运行.</li><li>然后进行判断如果服务没有运行，则关闭keepalived.</li><li>修改keepalived配置文件，通过keepalived调用这个脚本</li></ul><p>书写脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;server&#x2F;scripts&#x2F;keep-lb.sh#!&#x2F;bin&#x2F;bash# desc: 监控nginx端口数量port_cnt&#x3D;&#96;ss -lntup | grep nginx | wc -l&#96;if [ $port_cnt -eq 0 ];then   systemctl stop keepalived;fi# 给予脚本执行权限[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#chmod a+x &#x2F;server&#x2F;scripts&#x2F;keep-lb.sh</code></pre></div></figure><p>keepalived配置文件监控</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf! Configuration File for keepalivedglobal_defs &#123;  router_id lb01&#125;! 定义监控脚本vrrp_script keep-lb.sh &#123;  script &#x2F;server&#x2F;scripts&#x2F;keep-lb.sh  interval 2  weight 1  user root&#125;vrrp_instance vip_3 &#123;  state MASTER  interface ens33  virtual_router_id 51  priority 100  advert_int 1  authentication &#123;    auth_type PASS    auth_pass 1111  &#125;  virtual_ipaddress &#123;   ! 设置Vip ※※※    10.0.0.3 dev ens33 label ens33:0  &#125;  ! 这个vrrp实例使用keep-lb.sh脚本  track_script &#123;    keep-lb.sh  &#125;&#125;</code></pre></div></figure><p>测试：</p><ul><li>lb01，lb02都开启服务，默认走lb01</li><li>关闭lb01的nginx，脚本生效，lb01的keepalived服务也stop</li><li>lb02生效，改走lb02</li><li>手动重启lb01的nginx和keepalived服务，lb01重新上线，改走lb01</li></ul><blockquote><p>个人评价：</p><p>还是不太智能，后面lb01的nginx恢复了，但是脚本没法恢复keepalived，还是要手动启服务</p></blockquote><h2 id="1-5-进阶用法"><a href="#1-5-进阶用法" class="headerlink" title="1.5 进阶用法"></a>1.5 进阶用法</h2><h3 id="1-5-1-非抢占模式"><a href="#1-5-1-非抢占模式" class="headerlink" title="1.5.1 非抢占模式"></a>1.5.1 非抢占模式</h3><p>什么是非抢占模式？</p><ul><li>keepalived主备默认是抢占式：主挂了，备接管</li><li>非抢占模式：主恢复，不希望主重新抢回资源，继续备接管。</li></ul><p>配置非抢占模式：</p><ul><li>两个节点都改为BACKUP状态</li><li>配置nopreempt选项</li></ul><p><img src="/../../../img/image-20240510230717070.png" alt="image-20240510230717070"></p><h3 id="1-5-2-双主模式"><a href="#1-5-2-双主模式" class="headerlink" title="1.5.2 双主模式"></a>1.5.2 双主模式</h3><p>应对高并发的时候设置的双主模式：</p><ul><li>设置两个VIP，互为主备</li></ul><p><img src="/../../../img/image-20240510230842673.png" alt="image-20240510230842673"></p><h1 id="二、HTTPS证书"><a href="#二、HTTPS证书" class="headerlink" title="二、HTTPS证书"></a>二、HTTPS证书</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>https是基于http的协议，在传输的时候进行加密</p><p>部署https加密的流程</p><ul><li>域名 *.jd.com <a href="http://www.jd.com/">www.jd.com</a></li><li>根据域名申请https证书(私钥与公钥(ca证书))，自己创建</li><li>进行配置web&#x2F;lb.</li></ul><p>阿里云支持的SSL证书</p><p><img src="/../../../img/image-20240511092226204.png" alt="image-20240511092226204"></p><h2 id="2-2-真实证书申请"><a href="#2-2-真实证书申请" class="headerlink" title="2.2 真实证书申请"></a>2.2 真实证书申请</h2><p>申请SSL证书需要有真实域名，freedomain域名和SSL都免费</p><h3 id="2-2-1-freedomian申请"><a href="#2-2-1-freedomian申请" class="headerlink" title="2.2.1 freedomian申请"></a>2.2.1 freedomian申请</h3><p>在freedomian：<a href="https://freedomain.one/%E5%8F%AF%E4%BB%A5%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E7%9A%84%E5%9F%9F%E5%90%8D%E3%80%81DNS%E3%80%81SSL%E8%AF%81%E4%B9%A6">https://freedomain.one/可以申请免费的域名、DNS、SSL证书</a></p><p>我申请的：gsblog.work.gd</p><p>进入SSL页面申请证书</p><p><img src="/../../../img/image-20240511101002021.png" alt="image-20240511101002021"></p><p>申请完成</p><p><img src="/../../../img/image-20240511101242798.png" alt="image-20240511101242798"></p><p>下载证书</p><p><img src="/../../../img/image-20240511101335706.png" alt="image-20240511101335706"></p><p>里面是这三个文件</p><p><img src="/../../../img/image-20240511101423902.png" alt="image-20240511101423902"></p><h3 id="2-2-2-阿里云申请"><a href="#2-2-2-阿里云申请" class="headerlink" title="2.2.2 阿里云申请"></a>2.2.2 阿里云申请</h3><p>阿里云每个账户提供20个免费域名额度，申请需要个人信息验证</p><p>进入免费域名购买页面</p><p><img src="/../../../img/image-20240511100053875.png" alt="image-20240511100053875"></p><p>输入域名，申请证书，需要提供个人信息</p><p><img src="/../../../img/image-20240511100442396.png" alt="image-20240511100442396"></p><h2 id="2-3-命令行创建https证书"><a href="#2-3-命令行创建https证书" class="headerlink" title="2.3 命令行创建https证书"></a>2.3 命令行创建https证书</h2><p>如果实在申请不到真实证书，也可以使用命令行创建一对</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#创建私钥openssl genrsa -idea -out server.key 2048#根据私钥创建 证书openssl req -days 36500 -x509 -sha256 -nodes -newkey rsa:2048 -keyout server.key -out server.crt</code></pre></div></figure><blockquote><p>这种key会触发浏览器报警，不是私密连接</p></blockquote><p><img src="/../../../img/image-20240511104318120.png" alt="image-20240511104318120"></p><h2 id="2-4-HTTPS加密流程-单台"><a href="#2-4-HTTPS加密流程-单台" class="headerlink" title="2.4 HTTPS加密流程-单台"></a>2.4 HTTPS加密流程-单台</h2><blockquote><p>注意：</p><p>申请的https证书域名要与网站域名一致才能正常使用。否则用户访问会有警告与提示  </p></blockquote><h3 id="2-4-1-部署证书"><a href="#2-4-1-部署证书" class="headerlink" title="2.4.1 部署证书"></a>2.4.1 部署证书</h3><p>将freedomain下载的证书上传到服务器中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;ssl_keys]#lsgsblog.work.gd.ll730fjv.zip[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;ssl_keys]#unzip gsblog.work.gd.ll730fjv.zipArchive:  gsblog.work.gd.ll730fjv.zip  inflating: gsblog.work.gd.cer  inflating: gsblog.work.gd.key  inflating: ca.cer</code></pre></div></figure><h3 id="2-4-2-HTTPS部署流程"><a href="#2-4-2-HTTPS部署流程" class="headerlink" title="2.4.2 HTTPS部署流程"></a>2.4.2 HTTPS部署流程</h3><p>创建子配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat gsblog.work.gd.confserver &#123;  # 端口由80改为443  listen 443 ssl;  #ssl on;  # 1.15.0以后被废弃  server_name gsblog.work.gd;  root &#x2F;app&#x2F;code&#x2F;ssl;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-access.log main;  # ssh key   ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.cer;  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.key;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>创建站点目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p &#x2F;app&#x2F;code&#x2F;sslecho &quot;ssl web page web01&quot; &gt; &#x2F;app&#x2F;code&#x2F;ssl&#x2F;index.html</code></pre></div></figure><p>配置DNS，重启服务，测试访问https成功，证书安全有效</p><p><img src="/../../../img/image-20240511102557458.png" alt="image-20240511102557458"></p><h3 id="2-4-3-HTTP跳转HTTPS"><a href="#2-4-3-HTTP跳转HTTPS" class="headerlink" title="2.4.3 HTTP跳转HTTPS"></a>2.4.3 HTTP跳转HTTPS</h3><p>有人误输入了http怎么办，为了防止不能正常访问到站点，需要设置http跳转https</p><p>子配置文件如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat gsblog.work.gd.conf# 添加80端口跳转443server &#123;  listen 80;  server_name gsblog.work.gd;  return 301 https:&#x2F;&#x2F;gsblog.work.gd$request_uri;&#125;server &#123;  # 端口由80改为443  listen 443 ssl;  #ssl on;  # 1.15.0以后被废弃  server_name gsblog.work.gd;  root &#x2F;app&#x2F;code&#x2F;ssl;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-access.log main;  # ssh key  ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.cer;  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.key;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -Lv -H Host:gsblog.work.gd http:&#x2F;&#x2F;10.0.0.7# 先到80* About to connect() to 10.0.0.7 port 80 (#0)..&gt; Host:gsblog.work.gd# 再到301跳转&lt; HTTP&#x2F;1.1 301 Moved Permanently...# 再到443* About to connect() to gsblog.work.gd port 443 (#1)*   Trying 10.0.0.7...* Connected to gsblog.work.gd (10.0.0.7) port 443 (#1)* Initializing NSS with certpath: sql:&#x2F;etc&#x2F;pki&#x2F;nssdb...</code></pre></div></figure><h2 id="2-5-网站集群HTTPS配置"><a href="#2-5-网站集群HTTPS配置" class="headerlink" title="2.5 网站集群HTTPS配置"></a>2.5 网站集群HTTPS配置</h2><p>集群HTTPS分为<em><strong>全部加密</strong></em>和<em><strong>部分加密</strong></em></p><p>全部加密：</p><ul><li>用户 —-&gt; （加密）—-&gt; lb（监听80&#x2F;443） —-&gt; （加密）—-&gt;  web（监听443）</li></ul><p>部分加密：</p><ul><li>用户 —-&gt; （加密）—-&gt; lb（监听80&#x2F;443） —-&gt;  web（监听80）</li></ul><h3 id="2-5-1-全部加密"><a href="#2-5-1-全部加密" class="headerlink" title="2.5.1 全部加密"></a>2.5.1 全部加密</h3><p>web端加密，一心一意监听443</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat gsblog.work.gd.confserver &#123;  # 端口由80改为443  listen 443 ssl;  #ssl on;  # 1.15.0以后被废弃  server_name gsblog.work.gd;  root &#x2F;app&#x2F;code&#x2F;ssl;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-access.log main;  # ssh key  ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.cer;  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.key;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>lb端加密，守住前线80&#x2F;443端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat gsblog.work.gd.conf# 资源池upstream ssl_pools &#123;  server 10.0.0.7:443;&#125;# 80跳转443server &#123;  listen 80;  server_name gsblog.work.gd;  return 301 https:&#x2F;&#x2F;gsblog.work.gd$request_uri;&#125;# 443监听server &#123;  listen 443 ssl;  server_name gsblog.work.gd;  #ssl keys  ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.cer;  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.key;  location &#x2F; &#123;    proxy_pass https:&#x2F;&#x2F;ssl_pools;    proxy_set_header Host $http_host;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Real-Ip $remote_addr;  &#125;&#125;</code></pre></div></figure><p>设置hosts，重启服务，测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -Lv -H Host:gsblog.work.gd http:&#x2F;&#x2F;10.0.0.5# 先到80* About to connect() to 10.0.0.5 port 80 (#0)...# 再301跳转&lt; HTTP&#x2F;1.1 301 Moved Permanently...# 再到443* About to connect() to gsblog.work.gd port 443 (#1)*   Trying 10.0.0.5...* Connected to gsblog.work.gd (10.0.0.5) port 443 (#1)...</code></pre></div></figure><h4 id="加配置HTTP2-0"><a href="#加配置HTTP2-0" class="headerlink" title="加配置HTTP2.0"></a>加配置HTTP2.0</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat gsblog.work.gd.conf# 资源池...# 80跳转443...# 443监听server &#123;  listen 443 ssl http2; #此处加上标记即可  server_name gsblog.work.gd;...&#125;</code></pre></div></figure><blockquote><p>提示：</p><p>这个选项在1.25.1之后已被弃用</p><p>参考：<a href="https://cloud.tencent.com/developer/article/2325511">https://cloud.tencent.com/developer/article/2325511</a></p></blockquote><h3 id="2-5-2-部分加密"><a href="#2-5-2-部分加密" class="headerlink" title="2.5.2 部分加密"></a>2.5.2 部分加密</h3><p>web端不加密，监听80，放飞自我</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat gsblog.work.gd.confserver &#123;  listen 80;  server_name gsblog.work.gd;  root &#x2F;app&#x2F;code&#x2F;ssl;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ssl-access.log main;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>lb端加密，守住前线80&#x2F;443端口，<strong>转发注意改为80&#x2F;http</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat gsblog.work.gd.confupstream ssl_pools &#123;  # 改成80端口  server 10.0.0.7:80 ;&#125;server &#123;  listen 80;  server_name gsblog.work.gd;  return 301 https:&#x2F;&#x2F;gsblog.work.gd$request_uri;&#125;server &#123;  listen 443 ssl http2;  server_name gsblog.work.gd;  #ssl keys  ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.cer;  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl_keys&#x2F;gsblog.work.gd.key;  location &#x2F; &#123;    # 转发改成http    proxy_pass http:&#x2F;&#x2F;ssl_pools;    proxy_set_header Host $http_host;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Real-Ip $remote_addr;  &#125;&#125;</code></pre></div></figure><h2 id="2-6-课后任务"><a href="#2-6-课后任务" class="headerlink" title="2.6 课后任务"></a>2.6 课后任务</h2><p>搭建网站wordpress配置https.</p><p>给lb01,lb02配置keepalived监控nginx  </p><h1 id="三、优化与监控"><a href="#三、优化与监控" class="headerlink" title="三、优化与监控"></a>三、优化与监控</h1><h2 id="3-1-优化"><a href="#3-1-优化" class="headerlink" title="3.1 优化"></a>3.1 优化</h2><p>https &#x3D;&#x3D; http over tls</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 443 ssl;  keepalive_timeout 70;    #指定ssl加密协议的版本  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;     #加密算法.需要排除算法  #排除null空算法, md5算法  ssl_ciphers AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5;   # 密钥  ssl_certificate &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;cert.pem;  ssl_certificate_key &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;cert.key;  #设置https 会话缓存  ssl_session_cache shared:SSL:10m;    #超时时间 10分钟  ssl_session_timeout 10m;... &#125;</code></pre></div></figure><h2 id="3-2-监控证书过期时间"><a href="#3-2-监控证书过期时间" class="headerlink" title="3.2 监控证书过期时间"></a>3.2 监控证书过期时间</h2><p>流程：</p><ul><li>通过命令获取证书的过期日期</li><li>与当前日期对比(30天之前)</li></ul><p>获取剩余时间的命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 获取不了[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#curl -Lv https:&#x2F;&#x2F;www.baidu.com | grep &#39;expire date&#39;# 有一些命令的输出,并非标准输出,而是作为标准错误输出[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#curl -Lv https:&#x2F;&#x2F;www.baidu.com |&amp; grep &#39;expire date&#39;*       expire date: Aug 06 01:51:05 2024 GMT</code></pre></div></figure><blockquote><p><code>|&amp; </code>表示把管道前面标准输出(正确)和标准错误输出都传递给后面的命令。如果不加，默认传递标准输出(正确)  </p></blockquote><p>编写获取检查过期时间的脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;server&#x2F;scripts]#cat check-ssl.sh#!&#x2F;bin&#x2F;bashurl&#x3D;https:&#x2F;&#x2F;www.baidu.comexpire_date_ori&#x3D;&#96;curl -vL $url |&amp; grep &#39;expire date&#39; |awk -F &#39;date:|GMT&#39; &#39;&#123;print $2&#125;&#39;&#96;expire_date_opt&#x3D;&#96;date -d &quot;$expire_date_ori&quot; +%F&#96;echo 原始格式的过期时间 $expire_date_oriecho 处理后的过期时间 $expire_date_opt# 执行[root@lb01[ &#x2F;server&#x2F;scripts]#chmod a+x check-ssl.sh[root@lb01[ &#x2F;server&#x2F;scripts]#.&#x2F;check-ssl.sh原始格式的过期时间 Aug 06 01:51:05 2024处理后的过期时间 2024-08-06</code></pre></div></figure><p>改进版</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;server&#x2F;scripts]#cat check-ssl.sh#!&#x2F;bin&#x2F;bash#author: lidao996#version: v1.0 beta#desc: 检查指定url地址 https证书过期时间url&#x3D;https:&#x2F;&#x2F;www.jd.comexpire_date_ori&#x3D;&#96;curl -vL $url |&amp; grep &#39;expire date&#39; |awk -F &#39;date:|GMT&#39; &#39;&#123;print $2&#125;&#39;&#96;expire_date_opt&#x3D;&#96;date -d &quot;$expire_date_ori&quot; +%s&#96;#当前的日期与过期时间进行相减 秒数date_now_second&#x3D;&#96;date +%s&#96;expire_days&#x3D;&#96;echo &quot;($expire_date_opt - $date_now_second)&#x2F;(60*60*24)&quot;|bc&#96;echo &quot;网站$url证书过期倒计时:还有 $expire_days 天&quot;echo &quot;网站过期日期是:&#96;date -d &quot;$expire_date_ori&quot; +%F&#96;&quot;# 执行[root@lb01[ &#x2F;server&#x2F;scripts]#.&#x2F;check-ssl.sh网站https:&#x2F;&#x2F;www.jd.com证书过期倒计时:还有 211 天网站过期日期是:2024-12-09</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16-Web集群-Nginx(六)</title>
    <link href="/2024/05/10/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/16-web%E9%9B%86%E7%BE%A4-Nginx-6/"/>
    <url>/2024/05/10/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/16-web%E9%9B%86%E7%BE%A4-Nginx-6/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Nginx（六）"><a href="#Web集群-Nginx（六）" class="headerlink" title="Web集群-Nginx（六）"></a>Web集群-Nginx（六）</h1><p>今日内容：</p><ol><li>常见负载均衡轮询算法（面试会问）</li><li>rewriter规则</li></ol><h1 id="一、轮询算法"><a href="#一、轮询算法" class="headerlink" title="一、轮询算法"></a>一、轮询算法</h1><p>什么是轮询算法？</p><ul><li>决定负载均衡如何把请求分发给后端节点</li><li>这种分发的方式就是轮询算法</li></ul><h2 id="1-1-常见轮询算法"><a href="#1-1-常见轮询算法" class="headerlink" title="1.1 常见轮询算法"></a>1.1 常见轮询算法</h2><table><thead><tr><th>轮询算法</th><th>说明</th></tr></thead><tbody><tr><td>rr轮询</td><td>round robin 轮询,默认的循环访问.</td></tr><tr><td>wrr</td><td>加权轮询，在轮询的基础上增加权重功能。 <br/>server中的weight就是加权轮询。</td></tr><tr><td>ip_hash</td><td>ip哈希，只要客户端ip一样，就会一直访问同一个后端节点.(用户请求与web服务器绑定)<br/>用于解决会话保持&#x2F;会话共享。 <br/>可能导致负载不均。</td></tr><tr><td>xxx_hash</td><td>如url_hash<br/>只要用户访问的url相同&#x2F;uri相同,就访问相同的web服务器. <br/>用于缓存服务器：静态资源缓存</td></tr><tr><td>least_conn;</td><td>最小连接数，lc算法。<br/> 也可以配合上权重 weight, wlc权重的最小连接数</td></tr><tr><td>一致性hash算法</td><td>自己研究</td></tr></tbody></table><h2 id="1-2-轮询算法实现案例"><a href="#1-2-轮询算法实现案例" class="headerlink" title="1.2 轮询算法实现案例"></a>1.2 轮询算法实现案例</h2><h3 id="1-2-1-ip-hash"><a href="#1-2-1-ip-hash" class="headerlink" title="1.2.1 ip_hash"></a>1.2.1 ip_hash</h3><p>lb01配置如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat phpmyadmin.oldboylinux.cn.confupstream phpmyadmin_spools&#123;  # 开启ip hash  ip_hash;  server 10.0.0.7:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;  server 10.0.0.8:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;&#125;...</code></pre></div></figure><h3 id="1-2-2-url-hash"><a href="#1-2-2-url-hash" class="headerlink" title="1.2.2 url_hash"></a>1.2.2 url_hash</h3><p>lb01配置如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat phpmyadmin.oldboylinux.cn.confupstream phpmyadmin_spools&#123;  # 开启url hash  hash $request_uri;  server 10.0.0.7:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;  server 10.0.0.8:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;&#125;...</code></pre></div></figure><blockquote><p>补充：</p><p>hash算法下，一台机器宕机，会报错吗？</p><ul><li>不会报错，会切换到另外的机器上</li></ul></blockquote><h1 id="二、负载均衡状态检查"><a href="#二、负载均衡状态检查" class="headerlink" title="二、负载均衡状态检查"></a>二、负载均衡状态检查</h1><p>主要内容：</p><ul><li>掌握负载均衡状态检查模块的使用 — 基于Tengine</li><li>需要使用到第三方中间件（Tengine），编译安装，生成nginx命令文件</li><li>用tengine源码编译生成的nginx文件替换原来的nginx</li></ul><p>步骤：</p><ul><li>找一台<font color=red>db01</font>(无ngx即可)，编译tengine</li><li>生成ngx命令，替代lb上ngx的命令即可</li></ul><blockquote><p>tengine是什么？</p><ul><li>Tengine是阿里基于Nginx二次开发的高性能HTTP服务器</li><li>它把ngx常用的第3方模块放在了源代码中的modules目录下面，</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;# 编译安装的时候增加upstream_check模块&gt;--add-module&#x3D;modules&#x2F;ngx_http_upstream_check_module&gt;# 增加会话共享模块&gt;--add-module&#x3D;modules&#x2F;ngx_http_upstream_session_sticky_module&#x2F;</code></pre></div></figure></blockquote><h2 id="2-1-编译tengine"><a href="#2-1-编译tengine" class="headerlink" title="2.1 编译tengine"></a>2.1 编译tengine</h2><p>下载tengine代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;tengine.taobao.org&#x2F;download&#x2F;tengine-3.1.0.tar.gz</code></pre></div></figure><p>安装依赖</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y pcre* openssl-devel</code></pre></div></figure><p>编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># configure.&#x2F;configure --prefix&#x3D;&#x2F;etc&#x2F;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.lock --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt&#x3D;&#39;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fexceptions -fstack-protector-strong --param&#x3D;ssp-buffer-size&#x3D;4 -grecord-gcc-switches -m64 -mtune&#x3D;generic -fPIC&#39; --with-ld-opt&#x3D;&#39;-Wl,-z,relro -Wl,-z,now -pie&#39; --add-module&#x3D;modules&#x2F;ngx_http_upstream_check_module --add-module&#x3D;modules&#x2F;ngx_http_upstream_session_sticky_module&#x2F;# 编译make -j 2</code></pre></div></figure><p>编译完成不需要install安装，检查编译后生成的命令即可  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;objs&#x2F;nginx -VTengine version: Tengine&#x2F;3.1.0nginx version: nginx&#x2F;1.24.0</code></pre></div></figure><h2 id="2-2-替换nginx命令"><a href="#2-2-替换nginx命令" class="headerlink" title="2.2 替换nginx命令"></a>2.2 替换nginx命令</h2><p>把在db01编译出的tengine-nginx命令文件，替换到lb01中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 停止服务systemctl stop nginx# 复制过去[root@db01[ &#x2F;server&#x2F;tools&#x2F;tengine-3.1.0&#x2F;objs]#scp nginx 10.0.0.5:&#x2F;root&#x2F;# lb01备份[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#nginx -versionnginx version: nginx&#x2F;1.26.0[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#mv &#x2F;sbin&#x2F;nginx &#x2F;sbin&#x2F;nginx-1.26.0# 替换[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#mv &#x2F;root&#x2F;nginx &#x2F;sbin&#x2F;nginx[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#nginx -versionTengine version: Tengine&#x2F;3.1.0nginx version: nginx&#x2F;1.24.0# 检查[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful# 重启服务[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl restart nginx[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#ps -ef | grep nginxroot      24239      1  0 11:32 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.confnginx     24240  24239  0 11:32 ?        00:00:00 nginx: worker processroot      24242   2618  0 11:32 pts&#x2F;0    00:00:00 grep --color&#x3D;auto nginx</code></pre></div></figure><h2 id="2-3-tengine-chek说明"><a href="#2-3-tengine-chek说明" class="headerlink" title="2.3 tengine chek说明"></a>2.3 tengine chek说明</h2><blockquote><p>根据官方案例进行配置：</p><p><a href="https://tengine.taobao.org/document_cn/http_upstream_check_cn.html">https://tengine.taobao.org/document_cn/http_upstream_check_cn.html</a>  </p></blockquote><p>各选项说明：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http &#123;    upstream cluster1 &#123;        # simple round-robin        server 192.168.0.1:80;        server 192.168.0.2:80;        # curl命令访问：curl -I        # 超时检测：进行1000ms的超时检测, 成功2次，判定为存活，失败5次判定为失效        check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;        # 请求方法URI（uri最好反应业务是否正常，找开发写个页面）        check_http_send &quot;HEAD &#x2F; HTTP&#x2F;1.0\r\n\r\n&quot;;                # 认为是成功的状态码 2xx 3xx        check_http_expect_alive http_2xx http_3xx;    &#125;    upstream cluster2 &#123;        # simple round-robin        server 192.168.0.3:80;        server 192.168.0.4:80;        check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;        check_keepalive_requests 100;        check_http_send &quot;HEAD &#x2F; HTTP&#x2F;1.1\r\nConnection: keep-alive\r\n\r\n&quot;;        check_http_expect_alive http_2xx http_3xx;    &#125;    server &#123;        listen 80;        location &#x2F;1 &#123;            proxy_pass http:&#x2F;&#x2F;cluster1;        &#125;        location &#x2F;2 &#123;            proxy_pass http:&#x2F;&#x2F;cluster2;        &#125;        location &#x2F;status &#123;            check_status;            access_log   off;            # 白名单            allow SOME.IP.ADD.RESS;            deny all;        &#125;    &#125;&#125;</code></pre></div></figure><p>表格如下：</p><table><thead><tr><th>upstream_check模块指令说明</th><th></th></tr></thead><tbody><tr><td>check</td><td>指定检查频率,失败几次,成功几次,检查间隔,检查方式</td></tr><tr><td>check_http_send</td><td>通过http方式发出请求报文,请求报文起始行,请求方法,请求的URI,请求协议(默认使用的是ip方式 访问.)</td></tr><tr><td>check_http_expect_alive</td><td>收到指定的状态码,就认为是存活的.</td></tr><tr><td>check_status;</td><td>开启负载均衡状态检查功能,web页面.location 使用 如果加强安全.</td></tr></tbody></table><h2 id="2-4-配置tengine-check"><a href="#2-4-配置tengine-check" class="headerlink" title="2.4 配置tengine check"></a>2.4 配置tengine check</h2><p>配置文件如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat lb.oldboylinux.cn.confupstream lb_pools &#123;  server 10.0.0.7:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;  server 10.0.0.8:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;  check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;  check_http_send &quot;HEAD &#x2F; HTTP&#x2F;1.0\r\n\r\n&quot;;  check_http_expect_alive http_2xx http_3xx;&#125;server &#123;  listen 80;  server_name lb.oldboylinux.cn;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;lb-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;lb-access.log main;  location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;lb_pools;    proxy_set_header Host $http_host;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &#125;  location &#x2F;lb_status &#123;    check_status;    access_log off;    allow 10.0.0.1;    allow 10.0.0.0&#x2F;24;    deny all;  &#125;&#125;</code></pre></div></figure><h2 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h2><p>重新加载nginx服务，访问测试页面：<a href="http://lb.oldboylinux.cn/lb_status">http://lb.oldboylinux.cn/lb_status</a></p><p><img src="/../../../img/image-20240510114628339.png" alt="image-20240510114628339"></p><blockquote><p>注意: 如果后端web有多个虚拟主机</p><p>upstream check进行访问的时候默认使用的ip方式进行访问.</p><p>在发出http请求的时候指定域名</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;check_http_send &quot;HEAD &#x2F; HTTP&#x2F;1.0\r\nHost: lb.oldboylinux.cn\r\n\r\n&quot; ;</code></pre></div></figure></blockquote><h1 id="三、Nginx平滑升级案例"><a href="#三、Nginx平滑升级案例" class="headerlink" title="三、Nginx平滑升级案例"></a>三、Nginx平滑升级案例</h1><p>平滑升级的步骤</p><table><thead><tr><th>平滑更新步骤</th><th>说明</th></tr></thead><tbody><tr><td>1、准备好新的nginx命令(已经测试的)</td><td></td></tr><tr><td>2、把当前环境的nginx的命令备份,使用新的替换.</td><td></td></tr><tr><td>3、通过kill命令向当前运行ngx发出信号,准备被替代 -USR2 pid</td><td>把当前运行ngx的pid文件改个名 使用新的nginx命令启动ngx进程</td></tr><tr><td>4、测试调试,关闭旧的ngx的进程即可.(kill即可.)</td><td></td></tr></tbody></table><p>找一台负载均衡服务器（lb01），执行操作</p><h2 id="2-1-检查当前环境"><a href="#2-1-检查当前环境" class="headerlink" title="2.1 检查当前环境"></a>2.1 检查当前环境</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Nginx版本[root@lb01[ &#x2F;]#nginx -vnginx version: nginx&#x2F;1.26.0# 启动nginx[root@lb01[ &#x2F;]#systemctl start nginx[root@lb01[ &#x2F;]#ps -ef | grep ngxinroot      24726   2618  0 13:55 pts&#x2F;0    00:00:00 grep --color&#x3D;auto ngxin[root@lb01[ &#x2F;]#ps -ef | grep nginxroot      24239      1  0 11:32 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.confnginx     24300  24239  0 11:45 ?        00:00:01 nginx: worker processroot      24728   2618  0 13:55 pts&#x2F;0    00:00:00 grep --color&#x3D;auto nginx# 查看pid[root@lb01[ &#x2F;]#ll &#x2F;var&#x2F;run&#x2F;nginx.pid-rw-r--r--. 1 root root 6 May 10 10:20 &#x2F;var&#x2F;run&#x2F;nginx.pid[root@lb01[ &#x2F;]#ll &#x2F;var&#x2F;run&#x2F;nginx.pid*-rw-r--r--. 1 root root 6 May 10 10:20 &#x2F;var&#x2F;run&#x2F;nginx.pid[root@lb01[ &#x2F;]#cat &#x2F;var&#x2F;run&#x2F;nginx.pid24239</code></pre></div></figure><h2 id="2-2-升级nginx"><a href="#2-2-升级nginx" class="headerlink" title="2.2 升级nginx"></a>2.2 升级nginx</h2><p>替换新老nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 备份旧的Nginx[root@lb01[ &#x2F;]#mv &#x2F;sbin&#x2F;nginx &#x2F;sbin&#x2F;nginx-v.1.26.0# 将新的nginx拷贝进去[root@lb01[ &#x2F;]#mv &#x2F;root&#x2F;tengine-nginx &#x2F;sbin&#x2F;nginx# 检查替换后的信息[root@lb01[ &#x2F;]#nginx -vTengine version: Tengine&#x2F;3.1.0nginx version: nginx&#x2F;1.24.0</code></pre></div></figure><p>PID相关处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 准备新老交替[root@lb01[ &#x2F;]#kill -USR2 &#96;cat &#x2F;var&#x2F;run&#x2F;nginx.pid&#96;# 会生成一个新的Pid文件，并重命名旧的PID文件[root@lb01[ &#x2F;var&#x2F;run]#ll &#x2F;var&#x2F;run&#x2F;nginx.pid*-rw-r--r--. 1 root root 6 May 10 13:42 &#x2F;var&#x2F;run&#x2F;nginx.pid-rw-r--r--. 1 root root 6 May 10 13:41 &#x2F;var&#x2F;run&#x2F;nginx.pid.oldbin# 查看oldbin里面的PID[root@lb01[ &#x2F;var&#x2F;run]#cat &#x2F;var&#x2F;run&#x2F;nginx.pid.oldbin24239# 查看现在的nginx进程[root@lb01[ &#x2F;var&#x2F;run]#ps -ef | grep nginxroot      24239      1  0 11:32 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.confnginx     24300  24239  0 11:45 ?        00:00:02 nginx: worker processroot      24740  24239  0 13:57 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.confnginx     24741  24740  0 13:57 ?        00:00:00 nginx: worker processroot      24770   2618  0 13:58 pts&#x2F;0    00:00:00 grep --color&#x3D;auto nginx# 干掉与PID对应的进程号[root@lb01[ &#x2F;var&#x2F;run]#kill 24239[root@lb01[ &#x2F;var&#x2F;run]#ps -ef | grep nginxroot      24740      1  0 13:57 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.confnginx     24741  24740  0 13:57 ?        00:00:00 nginx: worker processroot      24772   2618  0 13:59 pts&#x2F;0    00:00:00 grep --color&#x3D;auto nginx# 新的PID已生效[root@lb01[ &#x2F;var&#x2F;run]#ss -lntup | grep 80tcp    LISTEN     0      128       *:80                    *:*                   users:((&quot;nginx&quot;,pid&#x3D;24741,fd&#x3D;14),(&quot;nginx&quot;,pid&#x3D;24740,fd&#x3D;14))[root@lb01[ &#x2F;var&#x2F;run]#cat &#x2F;var&#x2F;run&#x2F;nginx.pid24740</code></pre></div></figure><h1 id="四、Nginx重定向功能"><a href="#四、Nginx重定向功能" class="headerlink" title="四、Nginx重定向功能"></a>四、Nginx重定向功能</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>重定向（rewrite），也叫URL重定向，也叫URL改写</p><p>用于未来的需求：</p><ul><li>1、URL重定向：网站是http(80) —&gt; https(443) <ul><li>用户<a href="http://www.baidu.com/">http://www.baidu.com</a> —&gt; <a href="https://www.baidu.com/">https://www.baidu.com/</a></li></ul></li><li>2、根据客户端访问类型进行跳转（如客户端类型）<ul><li>如果用户的客户端是ios,iphone,android,访问m.oldboyedu.com</li><li>否则默认访问<a href="http://www.oldboyedu.com/">www.oldboyedu.com</a></li></ul></li><li>3、新老域名跳转: <a href="http://www.360buy.com/">www.360buy.com</a> —-&gt; jd.com</li><li>4、需要我们调整url格式：改成伪静态(方便搜索引擎收入) ，满足运营要求<ul><li><a href="http://www.oldboylinux.cn/index.php">www.oldboylinux.cn/index.php</a></li><li>原站点：<a href="https://docs.qq.com/desktop/mydoc/folder/RvMUOloshpGc?u=159d26a006074197b7a526a51aa28f55">https://docs.qq.com/desktop/mydoc/folder/RvMUOloshpGc?u=159d26a006074197b7a526a51aa28f55</a></li><li>伪静态：<a href="https://docs.qq.com/desktop/mydoc/folder/RvMUOloshpGc-159d26a006074197b7a526a51aa28f55.html">https://docs.qq.com/desktop/mydoc/folder/RvMUOloshpGc-159d26a006074197b7a526a51aa28f55.html</a></li></ul></li></ul><h2 id="4-2-重定向模块的指令"><a href="#4-2-重定向模块的指令" class="headerlink" title="4.2 重定向模块的指令"></a>4.2 重定向模块的指令</h2><table><thead><tr><th>相关的指令</th><th>说明</th></tr></thead><tbody><tr><td>return</td><td>实现对url的改写,一般与ngx变量一起使用，返回指定的状态码.</td></tr><tr><td>rewrite</td><td>实现对url的改写，使用正则匹配uri，进行改写.，还有各种标记.</td></tr><tr><td>set</td><td>创建或修改ngx变量.</td></tr><tr><td>if</td><td>判断,一般与ngx变量一起使用.</td></tr></tbody></table><h3 id="4-2-1-return指令"><a href="#4-2-1-return指令" class="headerlink" title="4.2.1 return指令"></a>4.2.1 return指令</h3><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>格式1</td><td>return code URL;返回状态码+新的url地址.</td></tr><tr><td>格式2</td><td>return code; 返回指定状态码.</td></tr><tr><td>放哪</td><td>server、location、if</td></tr></tbody></table><h4 id="案例01：返回状态码"><a href="#案例01：返回状态码" class="headerlink" title="案例01：返回状态码"></a>案例01：返回状态码</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 子配置文件[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat rewrite.oldboylinux.cn.confserver &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite;  charset utf8;  location &#x2F; &#123;    index index.html;  &#125;  location &#x2F;admin&#x2F; &#123;    # 重定向    return 403;  &#125;&#125;# 创建对应站点目录[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#mkdir &#x2F;app&#x2F;code&#x2F;rewrite[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#echo &quot;重定向测试页面&quot; &gt;&#x2F;app&#x2F;code&#x2F;rewrite&#x2F;index.html# 重启服务[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl reload nginx</code></pre></div></figure><blockquote><p>return 403</p><p>所有人禁止访问&#x2F;admin&#x2F;页面.  </p></blockquote><p>命令行测试：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7重定向测试页面[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;admin&#x2F;&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.26.0&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>浏览器测试：</p><p>访问：<a href="http://rewrite.oldboylinux.cn/">http://rewrite.oldboylinux.cn/</a></p><p><img src="/../../../img/image-20240510152227461.png" alt="image-20240510152227461"></p><p>访问：<a href="http://rewrite.oldboylinux.cn/admin">http://rewrite.oldboylinux.cn/admin</a></p><p><img src="/../../../img/image-20240510152504420.png" alt="image-20240510152504420"></p><h4 id="案例02：域名间跳转"><a href="#案例02：域名间跳转" class="headerlink" title="案例02：域名间跳转"></a>案例02：域名间跳转</h4><p>用户访问<a href="http://rewrite.oldboylinux.cn/admin/%E8%B7%B3%E8%BD%AC%E5%88%B0www.baidu.com">http://rewrite.oldboylinux.cn/admin/跳转到www.baidu.com</a>  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite;  charset utf8;  location &#x2F; &#123;    index index.html;  &#125;  location &#x2F;admin&#x2F; &#123;    # 重定向    return 301 https:&#x2F;&#x2F;www.baidu.com;  &#125;&#125;</code></pre></div></figure><p>也可以访问<a href="http://rewrite.oldboylinux.cn就跳转到www.baidu.com/">http://rewrite.oldboylinux.cn就跳转到www.baidu.com</a>  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  return 301 https:&#x2F;&#x2F;www.baidu.com;&#125;</code></pre></div></figure><p>curl命令行测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -Lv -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;admin&#x2F;# 先到rewrite.oldboylinux.cn* About to connect() to 10.0.0.7 port 80 (#0)...&gt; Host:rewrite.oldboylinux.cn&gt;# 再301跳转&lt; HTTP&#x2F;1.1 301 Moved Permanently&lt; Server: nginx&#x2F;1.26.0&lt; Date: Fri, 10 May 2024 07:31:06 GMT&lt; Content-Type: text&#x2F;html&lt; Content-Length: 169&lt; Connection: keep-alive&lt; Location: https:&#x2F;&#x2F;www.baidu.com...# 再到baidu&gt; GET &#x2F; HTTP&#x2F;1.1&gt; User-Agent: curl&#x2F;7.29.0&gt; Host: www.baidu.com&gt; Accept: *&#x2F;*&gt;&lt; HTTP&#x2F;1.1 200 OK&lt; Accept-Ranges: bytes...&lt;title&gt;百度一下，你就知道&lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &lt;body ...* Connection #1 to host www.baidu.com left intact</code></pre></div></figure><blockquote><p>curl -L –location 跟随跳转：</p><p>响应是301、302跳转的时候使用  </p></blockquote><h4 id="案例03：http跳转https（TODO）"><a href="#案例03：http跳转https（TODO）" class="headerlink" title="案例03：http跳转https（TODO）"></a>案例03：http跳转https（TODO）</h4><p>完整流程等讲完https再说，大致如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  return 302  https:&#x2F;&#x2F;rewrite.oldboylinux.cn$request_uri;&#125;server &#123;  listen 443 ssl;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite&#x2F;;  私钥  公钥(证书)  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><h3 id="4-2-2-if指令"><a href="#4-2-2-if指令" class="headerlink" title="4.2.2 if指令"></a>4.2.2 if指令</h3><p>if可以用于进行判断，配合ngx中的变量使用：</p><ul><li>可以比大小.</li><li>也可以进行等于,不等于.</li><li>也可以进行匹配(过滤).</li></ul><p>格式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">if (条件) &#123;满足条件执行的内容.&#125;</code></pre></div></figure><p>可以放在：</p><ul><li>server、location</li></ul><p>可以使用的符号：</p><ul><li>常用<code>~, ~*, !~, !~*</code>匹配正则</li><li><code>~</code>大小写敏感，<code>~*</code>大小写不敏感</li><li>ngx取反,排除,只能用if</li></ul><h4 id="案例01：限定请求方法"><a href="#案例01：限定请求方法" class="headerlink" title="案例01：限定请求方法"></a>案例01：限定请求方法</h4><p>rewrite.oldboylinux.cn 网站只准许GET、POST这2种请求方法，其他访问禁止访问  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat rewrite.oldboylinux.cn.confserver &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite;  charset utf8;  if ($request_method !~ &quot;GET|POST&quot;) &#123;    return 403;  &#125;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># GET请求正常[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;重定向测试页面# HEAD请求失败[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -I -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;HTTP&#x2F;1.1 403 ForbiddenServer: nginx&#x2F;1.26.0Date: Fri, 10 May 2024 07:45:10 GMTContent-Type: text&#x2F;html; charset&#x3D;utf8Content-Length: 153Connection: keep-alive</code></pre></div></figure><h3 id="4-2-3-set指令"><a href="#4-2-3-set指令" class="headerlink" title="4.2.3 set指令"></a>4.2.3 set指令</h3><p>用于自己创建或修改ngx变量 ，一般与<code>if</code>搭配使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#shell变量写法oldboy&#x3D;666echo $oldboy#ngx中变量写法，进行赋值与进行使用都需要加上$符号set $变量 值;set $lidao 996;</code></pre></div></figure><h4 id="案例01：基本使用"><a href="#案例01：基本使用" class="headerlink" title="案例01：基本使用"></a>案例01：基本使用</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat rewrite.oldboylinux.cn.confserver &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite;  charset utf8;  set $oldboy &quot;lidao996&quot;;  return 200 $oldboy;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 内容变成变量值了[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;lidao996</code></pre></div></figure><p>可以根据变量显示网站uri</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#!catcat rewrite.oldboylinux.cn.confserver &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite;  charset utf8;  # 变量设置成uri  set $oldboy $http_host$request_uri;  return 200 $oldboy;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>测试访问，显示输入的uri</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;rewrite.oldboylinux.cn&#x2F;[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;adminrewrite.oldboylinux.cn&#x2F;admin[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;testrewrite.oldboylinux.cn&#x2F;test</code></pre></div></figure><h4 id="案例02：设置网站维护状态"><a href="#案例02：设置网站维护状态" class="headerlink" title="案例02：设置网站维护状态"></a>案例02：设置网站维护状态</h4><p>设置网站是否为维护状态：</p><ul><li>如果维护状态，返回503状态码</li><li>否则正常访问</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite;  charset utf8  set $flag 0;  #include conf.d&#x2F;rewrite-status.var;  if ( $flag &#x3D; 1 ) &#123;    return 503;  &#125;    location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>变量文件可以单独写到一个文件中，再导入</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat rewrite-status.flagset $flag 0;# 导入[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat rewrite.oldboylinux.cn.confserver &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite;  charset utf8;  # 导入  include conf.d&#x2F;rewrite-status.flag;    # 判断  if  ($flag &#x3D; 1) &#123;    return 503;  &#125;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;重定向测试页面# 中间修改flag的值，reload ngx服务[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;&lt;html&gt;&lt;head&gt;&lt;title&gt;503 Service Temporarily Unavailable&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;503 Service Temporarily Unavailable&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.26.0&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h3 id="4-2-4-rewrite指令"><a href="#4-2-4-rewrite指令" class="headerlink" title="4.2.4 rewrite指令"></a>4.2.4 rewrite指令</h3><p>rewrite正则用于匹配用户请求的uri.</p><p>命令的格式与<code>sed &#39;s###g&#39;</code>类似，实现替换功能，rewrite替换url内容.(改写)</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>格式</td><td>rewrite 找什么(具体内容&#x2F;正则&#x2F;保护分组) 替换成什么(具体内容,后向引用) [标记]; 标记可以省略,默认使用 redirect标记(302)</td></tr><tr><td>放在哪里</td><td>server , location , if</td></tr><tr><td>⚠</td><td>rewrite匹配的内容,匹配uri.</td></tr></tbody></table><p>rewrite的301，302标记</p><table><thead><tr><th>rewrite的301,302标记</th><th></th></tr></thead><tbody><tr><td>redirect</td><td>302</td></tr><tr><td>permanent</td><td>301</td></tr></tbody></table><h4 id="案例01：域名跳转"><a href="#案例01：域名跳转" class="headerlink" title="案例01：域名跳转"></a>案例01：域名跳转</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  rewrite ^(.*)$ http:&#x2F;&#x2F;www.baidu.com$1;&#125;</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02[ &#x2F;etc&#x2F;php-fpm.d]#curl -Lv -H Host:rewrite.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7...&gt; Host:rewrite.oldboylinux.cn&gt;&lt; HTTP&#x2F;1.1 302 Moved Temporarily...&lt; HTTP&#x2F;1.1 200 OK&lt; Accept-Ranges: bytes...&lt;title&gt;百度一下，你就知道&lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &lt;body link&#x3D;#0000cc&gt; &lt;div ...</code></pre></div></figure><h4 id="案例02：http跳转https（TODO）"><a href="#案例02：http跳转https（TODO）" class="headerlink" title="案例02：http跳转https（TODO）"></a>案例02：http跳转https（TODO）</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 80;  server_name rewrite.oldboylinux.cn;  #return 302 https:&#x2F;&#x2F;rewrite.oldboylinux.cn$request_uri;  rewrite ^(.*)$ https:&#x2F;&#x2F;rewrite.oldboylinux.cn$1 ;  #302&#125;server &#123;  listen 443 ssl;  server_name rewrite.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;rewrite&#x2F;;  私钥  公钥(证书)  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><h4 id="案例03：rewrite的各种标记"><a href="#案例03：rewrite的各种标记" class="headerlink" title="案例03：rewrite的各种标记"></a>案例03：rewrite的各种标记</h4><table><thead><tr><th>标记</th><th>说明</th><th>补充</th></tr></thead><tbody><tr><td>redirect</td><td>302 临时 用户访问的时候,收到302提示及新的位置Location(响应头),用户根据 Location新的位置进行访问(让用户重新发出http请求)</td><td>新旧地址都可以用.</td></tr><tr><td>permanent</td><td>301 永久 用户访问的时候,收到302提示及新的位置Location(响应头),用户根据 Location新的位置进行访问(让用户重新发出http请求)</td><td>旧的地址排名取消,旧地旧的 不用了,只用新的网站.</td></tr><tr><td>break</td><td>用户的请求匹配到包含break指令或rewrite规则后,及时后面还有location规则, 不会继续运行.终止运行.</td><td></td></tr><tr><td>last</td><td>用户请求匹配到包含last标记的rewrite规则后,停止继续执行,ngx会重新发出内部请求,请求与location规则进行匹配.</td><td>开启ngx rewrite_log才能看到</td></tr></tbody></table><p>rewrite标记使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 子配置文件server &#123;  listen 80;  server_name flag.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;flag;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;flag-error.log notice;  rewrite_log on; #需要错误日志debug ՎՎʢ notice  location &#x2F; &#123;    # 匹配到了，继续执行    rewrite &#x2F;1.html &#x2F;2.html ;    # 匹配到了，继续执行    rewrite &#x2F;2.html &#x2F;3.html ;  &#125;  location &#x2F;2.html &#123;    # 匹配到了，继续执行    rewrite &#x2F;2.html &#x2F;3.html ;  &#125;  location &#x2F;3.html &#123;    # 匹配到了，继续执行    rewrite &#x2F;3.html &#x2F;a.html ;  &#125;&#125;# 准备文件echo 1.html url &gt;&#x2F;app&#x2F;code&#x2F;flag&#x2F;1.htmlecho 2.html url &gt;&#x2F;app&#x2F;code&#x2F;flag&#x2F;2.htmlecho 3.html url &gt;&#x2F;app&#x2F;code&#x2F;flag&#x2F;3.htmlecho a.html url &gt;&#x2F;app&#x2F;code&#x2F;flag&#x2F;a.htmlecho b.html url &gt;&#x2F;app&#x2F;code&#x2F;flag&#x2F;b.html</code></pre></div></figure><p>测试rewrite：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.访问&#x2F;1.html显示a.html内容[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# curl -H Host:flag.oldboylinux.cn 10.0.0.7&#x2F;1.htmla.html url# 2.访问&#x2F;2.html显示a.html内容[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# curl -H Host:flag.oldboylinux.cn 10.0.0.7&#x2F;2.htmla.html url</code></pre></div></figure><p>break标记使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 3. 在rewrite &#x2F;1.html &#x2F;2.html的时候加上标记break标记.# rewrite &#x2F;1.html &#x2F;2.html break; 执行完成rewrite后会直接结束server &#123;  listen 80;  server_name flag.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;flag;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;flag-error.log notice;  rewrite_log on; #需要错误日志debug ... notice  location &#x2F; &#123;    # 匹配到了，执行，遇到break，停止    rewrite &#x2F;1.html &#x2F;2.html break;    rewrite &#x2F;2.html &#x2F;3.html ;  &#125;  location &#x2F;2.html &#123;    rewrite &#x2F;2.html &#x2F;3.html ;  &#125;  location &#x2F;3.html &#123;    rewrite &#x2F;3.html &#x2F;a.html ;  &#125;&#125;</code></pre></div></figure><p>测试break，跳转到2.html就结束了</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# curl -H Host:flag.oldboylinux.cn 10.0.0.7&#x2F;1.html2.html url</code></pre></div></figure><p>last标记使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 4. 在rewrite &#x2F;1.html &#x2F;2.html的时候加上标记last标记。注意这一步修改下配置文件,创建新的页面b.html[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# cat flag.oldboylinux.cn.confserver &#123;  listen 80;  server_name flag.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;flag;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;flag-error.log notice;  rewrite_log on; #需要错误日志debug ... notice  location &#x2F; &#123;    # 匹配到了，执行，遇到last，暂停，内部重新发起请求    rewrite &#x2F;1.html &#x2F;2.html last;    rewrite &#x2F;2.html &#x2F;3.html ;  &#125;  location &#x2F;2.html &#123;    # 收到内部发起的请求，继续处理    rewrite &#x2F;2.html &#x2F;b.html ;  &#125;  location &#x2F;3.html &#123;    rewrite &#x2F;3.html &#x2F;a.html ;  &#125;&#125;</code></pre></div></figure><p>last标记测试，重新发送请求，至b.html结束</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# curl -H Host:flag.oldboylinux.cn 10.0.0.7&#x2F;1.htmlb.html url</code></pre></div></figure><h1 id="五、Nginx总结"><a href="#五、Nginx总结" class="headerlink" title="五、Nginx总结"></a>五、Nginx总结</h1><p><a href="https://www.processon.com/view/link/63e992c0d0902d35a13e18a1">https://www.processon.com/view/link/63e992c0d0902d35a13e18a1</a> </p><p>访问密码：oldboylidao996  </p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15-Web集群-Nginx(五)</title>
    <link href="/2024/05/09/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/15-web%E9%9B%86%E7%BE%A4-Nginx-5/"/>
    <url>/2024/05/09/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/15-web%E9%9B%86%E7%BE%A4-Nginx-5/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Nginx（五）"><a href="#Web集群-Nginx（五）" class="headerlink" title="Web集群-Nginx（五）"></a>Web集群-Nginx（五）</h1><p>今日内容：</p><ol><li>反向代理 vs 负载均衡区别</li><li>wordpress动态网站接入到负载均衡</li><li>其他负载案例</li></ol><h1 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h1><h2 id="1-1-Nginx处理用户请求流程"><a href="#1-1-Nginx处理用户请求流程" class="headerlink" title="1.1 Nginx处理用户请求流程"></a>1.1 Nginx处理用户请求流程</h2><p>处理用户请求流程，静态，无负载</p><p><img src="/../../../img/image-20240509165111273.png" alt="image-20240509165111273"></p><p>处理用户请求流程，动态，无负载</p><p><img src="/../../../img/image-20240509165153838.png" alt="image-20240509165153838"></p><h2 id="1-2-负载均衡处理用户请求流程"><a href="#1-2-负载均衡处理用户请求流程" class="headerlink" title="1.2 负载均衡处理用户请求流程"></a>1.2 负载均衡处理用户请求流程</h2><p>参考：<a href="https://www.processon.com/view/link/619d93310e3e74287fe4e3de">https://www.processon.com/view/link/619d93310e3e74287fe4e3de</a></p><h1 id="二、负载均衡补充"><a href="#二、负载均衡补充" class="headerlink" title="二、负载均衡补充"></a>二、负载均衡补充</h1><h2 id="2-1-负载均衡-VS-反向代理"><a href="#2-1-负载均衡-VS-反向代理" class="headerlink" title="2.1 负载均衡 VS 反向代理"></a>2.1 负载均衡 VS 反向代理</h2><blockquote><p>一般出现在面试中,如果不是一般认为这两个是一致的.</p><p>区别在于处理用户请求的方式.  </p></blockquote><table><thead><tr><th>内容</th><th>共同点</th><th>区别</th><th>服务</th></tr></thead><tbody><tr><td>负载 均衡</td><td>用户的请求分发到 后端节点上.</td><td>用户—&gt;lb—-&gt;web lb负载均衡做的是数据转发,不会产生新的请求. 1个请求1个响应</td><td>lvs</td></tr><tr><td>反向 代理</td><td>用户的请求分发到后端节点上.</td><td>中间有个中介,用户—&gt;中介—&gt;web 2个请求2个响应. 代理代替用户去找web服务器.</td><td>ngx&#x2F;tengine&#x2F;openresty&#x2F;haproxy</td></tr></tbody></table><p>图示如下：</p><p><img src="/../../../img/image-20240509170011620.png" alt="image-20240509170011620"></p><h2 id="2-2-负载均衡模块的选项"><a href="#2-2-负载均衡模块的选项" class="headerlink" title="2.2 负载均衡模块的选项"></a>2.2 负载均衡模块的选项</h2><p>upstream模块 sever 指令支持的选项 </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstrem pools &#123;  server 10.0.0.7:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;10s;  server 10.0.0.8:80 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;10s;  server 10.0.0.8:80 backup;&#125;</code></pre></div></figure><p>选项说明：</p><table><thead><tr><th>选项</th><th>说明</th><th>应用场景</th></tr></thead><tbody><tr><td>weight</td><td>权重,根据权重ngx分配请求.</td><td>如果web服务端配置不同,1c2g, 2c8g. 代码更新与测试的时候,给测试服务器较小的权重.</td></tr><tr><td>max_fails</td><td>ngx具备一些健康检查功能,指定失败的次数,超过这个次 数就认为节点挂了.</td><td>一般情况下可以设置1-3即可. 不太重要,缓存业 务,可以设置为10.</td></tr><tr><td>fail_timeout</td><td>认为节点挂了后间隔多久再次检查健康情况. 默认是 10s.</td><td>根据要求设置时间即可,可以长一些.30&#x2F;60s.</td></tr><tr><td>backup</td><td>备胎服务器,其他所有服务器都挂了的时候,才启用.</td><td>使用的时候需要考虑雪崩的情况</td></tr></tbody></table><h1 id="三、负载均衡案例"><a href="#三、负载均衡案例" class="headerlink" title="三、负载均衡案例"></a>三、负载均衡案例</h1><h2 id="3-1-案例01：wordpress接入负载均衡"><a href="#3-1-案例01：wordpress接入负载均衡" class="headerlink" title="3.1 案例01：wordpress接入负载均衡"></a>3.1 案例01：wordpress接入负载均衡</h2><p>需求：</p><ul><li>nfs01挂载</li><li>db数据库，库用户</li><li>web01,web02 部署环境ngx+php，测试，部署代码，挂载nfs。</li><li>接入负载</li></ul><p>图示：</p><p><img src="/../../../img/image-20240509230010825.png" alt="image-20240509230010825"></p><h3 id="3-1-1-NFS存储配置"><a href="#3-1-1-NFS存储配置" class="headerlink" title="3.1.1 NFS存储配置"></a>3.1.1 NFS存储配置</h3><p>nfs01服务器，10.0.0.31配置，</p><blockquote><p>注意事项：</p><p>共享的&#x2F;nfs&#x2F;wordpress文件夹，所属用户和组都是www</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加www用户和用户组useradd -u 1999 -s &#x2F;sbin&#x2F;nologin -M www# 查看用户id www# 修改nfs配置文件，指定文件夹用户[root@nfs01[ ~]#cat &#x2F;etc&#x2F;exports...&#x2F;nfs&#x2F;wordpress&#x2F; 172.16.1.0&#x2F;24(rw, all_squash, anonuid&#x3D;1999, anongid&#x3D;1999)# 重启服务systemctl restart rpcbind nfs# 查看nfs是否正常[root@nfs01[ &#x2F;]#showmount -e 172.16.1.31Export list for 172.16.1.31:&#x2F;nfs&#x2F;wordpress&#x2F; 172.16.1.0&#x2F;24# 创建目录，修改所有者[root@nfs01[ ~]#mkdir -p &#x2F;nfs&#x2F;wordpress[root@nfs01[ ~]#chown -R www.www &#x2F;nfs&#x2F;wordpress</code></pre></div></figure><h3 id="3-1-2-数据库配置"><a href="#3-1-2-数据库配置" class="headerlink" title="3.1.2 数据库配置"></a>3.1.2 数据库配置</h3><p>db01服务器，10.0.0.51配置，为wordpress创建专门的数据库，以及数据库用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建wordpress数据库MariaDB [(none)]&gt; create database wordpress;Query OK, 1 row affected (0.00 sec)# 创建wp用户MariaDB [(none)]&gt; grant all on wordpress.* to &#39;wp&#39;@&#39;172.16.1.%&#39; identified by &#39;redhat123&#39;;Query OK, 0 rows affected (0.00 sec)# 查看用户MariaDB [(none)]&gt; select user,host from mysql.user;+-----------+------------+| user      | host       |+-----------+------------+| root      | 127.0.0.1  || wordpress | 172.16.1.% || wp        | 172.16.1.% |# 存在| root      | ::1        || root      | localhost  || wordpress | localhost  |+-----------+------------+6 rows in set (0.00 sec)</code></pre></div></figure><h3 id="3-1-3-web服务器配置"><a href="#3-1-3-web服务器配置" class="headerlink" title="3.1.3 web服务器配置"></a>3.1.3 web服务器配置</h3><p>web01和web02均做同样配置，保持一致</p><blockquote><p>注意事项：</p><p>nginx和php都要使用www用户和用户组</p><p>nginx：</p><ul><li>主配置文件：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf，其中的user</li><li>站点目录，&#x2F;app&#x2F;code&#x2F;blog，修改用户和属组</li></ul><p>php:</p><ul><li>&#x2F;etc&#x2F;php-fpm.d&#x2F;<a href="http://www.conf,修改user和group/">www.conf，修改user和group</a></li></ul></blockquote><p>www用户相关配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加www用户和用户组useradd -u 1999 -s &#x2F;sbin&#x2F;nologin -M www# 查看用户id www# nginx主配置文件修改user,由nginx改为www[root@web01[ &#x2F;app&#x2F;code&#x2F;blog]#cat &#x2F;etc&#x2F;nginx&#x2F;nginx.confuser  www;...# 修改php-fpm的用户[root@web02[ &#x2F;app&#x2F;code&#x2F;blog]#cat &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf...user &#x3D; wwwgroup &#x3D; www</code></pre></div></figure><p>子配置文件和挂载目录相关</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># blog.oldboylinux.cn子配置文件[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat blog.oldboylinux.cn.confserver &#123;  listen 80;  server_name blog.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;blog;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-access.log main;  location &#x2F; &#123;    index index.php;  &#125;  location ~ \.php$ &#123;    fastcgi_pass 127.0.0.1:9000;    fastcgi_index index.php;    fastcgi_buffering on;    fastcgi_buffers 64 64k;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;  &#125;&#125;# wordpress站点目录，创建uploads文件夹[root@web01[ &#x2F;app&#x2F;code&#x2F;blog]#mkdir wp-content&#x2F;uploads# 修改站点目录所有者是www[root@web01[ &#x2F;app&#x2F;code]#chown -R www.www blog&#x2F;# uploads文件夹挂载为nfs存储[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;etc&#x2F;fstab....172.16.1.31:&#x2F;nfs&#x2F;wordpress &#x2F;app&#x2F;code&#x2F;blog&#x2F;wp-content&#x2F;uploads nfs defaults 0 0# 永久挂载[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#mount -a# 打包站点代码，排除上传目录tar zcf ~&#x2F;wordpress-no-uploads.tar.gz . --exclude&#x3D;.&#x2F;wp-content&#x2F;uploads&#x2F;*# 拷贝代码到web02部署，站点内容需保持一致[root@web01[ &#x2F;app&#x2F;code&#x2F;blog]#scp ~&#x2F;wordpress-no-uploads.tar.gz 10.0.0.8:&#x2F;app&#x2F;code&#x2F;blog# 解压[root@web02[ &#x2F;app&#x2F;code&#x2F;blog]#lswordpress-no-uploads.tar.gz[root@web02[ &#x2F;app&#x2F;code&#x2F;blog]#tar -vxf wordpress-no-uploads.tar.gz# 重启服务[root@web01[ &#x2F;app&#x2F;code]#systemctl restart nginx php-fpm[root@web01[ &#x2F;app&#x2F;code]#ps -ef | grep wwwwww        5478   5475  0 23:37 ?        00:00:00 php-fpm: pool wwwwww        5479   5475  0 23:37 ?        00:00:00 php-fpm: pool wwwwww        5480   5475  0 23:37 ?        00:00:00 php-fpm: pool wwwwww        5481   5475  0 23:37 ?        00:00:00 php-fpm: pool wwwwww        5482   5475  0 23:37 ?        00:00:00 php-fpm: pool wwwwww        5485   5484  0 23:37 ?        00:00:00 nginx: worker processroot       5487   1764  0 23:37 pts&#x2F;0    00:00:00 grep --color&#x3D;auto www</code></pre></div></figure><h3 id="3-1-4-接入负载均衡"><a href="#3-1-4-接入负载均衡" class="headerlink" title="3.1.4 接入负载均衡"></a>3.1.4 接入负载均衡</h3><p>lb01配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建自配置文件，接入负载均衡[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat blog.oldboylinux.cn.confupstream blog_spools&#123;  server 10.0.0.7:80;  server 10.0.0.8:80;&#125;server &#123;  listen 80;  server_name blog.oldboylinux.cn;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-acess.log main;  location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;blog_spools;    proxy_set_header Host $http_host;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &#125;&#125;</code></pre></div></figure><h3 id="3-1-5-测试"><a href="#3-1-5-测试" class="headerlink" title="3.1.5 测试"></a>3.1.5 测试</h3><h4 id="a-负载均衡测试"><a href="#a-负载均衡测试" class="headerlink" title="a) 负载均衡测试"></a>a) 负载均衡测试</h4><p>先是走10.0.0.7</p><p><img src="/../../../img/image-20240509175210664.png" alt="image-20240509175210664"></p><p>把0.7的nginx关了，仍可以正常访问，该走0.8</p><p><img src="/../../../img/image-20240509175315454.png" alt="image-20240509175315454"></p><h4 id="b-文件上传测试"><a href="#b-文件上传测试" class="headerlink" title="b) 文件上传测试"></a>b) 文件上传测试</h4><p>写一篇文章，上传图片</p><p><img src="/../../../img/image-20240509175430280.png" alt="image-20240509175430280"></p><p>图片成功显示，且通过nfs上传到nfs01服务器中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01[ &#x2F;nfs&#x2F;wordpress]#ls 2024&#x2F;05&#x2F;自律即自由-1024x576.jpg  自律即自由-1536x864.jpg  自律即自由-768x432.jpg自律即自由-150x150.jpg   自律即自由-300x169.jpg   自律即自由.jpg</code></pre></div></figure><h2 id="3-2-案例02-会话保持"><a href="#3-2-案例02-会话保持" class="headerlink" title="3.2 案例02-会话保持"></a>3.2 案例02-会话保持</h2><p>目前的站点虽然可以正常访问，但仍然存在问题：会话无法保持</p><p>什么是会话？</p><ul><li>用户的登录状态，或者未来购物网站的购物车状态，都可以称之为对话。</li><li>以登录状态为例，如果会话不能保持统一，可能造成用户频繁需要重新登录的问题，体验不好</li></ul><p>本节的目标： 实现会话保持&#x2F;会话共享。</p><h3 id="3-2-1-cookie和session"><a href="#3-2-1-cookie和session" class="headerlink" title="3.2.1 cookie和session"></a>3.2.1 cookie和session</h3><p>需要大致知晓cookie和session的含义</p><table><thead><tr><th>技术点</th><th>共同点</th><th>区别</th><th>其他</th></tr></thead><tbody><tr><td>cookie</td><td>存放用户的信息，如登录信息</td><td>存放在客户端浏览器</td><td>服务器给客户端响应，进行设置set-cookie，未来再次访问时，将携带着cookie访问服务端</td></tr><tr><td>session</td><td>存放用户的信息，如登录信息</td><td>存放服务端(文件,数据 库…)</td><td>浏览器cookie与服务端的session对应</td></tr></tbody></table><p>浏览器F12查看网站cookie</p><p><img src="/../../../img/image-20240509180842156.png" alt="image-20240509180842156"></p><h3 id="3-2-2-会话保持方案"><a href="#3-2-2-会话保持方案" class="headerlink" title="3.2.2 会话保持方案"></a>3.2.2 会话保持方案</h3><p>方案：</p><ul><li>cookie+session方式<ul><li>登录状态写入cookie中</li><li>需要有统一存放session服务器(会话保持服务器)</li><li>客户端浏览器持cookie和服务器session对比</li></ul></li><li>通过认证服务Oauth2.0实现 <ul><li>使用token方式—token古代的令牌</li><li>偏开发，了解即可</li></ul></li><li>ip_hash方案<ul><li>第一次认证的那台服务器，后续就一直选择那台</li><li>跟负载均衡的作用有些冲突</li></ul></li><li>通过redis实现<ul><li>把认证信息存放在redis服务器中</li></ul></li></ul><h3 id="3-2-3-redis方案极速上手"><a href="#3-2-3-redis方案极速上手" class="headerlink" title="3.2.3 redis方案极速上手"></a>3.2.3 redis方案极速上手</h3><blockquote><p>案例：部署phpMyAdmin + redis会话保持</p><p>phpMyadmin是一个基于PHP的web页面版本的数据库管理工具，可以执行SQL语句。</p><p>只需要nginx + php，不需要创建库，只需在mysql添加用户(权限设大点).  </p></blockquote><p>流程如下：</p><ul><li>db: phpmyadmin用户,权限大一些.</li><li>web: 部署代码,传输到另外一个web上</li><li>准备redis环境(db01)</li><li>修改php配置(创建新的端口)</li><li>接入负载均衡.访问与测试</li></ul><h4 id="a）db01准备用户"><a href="#a）db01准备用户" class="headerlink" title="a）db01准备用户"></a>a）db01准备用户</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Mysql中创建phpmyadmin用户MariaDB [(none)]&gt; grant all on *.* to &#39;phpmyadmin&#39;@&#39;172.16.1.%&#39; identified by &#39;redhat123&#39;;Query OK, 0 rows affected (0.00 sec)</code></pre></div></figure><h4 id="b）部署phpmyadmin"><a href="#b）部署phpmyadmin" class="headerlink" title="b）部署phpmyadmin"></a>b）部署phpmyadmin</h4><p>web01和web02做同样的操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载wget https:&#x2F;&#x2F;files.phpmyadmin.net&#x2F;phpMyAdmin&#x2F;5.2.1&#x2F;phpMyAdmin-5.2.1-all-languages.zip# 创建站点文件夹，解压放入[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#ls &#x2F;app&#x2F;code&#x2F;phpmyadmin&#x2F;babel.config.json      CONTRIBUTING.md  js            README                  sql        yarn.lockChangeLog              doc              libraries     RELEASE-DATE-5.2.1      templatescomposer.json          examples         LICENSE       robots.txt              themescomposer.lock          favicon.ico      locale        setup                   url.phpconfig.sample.inc.php  index.php        package.json  show_config_errors.php  vendor# 子配置文件[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat phpmyadmin.oldboylinux.cn.confserver &#123;  listen 80;  server_name phpmyadmin.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;phpmyadmin;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;phpmyadmin-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;phpmyadmin-access.log main;  location &#x2F; &#123;    index index.php;  &#125;  location ~ \.php$ &#123;    # 传递给php    fastcgi_pass 127.0.0.1:9000;    fastcgi_index index.php;    fastcgi_buffering on;    fastcgi_buffers 64 64k;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;  &#125;&#125;# 检查语法，重新加载服务[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl reload nginx</code></pre></div></figure><blockquote><p>配置文件vim编辑时的替换方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;:%s#blog#phpmyadmin#g</code></pre></div></figure></blockquote><p>配置hosts，测试访问，报错<strong>Permission denied</strong></p><p><img src="/../../../img/image-20240509223814652.png" alt="image-20240509223814652"></p><p>原因是因为session目录没有权限，解决方法：将session目录用户和属组修改为www</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改所有者[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#chown -R www.www &#x2F;var&#x2F;lib&#x2F;php&#x2F;session</code></pre></div></figure><blockquote><p>这里的www用户和用户组是根据nginx的配置文件来的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;etc&#x2F;nginx&#x2F;nginx.conf&gt;...&gt;user  nginx;&gt;...</code></pre></div></figure><p>user项里是什么，就改成什么，我的原来是nginx，后面改成www</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;etc&#x2F;nginx&#x2F;nginx.conf&gt;...&gt;user www;&gt;worker_processes  auto;&gt;...</code></pre></div></figure></blockquote><p>再次访问，正常</p><p><img src="/../../../img/image-20240510092319840.png" alt="image-20240510092319840"></p><p>phpmyadmin默认的数据库IP为localhost，因此需要在站点文件夹中，手动创建连接数据库的配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 拷贝一份cp config.sample.inc.php config.inc.php# 把host改成数据库的IPgrep -wn host config.inc.php30:$cfg[&#39;Servers&#39;][$i][&#39;host&#39;] &#x3D; &#39;172.16.1.51&#39;;</code></pre></div></figure><p>测试访问（10.0.0.8单机部署），帐号密码为mysql用户，用之前创建的phpmyadmin用户登录</p><p><img src="/../../../img/image-20240510094005767.png" alt="image-20240510094005767"></p><p>访问成功，10.0.0.7也做相同配置，站点代码保持一致</p><h4 id="c）部署负载均衡"><a href="#c）部署负载均衡" class="headerlink" title="c）部署负载均衡"></a>c）部署负载均衡</h4><p>lb01部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 子配置文件[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat phpmyadmin.oldboylinux.cn.confupstream phpmyadmin_spools&#123;  server 10.0.0.7:80;  server 10.0.0.8:80;&#125;server &#123;  listen 80;  server_name phpmyadmin.oldboylinux.cn;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;phpmyadmin-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;phpmyadmin-acess.log main;  location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;phpmyadmin_spools;    proxy_set_header Host $http_host;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &#125;&#125;# 重新加载[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl reload nginx</code></pre></div></figure><p>测试：经过负载均衡访问，无法正常登录了，报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Failed to set session cookie. Maybe you are using HTTP instead of HTTPS to access phpMyAdmin.</code></pre></div></figure><p><img src="/../../../img/image-20240510094652072.png" alt="image-20240510094652072"></p><p>这是怎么回事？</p><ul><li>跟session cookie相关，想必就是会话保持的问题引起的！</li><li>通过部署redis服务来保存会话，解决这个问题。</li></ul><h4 id="d）部署redis服务"><a href="#d）部署redis服务" class="headerlink" title="d）部署redis服务"></a>d）部署redis服务</h4><blockquote><p>此操作在<font color=red>数据库服务器</font>操作（db01 - 10.0.0.51）</p></blockquote><p>部署redis</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装yum install -y redis# 修改配置文件[root@db01[ ~]#grep -wn &#39;bind&#39; &#x2F;etc&#x2F;redis.conf...61:bind 127.0.0.1 172.16.1.51# 绑定本地网卡IP...# 重启服务，--now就不需要额外的start reload了systemctl enable --now redis# 查看进程状态, 在6379端口[root@db01[ ~]#ss -lntup | grep redistcp    LISTEN     0      128    172.16.1.51:6379                  *:*                   users:((&quot;redis-server&quot;,pid&#x3D;9992,fd&#x3D;5))tcp    LISTEN     0      128    127.0.0.1:6379                  *:*                   users:((&quot;redis-server&quot;,pid&#x3D;9992,fd&#x3D;4))</code></pre></div></figure><h4 id="e）php配置文件指定会话存放位置"><a href="#e）php配置文件指定会话存放位置" class="headerlink" title="e）php配置文件指定会话存放位置"></a>e）php配置文件指定会话存放位置</h4><blockquote><p>此操作在<font color=red>web服务器</font>操作（web01、web02）</p><p>通知php指定会话保持位置：redis tcp:&#x2F;&#x2F;172.16.1.51:6379  </p></blockquote><p>创建php配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 原使用www.conf文件，9000端口，复制创建新的conf文件：session.conf，使用9001端口cp &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf &#x2F;etc&#x2F;php-fpm.d&#x2F;session.conf# 配置文件全部信息如下[root@web01[ &#x2F;etc&#x2F;php-fpm.d]#egrep -v &#39;^$|;&#39; session.conf[session]# 会话名修改user &#x3D; wwwgroup &#x3D; wwwlisten &#x3D; 127.0.0.1:9001# 端口改成9001listen.allowed_clients &#x3D; 127.0.0.1pm &#x3D; dynamicpm.max_children &#x3D; 50pm.start_servers &#x3D; 5pm.min_spare_servers &#x3D; 5pm.max_spare_servers &#x3D; 35slowlog &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;www-slow.logphp_admin_value[error_log] &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;www-error.logphp_admin_flag[log_errors] &#x3D; onphp_value[session.save_handler] &#x3D; redis# files改为redisphp_value[session.save_path]    &#x3D; tcp:&#x2F;&#x2F;172.16.1.51:6379# 文件改成redis地址php_value[soap.wsdl_cache_dir]  &#x3D; &#x2F;var&#x2F;lib&#x2F;php&#x2F;wsdlcache# 重启服务systemctl restart php-fpm</code></pre></div></figure><p>修改nginx配置文件，转发到9001端口处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;php-fpm.d]#cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;phpmyadmin.oldboylinux.cn.confserver &#123;...  location ~ \.php$ &#123;    # 传递给php    fastcgi_pass 127.0.0.1:9001;# 9000改9001...  &#125;&#125;# 重启服务systemctl restart nginx php-fpm</code></pre></div></figure><h4 id="d）最终测试"><a href="#d）最终测试" class="headerlink" title="d）最终测试"></a>d）最终测试</h4><p>再次登录正常</p><p><img src="/../../../img/image-20240510102005704.png" alt="image-20240510102005704"></p><p>不断刷新，172.16.1.7和1.8都有，说明负载均衡生效，且不需要重新登录，会话保存成功</p><p><img src="/../../../img/image-20240510102128652.png" alt="image-20240510102128652"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-Web集群-Nginx(四)</title>
    <link href="/2024/05/09/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/14-web%E9%9B%86%E7%BE%A4-Nginx-4/"/>
    <url>/2024/05/09/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/14-web%E9%9B%86%E7%BE%A4-Nginx-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Nginx（四）"><a href="#Web集群-Nginx（四）" class="headerlink" title="Web集群-Nginx（四）"></a>Web集群-Nginx（四）</h1><p>今日内容：</p><p>1、lnmp深入原理与排错</p><p>2、nginx代理</p><ul><li>案例：多个虚拟主机的情况</li><li>案例：后端节点记录用户的真实IP地址</li></ul><p>3、nginx负载均衡</p><ul><li>案例：基本负载均衡案例</li><li>案例：动静分离案例</li></ul><h1 id="一、LNMP流程详解"><a href="#一、LNMP流程详解" class="headerlink" title="一、LNMP流程详解"></a>一、LNMP流程详解</h1><p>高清地址：<a href="https://www.processon.com/view/link/63e99e40d0902d35a13e3496">https://www.processon.com/view/link/63e99e40d0902d35a13e3496</a></p><h2 id="1-1-简单流程"><a href="#1-1-简单流程" class="headerlink" title="1.1 简单流程"></a>1.1 简单流程</h2><p>简单流程如下：</p><ol><li>用户发起请求</li><li>LNMP收到用户请求<ol><li>静态请求交给Nginx处理</li><li>动态请求nginx交给php处理</li></ol></li><li>LNMP返回处理结果</li></ol><p><img src="/../../../img/image-20240509093225114.png" alt="image-20240509093225114"></p><h2 id="1-2-详细流程"><a href="#1-2-详细流程" class="headerlink" title="1.2 详细流程"></a>1.2 详细流程</h2><p>比1.1更为详细：</p><ol><li>用户发起请求（使用HTTP协议）</li><li>Nginx收到请求<ol><li>静态请求ngx自己处理</li><li>动态请求转交php处理（通过fastcgi协议）</li></ol></li><li>PHP收到请求<ol><li>处理动态请求</li><li>数据库相关的处理，通过PHP函数连接数据库获取</li></ol></li></ol><p><img src="/../../../img/image-20240509093234136.png" alt="image-20240509093234136"></p><p>更为详细的流程，如下图：</p><p><img src="/../../../img/image-20240509093250602.png" alt="image-20240509093250602"></p><h2 id="1-3-fastcgi-param解析"><a href="#1-3-fastcgi-param解析" class="headerlink" title="1.3 fastcgi_param解析"></a>1.3 fastcgi_param解析</h2><p><img src="/../../../img/image-20240509093312895.png" alt="image-20240509093312895"></p><h1 id="二、LNMP排错"><a href="#二、LNMP排错" class="headerlink" title="二、LNMP排错"></a>二、LNMP排错</h1><p>采用排除法</p><ul><li>Linux:防火墙,selinux.</li><li>Nginx:检查配置,处理流程检查. 测试ngx.</li><li>PHP:处理动态请求. 测试:ngx+php</li><li>MySQL: 测试php+数据库</li></ul><p>如Nginx部署wordpress（php站点）报错了该如何排查。</p><h2 id="2-1-检查Nginx是否正常运行"><a href="#2-1-检查Nginx是否正常运行" class="headerlink" title="2.1 检查Nginx是否正常运行"></a>2.1 检查Nginx是否正常运行</h2><p>检查流程：</p><ul><li>检查端口：ss -lntup</li><li>检查进程：ps -ef</li><li>检查配置：&#x2F;etc&#x2F;nginx&#x2F;conf.d</li><li>站点目录下面创建 test.html写入内容</li><li>curl 访问.</li></ul><h2 id="2-2-检查PHP是否正常运行"><a href="#2-2-检查PHP是否正常运行" class="headerlink" title="2.2 检查PHP是否正常运行"></a>2.2 检查PHP是否正常运行</h2><p>检查ngx是否把动态页面转发php,php是否解析。</p><p>站点目录下创建<code>testinfo.php</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;?phpphpinfo();?&gt;</code></pre></div></figure><p><font color=red>测试完成,务必删除,否则网站信息泄漏</font></p><h2 id="2-3-检查数据库是否正常"><a href="#2-3-检查数据库是否正常" class="headerlink" title="2.3 检查数据库是否正常"></a>2.3 检查数据库是否正常</h2><p>检查数据库是否正常：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -u用户 -p密码 -h 数据库的ip&gt; show databases;</code></pre></div></figure><p>检查php连接数据库是否正常(测试数据库用户名和密码)  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#书写页面测试 testmysql.php&lt;?php&#x2F;&#x2F; 数据库地址$db_host&#x3D;&#39;172.16.1.51&#39;;&#x2F;&#x2F; 数据库用户名$db_user&#x3D;&#39;lidao&#39;;$db_pass&#x3D;&#39;1&#39;;&#x2F;&#x2F; 数据库名字$db_name&#x3D;&#39;lidao&#39;;$link_id&#x3D;mysqli_connect($db_host,$db_user,$db_pass,$db_name);if($link_id)&#123;echo &quot;successful by oldboy lidao996! 库名字:$db_name 库用户:$db_user 库密码:$db_pass&quot; ;&#125;else&#123;echo &quot;connection failed! 库名字:$db_name 库用户:$db_user 库密码:$db_pass&quot; ;&#125;?&gt;# 虚拟主机设置location ~* (testinfo|testmysq).php$ &#123;  allow 10.0.0.0&#x2F;24;  allow 172.16.1.0&#x2F;24;  deny all;  fastcgi_pass 127.0.0.1:9000;  fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;  include fastcgi_params;&#125;</code></pre></div></figure><blockquote><p>推荐看的，运维基操：</p><p><a href="https://www.yuque.com/r/notes/share/492805e4-31e6-4fc9-b8fe-d1f86de3b231">https://www.yuque.com/r/notes/share/492805e4-31e6-4fc9-b8fe-d1f86de3b231</a>  </p></blockquote><h1 id="三、Nginx代理"><a href="#三、Nginx代理" class="headerlink" title="三、Nginx代理"></a>三、Nginx代理</h1><p>目标：</p><ul><li>我们可以熟练使用proxy_pass指令把ngx数据转发给指定的ip和端口.</li><li>掌握使用proxy_pass的2个故障案例.</li><li>会给任意站点部署负载均衡.(upstream,proxy_pass)</li><li>负载均衡案例</li></ul><h2 id="3-1-代理概念"><a href="#3-1-代理概念" class="headerlink" title="3.1 代理概念"></a>3.1 代理概念</h2><p>如外卖&#x2F;中介，用户无法直接做某些事情，通过中介进行处理，这个中介就是代理。在Nginx中，代理也处于中间位置：</p><p><strong>用户 —&gt; 代理 —&gt; WEB节点</strong></p><ul><li>如果后面只有一个节点，一般使用nginx的代理功能即可</li><li>如果后面是集群，需要使用ngxin的负载均衡功能</li></ul><h2 id="3-2-代理分类"><a href="#3-2-代理分类" class="headerlink" title="3.2 代理分类"></a>3.2 代理分类</h2><p>代理分为正向代理和反向代理，区别在于形式上服务的”对象”不一样：</p><ul><li>正向代理：代理的对象是客户端，为客户端服务   【PC电脑】</li><li>反向代理：代理的对象是服务端，为服务端服务【服务器】</li></ul><table><thead><tr><th>代理分类</th><th>方向</th><th>应用</th></tr></thead><tbody><tr><td>正向代理</td><td>用户(服务器)—&gt;代理—&gt;外部(某网站)</td><td>服务器通过代理实现共享上网&#x2F;访问某个网站.</td></tr><tr><td>反向代 理</td><td>用户(app&#x2F;浏览器)—&gt;代理—&gt;网站服务器 (WEB)</td><td>给网站设置个统一入口,后面是网站集群(可以使用负载均衡 功能)</td></tr></tbody></table><h3 id="3-2-1-正向代理"><a href="#3-2-1-正向代理" class="headerlink" title="3.2.1 正向代理"></a>3.2.1 正向代理</h3><p>图解正向代理</p><p><img src="/../../../img/image-20240509100330829.png" alt="image-20240509100330829"></p><p>正向代理的应用</p><p><img src="/../../../img/image-20240509100349040.png" alt="image-20240509100349040"></p><h3 id="3-2-2-反向代理"><a href="#3-2-2-反向代理" class="headerlink" title="3.2.2 反向代理"></a>3.2.2 反向代理</h3><p>反向代理分几种模式，对应的模块如下</p><table><thead><tr><th>反向代理模式</th><th>Nginx配置模块</th></tr></thead><tbody><tr><td>http、websocket、https</td><td>ngx_http_proxy_module</td></tr><tr><td>fastcgi</td><td>ngx_http_fastcgi_module</td></tr><tr><td>uwsgi</td><td>ngx_http_uwsgi_module</td></tr><tr><td>grpc</td><td>ngx_http_v2_module</td></tr></tbody></table><p>图解反向代理：</p><p><img src="/../../../img/image-20240509100415694.png" alt="image-20240509100415694"></p><p>反向代理的应用：</p><p><img src="/../../../img/image-20240509100427870.png" alt="image-20240509100427870"></p><h2 id="3-3-极速上手"><a href="#3-3-极速上手" class="headerlink" title="3.3 极速上手"></a>3.3 极速上手</h2><h3 id="3-3-1-代理服务器准备"><a href="#3-3-1-代理服务器准备" class="headerlink" title="3.3.1 代理服务器准备"></a>3.3.1 代理服务器准备</h3><table><thead><tr><th>角色</th><th>主机名</th><th>ip</th></tr></thead><tbody><tr><td>代理</td><td>lb01</td><td>10.0.0.5&#x2F;172.16.1.5</td></tr><tr><td>web</td><td>web01</td><td>10.0.0.7&#x2F;172.16.1.7</td></tr><tr><td>域名:proxy.oldboylinux.cn</td><td></td><td></td></tr><tr><td>站点目录:&#x2F;app&#x2F;code&#x2F;proxy&#x2F;index.html</td><td></td><td></td></tr><tr><td>建议开启db01和nfs01</td><td></td><td></td></tr></tbody></table><p>代理服务器lb01配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置nginx yum源[root@lb01[ &#x2F;etc&#x2F;yum.repos.d]#cat nginx.repo[nginx-stable]name&#x3D;nginx stable repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;gpgcheck&#x3D;1enabled&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.keymodule_hotfixes&#x3D;true# 安装yum clean allyum makecacheyum install -y nginx # 检查rpm -qa nginxsystemctl enable nginxsystemctl start nginx</code></pre></div></figure><p>nginx启动后默认是web服务，需要使用对应的模块</p><ul><li>proxy模块，代理</li><li>upstream模块，负载均衡</li></ul><h3 id="3-3-2-web服务器准备"><a href="#3-3-2-web服务器准备" class="headerlink" title="3.3.2 web服务器准备"></a>3.3.2 web服务器准备</h3><table><thead><tr><th>域名</th><th>站点目录</th><th>首页文件</th></tr></thead><tbody><tr><td>proxy.oldboylinux.cn</td><td>&#x2F;app&#x2F;code&#x2F;proxy&#x2F;</td><td>index.html</td></tr></tbody></table><p>配置虚拟主机(<strong>以前配置的都注释掉</strong>)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 子配置文件[root@web01[ &#x2F;app&#x2F;code&#x2F;proxy]#cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.oldboylinux.cn.confserver &#123;  listen 80;  server_name proxy.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;proxy;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy-access.log main;  location &#x2F; &#123;    index index.html;  &#125;&#125;# 站点目录文件[root@web01[ &#x2F;app&#x2F;code&#x2F;proxy]#echo &quot;PROXY WEB PAGE&quot; &gt; index.html</code></pre></div></figure><p>测试连接</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;proxy]#curl -H Host:proxy.oldboylinux.cn 10.0.0.7PROXY WEB PAGE</code></pre></div></figure><h3 id="3-3-3-代理基本使用"><a href="#3-3-3-代理基本使用" class="headerlink" title="3.3.3 代理基本使用"></a>3.3.3 代理基本使用</h3><p>在lb01服务器配置代理</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat proxy.oldboylinux.cn.confserver &#123;  listen 80;  server_name proxy.oldboylinux.cn;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy-acess.log main;  location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;10.0.0.7:80;    proxy_set_header Host $http_host;  &#125;&#125;# 检查并重启服务nginx -tsystemctl reload nginx</code></pre></div></figure><p>命令测试（注意，这里是经过10.0.0.5访问，而不是0.7）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01[ ~]#curl -H Host:proxy.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.5PROXY WEB PAGE</code></pre></div></figure><p>浏览器测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># windows hosts10.0.0.5 proxy.oldboylinux.cn</code></pre></div></figure><p><img src="/../../../img/image-20240509103538026.png" alt="image-20240509103538026"></p><p>抓包查看代理流程</p><p><img src="/../../../img/image-20240509104107318.png" alt="image-20240509104107318"></p><p>流程如下：</p><p><img src="/../../../img/image-20240509114353762.png" alt="image-20240509114353762"></p><h3 id="3-3-4-代理案例01–web有多个虚拟主机故障"><a href="#3-3-4-代理案例01–web有多个虚拟主机故障" class="headerlink" title="3.3.4 代理案例01–web有多个虚拟主机故障"></a>3.3.4 代理案例01–web有多个虚拟主机故障</h3><p>故障现象:</p><ul><li>web服务器有多个虚拟主机的时候,通过代理访问web出现异常.访问的不是我们想要的虚拟主机.</li></ul><p>原因:</p><ul><li>代理向后端web节点发出请求的时候,请求头中的Host,被修改成ip地址形式了.</li><li>相当于代理通过ip地址访问web服务器,只显示默认虚拟主机.</li></ul><p>解决:</p><ul><li>方向:目标就是修改,代理到web的请求头,Host部分.</li><li>proxy_set_header Host $http_host;</li><li>proxy_set_header Host “proxy.oldboylinux.cn”;</li></ul><p>解决的原理</p><ul><li>代理—&gt;web发出请求的时候,修改请求头中的Host部分,设置为用户请求的域名</li></ul><p>流程图如下：</p><p><img src="/../../../img/image-20240509104422062.png" alt="image-20240509104422062"></p><blockquote><p>提示：</p><p>$http_host是ngx的变量之一,用于取出Host的内容(域名),这里面取出的是proxy.oldboylinux.cn  </p><p>proxy ngx模块  </p><p>proxy_pass :传球,请求传递给指定的节点.</p><p>proxy_set_header : 修改请求头,代理—&gt;后端节点.  </p></blockquote><h3 id="3-3-5-代理案例02–web记录用户真实ip地址"><a href="#3-3-5-代理案例02–web记录用户真实ip地址" class="headerlink" title="3.3.5 代理案例02–web记录用户真实ip地址"></a>3.3.5 代理案例02–web记录用户真实ip地址</h3><p>现象: </p><p>用户请求经过代理访问web，web服务器没有记录真实的客户端的ip地址，而是记录了代理的ip.  </p><p>解决:</p><p>在代理上面修改请求头:<code>proxy_set_header X-Forwarded-For $remote_addr;</code></p><p>最后在web服务器上记录了真实的ip地址：<code>$http_x_forwarded_ for</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">the “X-Forwarded-For” client request header fieldwith the $remote_addr variable appended to it,separated by a comma. If the “X-Forwarded-For” fieldis not present in the client request header, the$proxy_add_x_forwarded_for variable is equal to the$remote_addr variable.$proxy_add_x_forwarded_for变量相当于$remote_addr 客户ip地址.多层代理的时候,会记录每个代理的ip地址.相当于记录了多个$remote_addr</code></pre></div></figure><p>配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# cat&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.oldboylinux.cn.conf#lb 代理服务器的ngx 配置server &#123;  listen 80;  server_name proxy.oldboylinux.cn;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy-acess.log main;location &#x2F; &#123;  proxy_pass http:&#x2F;&#x2F;10.0.0.7:80 ;  #代理--&gt;节点发出请求,修改请求头.  #proxy_set_header 请求头字段 内容(变量);  proxy_set_header Host $http_host;  #proxy_set_header X-Forwarded-For 取出客户端ip地址  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;&#125;</code></pre></div></figure><p>XFF头的内容需要通过$http_x_forwarded_for变量获取并写入到日志中  </p><p><font color=red>浏览器测试没看到</font></p><p><img src="/../../../img/image-20240509110830878.png" alt="image-20240509110830878"></p><p>也可以在访问日志文件中看到：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code]#cat &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy-access.log...10.0.0.5 - - [09&#x2F;May&#x2F;2024:11:07:18 +0800] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.0&quot; 404 153 &quot;http:&#x2F;&#x2F;proxy.oldboylinux.cn&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko&#x2F;20100101 Firefox&#x2F;121.0&quot; &quot;10.0.0.1&quot;...</code></pre></div></figure><h2 id="3-4-参数多的时候如何配置"><a href="#3-4-参数多的时候如何配置" class="headerlink" title="3.4 参数多的时候如何配置"></a>3.4 参数多的时候如何配置</h2><blockquote><p>可将参数写到一个文件中，然后在nginx配置文件里include包含进去</p></blockquote><p>1、创建包含参数的文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 conf.d]# cat &#x2F;etc&#x2F;nginx&#x2F;proxy_paramsproxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffering on;proxy_buffer_size 32k;proxy_buffers 4 128k;</code></pre></div></figure><p>2、在配置文件中导入，方便后续多个location使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;10.0.0.7:80;    include proxy_params;&#125;</code></pre></div></figure><h2 id="3-5-代理小结"><a href="#3-5-代理小结" class="headerlink" title="3.5 代理小结"></a>3.5 代理小结</h2><p>1、什么是正向代理，什么是反向代理</p><p>2、核心指令：<code>proxy_pass</code></p><p>3、2个故障案例：</p><ul><li><p>web节点有多个虚拟主机：<code>proxy_set_header Host $http_host;  </code></p></li><li><p>web节点记录用户真实IP地址 XFF头 <code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </code></p></li></ul><p>4、生产建议配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></pre></div></figure><p>5、常用参数解释</p><table><thead><tr><th></th><th>作用</th></tr></thead><tbody><tr><td>proxy_pass <a href="http://10.0.0.7/">http://10.0.0.7:80</a>;</td><td></td></tr><tr><td>proxy_http_version 1.1;</td><td>代理向后端请求使用的版本</td></tr><tr><td>proxy_set_header Host $http_host;</td><td>代理向后端请求携带的域名</td></tr><tr><td>proxy_set_header X-Real-IP $remote_addr;</td><td><font color="blue">用于获取客户端真实IP（不如x-forward）</font></td></tr><tr><td>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</td><td><font color="blue">获取客户端真实IP及全链路IP</font></td></tr><tr><td>proxy_connect_timeout 30;</td><td>代理接连后端超时时间</td></tr><tr><td>proxy_send_timeout 60;</td><td>后端传递数据至代理的超时时间</td></tr><tr><td>proxy_read_timeout 60;</td><td>后端相应代理的超时时间</td></tr><tr><td>proxy_buffering on;</td><td>是否开启proxy的buffer功能</td></tr><tr><td>proxy_buffer_size 32k;</td><td>设置buffer大小</td></tr><tr><td>proxy_buffers 4 128k;</td><td>设置存储被代理服务器上的数据所占用的buffer的个数和每个buffer的大小</td></tr></tbody></table><h1 id="四、Nginx负载均衡"><a href="#四、Nginx负载均衡" class="headerlink" title="四、Nginx负载均衡"></a>四、Nginx负载均衡</h1><p>负载均衡（Load Balance）的作用：</p><ul><li>用户访问一个网站</li><li>后端只有一台服务器，扛不住了</li><li>需要使用多台web服务器组成集群，这个集群前面需要一台负载均衡进行调度</li></ul><h2 id="4-1-负载均衡的选型"><a href="#4-1-负载均衡的选型" class="headerlink" title="4.1 负载均衡的选型"></a>4.1 负载均衡的选型</h2><table><thead><tr><th>选型</th><th>选择</th></tr></thead><tbody><tr><td>硬件</td><td>F5,A10</td></tr><tr><td>软件</td><td>Nginx，Tengine，Openresty(内置lua)，Haproxy(专业负载)，LVS(高性能)</td></tr><tr><td>公有云服务</td><td>SLB，CLB…</td></tr></tbody></table><h2 id="4-2-极速上手"><a href="#4-2-极速上手" class="headerlink" title="4.2 极速上手"></a>4.2 极速上手</h2><p>环境准备</p><table><thead><tr><th>角色</th><th></th><th></th></tr></thead><tbody><tr><td>lb01 负载均衡</td><td>10.0.0.5&#x2F;172.16.1.5</td><td>lb.oldboylinux.cn</td></tr><tr><td>web01</td><td>10.0.0.7&#x2F;172.16.1.7</td><td>lb.oldboylinux.cn &#x2F;app&#x2F;code&#x2F;lb&#x2F;</td></tr><tr><td>web02</td><td>10.0.0.8&#x2F;172.16.1.8</td><td>lb.oldboylinux.cn &#x2F;app&#x2F;code&#x2F;lb&#x2F;</td></tr><tr><td>首页文件内容lb.oldboylinux.cn 主机名</td><td></td><td></td></tr></tbody></table><p>web服务器准备，两台都做相同配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 子配置文件[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# cat lb.oldboylinux.cn.confserver &#123;  listen 80;  server_name lb.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;lb;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;lb-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;lb-access.log main;  location &#x2F; &#123;    index index.html;  &#125;&#125;# 站点内容[root@web01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# cat &#x2F;app&#x2F;code&#x2F;lb&#x2F;index.htmllb.oldboylinux.cn web01</code></pre></div></figure><p>检查web服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01[ ~]#curl -H Host:lb.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7WEB 01 PAGE[root@db01[ ~]#curl -H Host:lb.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.8WEB 02 PAGE</code></pre></div></figure><h2 id="4-2-负载均衡配置"><a href="#4-2-负载均衡配置" class="headerlink" title="4.2 负载均衡配置"></a>4.2 负载均衡配置</h2><p>lb01配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 &#x2F;etc&#x2F;nginx&#x2F;conf.d]# catlb.oldboylinux.cn.conf# upstream创建资源池upstream lb_pools &#123;  server 10.0.0.7:80;  server 10.0.0.8:80;&#125;# server指向资源池server &#123;  listen 80;  server_name lb.oldboylinux.cn;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;lb-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;lb-access.log main;  location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;lb_pools;    proxy_set_header Host $http_host;    proxy_set_header X-Real-Ip $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &#125;&#125;</code></pre></div></figure><p>命令行测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01[ ~]#curl -H Host:lb.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.5WEB 01 PAGE[root@db01[ ~]#curl -H Host:lb.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.5WEB 02 PAGE</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-Web集群-Nginx(三)</title>
    <link href="/2024/05/08/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/13-web%E9%9B%86%E7%BE%A4-Nginx-3/"/>
    <url>/2024/05/08/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/13-web%E9%9B%86%E7%BE%A4-Nginx-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Nginx（三）"><a href="#Web集群-Nginx（三）" class="headerlink" title="Web集群-Nginx（三）"></a>Web集群-Nginx（三）</h1><p>今日内容：</p><p>1、搭建高检视频下载站点</p><p>2、动态网站架构（部署一份开发的PHP代码）</p><h1 id="一、搭建高清视频下载站点"><a href="#一、搭建高清视频下载站点" class="headerlink" title="一、搭建高清视频下载站点"></a>一、搭建高清视频下载站点</h1><p>目标：提供网页目录结构，类似：清华大学开源软件镜像站</p><p>要求：</p><ol><li>浏览器打开后，显示目录结构(如上图)。</li><li>增加svip功能</li><li>增加统计功能,统计nginx服务的状态,访问情况</li></ol><h2 id="1-1-站点基本配置"><a href="#1-1-站点基本配置" class="headerlink" title="1.1 站点基本配置"></a>1.1 站点基本配置</h2><p>配置要求：</p><ul><li>域名:v.oldboylinux.cn</li><li>站点目录: &#x2F;app&#x2F;code&#x2F;v&#x2F;</li><li>touch 几个文件即可  </li><li>自动索引功能（列表站点目录的功能），首页文件不存在</li></ul><p>其中自动索引功能需要用到autoindex模块</p><table><thead><tr><th>使用方法</th><th>功能</th></tr></thead><tbody><tr><td>autoindex on ;</td><td>开启目录索引功能(显示站点目录下的文件的列表,首页文件不存在.)</td></tr><tr><td>autoindex_localtime on;</td><td>显示本地时间.</td></tr><tr><td>autoindex_exact_size off;</td><td>是否显示精确的文件的大小. off表示以人类可读形式显示大小</td></tr></tbody></table><p>配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat v.oldboylinux.cn.confserver &#123;  listen 80;  server_name v.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;v;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;v.oldboylinux.cn-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;v.oldboylinux.cn-access.log main;  charset utf8;# 字符集  autoindex on;  autoindex_localtime on;  autoindex_exact_size off;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>准备文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;v]#ls苍老师教学.avi  葫芦娃.avi</code></pre></div></figure><p>reload服务，设置hosts访问</p><p><img src="/../../../img/image-20240508130908982.png" alt="image-20240508130908982"></p><h2 id="1-2-增加VIP认证功能"><a href="#1-2-增加VIP认证功能" class="headerlink" title="1.2 增加VIP认证功能"></a>1.2 增加VIP认证功能</h2><p>需求：</p><ul><li>增加一个svip目录,里面创建文件.</li><li>增加认证功能(用户名和密码).</li><li>只要用户访问的路径中包含VIP资源，提示输入密码</li></ul><p>认证功能，需要使用到auth_basic模块  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">auth_basic &quot;请输入密码:&quot;; #输出提示,根据不同浏览器,可能不显示.auth_basic_user_file conf&#x2F;htpasswd; #指定用户名,密码文件</code></pre></div></figure><p>实现：创建密码文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、安装httpd-tools工具[root@web01[ &#x2F;]# yum install -y httpd-tools# 2、创建用户文件-c, -b为明文密码追加[root@web01[ &#x2F;]#htpasswd -bc &#x2F;etc&#x2F;nginx&#x2F;user lidao996 redhat123Adding password for user lidao996# 用户文件追加用户[root@web01[ &#x2F;]#htpasswd -b &#x2F;etc&#x2F;nginx&#x2F;user oldboy redhat123Adding password for user oldboy# 修改用户文件权限[root@web01[ &#x2F;]#chmod 600 &#x2F;etc&#x2F;nginx&#x2F;user[root@web01[ &#x2F;]#chown nginx.nginx &#x2F;etc&#x2F;nginx&#x2F;user</code></pre></div></figure><p>虚拟主机配置文件修改：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat v.oldboylinux.cn.confserver &#123;  listen 80;  server_name v.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;v;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;v.oldboylinux.cn-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;v.oldboylinux.cn-access.log main;  charset utf8;  autoindex on;  autoindex_localtime on;  autoindex_exact_size off;  location &#x2F; &#123;    index index.html;  &#125;    # 新增认证功能  location &#x2F;svip&#x2F; &#123;    auth_basic &quot;请输入密码: &quot;;    auth_basic_user_file &#x2F;etc&#x2F;nginx&#x2F;user;  &#125;&#125;</code></pre></div></figure><p>检查语法</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@web01[ &#x2F;app&#x2F;code&#x2F;v]#nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</code></pre></div></figure><p>创建svip目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;v]#ls -ltotal 0drwxr-xr-x. 2 root root 66 May  8 13:17 svip-rw-r--r--. 1 root root  0 May  8 13:02 苍老师教学.avi-rw-r--r--. 1 root root  0 May  8 13:02 葫芦娃.avi[root@web01[ &#x2F;app&#x2F;code&#x2F;v]#ls svip&#x2F;不为人知的故事.mp4  午夜屠猪男.avi</code></pre></div></figure><p>浏览器访问，提示输入密码</p><p><img src="/../../../img/image-20240508132709363.png" alt="image-20240508132709363"></p><p>密码正确，访问成功</p><p><img src="/../../../img/image-20240508132742178.png" alt="image-20240508132742178"></p><h2 id="1-3-增加统计功能"><a href="#1-3-增加统计功能" class="headerlink" title="1.3 增加统计功能"></a>1.3 增加统计功能</h2><p>要求：</p><ol><li>显示nginx状态信息，未来用于监控nginx</li><li>熟练使用状态模块</li></ol><p>显示nginx的状态信息，需要用到stub_status模块</p><h3 id="1-3-1-统计功能配置"><a href="#1-3-1-统计功能配置" class="headerlink" title="1.3.1 统计功能配置"></a>1.3.1 统计功能配置</h3><p>配置文件追加status模块</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;v]#cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;v.oldboylinux.cn.confserver &#123;...  location &#x2F;svip&#x2F; &#123;    auth_basic &quot;请输入密码: &quot;;    auth_basic_user_file &#x2F;etc&#x2F;nginx&#x2F;user;  &#125;    # status模块  location &#x2F;status &#123;    stub_status;  &#125;&#125;</code></pre></div></figure><p>浏览器访问</p><p><img src="/../../../img/image-20240508133134288.png" alt="image-20240508133134288"></p><h3 id="1-3-2-状态模块指标说明"><a href="#1-3-2-状态模块指标说明" class="headerlink" title="1.3.2 状态模块指标说明"></a>1.3.2 状态模块指标说明</h3><table><thead><tr><th>ngx状态模块中的指标说明</th><th>说明</th><th>说明</th></tr></thead><tbody><tr><td>Active connections</td><td>当前已经建立的连接数(est)和等待数量</td><td>体现:ngx并发</td></tr><tr><td>server accepts</td><td>已经接收到客户端的连接总数.</td><td></td></tr><tr><td>handled</td><td>服务端已经处理的连接.</td><td></td></tr><tr><td>requests</td><td>客户端发出请求的总数.</td><td></td></tr><tr><td>reading</td><td>正在读取的请求头连接数量</td><td></td></tr><tr><td>writing</td><td>正在进行的响应的连接数量</td><td></td></tr><tr><td>waiting</td><td>排队数量</td><td>排队情况</td></tr></tbody></table><h3 id="1-3-3-网页压力测试"><a href="#1-3-3-网页压力测试" class="headerlink" title="1.3.3 网页压力测试"></a>1.3.3 网页压力测试</h3><p>在mn01使用ab工具做网页压力测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#ab -n 9999999 -c 3 -H Host:v.oldboylinux.cn http:&#x2F;&#x2F;10.0.0.7&#x2F;This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;Benchmarking 10.0.0.7 (be patient)</code></pre></div></figure><p>查看网页nginx状态信息，请求处理不断增多</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Active connections: 2 server accepts handled requests 158568 158568 158597 Reading: 0 Writing: 1 Waiting: 1 </code></pre></div></figure><h2 id="1-4-nginx模块小结"><a href="#1-4-nginx模块小结" class="headerlink" title="1.4 nginx模块小结"></a>1.4 nginx模块小结</h2><p>目前接触到的一些nginx模块</p><table><thead><tr><th>模块</th><th>核心指令</th><th>重要程度</th></tr></thead><tbody><tr><td>目录索引模块</td><td>autoindex on;</td><td>※</td></tr><tr><td>认证功能模块</td><td>auth_basic_user_file;</td><td>※</td></tr><tr><td>访问控制模块</td><td>allow, deny</td><td>※※※</td></tr><tr><td>状态模块</td><td>stub_status</td><td>※※※※※</td></tr><tr><td>ngx核心模块</td><td>root, location, err_log, server_name, listen</td><td>※※※※※</td></tr><tr><td>ngx日志模块</td><td>access_log_format</td><td>※※※※</td></tr></tbody></table><h1 id="二、动态网站架构"><a href="#二、动态网站架构" class="headerlink" title="二、动态网站架构"></a>二、动态网站架构</h1><p>案例：部署一份开发的php代码（wordpress网站）</p><p>要求：开发书写了一个php代码发给我们部署</p><ol><li>测试能否直接部署到nginx中？</li><li>需要什么服务，是什么原理？</li><li>准备服务并测试。</li><li>部署代码。</li></ol><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>了解什么是动态、静态网站</p><table><thead><tr><th>网站架构</th><th>说明与特点</th><th>性能</th><th>一句话说明</th></tr></thead><tbody><tr><td>静态网站</td><td>网站仅仅包含:html、css样式、js脚本、图片、视频…等ngx可以直接处理的静态资源.</td><td>只需要web服务器即可；nginx,可以承受较 高的访问量；不支持动态的功能，如：注册,、论。静态网站功能单一</td><td>浏览器端解析(客户端解析),服务 端仅仅负责发送.</td></tr><tr><td>动态网站</td><td>动态网站一般是通过开发语言实现如:java、php、python、Golang等</td><td>动态资源页面需要服务器进行处理，如nginx+php&#x2F;tomcat+数据库，处理后把结果返回给用户.</td><td>动态请求需要服务端进行处理与解 析,把结果给用户</td></tr></tbody></table><p>如何区分静态资源和动态资源</p><ul><li>通过url可以初步判断网站的类型</li><li>url中包含<code>&amp;</code>或<code>?</code>一般都是动态网站</li></ul><h2 id="2-2-常见动态网站架构"><a href="#2-2-常见动态网站架构" class="headerlink" title="2.2 常见动态网站架构"></a>2.2 常见动态网站架构</h2><p>常见架构如下：</p><ul><li>PHP: LNMP(LEMP), LAMP, WNMP&#x2F;WAMP (P—&gt;PHP,W—&gt;Windows,A—&gt;Apache)</li><li>Java: LNMT(Tomcat,Jetty,Weblogic,Jboss)</li><li>Python: LNMP(Python,uwsgi)</li><li>Golang: LNMG(Golang)</li><li>C&#x2F;C++: LNM?……..</li></ul><p>LNM是什么意思？</p><ul><li>Linux 系统</li><li>Nginx Web服务 Engine X</li><li>MySQL&#x2F;MariaDB 数据库</li></ul><p>也有LAMP和WNMP：</p><ul><li>LAMP A —&gt; apache  目前很少使用</li><li>WNMP&#x2F;WAMP W —&gt; Windows 一般开发使用</li></ul><h2 id="2-3-LNMP架构细节"><a href="#2-3-LNMP架构细节" class="headerlink" title="2.3 LNMP架构细节"></a>2.3 LNMP架构细节</h2><h3 id="2-3-1-LNMP流程图"><a href="#2-3-1-LNMP流程图" class="headerlink" title="2.3.1 LNMP流程图"></a>2.3.1 LNMP流程图</h3><p>Nginx处理静态请求流程</p><p><img src="/../../../img/image-20240508182636510.png" alt="image-20240508182636510"></p><p>Nginx处理动态请求流程</p><p><img src="/../../../img/image-20240508182659710.png" alt="image-20240508182659710"></p><h3 id="2-3-2-数据库"><a href="#2-3-2-数据库" class="headerlink" title="2.3.2 数据库"></a>2.3.2 数据库</h3><p>数据库基本概念: 库,表,字段,记录 知晓所属关系即可.  </p><p>库：database，相当于一个excel文件</p><p>表：table，相当于excel文件中的一个sheet（表格）</p><p>字段：列，字段名字（某列的名字）</p><p>记录：行，某个数据</p><p>实操：</p><p>创建数据库服务器 10.0.0.51&#x2F;172.16.1.51</p><h4 id="a-安装"><a href="#a-安装" class="headerlink" title="a) 安装"></a>a) 安装</h4><p>安装mariadb数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.安装yum install -y mariadb-server#mariadb-server 服务端#mariadb 客户端# 2.启动服务systemctl enable mariadbsystemctl start mariadb# 3.检查进程状态ss -lntup |grep mysqlps -ef |grep mysql</code></pre></div></figure><p>数据库安全配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 刚安装后运行，首次运行即可，用于设置root密码,清理用户和清理临时库.[root@db01[ ~]#mysql_secure_installation# 输入当前密码，没有，直接回车Enter current password for root (enter for none):回车# 设置密码，交互输入Set root password? [Y&#x2F;n] Y设置密码New password: 输入密码Re-enter new password: 再次输入Password updated successfully!Reloading privilege tables...... Success!# 删除数据库中的匿名用户(没有用户名的用户,容易导致安全问题)Remove anonymous users? [Y&#x2F;n] Y # 是否禁止root远程登录Disallow root login remotely? [Y&#x2F;n] Y # 是否删除test测试用的数据库Remove test database and access to it? [Y&#x2F;n] Y # 是否更新权限信息表Reload privilege tables now? [Y&#x2F;n] Y </code></pre></div></figure><p>进入数据库内部</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用帐号密码进入[root@db01[ ~]#mysql -uroot -predhat123# 将出现交互文字Welcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 10Server version: 5.5.68-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.MariaDB [(none)]&gt;</code></pre></div></figure><h4 id="b-数据库查找-基本"><a href="#b-数据库查找-基本" class="headerlink" title="b) 数据库查找-基本"></a>b) 数据库查找-基本</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看所有的数据库MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema |+--------------------+3 rows in set (0.00 sec)# 查看库里的表MariaDB [(none)]&gt; show tables from mysql;+---------------------------+| Tables_in_mysql           |+---------------------------+| columns_priv              || db                        || event                     || func                      || general_log               |...# 从表里查找字段（user、host）MariaDB [(none)]&gt; select user,host from mysql.user;+------+-----------+| user | host      |+------+-----------+| root | 127.0.0.1 || root | ::1       || root | localhost |+------+-----------+3 rows in set (0.00 sec)</code></pre></div></figure><h4 id="c-创建数据库"><a href="#c-创建数据库" class="headerlink" title="c) 创建数据库"></a>c) 创建数据库</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建数据库(熟练)create database lidao;创建用户(会用,会改) 未来通过用户管理数据库.#创建用户,进行授权grant all on lidao.* to &#39;lidao&#39;@&#39;localhost&#39; identified by &#39;redhat123&#39;;grant all on lidao.* to &#39;lidao&#39;@&#39;172.16.1.%&#39; identified by &#39;redhat123&#39;;# grant 所有权限 on 数据库.* to &#39;用户名&#39;@&#39;白名单&#39;</code></pre></div></figure><h4 id="d-删除数据库"><a href="#d-删除数据库" class="headerlink" title="d) 删除数据库"></a>d) 删除数据库</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 删除数据库drop database lidao;# 删除用户drop user &#39;lidao&#39;@&#39;172.16.1.%&#39; ;drop user &#39;lidao&#39;@&#39;localhost&#39; ;</code></pre></div></figure><h4 id="e-创建wordpress数据库"><a href="#e-创建wordpress数据库" class="headerlink" title="e) 创建wordpress数据库"></a>e) 创建wordpress数据库</h4><p>创建</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">MariaDB [(none)]&gt; create database wordpress;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; grant all on wordpress.* to &#39;wordpress&#39;@&#39;localhost&#39; identified by &#39;redhat123&#39;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; grant all on wordpress.* to &#39;wordpress&#39;@&#39;172.16.1.%&#39; identified by &#39;redhat123&#39;;Query OK, 0 rows affected (0.00 sec)</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 本地连接[root@db01[ ~]#mysql -uwordpress -predhat123Welcome to the MariaDB monitor.  Commands end with ; or \g....MariaDB [(none)]&gt; # 远程连接，web01 --&gt; db01[root@web01[ &#x2F;app&#x2F;code&#x2F;v]#mysql -uwordpress -predhat123 -h 172.16.1.51Welcome to the MariaDB monitor.  Commands end with ; or \g....MariaDB [(none)]&gt;</code></pre></div></figure><blockquote><p>补充：</p><p>程序代码怎么连接数据库？</p><ul><li>通过数据库相关的配置文件设置</li></ul></blockquote><h3 id="2-3-2-PHP"><a href="#2-3-2-PHP" class="headerlink" title="2.3.2 PHP"></a>2.3.2 PHP</h3><h4 id="a-安装-1"><a href="#a-安装-1" class="headerlink" title="a) 安装"></a>a) 安装</h4><p><font color=red>在web01操作</font></p><p>案例选择php 7.x，在生产环境中，需要根据开发书写代码环境准备即可.  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置yum源[root@web01[ &#x2F;]#cat &#x2F;etc&#x2F;yum.repos.d&#x2F;php.repo[webtatic-php]name &#x3D; php Repositorybaseurl &#x3D; http:&#x2F;&#x2F;us-east.repo.webtatic.com&#x2F;yum&#x2F;el7&#x2F;x86_64enabled &#x3D; 1gpgcheck &#x3D; 0# 安装yum install -y php72w php72w-cli php72w-common php72w-devel php72w-embedded php72w-gd php72w-mcrypt php72w-mbstring php72w-pdo php72w-xml php72w-fpm php72w-mysqlnd php72w-opcache php72w-pecl-memcached php72w-pecl-redis php72w-pecl-mongodb# 启动服务[root@web01[ &#x2F;]#systemctl enable nginx php-fpmCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;php-fpm.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;php-fpm.service.[root@web01[ &#x2F;]#systemctl start nginx php-fpm# 查看进程状态[root@web01[ &#x2F;]#ss -lntup | grep phptcp    LISTEN     0      128    127.0.0.1:9000                  *:*                   users:((&quot;php-fpm&quot;,pid&#x3D;3789,fd&#x3D;9),(&quot;php-fpm&quot;,pid&#x3D;3788,fd&#x3D;9),(&quot;php-fpm&quot;,pid&#x3D;3787,fd&#x3D;9),(&quot;php-fpm&quot;,pid&#x3D;3786,fd&#x3D;9),(&quot;php-fpm&quot;,pid&#x3D;3785,fd&#x3D;9),(&quot;php-fpm&quot;,pid&#x3D;3784,fd&#x3D;7))[root@web01[ &#x2F;]#ps -ef | grep phproot       3784      1  0 19:04 ?        00:00:00 php-fpm: master process (&#x2F;etc&#x2F;php-fpm.conf)apache     3785   3784  0 19:04 ?        00:00:00 php-fpm: pool wwwapache     3786   3784  0 19:04 ?        00:00:00 php-fpm: pool wwwapache     3787   3784  0 19:04 ?        00:00:00 php-fpm: pool wwwapache     3788   3784  0 19:04 ?        00:00:00 php-fpm: pool wwwapache     3789   3784  0 19:04 ?        00:00:00 php-fpm: pool wwwroot       3805   1866  0 19:04 pts&#x2F;0    00:00:00 grep --color&#x3D;auto php</code></pre></div></figure><h4 id="b-php用户设置"><a href="#b-php用户设置" class="headerlink" title="b) php用户设置"></a>b) php用户设置</h4><p>php用户与nginx统一，统一为nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改php配置文件[root@web01[ &#x2F;]#egrep -n &#39;^user|^group&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf8:user &#x3D; nginx10:group &#x3D; nginx</code></pre></div></figure><h3 id="2-3-3-nginx配置"><a href="#2-3-3-nginx配置" class="headerlink" title="2.3.3 nginx配置"></a>2.3.3 nginx配置</h3><p>配置信息如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;  listen 80;  server_name blog.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;blog;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-access.log main;  location &#x2F; &#123;    index index.php;  &#125;  location ~ \.php$ &#123;  fastcgi_pass 127.0.0.1:9000;  fastcgi_index index.php;  fastcgi_param SCRIPT_FILENAME  $document_root$fastcgi_script_name;  include fastcgi_params;&#125;</code></pre></div></figure><h3 id="2-3-4-部署wordpress"><a href="#2-3-4-部署wordpress" class="headerlink" title="2.3.4 部署wordpress"></a>2.3.4 部署wordpress</h3><p>ngxin虚拟主机</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code]#cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;blog.oldboylinux.cn.confserver &#123;  listen 80;  server_name blog.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;blog;  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog-access.log main;  location &#x2F; &#123;    index index.php;  &#125;  location ~ \.php$ &#123;    fastcgi_pass 127.0.0.1:9000;    fastcgi_index index.php;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;  &#125;&#125;</code></pre></div></figure><p>浏览器访问：<a href="http://blog.oldboylinux.cn,进入配置页面/">http://blog.oldboylinux.cn，进入配置页面</a></p><p><img src="/../../../img/image-20240508201957016.png" alt="image-20240508201957016"></p><p>设置数据库信息</p><p><img src="/../../../img/image-20240508202047163.png" alt="image-20240508202047163"></p><p>遇到不能写入wp-config.php文件的问题</p><p><img src="/../../../img/image-20240508202242298.png" alt="image-20240508202242298"></p><p>创建该文件，把内容粘贴进去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;blog]#cat wp-config.php&lt;?php&#x2F;** * The base configuration for WordPress *...</code></pre></div></figure><p>再点击Run the installation，会来到welcome界面</p><p><img src="/../../../img/image-20240508202501506.png" alt="image-20240508202501506"></p><p>设置博客标题、账户、密码等信息</p><p><img src="/../../../img/image-20240508202650148.png" alt="image-20240508202650148"></p><p>设置完，在进入，来到登陆界面</p><p><img src="/../../../img/image-20240508202720450.png" alt="image-20240508202720450"></p><p>登录后的界面</p><p><img src="/../../../img/image-20240508202738857.png" alt="image-20240508202738857"></p><h2 id="2-4-LNMP排错与调试方法"><a href="#2-4-LNMP排错与调试方法" class="headerlink" title="2.4 LNMP排错与调试方法"></a>2.4 LNMP排错与调试方法</h2><h3 id="2-4-1-测试nginx-php静态页面"><a href="#2-4-1-测试nginx-php静态页面" class="headerlink" title="2.4.1 测试nginx + php静态页面"></a>2.4.1 测试nginx + php静态页面</h3><p>仍以blog虚拟主机为载体，设置如下php文件作为网站内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;blog]#cat info.php&lt;?phpphpinfo();?&gt;</code></pre></div></figure><p>访问：<a href="http://blog.oldboylinux.cn/info.php">http://blog.oldboylinux.cn/info.php</a></p><p><img src="/../../../img/image-20240508203123854.png" alt="image-20240508203123854"></p><h3 id="2-4-2-测试ngxin-php动态页面"><a href="#2-4-2-测试ngxin-php动态页面" class="headerlink" title="2.4.2 测试ngxin + php动态页面"></a>2.4.2 测试ngxin + php动态页面</h3><p>配置界面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;blog]#cat info.php&lt;?php&#x2F;&#x2F; 数据库地址$db_host&#x3D;&#39;172.16.1.51&#39;;&#x2F;&#x2F; 数据库用户名$db_user&#x3D;&#39;wordpress&#39;;$db_pass&#x3D;&#39;redhat123&#39;;$link_id&#x3D;mysqli_connect($db_host,$db_user,$db_pass);if($link_id)&#123;  echo &quot;mysql successful by oldboy lidao996!\n&quot; ;&#125;else&#123;  echo &quot;connection failed!\n&quot; ;&#125;?&gt;</code></pre></div></figure><p>测试</p><p><img src="/../../../img/image-20240508204013770.png" alt="image-20240508204013770"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-Web集群-Nginx(一)</title>
    <link href="/2024/05/07/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/11-web%E9%9B%86%E7%BE%A4-Nginx-1/"/>
    <url>/2024/05/07/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/11-web%E9%9B%86%E7%BE%A4-Nginx-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Nginx（一）"><a href="#Web集群-Nginx（一）" class="headerlink" title="Web集群-Nginx（一）"></a>Web集群-Nginx（一）</h1><h1 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h1><h2 id="1-1-HTTP协议概述"><a href="#1-1-HTTP协议概述" class="headerlink" title="1.1 HTTP协议概述"></a>1.1 HTTP协议概述</h2><p>什么是HTTP协议？</p><ul><li>http协议全称叫超文本传输协议，默认端口是80，主要用于数据请求与响应。解决网络传输问题：<ul><li>用户的数据如何传递给网站（请求request）<ul><li>打开网站，访问网站</li></ul></li><li>网站如何传递数据给用户（响应response）<ul><li>网站显示，返回你想要的内容</li></ul></li></ul></li></ul><p>什么是超文本？</p><ul><li>文本,图片,视频….都是超文本</li></ul><p>案例01：通过curl或wget访问网站并显示详细过程,能够找出哪部分是请求和响应 </p><p>curl</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#curl -v baidu.com* About to connect() to baidu.com port 80 (#0)*   Trying 110.242.68.66...* Connected to baidu.com (110.242.68.66) port 80 (#0)&gt; GET &#x2F; HTTP&#x2F;1.1&gt; User-Agent: curl&#x2F;7.29.0&gt; Host: baidu.com&gt; Accept: *&#x2F;*&gt;&lt; HTTP&#x2F;1.1 200 OK&lt; Date: Tue, 07 May 2024 02:06:40 GMT&lt; Server: Apache&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT&lt; ETag: &quot;51-47cf7e6ee8400&quot;&lt; Accept-Ranges: bytes&lt; Content-Length: 81&lt; Cache-Control: max-age&#x3D;86400&lt; Expires: Wed, 08 May 2024 02:06:40 GMT&lt; Connection: Keep-Alive&lt; Content-Type: text&#x2F;html&lt;&lt;html&gt;&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;&lt;&#x2F;html&gt;* Connection #0 to host baidu.com left intact</code></pre></div></figure><p>wget</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#wget --debug baidu.com...---request begin---GET &#x2F; HTTP&#x2F;1.1User-Agent: Wget&#x2F;1.14 (linux-gnu)Accept: *&#x2F;*Host: baidu.comConnection: Keep-Alive---request end---HTTP request sent, awaiting response...---response begin---HTTP&#x2F;1.1 200 OKDate: Tue, 07 May 2024 02:07:08 GMTServer: ApacheLast-Modified: Tue, 12 Jan 2010 13:48:00 GMTETag: &quot;51-47cf7e6ee8400&quot;Accept-Ranges: bytesContent-Length: 81Cache-Control: max-age&#x3D;86400Expires: Wed, 08 May 2024 02:07:08 GMTConnection: Keep-AliveContent-Type: text&#x2F;html---response end---200 OKRegistered socket 3 for persistent reuse.Length: 81 [text&#x2F;html]Saving to: ‘index.html’...</code></pre></div></figure><h2 id="1-2-HTTP协议版本"><a href="#1-2-HTTP协议版本" class="headerlink" title="1.2 HTTP协议版本"></a>1.2 HTTP协议版本</h2><table><thead><tr><th></th><th>http1.0</th><th>http1.1</th><th>http2.0</th><th>http3.0</th></tr></thead><tbody><tr><td>特点</td><td>短连接,每次请求都需要重复建立 断开连接.</td><td>加入长连接功能</td><td>增加并发 问更快 ,访</td><td>基于 流媒体 udp更快,应用于</td></tr><tr><td></td><td>占用服务端资源</td><td>keepalive功能 (网站响应后不会立刻断开,保留下 这个连接)</td><td></td><td></td></tr><tr><td>是否加密</td><td></td><td>http 不加密的 https 加密的</td><td>默认基于 https</td><td></td></tr><tr><td>基于 tcp&#x2F;udp</td><td>tcp</td><td>tcp</td><td>tcp</td><td>udp</td></tr></tbody></table><blockquote><p>目前状况：</p><ul><li>大部分企业还在使用http1.1, 一部分使用http2.0</li><li>目前http3.0( QUIC ) 流媒体直播在使用.</li></ul></blockquote><h2 id="1-3-HTTP协议详解"><a href="#1-3-HTTP协议详解" class="headerlink" title="1.3 HTTP协议详解"></a>1.3 HTTP协议详解</h2><p>图示一：请求报文和响应报文</p><p><img src="/../../../img/image-20240507101353334.png" alt="image-20240507101353334"></p><p>更为详细的流程如图：</p><p><img src="/../../../img/image-20240507103819706.png" alt="image-20240507103819706"></p><h3 id="1-3-1-HTTP请求"><a href="#1-3-1-HTTP请求" class="headerlink" title="1.3.1 HTTP请求"></a>1.3.1 HTTP请求</h3><h4 id="a-概述"><a href="#a-概述" class="headerlink" title="a) 概述"></a>a) 概述</h4><p>请求流程图示：</p><p><img src="/../../../img/image-20240507101546545.png" alt="image-20240507101546545"></p><h4 id="b-请求报文起始行"><a href="#b-请求报文起始行" class="headerlink" title="b) 请求报文起始行"></a>b) 请求报文起始行</h4><p>请求方法: 用于指定客户端如何访问服务端(下载,上传,查看服务端信息)  </p><table><thead><tr><th>常见的请求方法</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>下载(大部分请求)</td></tr><tr><td>POST</td><td>上传(上传文件内容,登录)</td></tr><tr><td>HEAD</td><td>类似于GET,仅仅输出响应的头部信息.(查看服务端的信息,一般用于检查)</td></tr></tbody></table><p>资源的位置(URI): 这个资源在网站站点目录的哪个地方,叫什么名字.  </p><p>这里面写的<code>/lidao.mp4</code>,斜线并非是Linux系统的根目录.这个<code>/</code>叫网站的站点目录  </p><blockquote><p>什么是URI (uri)？</p><ul><li>统一资源标识符</li></ul><p>什么是站点目录？</p><ul><li>用于存放网站代码的地方。未来在nginx中我们可以指定与查看。</li><li>GET &#x2F;lidaoav.mp4 HTTP&#x2F;1.1 这里的&#x2F;不是根,是网站站点目录,未来可以在web服务中进行配置.</li><li>比如&#x2F;app&#x2F;code&#x2F;www&#x2F;是站点目录</li><li>访问&#x2F;lidaoav.mp4 &#x3D;&#x3D; &#x2F;app&#x2F;code&#x2F;www&#x2F;lidaoav.mp4</li></ul></blockquote><h4 id="c-请求头"><a href="#c-请求头" class="headerlink" title="c) 请求头"></a>c) 请求头</h4><table><thead><tr><th>字段(一些关键词)</th><th>含义</th></tr></thead><tbody><tr><td>User-Agent</td><td>客户端代理(用什么工具访问网站),浏览器.</td></tr><tr><td>Host</td><td>表示访问的目标网站:域名或ip</td></tr><tr><td>….</td><td></td></tr></tbody></table><h4 id="d-其他"><a href="#d-其他" class="headerlink" title="d) 其他"></a>d) 其他</h4><p>请求报文中还包含：</p><ul><li>空行: 分割请求头与请求报文主体</li><li>请求报文主体(body): 一般上传的时候才有</li></ul><h3 id="1-3-2-HTTP响应"><a href="#1-3-2-HTTP响应" class="headerlink" title="1.3.2 HTTP响应"></a>1.3.2 HTTP响应</h3><h4 id="a-概述-1"><a href="#a-概述-1" class="headerlink" title="a) 概述"></a>a) 概述</h4><p>状态码与服务端信息  </p><p><img src="/../../../img/image-20240507103341566.png" alt="image-20240507103341566"></p><h4 id="b-响应报文起始行"><a href="#b-响应报文起始行" class="headerlink" title="b) 响应报文起始行"></a>b) 响应报文起始行</h4><p>协议与版本 HTTP&#x2F;1.1</p><p>状态码: 数字3位,用于描述服务端是否能找到或处理用户的请求.(类似于命令行错误提示) 200 ok. 404</p><p>状态码描述:  见1.3.3</p><h4 id="c-响应头"><a href="#c-响应头" class="headerlink" title="c) 响应头"></a>c) 响应头</h4><table><thead><tr><th>响应头字段</th><th></th></tr></thead><tbody><tr><td>Server</td><td>显示服务端使用的web服务器及版本</td></tr><tr><td>下面了解</td><td></td></tr><tr><td>Content-Type</td><td>媒体类型(文件类型)</td></tr><tr><td>Content-Length</td><td>大小</td></tr><tr><td>Location</td><td>跳转之后的新的位置(未来讲解rewrite 301&#x2F;302),跳转的时候才有</td></tr></tbody></table><h4 id="d）其他"><a href="#d）其他" class="headerlink" title="d）其他"></a>d）其他</h4><p>响应报文中还有什么？</p><ul><li>空行</li><li>响应报文主体: 服务端返回给客户端的数据</li></ul><h3 id="1-3-3-状态码"><a href="#1-3-3-状态码" class="headerlink" title="1.3.3 状态码"></a>1.3.3 状态码</h3><p>状态码:：错误提示，反映出服务端是否能够正常的处理用户请求  </p><p>大致分类：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>2xx</td><td>表示正常</td></tr><tr><td>3xx</td><td>表示需要进行跳转,表示正常</td></tr><tr><td>4xx</td><td>表示异常,客户端问题</td></tr><tr><td>5xx</td><td>表示异常,服务端问题</td></tr></tbody></table><p>详细状态码：</p><table><thead><tr><th>详细的状态码</th><th>说明</th></tr></thead><tbody><tr><td>200 ok</td><td>访问正常</td></tr><tr><td>301 Moved Permanently</td><td>永久跳转</td></tr><tr><td>302 Found或Moved Temporarily</td><td>临时跳转</td></tr><tr><td>304 Not Modified</td><td>浏览器缓存</td></tr><tr><td>403 Forbidden</td><td>权限拒绝(拒绝访问)</td></tr><tr><td>404 Not Found</td><td>文件找不到,一般辅助错误日志排查</td></tr><tr><td>500 Internal Error</td><td>内部错误,SElinux开启,其他原因一般辅助错误日志排查</td></tr><tr><td>502 Bad Gateway</td><td>网关错误,一般发生在负载中(类似场景下),请求发送到后面,后面无人处理,提示 502.</td></tr><tr><td>503 service temporarily unavailable</td><td>服务临时不可用,后端负载异常等情况,人为设置(升级)</td></tr><tr><td>504 Gateway Time-out</td><td>网关超时</td></tr></tbody></table><h3 id="1-3-4-HTTP协议小结"><a href="#1-3-4-HTTP协议小结" class="headerlink" title="1.3.4 HTTP协议小结"></a>1.3.4 HTTP协议小结</h3><p>HTTP: 用户的请求与响应的格式与定义</p><p>HTTP请求报文</p><ul><li>请求起始行: GET &#x2F; (url) HTTP&#x2F;1.1</li><li>请求头(head):<ul><li>User-Agent: 客户端代理(浏览器)  </li><li>Host: 域名</li></ul></li><li>空行</li><li>请求豹纹主体(body): POST</li></ul><p>HTTP响应报文</p><ul><li>响应报文的起始行: HTTP&#x2F;1.1 状态码</li><li>响应头: Server(web服务器)</li><li>空行</li><li>响应豹纹的主体(body): 文件内容</li></ul><p>状态码</p><h1 id="二、衡量系统访问量的指标"><a href="#二、衡量系统访问量的指标" class="headerlink" title="二、衡量系统访问量的指标"></a>二、衡量系统访问量的指标</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>指标分为：</p><table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td>IP</td><td>访问网站的独立ip数量，公网ip.</td></tr><tr><td>PV</td><td>页面访问量Page view.</td></tr><tr><td>UV</td><td>独立访客数量，接近于用户数量 Unique Vistor</td></tr><tr><td>DAU</td><td>每天的活跃用户的数量：日活(日活跃用户)</td></tr><tr><td>MAU</td><td>月活(月活跃用户)</td></tr></tbody></table><h2 id="2-2-统计方法"><a href="#2-2-统计方法" class="headerlink" title="2.2 统计方法"></a>2.2 统计方法</h2><p>IP,PV,UV </p><ul><li>使用三剑客进行过滤</li><li>第三方统计插件(百度统计,…..网站页面加入代码),ELK</li></ul><p>DAU,MAU </p><ul><li>第3方工具统计</li><li>数据库统计用户登录情况</li></ul><h1 id="三、Nginx介绍"><a href="#三、Nginx介绍" class="headerlink" title="三、Nginx介绍"></a>三、Nginx介绍</h1><h2 id="3-1-web服务概述"><a href="#3-1-web服务概述" class="headerlink" title="3.1 web服务概述"></a>3.1 web服务概述</h2><p><strong>WEB服务</strong>：网站服务,部署并启动了这个服务,你就可以搭建一个网站.<br><strong>WEB中间件</strong>：等同于WEB服务<br>中间件：范围更加广泛,指的负载均衡之后的服务.<br>数据库中间件：数据库缓存,消息对列… </p><h2 id="3-2-常见网站服务"><a href="#3-2-常见网站服务" class="headerlink" title="3.2 常见网站服务"></a>3.2 常见网站服务</h2><table><thead><tr><th>网站服务</th><th>说明</th></tr></thead><tbody><tr><td>Nginx</td><td>大部分使用nginx,Engine X</td></tr><tr><td>Tengine</td><td>基于Nginx二开,淘宝开源,更多内置模块</td></tr><tr><td>Openresty</td><td>基于Nginx二开,加强Lua功能与模块</td></tr><tr><td>……</td><td></td></tr><tr><td>Tomcat&#x2F;Jboss&#x2F;Jetty&#x2F;Weblogic</td><td>运行java环境的,web服务</td></tr><tr><td>PHP</td><td>运行php环境,需要ngx(LNMP)</td></tr></tbody></table><h2 id="3-3-配置Nginx"><a href="#3-3-配置Nginx" class="headerlink" title="3.3 配置Nginx"></a>3.3 配置Nginx</h2><p>Nginx版本选择：</p><ul><li>记录常用服务的版本：1.22.1</li><li>选用稳定版本：上一个稳定版本</li></ul><p><font color=red>本配置在web01（10.0.0.7）服务器操作</font></p><h3 id="3-3-1-安装nginx"><a href="#3-3-1-安装nginx" class="headerlink" title="3.3.1 安装nginx"></a>3.3.1 安装nginx</h3><p>配置yum源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;]#cat &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo[nginx-stable]name&#x3D;nginx stable repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;gpgcheck&#x3D;1enabled&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.keymodule_hotfixes&#x3D;true# 刷新yum源yum clean allyum makecache</code></pre></div></figure><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;]#yum install nginx -y# 查看安装情况[root@web01[ &#x2F;]#rpm -ql nginx&#x2F;etc&#x2F;logrotate.d&#x2F;nginx&#x2F;etc&#x2F;nginx&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params&#x2F;etc&#x2F;nginx&#x2F;mime.types&#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&#x2F;etc&#x2F;nginx&#x2F;scgi_params&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx-debug.service&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules&#x2F;usr&#x2F;libexec&#x2F;initscripts&#x2F;legacy-actions&#x2F;nginx&#x2F;usr&#x2F;libexec&#x2F;initscripts&#x2F;legacy-actions&#x2F;nginx&#x2F;check-reload&#x2F;usr&#x2F;libexec&#x2F;initscripts&#x2F;legacy-actions&#x2F;nginx&#x2F;upgrade&#x2F;usr&#x2F;sbin&#x2F;nginx&#x2F;usr&#x2F;sbin&#x2F;nginx-debug&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.26.0&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.26.0&#x2F;COPYRIGHT&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;var&#x2F;log&#x2F;nginx[root@web01[ &#x2F;]#rpm -qa nginxnginx-1.26.0-1.el7.ngx.x86_64</code></pre></div></figure><h3 id="3-3-2-nginx目录结构"><a href="#3-3-2-nginx目录结构" class="headerlink" title="3.3.2 nginx目录结构"></a>3.3.2 nginx目录结构</h3><blockquote><p>温馨提示:</p><p>Nginx不同的安装方法，目录，文件会有所区别.  </p></blockquote><table><thead><tr><th>目录结构</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;nginx&#x2F;</td><td>nginx各种配置目录</td></tr><tr><td>&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</td><td>主配置文件</td></tr><tr><td>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</td><td>子配置文件(网站)</td></tr><tr><td>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</td><td>默认的子配置文件</td></tr><tr><td>&#x2F;usr&#x2F;sbin&#x2F;nginx</td><td>ngx命令</td></tr><tr><td>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</td><td>ngx默认的站点目录,网站的根目录</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;</td><td>ngx日志: 访问日志,错误日志 ,跳转日志</td></tr></tbody></table><p>其他目录说明</p><table><thead><tr><th>其他目录和文件</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;logrotate.d&#x2F;nginx</td><td>日志切割(防止文件过大)</td></tr><tr><td>&#x2F;etc&#x2F;nginx&#x2F;mime.types</td><td>媒体类型</td></tr><tr><td>&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params</td><td>ngx+php</td></tr><tr><td>&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params</td><td>ngx+python</td></tr><tr><td>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service</td><td>systemctl配置文件</td></tr><tr><td>&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;</td><td>缓存目录</td></tr></tbody></table><h3 id="3-3-3-服务启动与管理"><a href="#3-3-3-服务启动与管理" class="headerlink" title="3.3.3 服务启动与管理"></a>3.3.3 服务启动与管理</h3><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable nginxsystemctl start nginx</code></pre></div></figure><p>检查端口与进程</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#检查服务状态systemctl status nginx#检查端口，会显示TCP和UDPss -lntup |grep 80#检查进程ps -ef |grep nginx</code></pre></div></figure><p>浏览器访问：<a href="http://10.0.0.7/">http://10.0.0.7</a></p><p><img src="/../../../img/image-20240507110935037.png" alt="image-20240507110935037"></p><p>命令访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl 10.0.0.7curl -v 10.0.0.7</code></pre></div></figure><h1 id="四、Nginx核心功能"><a href="#四、Nginx核心功能" class="headerlink" title="四、Nginx核心功能"></a>四、Nginx核心功能</h1><h2 id="4-1-配置文件详解"><a href="#4-1-配置文件详解" class="headerlink" title="4.1 配置文件详解"></a>4.1 配置文件详解</h2><h3 id="4-1-1-主配置文件"><a href="#4-1-1-主配置文件" class="headerlink" title="4.1.1 主配置文件"></a>4.1.1 主配置文件</h3><p>主配置文件：<code>/etc/nginx/nginx.conf  </code></p><p>各配置项的详解如下：</p><p><img src="/../../../img/image-20240507111202660.png" alt="image-20240507111202660"></p><blockquote><p>需要熟练掌握的配置项</p><ul><li>include 文件包含,引用其他地方的ngx配置文件.</li><li>user指定ngx用户.</li><li>error_log错误日志</li><li>log_format日志格式</li><li>access_log 访问日志</li></ul></blockquote><h3 id="4-1-2-子配置文件"><a href="#4-1-2-子配置文件" class="headerlink" title="4.1.2 子配置文件"></a>4.1.2 子配置文件</h3><p>子配置文件：<code>/etc/nginx/conf.d/default.conf</code></p><p><img src="/../../../img/image-20240507111428798.png" alt="image-20240507111428798"></p><p>常用选项如下：</p><table><thead><tr><th>网站中常用必会指 令</th><th>说明</th></tr></thead><tbody><tr><td>listen</td><td>指定监听端口</td></tr><tr><td>server_name</td><td>指定域名,多个通过空格分割.</td></tr><tr><td>location(区域)</td><td>匹配请求中的uri(资源地址)</td></tr><tr><td>root</td><td>指定站点目录(网站的根目录) root &#x2F;app&#x2F;code&#x2F;www; <a href="http://www.baidu.com/lidao/lidao.txt">www.baidu.com/lidao/lidao.txt</a> &#x3D;&#x3D; &#x2F;app&#x2F;code&#x2F;www&#x2F;lidao&#x2F;lidao.txt</td></tr><tr><td>index</td><td>指定站点的首页文件. 用户访问的时候不加上任何的文件,展示首页文件.</td></tr><tr><td>error_log</td><td>指定错误状态码与对应的错误页面.</td></tr></tbody></table><blockquote><p>ngx:必会问题：</p><p>如果删除首页文件,进行(不指定文件)访问会发生什么?</p><ul><li>403首页文件不存在.</li></ul></blockquote><h2 id="4-2-部署第一个CXK网站"><a href="#4-2-部署第一个CXK网站" class="headerlink" title="4.2 部署第一个CXK网站"></a>4.2 部署第一个CXK网站</h2><table><thead><tr><th>网站要求</th><th>说明</th></tr></thead><tbody><tr><td>域名</td><td>cxk.oldboylinux.cn</td></tr><tr><td>站点目录</td><td>&#x2F;app&#x2F;code&#x2F;cxk</td></tr><tr><td>代码来源</td><td><a href="https://gitee.com/xiaomingcai/cxk">https://gitee.com/xiaomingcai/cxk</a></td></tr></tbody></table><h3 id="a-部署代码"><a href="#a-部署代码" class="headerlink" title="a) 部署代码"></a>a) 部署代码</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建目录&#x2F;app&#x2F;cpde&#x2F;cxk[root@web01[ &#x2F;app]#mkdir -p code&#x2F;cxk# 解压代码放进去[root@web01[ &#x2F;]#tree -F app&#x2F;code&#x2F;cxkapp&#x2F;code&#x2F;cxk├── about.md├── css&#x2F;│   ├── common.css│   └── style.css├── images&#x2F;│   ├── b1.png│   ├── b2.png....</code></pre></div></figure><h3 id="b-创建配置文件"><a href="#b-创建配置文件" class="headerlink" title="b) 创建配置文件"></a>b) 创建配置文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 新建配置文件[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat cxk.oldboylinux.cn.confserver &#123;  listen 80;  server_name cxk.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;cxk;  location &#x2F; &#123;    index index.html;  &#125;&#125;# 检查[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful# 重新加载[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl reload nginx</code></pre></div></figure><h2 id="c-设置客户机器的hosts解析文件"><a href="#c-设置客户机器的hosts解析文件" class="headerlink" title="c) 设置客户机器的hosts解析文件"></a>c) 设置客户机器的hosts解析文件</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">10.0.0.7 cxk.oldboylinux.cn</code></pre></div></figure><p>访问</p><p><img src="/../../../img/image-20240507113859205.png" alt="image-20240507113859205"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-Web集群-Nginx(二)</title>
    <link href="/2024/05/07/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/12-web%E9%9B%86%E7%BE%A4-Nginx-2/"/>
    <url>/2024/05/07/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/12-web%E9%9B%86%E7%BE%A4-Nginx-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Web集群-Nginx（二）"><a href="#Web集群-Nginx（二）" class="headerlink" title="Web集群-Nginx（二）"></a>Web集群-Nginx（二）</h1><h1 id="一、Nginx处理用户请求流程"><a href="#一、Nginx处理用户请求流程" class="headerlink" title="一、Nginx处理用户请求流程"></a>一、Nginx处理用户请求流程</h1><p>思考问题：之前搭建的cxk.oldboylinux.cn网站,使用域名访问或ip访问都是没有问</p><p>题的.如果把配置文件名game.cxk.oldboylinux.cn.conf使用域名或ip访问或怎么样?  </p><p>答案：</p><ul><li>域名访问网站没有任何问题.</li><li>使用ip访问则显示静态页面,另外一个网站了</li></ul><p>域名访问正常：</p><p><img src="/../../../img/image-20240507151441247.png" alt="image-20240507151441247"></p><p>IP访问异常</p><p><img src="/../../../img/image-20240507151451949.png" alt="image-20240507151451949"></p><p>为什么是这样？它的详细原理是什么。</p><h2 id="1-1-详细原理"><a href="#1-1-详细原理" class="headerlink" title="1.1 详细原理"></a>1.1 详细原理</h2><p>使用域名访问网站的流程图示如下：</p><p><img src="/../../../img/image-20240507152303529.png" alt="image-20240507152303529"></p><h3 id="1-1-1-正常流程步骤"><a href="#1-1-1-正常流程步骤" class="headerlink" title="1.1.1 正常流程步骤"></a>1.1.1 正常流程步骤</h3><p>1、DNS解析：cxk.oldboylinux.cn –&gt; 10.0.0.7</p><p>2、连接80端口：TCP三次握手与网站80端口建立连接</p><p>3、发送HTTP请求报文：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">GET &#x2F;index.htmlHOST: cxk.oldboylinux.cnUser-Agent: Chrome&#x2F;xxx</code></pre></div></figure><p>4、nginx处理：</p><ul><li>http请求，http区域处理</li><li>不同server{}区域（子配置文件）处理<ul><li>端口</li><li>域名：用户请求的域名与子配置文件server_name进行匹配  </li><li>匹配成功,就让对应的子配置文件(server{})处理</li><li>根据子配置文件的,root,location规则,index进行处理查找文件.</li><li>把找到的文件发回给用户</li></ul></li></ul><p>5、HTTP响应报文：</p><ul><li>状态码：200 ok</li><li>server信息</li><li>其他信息</li><li>文件内容</li></ul><p>6、客户收到文件，浏览器解析，进行展示</p><h3 id="1-1-2-请求域名不存在的流程"><a href="#1-1-2-请求域名不存在的流程" class="headerlink" title="1.1.2 请求域名不存在的流程"></a>1.1.2 请求域名不存在的流程</h3><p>对于没有正确匹配到请求域名的访问：</p><ul><li><p>没有配置&#x2F;指定默认的虚拟主机（子配置文件）</p><ul><li>把子配置文件按字母排序，返回第一个</li></ul></li><li><p>配置了默认站点让用户访问</p><ul><li>返回default_server设置的默认站点</li></ul></li></ul><p>此流程只适应于没有配置过虚拟主机的域名，如果域名已经配置过server{}，只是</p><p>没有找到对应的文件，则还是会返回404</p><h1 id="二、虚拟主机"><a href="#二、虚拟主机" class="headerlink" title="二、虚拟主机"></a>二、虚拟主机</h1><p>在第一章中老师提到<code>虚拟主机</code>，它到底是什么？</p><ul><li>一个虚拟主机：相当于是一个网站，在nginx中通过<code>server&#123;&#125;</code>区域实现</li><li>虚拟主机有<strong>不同的类型</strong>，配置也相同</li></ul><h2 id="2-1-概述和分类"><a href="#2-1-概述和分类" class="headerlink" title="2.1 概述和分类"></a>2.1 概述和分类</h2><p>虚拟主机的类型和介绍</p><table><thead><tr><th>虚拟主机的分类</th><th>说明</th><th>应用场景</th></tr></thead><tbody><tr><td><font color=red>基于域名的虚拟主机 </font></td><td>不同<strong>域名</strong>访问不同的站点.</td><td>生产环境<strong>最常用</strong>的.</td></tr><tr><td>基于端口的虚拟主机</td><td>不同<strong>端口</strong>访问不同的站点.</td><td>保护,设置特殊端口.1024以上 8888 18888</td></tr><tr><td>基于IP的虚拟主机</td><td>不同<strong>IP</strong>访问不同的站点.</td><td>保护,用户只能通过某个ip连接进来. 用来限制网站只能通过指定的ip进行访问内网ip,vpn ip.</td></tr></tbody></table><h2 id="2-2-基于域名的虚拟主机"><a href="#2-2-基于域名的虚拟主机" class="headerlink" title="2.2 基于域名的虚拟主机"></a>2.2 基于域名的虚拟主机</h2><p>顾名思义：通过不同域名访问不同的主机</p><p>案例：创建bird.oldboylinux.cn网站，站点目录<code>/app/code/bird/</code>，书写配置文件.  </p><blockquote><p>思考：</p><p>1.完成后不创建站点目录进行访问看看报什么错误.</p><p>2.创建站点目录后再访问看看报什么错误.</p><p>3.创建首页文件和内容,访问看看显示什么  </p><p>补充思考：</p><p>访问一个完全没配置过虚拟主机的域名会怎样？</p></blockquote><p>书写配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建子配置文件[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat bird.oldboylinux.cn.confserver &#123;  listen 80;  server_name bird.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;bird;  location &#x2F; &#123;    index index.html;  &#125;&#125;# 重新加载服务[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#systemctl reload nginx# windows客户端做hosts解析...</code></pre></div></figure><p>测试：</p><ul><li>完成后不创建站点目录进行访问看看报什么错误？<ul><li>404错误</li></ul></li><li>创建站点目录后再访问看看报什么错误<ul><li>403错误</li></ul></li><li>创建首页文件和内容,访问看看显示什么 <ul><li>正常显示</li></ul></li><li>访问一个完全没配置过虚拟主机的域名会怎样<ul><li>hosts设置，<code>10.0.0.7 test.oldboylinux.cn</code></li><li>访问显示bird的页面，说明<code>1.1.2</code>小节流程有效</li></ul></li></ul><p><img src="/../../../img/image-20240507155234141.png" alt="image-20240507155234141"></p><blockquote><p>本地测试域名的小技巧(linux)  </p><ul><li>curl -v -H “Host: cxk.oldboylinux.cn” <a href="http://10.0.0.7/index.html">http://10.0.0.7/index.html</a></li><li>-H修改请求头里面的内容</li></ul></blockquote><h2 id="2-3-基于端口的虚拟主机"><a href="#2-3-基于端口的虚拟主机" class="headerlink" title="2.3 基于端口的虚拟主机"></a>2.3 基于端口的虚拟主机</h2><p>顾名思义：根据不同的端口，访问不同的网站</p><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建live网站，并将端口改为81[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat live.oldboylinux.cn.confserver &#123;  listen 81;  server_name live.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;live;  location &#x2F; &#123;    index index.html;  &#125;&#125;# 添加网页文件[root@web01[ &#x2F;app&#x2F;code&#x2F;live]#tree &#x2F;app&#x2F;code&#x2F;live&#x2F;&#x2F;app&#x2F;code&#x2F;live&#x2F;└── index.html</code></pre></div></figure><p>测试访问：</p><p>命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;live]#curl -v -H &quot;Host: live.oldboylinux.cn&quot; http:&#x2F;&#x2F;10.0.0.7:81&#x2F;index.html* About to connect() to 10.0.0.7 port 81 (#0)*   Trying 10.0.0.7...* Connected to 10.0.0.7 (10.0.0.7) port 81 (#0)&gt; GET &#x2F;index.html HTTP&#x2F;1.1&gt; User-Agent: curl&#x2F;7.29.0&gt; Accept: *&#x2F;*&gt; Host: live.oldboylinux.cn&gt;&lt; HTTP&#x2F;1.1 200 OK&lt; Server: nginx&#x2F;1.26.0&lt; Date: Tue, 07 May 2024 07:58:07 GMT&lt; Content-Type: text&#x2F;html&lt; Content-Length: 252&lt; Last-Modified: Tue, 07 May 2024 07:54:57 GMT&lt; Connection: keep-alive&lt; ETag: &quot;6639de51-fc&quot;&lt; Accept-Ranges: bytes&lt;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Live Show&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;Welcome to Live Show Page&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;* Connection #0 to host 10.0.0.7 left intact</code></pre></div></figure><p>浏览器</p><p><img src="/../../../img/image-20240507155545483.png" alt="image-20240507155545483"></p><h2 id="2-4-基于IP的虚拟主机"><a href="#2-4-基于IP的虚拟主机" class="headerlink" title="2.4 基于IP的虚拟主机"></a>2.4 基于IP的虚拟主机</h2><p>搭建mimi网站,端口是8888,只能通过172.16.1.7内网访问  </p><p><font color=red>在listen字段需要绑定IP</font></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建虚拟主机[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat mi.oldboylinux.cn.confserver &#123;  listen 172.16.1.7:8888;  server_name mi.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;mi;  location &#x2F; &#123;    index index.html;  &#125;&#125;# 添加网页文件[root@web01[ &#x2F;app&#x2F;code]#tree &#x2F;app&#x2F;code&#x2F;mi&#x2F;&#x2F;app&#x2F;code&#x2F;mi&#x2F;└── index.html</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 172网段访问成功[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#curl -v -H &quot;Host: mi.oldboylinux.cn&quot; http:&#x2F;&#x2F;172.16.1.7:8888&#x2F;index.html* About to connect() to 172.16.1.7 port 8888 (#0)*   Trying 172.16.1.7...* Connected to 172.16.1.7 (172.16.1.7) port 8888 (#0)。...&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Mi Mi Small Mi&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;年青人的第一个MI页面&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;* Connection #0 to host 172.16.1.7 left intact# 10网段访问失败[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#curl -v -H &quot;Host: mi.oldboylinux.cn&quot; http:&#x2F;&#x2F;10.0.0.7:8888&#x2F;index.html* About to connect() to 10.0.0.7 port 8888 (#0)*   Trying 10.0.0.7...* Connection refused* Failed connect to 10.0.0.7:8888; Connection refused* Closing connection 0curl: (7) Failed connect to 10.0.0.7:8888; Connection refused</code></pre></div></figure><h1 id="三、Nginx日志"><a href="#三、Nginx日志" class="headerlink" title="三、Nginx日志"></a>三、Nginx日志</h1><p>主要内容：</p><ul><li>如何给每个虚拟主机指定自己独立的错误日志  </li><li>如何给每个虚拟主机指定自己独立的访问日志</li></ul><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>错误日志和访问日志的定义</p><table><thead><tr><th>日志</th><th>使用建议</th><th>定义</th><th>使用</th></tr></thead><tbody><tr><td>错误日志</td><td>发生故障的时候可以查看,4xx,5xx</td><td>通过错误级别指定</td><td>error_log</td></tr><tr><td>访问日志</td><td>记录着用户什么时候访问 网站哪些页面,客户端信息.</td><td>通过log_format定义访问日志的格式</td><td>access_log</td></tr></tbody></table><h2 id="3-2-错误日志"><a href="#3-2-错误日志" class="headerlink" title="3.2 错误日志"></a>3.2 错误日志</h2><p>指定错误日志的位置和错误日志级别</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">格式:error_log 文件名 级别</code></pre></div></figure><p>错误日志级别</p><table><thead><tr><th>级别</th><th>定义</th></tr></thead><tbody><tr><td>debug</td><td>记录调试信息</td></tr><tr><td>info</td><td>记录一般信息</td></tr><tr><td>notice</td><td>记录不影响操作的信息</td></tr><tr><td>warn</td><td>记录警告信息</td></tr><tr><td>error</td><td>记录错误信息</td></tr><tr><td>crit</td><td>记录严重的错误信息</td></tr><tr><td>alert</td><td>记录必须立即处理的信息</td></tr><tr><td>emerg</td><td>记录紧急的信息</td></tr></tbody></table><blockquote><p>debug: 未来主要用于调试使用，短时间开启，在网站访问量较大时别开</p></blockquote><p>案例：给每个虚拟主机指定自己独立的错误日志  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat cxk.oldboylinux.cn.confserver &#123;  listen 80;  server_name cxk.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;cxk;  # 设置错误日志  error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;cxk.oldboylinux.cn-error.log notice;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>**<font color=red>注意：</font>**如开启独立错误日志，需要把nginx.conf里面的error_log注释</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;etc&#x2F;nginx&#x2F;nginx.confuser  nginx;worker_processes  auto;#error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log notice;pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;...</code></pre></div></figure><h2 id="3-2-访问日志"><a href="#3-2-访问日志" class="headerlink" title="3.2 访问日志"></a>3.2 访问日志</h2><h3 id="3-2-1-日志格式配置"><a href="#3-2-1-日志格式配置" class="headerlink" title="3.2.1 日志格式配置"></a>3.2.1 日志格式配置</h3><p>辅助我们进行分析，如网站访问量，ip，pv，访问日志设置的格式</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">log_format 格式名字 格式.....;</code></pre></div></figure><p> 访问日志格式</p><table><thead><tr><th>Ngx访问日志格式(ngx内置变量)</th><th>说明</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端ip地址</td></tr><tr><td>$remote_user</td><td>用户名(空,进行认证用户)</td></tr><tr><td>$time_local</td><td>时间 30&#x2F;Aug&#x2F;2022:14:44:27 +0800</td></tr><tr><td>$request</td><td>请求报文的起始行(请求方法 URI HTTP&#x2F;1.1)</td></tr><tr><td>$status</td><td>http状态码</td></tr><tr><td>$body_bytes_sent</td><td>响应给客户的文件的大小,响应报文的主体大小(文件大小) 单位字节</td></tr><tr><td>$http_referer</td><td>从哪里跳转,访问到这个网站的. 网站运营分析</td></tr><tr><td>$http_user_agent</td><td>客户端代理(浏览器)</td></tr><tr><td>$http_x_forwarded_for</td><td>XFF头,负载中使用,记录用户真实的ip地址.</td></tr></tbody></table><p>日志格式配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;var&#x2F;log&#x2F;nginx]#cat &#x2F;etc&#x2F;nginx&#x2F;nginx.conf...http &#123;...    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;#    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;...&#125;</code></pre></div></figure><h3 id="3-2-2-访问日志配置"><a href="#3-2-2-访问日志配置" class="headerlink" title="3.2.2 访问日志配置"></a>3.2.2 访问日志配置</h3><p>access_log指定日志，使用对应格式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">access_log 日志位置 格式</code></pre></div></figure><p>案例：给每个虚拟主机指定自己独立的访问日志  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat cxk.oldboylinux.cn.confserver &#123;  listen 80;  server_name cxk.oldboylinux.cn;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;cxk.oldboylinux.cn-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;cxk.oldboylinux.cn-access.log main;  root &#x2F;app&#x2F;code&#x2F;cxk;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><p>**<font color=red>注意：</font>**如开启独立错误日志，需要把nginx.conf里面的access_log注释</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat &#x2F;etc&#x2F;nginx&#x2F;nginx.conf...#    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</code></pre></div></figure><p>查看效果</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#tree &#x2F;var&#x2F;log&#x2F;nginx&#x2F;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;├── access.log├── cxk.oldboylinux.cn-access.log├── cxk.oldboylinux.cn-error.log└── error.log</code></pre></div></figure><h3 id="3-2-3-访问日志其他选项"><a href="#3-2-3-访问日志其他选项" class="headerlink" title="3.2.3 访问日志其他选项"></a>3.2.3 访问日志其他选项</h3><p>了解即可，未来根据需要进行配置</p><table><thead><tr><th>access_log</th><th>说明</th></tr></thead><tbody><tr><td>访问日志进行压缩</td><td>gzip需要通过zcat&#x2F;zless&#x2F;zgrep查看</td></tr><tr><td>进行缓存</td><td>buffer &#x3D; 32k 先把日志写入到内存中,定期写入到磁盘</td></tr><tr><td>定义刷新时间</td><td>flush &#x3D;10s</td></tr></tbody></table><p>配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx]#cat conf.d&#x2F;cxk.oldboylinux.cn.confserver &#123;  listen 80;  server_name cxk.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;cxk;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;cxk.oldboylinux.cn-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;cxk.oldboylinux.cn-access.log main gzip buffer&#x3D;32k flush&#x3D;10s;  location &#x2F; &#123;    index index.html;  &#125;&#125;</code></pre></div></figure><h1 id="四、Location规则"><a href="#四、Location规则" class="headerlink" title="四、Location规则"></a>四、Location规则</h1><p>通过两个案例来了解location规则</p><h2 id="4-1-location概述"><a href="#4-1-location概述" class="headerlink" title="4.1 location概述"></a>4.1 location概述</h2><p>ngx的location规则，也叫<strong>路由规则</strong></p><ul><li>在ngx用于匹配用户请求中的uri，ngx对用户请求中的uri进行判断.</li><li>如果用户请求的uri是xxxx,则做xxxx.</li></ul><blockquote><p><strong>URI和URL的区别</strong></p><p>URL：网址 <a href="https://nginx.org/en/docs/">https://nginx.org/en/docs/</a></p><p>URI：&#x2F;en&#x2F;docs&#x2F;</p><p>对比：<a href="http://www.baidu.com/lidao/lidao.avi">http://www.baidu.com/lidao/lidao.avi</a></p><p>URI：&#x2F;lidao&#x2F;lidao.avi 域名后面的内容</p><p>URL: <a href="http://www.baidu.com/lidao/lidao.avi">http://www.baidu.com/lidao/lidao.avi</a> 网址</p><p>对比：<a href="http://www.baidu.com/">http://www.baidu.com</a></p><p>URI: &#x2F; 域名后面的内容</p><p>URL: <a href="http://www.baidu.com/">http://www.baidu.com</a> 网址  </p></blockquote><p>location规则说明</p><table><thead><tr><th>location规则</th><th>说明</th></tr></thead><tbody><tr><td>⭐location &#x2F; {xxxx}</td><td>默认规则,保底,location规则在进行匹配的时候,其他的规则都匹配失败了,这时候匹 配默认的规则.</td></tr><tr><td>⭐location &#x2F;image&#x2F; {}</td><td>用于匹配请求的uri (路径) cxk.oldboylinux.cn&#x2F;image&#x2F;lidao.txt ✅</td></tr><tr><td>⭐location ~ . (jpg|jpeg)$ {}</td><td>支持正则,区分大小写 cxk.oldboylinux.cn&#x2F;lidao&#x2F;lidao.jpg</td></tr><tr><td>⭐location ~* . (jpg|jpeg)$ {}</td><td>支持正则,不区分大小写 cxk.oldboylinux.cn&#x2F;lidao&#x2F;lidao.jpg</td></tr><tr><td>location ^~ &#x2F;lidao&#x2F;</td><td>不支持正则,仅仅匹配普通字符,很少使用,优先.</td></tr><tr><td>location &#x3D; &#x2F;50x.html</td><td>不支持正则,精确匹配,使用较少.</td></tr><tr><td>location @名字 {}</td><td>命名的location一般用于return&#x2F;error_log 跳转.</td></tr></tbody></table><p>location匹配优先级</p><table><thead><tr><th>优先级</th><th>符号</th></tr></thead><tbody><tr><td>1</td><td>&#x3D;</td></tr><tr><td>2</td><td>^~</td></tr><tr><td>3</td><td><del>、</del>*</td></tr><tr><td>4</td><td>&#x2F;image&#x2F;</td></tr><tr><td>5</td><td>&#x2F;</td></tr></tbody></table><h2 id="4-2-location案例1"><a href="#4-2-location案例1" class="headerlink" title="4.2 location案例1"></a>4.2 location案例1</h2><p>案例：搭建大型直播购物网站  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">要求：域名:buy.oldboylinux.cn站点目录:&#x2F;app&#x2F;code&#x2F;buy&#x2F; 首页文件index.html后台管理页面:&#x2F;app&#x2F;code&#x2F;buy&#x2F;admin&#x2F;index.html要求后台页面（admin）只能内网访问:172.16.1.0&#x2F;24网段</code></pre></div></figure><p>配置虚拟主机：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;etc&#x2F;nginx&#x2F;conf.d]#cat buy.oldboylinux.cn.confserver &#123;  listen 80;  server_name buy.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;buy;  error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;buy.oldboylinux.cn-error.log notice;  access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;buy.oldboylinux.cn-access.log main;  location &#x2F; &#123;    index index.html;  &#125;  #buy.oldboylinux.cn&#x2F;admin&#x2F;  #uri: &#x2F;admin&#x2F;  # 后台页面特殊配置  location &#x2F;admin &#123;    # 准许172.16.1.0&#x2F;24网段访问    allow 172.16.1.0&#x2F;24    # 拒绝其他所有    deny all  &#125;&#125;</code></pre></div></figure><p>添加网页文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;buy]#echo &quot;buy web site&quot; &gt; index.html[root@web01[ &#x2F;app&#x2F;code&#x2F;buy]#echo &quot;admin web site&quot; &gt; admin&#x2F;index.html[root@web01[ &#x2F;app&#x2F;code&#x2F;buy]#tree &#x2F;app&#x2F;code&#x2F;buy&#x2F;&#x2F;app&#x2F;code&#x2F;buy&#x2F;├── admin│   └── index.html└── index.html</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 10网段访问主页面 --- OK[root@web01[ &#x2F;app&#x2F;code]#curl -v -H &quot;Host: buy.oldboylinux.cn&quot; http:&#x2F;&#x2F;10.0.0.7:80&#x2F;index.html* About to connect() to 10.0.0.7 port 80 (#0)...&lt; HTTP&#x2F;1.1 200 OK...buy web site# 10网段访问admin页面 --- ERROR[root@web01[ &#x2F;app&#x2F;code]#curl -v -H &quot;Host: buy.oldboylinux.cn&quot; http:&#x2F;&#x2F;10.0.0.7:80&#x2F;admin&#x2F;index.html* About to connect() to 10.0.0.7 port 80 (#0)...&lt; HTTP&#x2F;1.1 403 Forbidden# 172网段访问admin页面 --- OK[root@web01[ &#x2F;app&#x2F;code]#curl -v -H &quot;Host: buy.oldboylinux.cn&quot; http:&#x2F;&#x2F;172.16.1.7:80&#x2F;admin&#x2F;index.html* About to connect() to 10.0.0.7 port 80 (#0)...&lt; HTTP&#x2F;1.1 200 OK...admin web site</code></pre></div></figure><h2 id="4-3-location案例2"><a href="#4-3-location案例2" class="headerlink" title="4.3 location案例2"></a>4.3 location案例2</h2><p>案例：搭建bird小鸟飞飞网站，给网站加速，设置缓存，网站中html、js、css结</p><p>尾的文件缓存1天，图片缓存1小时 。</p><blockquote><p>缓存了解：</p><p>基本配置浏览器访问并没有缓存  </p></blockquote><p>配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;app&#x2F;code&#x2F;bird]#cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;bird.oldboylinux.cn.confserver &#123;  listen 80;  server_name bird.oldboylinux.cn;  root &#x2F;app&#x2F;code&#x2F;bird;  location &#x2F; &#123;    index index.html;  &#125;  # uri包含 .html或者.js或者.css 缓存1天  location ~* \.(html|js|css)$ &#123;    expires 1d;    #expires max;  &#125;  # uri包含 .jpg或.jpge或.png或.gif或.bmp 缓存1小时  location ~* \.(jpg|jpeg|png|gif|bmp)$ &#123;    expier 1h;  &#125;&#125;</code></pre></div></figure><p>网页内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载flyppy birdhttps:&#x2F;&#x2F;gitee.com&#x2F;rc-wei&#x2F;JS-Flappy-Bird&#x2F;repository&#x2F;archive&#x2F;master.zip# 导入[root@web01[ &#x2F;app&#x2F;code&#x2F;bird]#tree ..├── flappy.css├── flappy.js├── img│   ├── banner.jpg│   ├── bg.jpg│   ├── bird.gif│   ├── down.gif│   ├── down_mod.png│   ├── down_pipe.png│   ├── head.jpg│   ├── start.jpg│   ├── up.gif│   ├── up_mod.png│   └── up_pipe.png├── index.html└── README.md</code></pre></div></figure><p>测试访问正常</p><p><img src="/../../../img/image-20240507175222019.png" alt="image-20240507175222019"></p><p>chrome浏览器F12开启缓存查看</p><p><img src="/../../../img/image-20240507175140195.png" alt="image-20240507175140195"></p><p>缓存生效</p><p><img src="/../../../img/image-20240507175201535.png" alt="image-20240507175201535"></p><h2 id="4-4-location案例3"><a href="#4-4-location案例3" class="headerlink" title="4.4 location案例3"></a>4.4 location案例3</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name l.oldboylinux.cn;    default_type text&#x2F;html;    location &#x2F; &#123;      return 200 &quot;location &#x2F;\n&quot;;    &#125;    location &#x3D; &#x2F;index.html &#123;      return 200 &quot;location &#x3D;&#x2F;\n&quot;;    &#125;    location ~ &#x2F;index.html &#123;      return 200 &quot;location ~&#x2F;\n&quot;;    &#125;    location ^~ &#x2F;index.html &#123;      return 200 &quot;location ^~\n&quot;;    &#125;&#125;</code></pre></div></figure><p>以上的访问优先级是什么？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x3D; &#x2F; &#123;[ configuration A ]&#125;location &#x2F; &#123;[ configuration B ]&#125;location &#x2F;documents&#x2F; &#123;[ configuration C ]&#125;location ^~ &#x2F;images&#x2F; &#123;[ configuration D ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123;[ configuration E ]&#125;</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">“&#x2F;” A“&#x2F;index.html” B“&#x2F;documents&#x2F;document.html” C“&#x2F;images&#x2F;1.gif” D“&#x2F;documents&#x2F;1.jpg” E</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-集群自动化维护-Ansible(四)-完结</title>
    <link href="/2024/05/06/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/10-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-4-%E5%AE%8C%E7%BB%93/"/>
    <url>/2024/05/06/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/10-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-4-%E5%AE%8C%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Ansible集群自动化维护（四）-完结"><a href="#Ansible集群自动化维护（四）-完结" class="headerlink" title="Ansible集群自动化维护（四）- 完结"></a>Ansible集群自动化维护（四）- 完结</h1><h1 id="一、include文件包含"><a href="#一、include文件包含" class="headerlink" title="一、include文件包含"></a>一、include文件包含</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>应用场景：</p><p>在我们书写剧本的时候，会涉及到多个步骤，有时还会涉及到服务端和客户端。当剧本越来越大时，不容易进行分</p><p>析与阅读，这时候就需要把剧本拆分开，分成多个文件，如服务端、客户端。然后可以通过include_tasks的功能把</p><p>多个剧本文件合并在一起，让剧本变成多个方便阅读与维护  </p><p>如：普通部署nfs服务的方式：</p><p><img src="/../../../img/image-20240506170319545.png" alt="image-20240506170319545"></p><p>采用include的剧本</p><p><img src="/../../../img/image-20240506170346946.png" alt="image-20240506170346946"></p><h2 id="1-2-实现案例"><a href="#1-2-实现案例" class="headerlink" title="1.2 实现案例"></a>1.2 实现案例</h2><p>拆分nfs部署的剧本，实现如下：</p><p>部署服务端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 服务端[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 15-deploy-nfs-server.yml    - name: 01. 安装服务      yum:        name: nfs-utils, rpcbind        state: present      # 打标签tag      tags:        - 01.install    - name: 02. 修改配置文件      lineinfile:        path: &#x2F;etc&#x2F;exports        line: &quot;&#x2F;backup-nfs 172.16.1.0&#x2F;24(rw, all_squash)&quot;        create: true      tags:        - 02.conf    - name: 03. 创建共享目录并修改所有者      file:        path: &#x2F;backup-nfs        owner: nfsnobody        group: nfsnobody        state: directory      tags:        - 03.dir    - name: 04. 启动服务      systemd:        name: &quot;&#123;&#123; item &#125;&#125;&quot;        state: started        enabled: yes      loop:        - rpcbind        - nfs      tags:        - 04.start_srv</code></pre></div></figure><p>部署客户端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 15-deploy-nfs-client.yml# 客户端    - name: 01. 部署nfs-utils      yum:        name: nfs-utils        state: present    - name: 02. 挂载nfs      mount:        src: 172.16.1.41:&#x2F;backup-nfs        path: &#x2F;ans-upload        fstype: nfs        state: mounted</code></pre></div></figure><p>include整合</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 15-deploy-nfs-all.yml# 服务端- hosts: backup01  tasks:    - include_tasks: 15-deploy-nfs-server.yml# 客户端- hosts: web01  tasks:    - include_tasks: 15-deploy-nfs-client.yml</code></pre></div></figure><h1 id="二、Roles标准"><a href="#二、Roles标准" class="headerlink" title="二、Roles标准"></a>二、Roles标准</h1><p>Roles是一套playbook的目录结构标准，用于解决剧本文件存放比较混乱的问题。例如当剧本规模扩大，各种handlers文件、变量文件，j2文件等存放在一起，怎么定义其目录结构呢？</p><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>Roles的目录规范如下图所示：</p><p><img src="/../../../img/image-20240506181106251.png" alt="image-20240506181106251"></p><p>同样以nfs剧本为例，按照Roles规则调整后的目录如图所示：</p><p><img src="/../../../img/image-20240506181052793.png" alt="image-20240506181052793"></p><h2 id="2-2-实现案例"><a href="#2-2-实现案例" class="headerlink" title="2.2 实现案例"></a>2.2 实现案例</h2><p>使用Roles规则，实现nfs服务部署剧本</p><h3 id="2-2-1-目录准备"><a href="#2-2-1-目录准备" class="headerlink" title="2.2.1 目录准备"></a>2.2.1 目录准备</h3><p>按照Roles规则创建目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#tree -F.├── group_vars&#x2F;│   └── all&#x2F;# 用于存放变量文件├── hosts# hosts文件，方便指定├── nfs-server&#x2F;·│   ├── files&#x2F;# 存放需要下发的普通文件│   ├── handlers&#x2F;# 存放handler操作│   ├── tasks&#x2F;·# 存放tasks任务│   └── templates&#x2F;# 存放需要下发的j2文件└── top.yml# 整体调用接口7 directories, 2 files</code></pre></div></figure><h3 id="2-2-2-添加文件"><a href="#2-2-2-添加文件" class="headerlink" title="2.2.2 添加文件"></a>2.2.2 添加文件</h3><p>创建各文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#tree -F.├── group_vars&#x2F;│   └── all&#x2F;├── hosts├── nfs-server&#x2F;│   ├── files&#x2F;│   │   └── exports│   ├── handlers&#x2F;│   │   └── main.yml│   ├── tasks&#x2F;│   │   └── main.yml│   └── templates&#x2F;│       └── motd.j2└── top.yml</code></pre></div></figure><p>exports文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat nfs-server&#x2F;files&#x2F;exports&#x2F;backup-nfs 172.16.1.0&#x2F;24(rw,all_squash)</code></pre></div></figure><p>handler&#x2F;main.yml文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat nfs-server&#x2F;handlers&#x2F;main.yml- name: restart nfs server  systemd:    name: nfs    state: reloaded</code></pre></div></figure><p>tasks&#x2F;main.yml文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat nfs-server&#x2F;tasks&#x2F;main.yml    - name: 01. 部署nfs-utils      yum:        name: nfs-utils,rpcbind        state: installed      tags:        - 01-install-nfs    - name: 02. 修改配置文件      copy:        src: exports        dest: &#x2F;etc&#x2F;exports        backup: yes      tags:        - 02-conf      notify:        - restart nfs server    - name: 03. 共享目录      file:        path: &#x2F;backup-nfs&#x2F;        owner: nfsnobody        group: nfsnobody        state: directory      tags:         - 03-mkdir    - name: 04. 启动服务 rpc nfs      systemd:        name: &quot;&#123;&#123; item &#125;&#125;&quot;        enabled: yes        state: started      loop:        - rpcbind        - nfs      tags:        - 04-start-service    - name: 05 分发motd      template:        src: motd.j2        dest: &#x2F;etc&#x2F;motd        backup: yes      tags:        - 05-motd</code></pre></div></figure><p>templates&#x2F;motd.j2文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat nfs-server&#x2F;templates&#x2F;motd.j2#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间主机名: &#123;&#123; ansible_hostname &#125;&#125;ip地址: &#123;&#123; ansible_default_ipv4.address &#125;&#125;内存大小: &#123;&#123; ansible_memtotal_mb &#125;&#125;CPU数量: &#123;&#123; ansible_processor_vcpus &#125;&#125;核心总数: &#123;&#123; ansible_processor_cores &#125;&#125;发行版本: &#123;&#123; ansible_distribution &#125;&#125;</code></pre></div></figure><h3 id="2-2-3-运行调试"><a href="#2-2-3-运行调试" class="headerlink" title="2.2.3 运行调试"></a>2.2.3 运行调试</h3><p>运行如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#ansible-playbook -i hosts top.yml _________________&lt; PLAY [backup01] &gt; -----------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     || ________________________&lt; TASK [Gathering Facts] &gt; ------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] _____________________________________&lt; TASK [nfs-server : 01. 部署nfs-utils] &gt; -------------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] ________________________________&lt; TASK [nfs-server : 02. 修改配置文件] &gt; --------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||changed: [172.16.1.41] ______________________________&lt; TASK [nfs-server : 03. 共享目录] &gt; ------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] ______________________________________&lt; TASK [nfs-server : 04. 启动服务 rpc nfs] &gt; --------------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] &#x3D;&gt; (item&#x3D;rpcbind)ok: [172.16.1.41] &#x3D;&gt; (item&#x3D;nfs) _______________________________&lt; TASK [nfs-server : 05 分发motd] &gt; -------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] ___________________________________________________&lt; RUNNING HANDLER [nfs-server : restart nfs server] &gt; ---------------------------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||changed: [172.16.1.41] ____________&lt; PLAY RECAP &gt; ------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||172.16.1.41                : ok&#x3D;7    changed&#x3D;2    unreachable&#x3D;0    failed&#x3D;0    skipped&#x3D;0    rescued&#x3D;0    ignored&#x3D;0</code></pre></div></figure><h2 id="2-3-加入变量"><a href="#2-3-加入变量" class="headerlink" title="2.3 加入变量"></a>2.3 加入变量</h2><p>使用<code>group_vars</code>文件夹，加入变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">路径、用户、uid、gid、域名&#x2F;端口</code></pre></div></figure><p>添加变量文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat group_vars&#x2F;all&#x2F;main.ymlnfs_share_dir: &#x2F;backup-nfs-v3&#x2F;nfs_user: nfsnobodynfs_user_id: 65534</code></pre></div></figure><p>下发文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat nfs-server&#x2F;templates&#x2F;exports.j2&#123;&#123; nfs_share_dir &#125;&#125; 172.16.1.0&#x2F;24(rw,all_squash,anonuid&#x3D;&#123;&#123;nfs_user_id&#125;&#125;,anongid&#x3D;&#123;&#123;nfs_user_id&#125;&#125;)</code></pre></div></figure><p>主任务文件（**<font color=red>注意调用需要双引号</font>**）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat nfs-server&#x2F;tasks&#x2F;main.yml    - name: 01. 部署nfs-utils      yum:        name: nfs-utils,rpcbind        state: installed      tags:        - 01-install-nfs    - name: 02. 修改配置文件      # 改动1，下发exports文件改用变量      template:        src: exports.j2        dest: &#x2F;etc&#x2F;exports        backup: yes      tags:        - 02-conf      notify:        - restart nfs server    - name: 03. 共享目录      file:        # 改动2, 共享目录改用变量        path: &quot;&#123;&#123; nfs_share_dir &#125;&#125;&quot;        owner: &quot;&#123;&#123; nfs_user &#125;&#125;&quot;        group: &quot;&#123;&#123; nfs_user &#125;&#125;&quot;        state: directory      tags:         - 03-mkdir    - name: 04. 启动服务 rpc nfs      systemd:        name: &quot;&#123;&#123; item &#125;&#125;&quot;        enabled: yes        state: started      loop:        - rpcbind        - nfs      tags:        - 04-start-service    - name: 05 分发motd      template:        src: motd.j2        dest: &#x2F;etc&#x2F;motd        backup: yes      tags:        - 05-motd</code></pre></div></figure><p>执行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#ansible-playbook -i hosts top.yml _________________&lt; PLAY [backup01] &gt; -----------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     || ________________________&lt; TASK [Gathering Facts] &gt; ------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] _____________________________________&lt; TASK [nfs-server : 01. 部署nfs-utils] &gt; -------------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] ________________________________&lt; TASK [nfs-server : 02. 修改配置文件] &gt; --------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||changed: [172.16.1.41] ______________________________&lt; TASK [nfs-server : 03. 共享目录] &gt; ------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] ______________________________________&lt; TASK [nfs-server : 04. 启动服务 rpc nfs] &gt; --------------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] &#x3D;&gt; (item&#x3D;rpcbind)ok: [172.16.1.41] &#x3D;&gt; (item&#x3D;nfs) _______________________________&lt; TASK [nfs-server : 05 分发motd] &gt; -------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.41] ___________________________________________________&lt; RUNNING HANDLER [nfs-server : restart nfs server] &gt; ---------------------------------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||changed: [172.16.1.41] ____________&lt; PLAY RECAP &gt; ------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||172.16.1.41                : ok&#x3D;7    changed&#x3D;2    unreachable&#x3D;0    failed&#x3D;0    skipped&#x3D;0    rescued&#x3D;0    ignored&#x3D;0</code></pre></div></figure><h1 id="三、Ansible文件加密-Vault"><a href="#三、Ansible文件加密-Vault" class="headerlink" title="三、Ansible文件加密-Vault"></a>三、Ansible文件加密-Vault</h1><p>使用方法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#进行加密ansible-vault encrypt 文件#enable#进行使用ansible或ansible-playbook --ask-vault-pass 即可#彻底解密ansible-vault decrypt hosts#</code></pre></div></figure><p>如果加密后是不能查看内容和执行的</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#ansible-playbook top.ymlERROR! Attempting to decrypt but no vault secrets found[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;roles-all&#x2F;roles01]#cat top.yml$ANSIBLE_VAULT;1.1;AES256383232323365353765383330396230353061303938313365636331346566613031663364343032313166623337343664653963646664326566303663653762620a353936373566316436613837313534643439326638333433643261373166336264373031303666636662636163663033616664333933303438343536306431300a6363313336623863646263626365373031646238653531396133333462616331306639636162383933346162336562613635343431366331656433373561303765643735313631383531613666613038353365636231326637333036626131316263366439643266643735393634653233353234353535663538326538366138</code></pre></div></figure><h1 id="四、Glaxy-别人的Roles"><a href="#四、Glaxy-别人的Roles" class="headerlink" title="四、Glaxy-别人的Roles"></a>四、Glaxy-别人的Roles</h1><p>可以从Glaxy网站下载别人做好的Roles，并安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">ansible-galaxy collection install nginxinc.nginx_core</code></pre></div></figure><h1 id="五、优化性能和安全性"><a href="#五、优化性能和安全性" class="headerlink" title="五、优化性能和安全性"></a>五、优化性能和安全性</h1><p>如图：</p><p><img src="/../../../img/image-20240506221240923.png" alt="image-20240506221240923"></p><p>其中安全–配置sudo的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">管理端:[root@m01 &#x2F;server&#x2F;scripts&#x2F;playbook]# egrep -v &#39;^$|#&#39; &#x2F;etc&#x2F;ansible&#x2F;ansible.cfg[defaults]sudo_user &#x3D; ans Վˁ被管理端上具有sudo权限的用户nopasswd: ALLremote_user &#x3D; ans Վˁ被管理端使用的用户,不指定默认是当前用户&#x2F;rootremote_port &#x3D; 22 Վˁ被管理端ssh端口号host_key_checking &#x3D; Falselog_path &#x3D; &#x2F;var&#x2F;log&#x2F;ansible.log[inventory][privilege_escalation]become&#x3D;True Վˁ开启sudo功能become_method&#x3D;sudo Վˁ使用sudo命令become_user&#x3D;root Վˁ普通用户切换为root[paramiko_connection][ssh_connection][persistent_connection][accelerate][selinux][colors][diff]# 被管理端:ans ALL&#x3D;(ALL) NOPASSWD: ALL&#96; 密码是1,ssh端口是 22# 重新分发密钥给ans普通用户.ssh-copy-id ans@10.0.0.7# 测试ansible -i hosts web -m ping</code></pre></div></figure><p>参考脑图：<a href="https://www.processon.com/view/link/61addd266376896056c1b1b2">https://www.processon.com/view/link/61addd266376896056c1b1b2</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-集群自动化维护-Ansible(三)</title>
    <link href="/2024/05/06/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/09-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-3/"/>
    <url>/2024/05/06/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/09-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Ansible集群自动化维护（三）"><a href="#Ansible集群自动化维护（三）" class="headerlink" title="Ansible集群自动化维护（三）"></a>Ansible集群自动化维护（三）</h1><p>主要内容：Ansible流程控制和调试方法</p><h1 id="1-流程控制"><a href="#1-流程控制" class="headerlink" title="1 流程控制"></a>1 流程控制</h1><p>流程控制分为</p><ul><li>handler</li><li>when</li><li>loop&#x2F;with_items</li></ul><h2 id="1-1-handler触发器"><a href="#1-1-handler触发器" class="headerlink" title="1.1 handler触发器"></a>1.1 handler触发器</h2><p>应用场景：</p><ul><li>一般用于分发配置文件的时候.</li><li>如果配置文件发生变化则重启服务,如果没有变化则重启</li></ul><p>案例01：没有使用触发器，无论下发文件有没有改变，都需要重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- hosts: backup  tasks:  - name: 分发配置文件    copy:    src: files&#x2F;exports    dest: &#x2F;etc&#x2F;exports    backup: yes  - name: 重启服务    systemd:    name: nfs    state: reloaded</code></pre></div></figure><p>使用触发器之后</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 10-handler.yml- hosts: backup01  gather_facts: no  tasks:    - name: 分发配置文件      copy:        src: &#x2F;server&#x2F;files&#x2F;exports        dest: &#x2F;etc&#x2F;exports        backup: yes      notify:        - 重启服务  handlers:    - name: 重启服务      systemd:        name: nfs        state: reloaded</code></pre></div></figure><p>执行效果：</p><ul><li>下发下去的文件识别“有改变”，则触发handler重启服务。</li><li>如文件没有改变，则不触发重启服务的handler</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 10-handler.yml _________________&lt; PLAY [backup01] &gt;... _______________&lt; TASK [分发配置文件] &gt; ---------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||changed: [172.16.1.41] ________________________&lt; RUNNING HANDLER [重启服务] &gt; ------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||changed: [172.16.1.41]...</code></pre></div></figure><h2 id="1-2-when判断"><a href="#1-2-when判断" class="headerlink" title="1.2 when判断"></a>1.2 when判断</h2><p>作用：</p><ul><li>用于给ans运行的task(模块)设置条件,满足或不满足条件在运行对应的模块.</li></ul><p>应用建议：</p><ul><li>when进行判断,一般与变量一起使用.</li><li>when条件一般与facts变量或register变量一起使用</li></ul><h3 id="1-2-1-单个条件"><a href="#1-2-1-单个条件" class="headerlink" title="1.2.1 单个条件"></a>1.2.1 单个条件</h3><p>案例：只想在web01上执行软件安装操作（以Debug msg方式模拟）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 11-when.yml- hosts: all  tasks:    - name: 只有web01安装软件（输出信息）      debug:        msg: &quot;这是web01，正在安装软件&quot;      when: ansible_hostname &#x3D;&#x3D; &quot;web01&quot;      </code></pre></div></figure><p>执行效果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 11-when.yml ____________&lt; PLAY [all] &gt; ------------... ________________________&lt; TASK [Gathering Facts] &gt;...ok: [172.16.1.41]ok: [172.16.1.7]ok: [172.16.1.31] __________________________&lt; TASK [只有web01安装软件（输出信息）] &gt; --------------------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||ok: [172.16.1.7] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;这是web01，正在安装软件&quot;&#125;skipping: [172.16.1.31]skipping: [172.16.1.41]...</code></pre></div></figure><blockquote><p>扩展1：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 也可以做系统方面的判断，如  when: ansible_distribution &#x3D;&#x3D; &quot;CentOS&quot;# 具体参数，可以通过以下命令获取[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible web01 -m setup | grep ansible&quot;ansible_facts&quot;: &#123;    &quot;ansible_all_ipv4_addresses&quot;: [    &quot;ansible_all_ipv6_addresses&quot;: [    &quot;ansible_apparmor&quot;: &#123;    &quot;ansible_architecture&quot;: &quot;x86_64&quot;,    &quot;ansible_bios_date&quot;: &quot;11&#x2F;12&#x2F;2020&quot;,    &quot;ansible_bios_version&quot;: &quot;6.00&quot;,    &quot;ansible_cmdline&quot;: &#123;    &quot;ansible_date_time&quot;: &#123;    &quot;ansible_default_ipv4&quot;: &#123;    &quot;ansible_default_ipv6&quot;: &#123;&#125;,    &quot;ansible_device_links&quot;: &#123;    &quot;ansible_devices&quot;: &#123;    &quot;ansible_distribution&quot;: &quot;CentOS&quot;,    &quot;ansible_distribution_file_parsed&quot;: true,    &quot;ansible_distribution_file_path&quot;: &quot;&#x2F;etc&#x2F;redhat-release&quot;,    &quot;ansible_distribution_file_variety&quot;: &quot;RedHat&quot;,    &quot;ansible_distribution_major_version&quot;: &quot;7&quot;,    &quot;ansible_distribution_release&quot;: &quot;Core&quot;,    &quot;ansible_distribution_version&quot;: &quot;7.9&quot;,...</code></pre></div></figure></blockquote><blockquote><p>扩展2：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;when中使用的符号&gt;&#x3D;&#x3D; 等于&gt;!&#x3D; 不等于&gt;is match(web)&gt;ansible_hostname is match(&quot;web|backup&quot;) #类似于grep,正则.&gt;ansible_hostname is not match(&quot;web|backup&quot;) #取反,排除.</code></pre></div></figure></blockquote><h3 id="1-2-3-多个条件"><a href="#1-2-3-多个条件" class="headerlink" title="1.2.3 多个条件"></a>1.2.3 多个条件</h3><p>当存在多个条件时，可以使用and和or</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 方法一when: #条件1 条件2 同时成立 相当于使用and.  - ansible_distribution &#x3D;&#x3D; &quot;CentOS&quot;  - ansible_hostname is match(&quot;web|backup&quot;)  # 方法二：when: ansible_distribution &#x3D;&#x3D; &quot;CentOS&quot; and ansible_hostname is match(&quot;web|backup&quot;)</code></pre></div></figure><h2 id="1-3-循环"><a href="#1-3-循环" class="headerlink" title="1.3 循环"></a>1.3 循环</h2><h3 id="1-3-1-循环单个变量"><a href="#1-3-1-循环单个变量" class="headerlink" title="1.3.1 循环单个变量"></a>1.3.1 循环单个变量</h3><p>循环的两种方式：</p><ul><li>with_items</li><li>loops</li></ul><p>常用于批量创建用户、文件夹、重启服务等</p><p>案例01：批量启动服务，rpcbind然后nfs</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- hosts: backup01  gather_facts: false  tasks:    - name: restared rpcbind and nfs      systemd:        name: &quot;&#123;&#123; item &#125;&#125;&quot;        state: restarted      loop:# 或者with_items        - rpcbind        - nfs</code></pre></div></figure><p>执行效果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 12-loop.yml _________________&lt; PLAY [backup01] &gt; ----------------- _________________________________&lt; TASK [restared rpcbind and nfs] &gt; ---------------------------------changed: [172.16.1.41] &#x3D;&gt; (item&#x3D;rpcbind)changed: [172.16.1.41] &#x3D;&gt; (item&#x3D;nfs) ____________...</code></pre></div></figure><h3 id="1-3-2-循环多个变量"><a href="#1-3-2-循环多个变量" class="headerlink" title="1.3.2 循环多个变量"></a>1.3.2 循环多个变量</h3><p>循环多个变量的例子：批量添加用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 13-loop-adduser.yml- hosts: backup01  tasks:    - name: 批量添加用户      user:        name: &quot;&#123;&#123; item.name &#125;&#125;&quot;        uid: &quot;&#123;&#123; item.uid &#125;&#125;&quot;        state: present      with_items:        - &#123; name: &#39;user01&#39;, uid: 2020 &#125;        - &#123; name: &#39;user02&#39;, uid: 2021 &#125;        - &#123; name: &#39;user03&#39;, uid: 2022 &#125;</code></pre></div></figure><p>执行效果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 13-loop-adduser.yml _________________&lt; PLAY [backup01] &gt; ----------------- ________________________&lt; TASK [Gathering Facts] &gt; ------------------------ok: [172.16.1.41] _______________&lt; TASK [批量添加用户] &gt; ---------------changed: [172.16.1.41] &#x3D;&gt; (item&#x3D;&#123;u&#39;name&#39;: u&#39;user01&#39;, u&#39;uid&#39;: 2020&#125;)changed: [172.16.1.41] &#x3D;&gt; (item&#x3D;&#123;u&#39;name&#39;: u&#39;user02&#39;, u&#39;uid&#39;: 2021&#125;)changed: [172.16.1.41] &#x3D;&gt; (item&#x3D;&#123;u&#39;name&#39;: u&#39;user03&#39;, u&#39;uid&#39;: 2022&#125;)...</code></pre></div></figure><h1 id="2-剧本调试"><a href="#2-剧本调试" class="headerlink" title="2 剧本调试"></a>2 剧本调试</h1><p>分为：</p><ul><li>剧本单步执行：如何检查语法</li><li>tag标签：如何运行指定task</li><li>忽略错误 ：如中间发生错误是否往后继续</li></ul><h2 id="2-1-检查语法和单步执行"><a href="#2-1-检查语法和单步执行" class="headerlink" title="2.1 检查语法和单步执行"></a>2.1 检查语法和单步执行</h2><p>选项如下：</p><ul><li><font color=blue><strong>-C</strong></font> –check 模拟运行,不作出改变,一些变量可能会提示报错,因为-C没有真正运行剧本.</li><li><font color=blue><strong>–syntax-check</strong></font> 只做语法检查,不运行.</li><li><font color=blue><strong>-step</strong></font> 单步运行. y执行这个task,n忽略这个task,c自动运行</li></ul><h2 id="2-2-tag标签"><a href="#2-2-tag标签" class="headerlink" title="2.2 tag标签"></a>2.2 tag标签</h2><p>以部署nfs服务的playbool为例，剧本中打上了几处tags，代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 14-deploy-nfs.yml# 服务端- hosts: backup01  tasks:    - name: 01. 安装服务      yum:        name: nfs-utils, rpcbind        state: present      # 打标签tag      tags:        - 01.install    - name: 02. 修改配置文件      lineinfile:        path: &#x2F;etc&#x2F;exports        line: &quot;&#x2F;backup-nfs 172.16.1.0&#x2F;24(rw, all_squash)&quot;        create: true      tags:        - 02.conf    - name: 03. 创建共享目录并修改所有者      file:        path: &#x2F;backup-nfs        owner: nfsnobody        group: nfsnobody        state: directory      tags:        - 03.dir    - name: 04. 启动服务      systemd:        name: &quot;&#123;&#123; item &#125;&#125;&quot;        state: started        enabled: yes      loop:        - rpcbind        - nfs      tags:        - 04.start_srv# 客户端- hosts: web01  tasks:    - name: 01. 部署nfs-utils      yum:        name: nfs-utils        state: present    - name: 02. 挂载nfs      mount:        src: 172.16.1.41:&#x2F;backup-nfs        path: &#x2F;ans-upload        fstype: nfs        state: mounted</code></pre></div></figure><p>在运行剧本的时候，可以通过：</p><ul><li>-t 运行指定的标签,如果多个标签通过”,”分割</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook -t 02.conf 14-deploy-nfs.yml _________________&lt; PLAY [backup01] &gt; -----------------...ok: [172.16.1.41] ___________________&lt; TASK [02. 修改配置文件] &gt; -------------------ok: [172.16.1.41] ______________&lt; PLAY [web01] &gt; -------------- ________________________&lt; TASK [Gathering Facts] &gt; ------------------------...</code></pre></div></figure><ul><li>–skip-tags 排除指定的tags,如果多个标签通过”,”分割</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook --skip-tags 01.install,02.conf 14-deploy-nfs.yml _________________&lt; PLAY [backup01] &gt; ----------------- ________________________&lt; TASK [Gathering Facts] &gt; ------------------------ok: [172.16.1.41] _________________________&lt; TASK [03. 创建共享目录并修改所有者] &gt; -------------------------ok: [172.16.1.41] _________________&lt; TASK [04. 启动服务] &gt; ----------------- ______________&lt; PLAY [web01] &gt; -------------- ________________________&lt; TASK [Gathering Facts] &gt; ------------------------ok: [172.16.1.7] ________________________&lt; TASK [01. 部署nfs-utils] &gt; ------------------------ok: [172.16.1.7] __________________&lt; TASK [02. 挂载nfs] &gt; ------------------ok: [172.16.1.7]</code></pre></div></figure><ul><li>–list-tags显示剧本中所有的tags标签</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook --list-tags 14-deploy-nfs.ymlplaybook: 14-deploy-nfs.yml  play #1 (backup01): backup01  TAGS: []      TASK TAGS: [01.install, 02.conf, 03.dir, 04.start_srv]  play #2 (web01): web01        TAGS: []      TASK TAGS: []</code></pre></div></figure><h2 id="2-3-忽略错误"><a href="#2-3-忽略错误" class="headerlink" title="2.3 忽略错误"></a>2.3 忽略错误</h2><p>运行剧本的时候，可能存在<strong>因为重复运行导致的错误提示</strong>，这些提示并非是真的错误，比如：目录已经存在，用</p><p>户已经存在。在这种情况下,我们可以通过使用<code>ignore_errors</code>忽略错误，让剧本可以继续运行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- hosts: backup01  ignore_errors: true  tasks:    - name: 批量添加用户    ...</code></pre></div></figure><h1 id="3-Jinjia2模板"><a href="#3-Jinjia2模板" class="headerlink" title="3 Jinjia2模板"></a>3 Jinjia2模板</h1><p>应用场景：</p><p>在进行配置文件或普通文件的分发时，如果需要对文件中使用的变量进行解析，则需要使用jinja2文件，如<code>nginx.conf.j2</code>文件需要使用template模块进行分发。图示如下：</p><p><img src="/../../../img/image-20240506163401162.png" alt="image-20240506163401162"></p><h2 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h2><p>案例: 分发motd文件，motd文件中包含ans变量(目标文件是&#x2F;etc&#x2F;motd)</p><p>motd文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat templates&#x2F;motd.j2#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: &#123;&#123; ansible_hostname &#125;&#125;ip地址: &#123;&#123; ansible_default_ipv4.address &#125;&#125;内存大小: &#123;&#123; ansible_memtotal_mb &#125;&#125;CPU数量: &#123;&#123; ansible_processor_vcpus &#125;&#125;核心总数: &#123;&#123; ansible_processor_cores &#125;&#125;发行版本: &#123;&#123; ansible_distribution &#125;&#125;</code></pre></div></figure><p>剧本分发，分别使用templates和copy两种方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 15-changemotd.yml- hosts: all  gather_facts: yes  tasks:    - name: template分发motd文件      template:        src: templates&#x2F;motd.j2        dest: &#x2F;etc&#x2F;motd        backup: yes    - name: copy分发motd文件      copy:        src: templates&#x2F;motd.j2        dest: &#x2F;tmp&#x2F;motd        backup: yes</code></pre></div></figure><p>查看执行结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 剧本执行[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 15-changemotd.yml ____________&lt; PLAY [all] &gt; ------------ ________________________&lt; TASK [Gathering Facts] &gt; ------------------------ok: [172.16.1.41]ok: [172.16.1.31]ok: [172.16.1.7] _________________________&lt; TASK [template分发motd文件] &gt; -------------------------ok: [172.16.1.7]ok: [172.16.1.41]ok: [172.16.1.31] _____________________&lt; TASK [copy分发motd文件] &gt; ---------------------ok: [172.16.1.31]ok: [172.16.1.7]ok: [172.16.1.41] ____________&lt; PLAY RECAP &gt; ------------...# 目标机器&#x2F;etc&#x2F;motd，得到解析[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible all -m shell -a  &quot;cat &#x2F;etc&#x2F;motd&quot;172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: backup01ip地址: 10.0.0.41内存大小: 1980CPU数量: 1核心总数: 1发行版本: CentOS172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: nfs01ip地址: 10.0.0.31内存大小: 1980CPU数量: 1核心总数: 1发行版本: CentOS172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: web01ip地址: 10.0.0.7内存大小: 1980CPU数量: 1核心总数: 1发行版本: CentOS# 目标机器&#x2F;tmp&#x2F;motd[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible all -m shell -a  &quot;cat &#x2F;tmp&#x2F;motd&quot;172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: &#123;&#123; ansible_hostname &#125;&#125;ip地址: &#123;&#123; ansible_default_ipv4.address &#125;&#125;内存大小: &#123;&#123; ansible_memtotal_mb &#125;&#125;CPU数量: &#123;&#123; ansible_processor_vcpus &#125;&#125;核心总数: &#123;&#123; ansible_processor_cores &#125;&#125;发行版本: &#123;&#123; ansible_distribution &#125;&#125;172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: &#123;&#123; ansible_hostname &#125;&#125;ip地址: &#123;&#123; ansible_default_ipv4.address &#125;&#125;内存大小: &#123;&#123; ansible_memtotal_mb &#125;&#125;CPU数量: &#123;&#123; ansible_processor_vcpus &#125;&#125;核心总数: &#123;&#123; ansible_processor_cores &#125;&#125;发行版本: &#123;&#123; ansible_distribution &#125;&#125;172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: &#123;&#123; ansible_hostname &#125;&#125;ip地址: &#123;&#123; ansible_default_ipv4.address &#125;&#125;内存大小: &#123;&#123; ansible_memtotal_mb &#125;&#125;CPU数量: &#123;&#123; ansible_processor_vcpus &#125;&#125;核心总数: &#123;&#123; ansible_processor_cores &#125;&#125;发行版本: &#123;&#123; ansible_distribution &#125;&#125;</code></pre></div></figure><h2 id="3-2-条件判断（未实践）"><a href="#3-2-条件判断（未实践）" class="headerlink" title="3.2 条件判断（未实践）"></a>3.2 条件判断（未实践）</h2><p>根据主机名或ip或其他条件，生成不同的配置文件</p>  <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;tmp&#x2F;keepalived.conflb01lb02配置文件内容&#x2F;tmp&#x2F;keepalived.confweb01 配置文件内容state MASTER&#x2F;tmp&#x2F;keepalived.confbackup 配置文件内容state BACKUP[root@m01 &#x2F;server&#x2F;scripts&#x2F;playbook]# cat 15.jinja2-if.yml- hosts: alltasks:- name: 分发配置文件template:src: templates&#x2F;keepalived.conf.j2dest: &#x2F;tmp&#x2F;keepalived.conf[root@m01 &#x2F;server&#x2F;scripts&#x2F;playbook]# tree templates&#x2F;templates&#x2F;├── keepalived.conf.j2└── motd.j20 directories, 2 files[root@m01 &#x2F;server&#x2F;scripts&#x2F;playbook]# cattemplates&#x2F;keepalived.conf.j2#this is keepalived.conf&#123;% if ansible_hostname &#x3D;&#x3D; &quot;web01&quot; %&#125;state 主节点&#123;% elif ansible_hostname &#x3D;&#x3D; &quot;backup&quot; %&#125;state 备节点&#123;% endif %&#125;</code></pre></div></figure><h2 id="3-3-循环语句（未实践）"><a href="#3-3-循环语句（未实践）" class="headerlink" title="3.3 循环语句（未实践）"></a>3.3 循环语句（未实践）</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">配置文件 server.conf web服务器的&#x2F;tmp&#x2F;目录下10.0.0.510.0.0.610.0.0.710.0.0.810.0.0.910.0.0.10&#123;% for ip in [1,2,3,4,5,6] %&#125;  10.0.0.&#123;&#123; ip &#125;&#125;&#123;% endfor %&#125;&#123;% for ip in range(2,11) %&#125;  10.0.0.&#123;&#123; ip &#125;&#125;&#123;%endfor%&#125;&#123;% for ip in [&quot;lidao&quot;,&quot;oldwang&quot;] %&#125;  10.0.0.&#123;&#123; ip &#125;&#125;&#123;%endfor%&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-集群自动化维护-Ansible(二)</title>
    <link href="/2024/05/04/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/08-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-2/"/>
    <url>/2024/05/04/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/08-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Ansible集群自动化维护（二）"><a href="#Ansible集群自动化维护（二）" class="headerlink" title="Ansible集群自动化维护（二）"></a>Ansible集群自动化维护（二）</h1><p>主要内容：剧本和变量</p><h1 id="1-剧本"><a href="#1-剧本" class="headerlink" title="1 剧本"></a>1 剧本</h1><h2 id="1-1-剧本介绍"><a href="#1-1-剧本介绍" class="headerlink" title="1.1 剧本介绍"></a>1.1 剧本介绍</h2><p>什么是ansible的剧本(play book)？</p><ul><li>剧本是一个yaml格式的文件，用于长久保存并且实现批量管理、维护、部署的文件。</li><li>类似于脚本存放命令和变量，剧本中存放各模块的使用命令</li><li>剧本是未来我们批量管理、运维必会的内容</li></ul><p>剧本和ansible命令的区别：</p><table><thead><tr><th></th><th>ansible剧本</th><th>ans ad-hoc（单条命令）</th></tr></thead><tbody><tr><td>共同点</td><td>批量管理,使用模块</td><td>批量管理,使用模块</td></tr><tr><td>区别</td><td>方便重复调用</td><td>不是很方便，不容易重复</td></tr><tr><td>应用建议(应用场景)</td><td>部署服务，多个步骤的任务</td><td>测试模块，临时性任务</td></tr></tbody></table><h2 id="1-2-剧本的书写格式"><a href="#1-2-剧本的书写格式" class="headerlink" title="1.2 剧本的书写格式"></a>1.2 剧本的书写格式</h2><p>剧本的书写格式</p><p><img src="/../../../img/image-20240504152707076.png" alt="image-20240504152707076"></p><blockquote><p>书写playbook注意事项:</p><ul><li>同一个层级的内容对齐的.</li><li>不同层级的通过2个空格对齐</li><li>不能使用tab键</li></ul></blockquote><h2 id="1-3-第一个剧本"><a href="#1-3-第一个剧本" class="headerlink" title="1.3 第一个剧本"></a>1.3 第一个剧本</h2><p>使用剧本在对象机器创建文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 01、创建剧本文件[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 01-show.yml---- hosts: all  tasks:    - name: 01 打开冰箱门      shell: echo 01 &gt;&gt; &#x2F;tmp&#x2F;bingxiang.log    - name: 02 把大象放进冰箱      shell: echo 02 &gt;&gt; &#x2F;tmp&#x2F;bingxiang.log    - name: 03 关上冰箱门      shell: echo 03 &gt;&gt; &#x2F;tmp&#x2F;bingxiang.log      # 02、执行剧本[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook -i &#x2F;etc&#x2F;ansible&#x2F;hosts 01-show.yml ____________&lt; PLAY [all] &gt; ------------        \   ^__^         \  (oo)\_______            (__)\       )\&#x2F;\                ||----w |                ||     ||...ok: [172.16.1.7]ok: [172.16.1.31]ok: [172.16.1.41] _________________&lt; TASK [01 打开冰箱门] &gt; -----------------...# 03、查看结果[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible all -m shell -a &quot;cat &#x2F;tmp&#x2F;bingxiang.log&quot;172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;010203172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;010203172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;010203</code></pre></div></figure><blockquote><p>执行的时候有奶牛：</p><p>可以删除软件 或 修改ansible.cfg配置进行关闭 #nocows &#x3D; 1去掉注释即可  </p></blockquote><h2 id="1-4-剧本案例"><a href="#1-4-剧本案例" class="headerlink" title="1.4 剧本案例"></a>1.4 剧本案例</h2><h3 id="1-4-1-案例01-创建目录"><a href="#1-4-1-案例01-创建目录" class="headerlink" title="1.4.1 案例01-创建目录"></a>1.4.1 案例01-创建目录</h3><p>创建目录并分发文件，要求:</p><ol><li>创建目录&#x2F;server&#x2F;files&#x2F;</li><li>&#x2F;etc&#x2F;hosts文件发送过去&#x2F;server&#x2F;files&#x2F;</li></ol><p>剧本编写：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 02-disk-file.yml- hosts: all  tasks:    - name: 01 创建目录      file: path&#x3D;&#x2F;server&#x2F;files&#x2F; state&#x3D;directory    - name: 02 分发文件      copy: src&#x3D;&#x2F;etc&#x2F;hosts dst&#x3D;&#x2F;server&#x2F;files</code></pre></div></figure><p>以上剧本path和state仍写在一行，更像是一条命令，改进后如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 02-disk-file.yml- hosts: all  tasks:    - name: 01 创建目录      file:        path: &#x2F;server&#x2F;files&#x2F;        state: directory    - name: 02 分发文件      copy:        src: &#x2F;etc&#x2F;hosts        dest: &#x2F;server&#x2F;files&#x2F;</code></pre></div></figure><p>执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 02-disk-file.yml ____________&lt; PLAY [all] &gt; ------------...ok: [172.16.1.31]ok: [172.16.1.7]ok: [172.16.1.41] ________________&lt; TASK [01 创建目录] &gt; ----------------...</code></pre></div></figure><h3 id="1-4-2-案例02-安装软件"><a href="#1-4-2-案例02-安装软件" class="headerlink" title="1.4.2 案例02-安装软件"></a>1.4.2 案例02-安装软件</h3><p>分发软件包、安装软件包、启动服务</p><p>步骤:</p><ul><li>zabbix-agent软件包(下载)</li><li>安装软件包</li><li>配置(略)</li><li>启动开机自启动</li></ul><p>实现如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 01、创建剧本[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 03-install-zabbix-agent.yml- hosts: all  tasks:    - name: 01. 下载安装包到&#x2F;tmp      get_url:        url: &quot;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;zabbix&#x2F;zabbix&#x2F;6.0&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-agent-6.0.7-1.el7.x86_64.rpm&quot;        validate_certs: no        dest: &#x2F;tmp&#x2F;    - name: 02. 安装软件包      yum:        name: &#x2F;tmp&#x2F;zabbix-agent-6.0.7-1.el7.x86_64.rpm        state: present    - name: 03. 配置      debug:        msg: &quot;进行配置zabbix-agent&quot;    - name: 04. 启动      systemd:        name: zabbix-agent        enabled: yes        state: started</code></pre></div></figure><p>运行剧本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 02、运行脚本[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 03-install-zabbix-agent.yml ____________&lt; PLAY [all] &gt;...ok: [172.16.1.7]ok: [172.16.1.31]ok: [172.16.1.41] _______________________&lt; TASK [01. 下载安装包到&#x2F;tmp] &gt;...ok: [172.16.1.31]ok: [172.16.1.41]ok: [172.16.1.7] __________________&lt; TASK [02. 安装软件包] &gt;...ok: [172.16.1.41]ok: [172.16.1.31]changed: [172.16.1.7] _______________&lt; TASK [03. 配置] &gt; ---------------...ok: [172.16.1.7] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;进行配置zabbix-agent&quot;&#125;ok: [172.16.1.31] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;进行配置zabbix-agent&quot;&#125;ok: [172.16.1.41] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;进行配置zabbix-agent&quot;&#125; _______________&lt; TASK [04. 启动] &gt;...ok: [172.16.1.31]ok: [172.16.1.41]changed: [172.16.1.7] ____________&lt; PLAY RECAP &gt; ------------</code></pre></div></figure><h3 id="1-4-3-案例03-部署服务"><a href="#1-4-3-案例03-部署服务" class="headerlink" title="1.4.3 案例03-部署服务"></a>1.4.3 案例03-部署服务</h3><p>NFS服务</p><ul><li>nfs服务端:在backup上部署nfs服务,共享&#x2F;backup-nfs目录,all_squash,匿名用户:nfsnobody</li><li>nfs客户端:web挂载 &#x2F;ans-upload目录挂载nfs服务端共享的&#x2F;backup-nfs(永久挂载)</li></ul><p>流程梳理：</p><ul><li>服务端流程:<ol><li>部署nfs-utils,rpcbind</li><li>修改配置文件</li><li>创建共享目录并改所有者</li><li>启动服务rpcbind,nfs(注意顺序)</li></ol></li><li>客户端流程:<ol><li>安装nfs-utils</li><li>挂载与永久挂载</li></ol></li></ul><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 04-deploy-nfs.yml# nfs服务端部署- hosts: backup01  tasks:    - name: 01 部署nfs-utils, rpcbind      yum:        name: nfs-utils,rpcbind        state: present    - name: 02 修改配置文件      lineinfile:        path: &#x2F;etc&#x2F;exports        line: &quot;&#x2F;backup-nfs 172.16.1.0&#x2F;24(rw,all_squash)&quot;        create: true    - name: 03 创建共享目录所有者并改权限      file:        path: &#x2F;backup-nfs        owner: nfsnobody        group: nfsnobody        state: directory    - name: 04 启动服务rpcbind（注意顺序）      systemd:        name: rpcbind        enabled: yes        state: started    - name: 05 启动服务nfs      systemd:        name: nfs        enabled: yes        state: started# nfs客户端部署- hosts: web01  tasks:    - name: 01 部署nfs-utils      yum:        name: nfs-utils        state: present    - name: 02 挂载nfs      mount:        src: 172.16.1.41:&#x2F;backup-nfs        path: &#x2F;ans-upload        fstype: nfs        state: mounted</code></pre></div></figure><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h1><p>ansible中额的变量无处不在,，ans中大部分地方都可以定义变量.</p><table><thead><tr><th>可以定义变量的地方</th><th>说明</th></tr></thead><tbody><tr><td>在剧本文件中定义</td><td>比较常用. 仅仅限于当前的play使用.</td></tr><tr><td>register变量(注册变量)</td><td>实现例如脚本中<code>反引号</code>的功能,可以获取命令结果</td></tr><tr><td>变量文件（根据主机清单分分组进行定义变量 ）</td><td>如果多个剧本,使用相同的变量,大型的剧本roles</td></tr><tr><td>inventory主机清单中定义变量</td><td>未来可以用于批量修改主机使用,其他很少用了.</td></tr><tr><td>命令行中</td><td>几乎不用.</td></tr><tr><td>facts变量</td><td>一般用于获取主机基本信息:ip,主机名,系统 (centos&#x2F;ubuntu) 如果不需要可以关闭,用于加速剧本的执行</td></tr></tbody></table><h2 id="2-1-剧本中的变量"><a href="#2-1-剧本中的变量" class="headerlink" title="2.1 剧本中的变量"></a>2.1 剧本中的变量</h2><p>在剧本中使用变量：</p><ol><li>仅仅在当前play生效.</li><li>一般用来存放路径,用户名,ip地址,类似于之前使用的脚本.</li><li>注意引号使用.</li></ol><p>案例：批量创建&#x2F;oldboy&#x2F;lidao&#x2F;upload&#x2F;  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 05-vars.yml- hosts: all  # 定义变量  vars:    dir: &#x2F;oldboy&#x2F;lidao&#x2F;upload  tasks:    - name: mkdir      file:        # 使用变量        path: &quot;&#123;&#123;dir&#125;&#125;&quot;        state: directory</code></pre></div></figure><blockquote><p>关于双引号的注意事项：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;dir: &#x2F;oldboy&#x2F;lidao&#x2F;upload&#x2F;&gt;file: path: &quot;&#123;&#123; dir &#125;&#125;&quot; #这种要添加,变量是开头.&gt;file: path: &#x2F;oldboy-new&#x2F;&#123;&#123; dir &#125;&#125; #这种可以不加引号,变量不是开头.</code></pre></div></figure></blockquote><h2 id="2-2-共用变量（变量文件）"><a href="#2-2-共用变量（变量文件）" class="headerlink" title="2.2 共用变量（变量文件）"></a>2.2 共用变量（变量文件）</h2><p>将变量写入新建的变量文件vars.yml，然后在剧本中引用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@m01 &#x2F;server&#x2F;scripts&#x2F;playbook]# cat 05.vars.yml- hosts: all  vars_files: .&#x2F;vars.yml  tasks:    - name: file      file:        path: &quot;&#123;&#123; dir &#125;&#125;&#x2F;&#123;&#123; user &#125;&#125;-&#123;&#123; file &#125;&#125;&quot;        state: touch        [root@m01 &#x2F;server&#x2F;scripts&#x2F;playbook]# cat vars.ymldir: &#x2F;tmp&#x2F;file: lidao.txtuser: lidao996kkk</code></pre></div></figure><h2 id="2-3-共用变量（根据主机组）"><a href="#2-3-共用变量（根据主机组）" class="headerlink" title="2.3 共用变量（根据主机组）"></a>2.3 共用变量（根据主机组）</h2><p>group_vars根据主机清单的分组去匹配变量文件，可以根据主机组创建变量文件，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xxxx-check.ymlgroup_vars&#x2F;lb&#x2F;vars.yml #存放lb组的变量web&#x2F;vars.yml #存放web组的变量data&#x2F;vars.yml #存放xxx组的变量all&#x2F;vars.yml #所有主机共用的变量</code></pre></div></figure><blockquote><p>未来一般使用all分组即可,把所有变量存放在一起,供剧本使用</p></blockquote><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建主机组变量文件[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat group_vars&#x2F;all&#x2F;vars.ymluser: wwwnfs_dir: &#x2F;nfs_backupweb_mount_dir: &#x2F;web_nfsnfs_server: 172.16.1.41rsync_pass: 1# 调用变量文件[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 07.group_vars.yml- hosts: all  tasks:  - name: 测试group变量    debug:      msg: &quot;变量内容 &#123;&#123;user&#125;&#125; &#123;&#123;rsync_pass&#125;&#125;&quot;- hosts: web01  tasks:  - name: 测试web组是否识别group变量    debug:      msg: &quot;web组识别的变量变量内容 &#123;&#123;user&#125;&#125; &#123;&#123;rsync_pass&#125;&#125;&quot;</code></pre></div></figure><p>执行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 07.group_vars.yml ____________&lt; PLAY [all] &gt; ------------...ok: [172.16.1.7] __________________&lt; TASK [测试group变量] &gt; ------------------...ok: [172.16.1.7] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;变量内容 www 1&quot;&#125;...&lt; TASK [测试web组是否识别group变量] &gt;...ok: [172.16.1.7] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;web组识别的变量变量内容 www 1&quot;&#125; ____________&lt; PLAY RECAP &gt; ------------</code></pre></div></figure><h2 id="2-4-facts变量"><a href="#2-4-facts变量" class="headerlink" title="2.4 facts变量"></a>2.4 facts变量</h2><p>什么是facts变量？</p><ul><li>运行剧本的时候ans会收集每个主机的基本信息，这些信息形成的变量叫做facts变量。</li><li>facts变量可以通过setup模块获取</li></ul><p>常用的fact变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">ansible_hostname #主机名ansible_memtotal_mb #内存大小(总计) 单位mbansible_processor_vcpus #cpu数量ansible_default_ipv4.address #默认的网卡ip eth0ansible_distribution #系统发行版本名字CentOS Ubuntu Debian ՎՎʢansible_processor_vcpusansible_processor_coresansible_date_time.date</code></pre></div></figure><p>案例：批量修改系统&#x2F;etc&#x2F;motd文件，登录的时候输出系统的基本信息，如</p><p>主机名、内存总大小、ip地址、发行版本、cpu数、核心数  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建fatcs变量文件[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat templates&#x2F;motd.j2#######################################welcome to oldboy elastic linux system操作需谨慎,删根弹指间.主机名: &#123;&#123; ansible_hostname &#125;&#125;ip地址: &#123;&#123; ansible_default_ipv4.address &#125;&#125;内存大小: &#123;&#123; ansible_memtotal_mb &#125;&#125;CPU数量: &#123;&#123; ansible_processor_vcpus &#125;&#125;核心总数: &#123;&#123; ansible_processor_cores &#125;&#125;发行版本: &#123;&#123; ansible_distribution &#125;&#125;# 分发[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 08-change-motd.yml- hosts: all  tasks:    - name: 分发motd文件      template:        src: templates&#x2F;motd.j2        dest: &#x2F;etc&#x2F;motd        backup: yes    - name: 分发motd文件      copy:        src: templates&#x2F;motd.j2        dest: &#x2F;tmp&#x2F;motd        backup: yes</code></pre></div></figure><blockquote><p><strong>温馨提示: template vs copy模块</strong></p><p>copy仅仅传输数据,复制文件</p><p>template 传输数据,复制文件的时候,文件中的变量会被解析和运行  </p><p>关于facts变量实际应用案例:</p><ol><li>通过facts变量获取系统的基本信息</li><li>通过facts变量获取信息并进行判断</li><li>如果不需要可以进行关闭,加速剧本的运行( gather_facts: no)</li></ol></blockquote><h2 id="2-5-register变量"><a href="#2-5-register变量" class="headerlink" title="2.5 register变量"></a>2.5 register变量</h2><p>本质上就是用来实现脚本中的<em>反引号</em>功能，用户通过命令获取的内容都存放到Register变量中  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 编写[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#cat 09-regvars.yml- hosts: all  tasks:    - name: 获取日期      shell: date +%F      register: result    - name: print result 变量内容      debug:        msg: |             &quot;register变量的全部内容是:&#123;&#123; result.stderr &#125;&#125;&quot;             &quot;register变量的精确的内容是:&#123;&#123; result.stdout &#125;&#125;&quot;               # 执行[root@mn01[ &#x2F;server&#x2F;scripts&#x2F;playbook]#ansible-playbook 09-regvars.yml ____________&lt; PLAY [all] &gt; ------------...ok: [172.16.1.7] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;\&quot;register变量的全部内容是:\&quot;\n\&quot;register变量的精确的内容是:2024-05-04\&quot;\n&quot;&#125;ok: [172.16.1.31] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;\&quot;register变量的全部内容是:\&quot;\n\&quot;register变量的精确的内容是:2024-05-04\&quot;\n&quot;&#125;ok: [172.16.1.41] &#x3D;&gt; &#123;    &quot;msg&quot;: &quot;\&quot;register变量的全部内容是:\&quot;\n\&quot;register变量的精确的内容是:2024-05-04\&quot;\n&quot;&#125;</code></pre></div></figure><blockquote><p>符号说明：</p><p>msg:中的<code>|</code>表示下面的内容是多行. <code>|</code>也可以用于其他模块中  </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-集群自动化维护-Ansible(一)</title>
    <link href="/2024/04/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/07-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-1/"/>
    <url>/2024/04/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/07-%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%B4%E6%8A%A4-Ansible-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Ansible集群自动化维护"><a href="#Ansible集群自动化维护" class="headerlink" title="Ansible集群自动化维护"></a>Ansible集群自动化维护</h1><h2 id="1-1-Ansible概述"><a href="#1-1-Ansible概述" class="headerlink" title="1.1 Ansible概述"></a>1.1 Ansible概述</h2><p>市面上的部分批量管理工具</p><table><thead><tr><th>批量管理工具</th><th>说明</th></tr></thead><tbody><tr><td>Ansible</td><td>无客户端,基于ssh进行管理与维护.</td></tr><tr><td>Saltstack</td><td>需要安装客户端,基于ssh进行管理,与ansible.</td></tr><tr><td>terraform</td><td>tf批量管理基础设施(批量创建100台公有云)</td></tr></tbody></table><p>Ansible是其中一种，基于Python语言实现，用于集群批量管理，批量分发，批量执行，维护等</p><h2 id="1-2-Ansible的管理框架"><a href="#1-2-Ansible的管理框架" class="headerlink" title="1.2 Ansible的管理框架"></a>1.2 Ansible的管理框架</h2><p>图示：</p><p><img src="/../../../img/image-20240429163838386.png" alt="image-20240429163838386"></p><p>详细解释：</p><ul><li>Inventory 主机机清单<ul><li>被管理主机的ip列表，分类.</li></ul></li><li>ad-hoc 模式：<ul><li>命令行批量管理(使用ans模块),临时任务.</li></ul></li><li>playbook 剧本模式<ul><li>类似于把操作写出脚本,可以重复运行这个脚本</li></ul></li></ul><h2 id="1-3-部署与配置"><a href="#1-3-部署与配置" class="headerlink" title="1.3 部署与配置"></a>1.3 部署与配置</h2><h3 id="1-3-1-安装"><a href="#1-3-1-安装" class="headerlink" title="1.3.1 安装"></a>1.3.1 安装</h3><p>在主控节点(mn01)安装ansible</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y ansible</code></pre></div></figure><h3 id="1-3-2-初始配置"><a href="#1-3-2-初始配置" class="headerlink" title="1.3.2 初始配置"></a>1.3.2 初始配置</h3><p>修改ansible的配置文件：</p><ul><li>关闭主机Host_key_checking .</li><li>开启日志功能</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#cp &#x2F;eegrep -vn &quot;^$|#&quot; &#x2F;etc&#x2F;ansible&#x2F;ansible.cfg10:[defaults]71:host_key_checking &#x3D; False# *111:log_path &#x3D; &#x2F;var&#x2F;log&#x2F;ansible.log# *327:[inventory]340:[privilege_escalation]346:[paramiko_connection]370:[ssh_connection]431:[persistent_connection]445:[accelerate]460:[selinux]469:[colors]485:[diff]</code></pre></div></figure><blockquote><p>Host_key_checking如果没关闭，将造成如下报错：</p><p><img src="/../../../img/image-20240429170421990.png" alt="image-20240429170421990"></p></blockquote><h2 id="1-3-Ans-inventory主机清单"><a href="#1-3-Ans-inventory主机清单" class="headerlink" title="1.3  Ans-inventory主机清单"></a>1.3  Ans-inventory主机清单</h2><p>主机清单，就是让ansible管理的节点的列表，默认读取在<code>/etc/ansible/hosts</code>文件,并非&#x2F;etc&#x2F;hosts。</p><p>未来实际使用中一般我们会把主机清单文件存放在指定的目录中,运行ansible的时候通过<code>-i</code>选项指定主机清单文件即可  </p><h3 id="1-3-1-主机清单的格式"><a href="#1-3-1-主机清单的格式" class="headerlink" title="1.3.1 主机清单的格式"></a>1.3.1 主机清单的格式</h3><blockquote><p>主机清单格式：</p><p>[分类或分组的名字]#注意分类要体现出服务器的作用</p><p>ip地址 或 主机名 或 域名 #注意主机名要能解析才行  </p><p>命令格式：<br>ansible [主机ip 或 分组 或 all]  -m [指定使用的模块名字]</p></blockquote><p>案例01-对主机分组并进行连接测试  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#cat &#x2F;etc&#x2F;ansible&#x2F;hosts[web01]172.16.1.7[backup01]172.16.1.41[nfs01]172.16.1.31# 测试, 这里的ping模块用于检查被管理端是否可以访问.  [root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m ping172.16.1.41 | SUCCESS &#x3D;&gt; &#123;    &quot;ansible_facts&quot;: &#123;        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;    &#125;,    &quot;changed&quot;: false,    &quot;ping&quot;: &quot;pong&quot;&#125;172.16.1.31 | SUCCESS &#x3D;&gt; &#123;....172.16.1.7 | SUCCESS &#x3D;&gt; &#123;....</code></pre></div></figure><h3 id="1-3-2-子组"><a href="#1-3-2-子组" class="headerlink" title="1.3.2 子组"></a>1.3.2 子组</h3><p>案例02: 我希望对backup01,nfs01两个主机分组,再创建个分区叫data分组 </p> <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用children关键字，创建子组[root@mn01[ &#x2F;server&#x2F;scripts]#cat &#x2F;etc&#x2F;ansible&#x2F;hosts[web01]172.16.1.7[backup01]172.16.1.41[nfs01]172.16.1.31[data:children]nfs01backup01# 测试[root@mn01[ &#x2F;server&#x2F;scripts]#ansible data -m ping172.16.1.41 | SUCCESS &#x3D;&gt; &#123;...&#125;172.16.1.31 | SUCCESS &#x3D;&gt; &#123;...&#125;</code></pre></div></figure><h3 id="1-3-3-指定用户名和密码"><a href="#1-3-3-指定用户名和密码" class="headerlink" title="1.3.3 指定用户名和密码"></a>1.3.3 指定用户名和密码</h3><p>如果没有实现进行<em>密钥认证</em>配置，也可以通过修改配置文件来指定<em>用户名和密码</em></p><p>该方法<font color=red>不推荐</font></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">172.16.1.7 ansible_user&#x3D;root ansible_password&#x3D;redhat123ansible_port&#x3D;22</code></pre></div></figure><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先删除172.16.1.7的密钥认证文件，再次ansible会失败[root@mn01[ &#x2F;server&#x2F;scripts]#ansible 172.16.1.7 -m ping172.16.1.7 | UNREACHABLE! &#x3D;&gt; &#123;    &quot;changed&quot;: false,    &quot;msg&quot;: &quot;Failed to connect to the host via ssh: Permission denied (publickey,password).&quot;,    &quot;unreachable&quot;: true&#125;# 配置用户名和密码[root@mn01[ &#x2F;server&#x2F;scripts]#cat &#x2F;etc&#x2F;ansible&#x2F;hosts[web01]172.16.1.7 ansible_user&#x3D;root ansible_password&#x3D;redhat123 ansible_port&#x3D;22[backup01]172.16.1.41...# 再次测试成功访问[root@mn01[ &#x2F;server&#x2F;scripts]#ansible 172.16.1.7 -m ping172.16.1.7 | SUCCESS &#x3D;&gt; &#123;    &quot;ansible_facts&quot;: &#123;        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;    &#125;,    &quot;changed&quot;: false,    &quot;ping&quot;: &quot;pong&quot;&#125;</code></pre></div></figure><h2 id="1-4-Ansible必知必会的模块"><a href="#1-4-Ansible必知必会的模块" class="headerlink" title="1.4 Ansible必知必会的模块"></a>1.4 Ansible必知必会的模块</h2><p>Ansible模块概述:<br>ansible中的模块就类似于Linux中的命令,我们Linux命令管理系统,我们通过ansible模块实现批量管理.<br>ansible中模块一般相当于Linux中的一些命令.yum模块,file模块,user模块.<br>ansible中的模块拥有不同的选项,这些选项一般都是一些单词,拥有自己的格式与要求.  </p><table><thead><tr><th>模块分类</th><th>模块</th></tr></thead><tbody><tr><td>命令和脚本模块</td><td>command模块 ans默认的模块,执行简单命令,不支持特殊符号</td></tr><tr><td></td><td>shell模块 执行命令,支持特殊符号</td></tr><tr><td></td><td>script模块 分发脚本并执行</td></tr><tr><td>文件</td><td>file 创建目录,文件,软连接,</td></tr><tr><td></td><td>copy 远程分发文件,修改权限,所有者,备份</td></tr><tr><td>服务</td><td>systemd服务管理</td></tr><tr><td></td><td>service 服务管理(了解)</td></tr><tr><td>软件包</td><td>yum源 yum_repository</td></tr><tr><td></td><td>yum命令</td></tr><tr><td></td><td>get_url下载软件</td></tr><tr><td>系统管理</td><td>mount模块 挂载</td></tr><tr><td></td><td>cron模块 定时任务</td></tr><tr><td>用户管理</td><td>group模块 管理用户组</td></tr><tr><td></td><td>user模块 管理用户</td></tr><tr><td>其他可以研究</td><td>压缩解压(unarchive) ,rsync模块(synchronize),数据库模块(mysql_db,mysql_user)ՎՎʢ</td></tr><tr><td>其他</td><td>ansible管理docker k8s zabbix grafana ՎՎʢ</td></tr><tr><td>用于调试模块</td><td>ping 模块检查 ansible与其他节点连通性.</td></tr><tr><td></td><td>debug 模块 用于检查&#x2F;显示 变量</td></tr></tbody></table><p>命令和模块使用方法描述</p><table><thead><tr><th>ansible</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>ansible</td><td>主机清单(all&#x2F;web&#x2F;172.16.1.7)</td><td>-m 模块</td><td>-a 模块中的选项</td></tr><tr><td>-i 指定主机清单文件</td><td></td><td></td><td></td></tr><tr><td>-m 指定模块</td><td></td><td></td><td></td></tr><tr><td>-a 指定模块中的选项</td><td></td><td></td><td></td></tr></tbody></table><h3 id="1-4-1-命令与脚本类模块"><a href="#1-4-1-命令与脚本类模块" class="headerlink" title="1.4.1 命令与脚本类模块"></a>1.4.1 命令与脚本类模块</h3><h4 id="a-command模块"><a href="#a-command模块" class="headerlink" title="a) command模块"></a>a) command模块</h4><p>command模块是ansible的默认模块，适用于执行简单的命令，不支持特殊符号</p><p>案例：批量获取所有主机的ens33网卡信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ansible all -m command -a &#39;ip a s ens33&#39;# 因为command是默认模块，可以省略指定ansible all -a &#39;ip a s ens33&#39;</code></pre></div></figure><h4 id="b-shell模块"><a href="#b-shell模块" class="headerlink" title="b) shell模块"></a>b) shell模块</h4><p>与command模块类似，但是shell模块<em>支持特殊符号</em></p><p>案例1：批量删除&#x2F;tmp下面的所有内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m shell -a &#39;rm -fr &#x2F;tmp&#x2F;*&#39;[WARNING]: Consider using the file module with state&#x3D;absent rather than running &#39;rm&#39;.  If you need to use command because file is insufficient you can add &#39;warn: false&#39; to this command task or set&#39;command_warnings&#x3D;False&#39; in ansible.cfg to get rid of this message.172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;</code></pre></div></figure><blockquote><p>删除文件会有warning提示，建议用file模块来操作</p></blockquote><p>案例2：批量获取IP地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m shell -a &quot;ip a s ens33 | awk -F&#39;[ &#x2F;]+&#39; &#39;NR&#x3D;&#x3D;3&#123;print \$3&#125;&#39;&quot;172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;10.0.0.31172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;10.0.0.7172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;10.0.0.41</code></pre></div></figure><h4 id="c-script-模块"><a href="#c-script-模块" class="headerlink" title="c) script 模块"></a>c) script 模块</h4><p>用于分发和执行脚本</p><p>案例：在所有主机中执行指定脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#cat &#x2F;server&#x2F;scripts&#x2F;ansible-script.sh#!&#x2F;bin&#x2F;bashh#desc: 系统巡检脚本hostnamehostname -Iip a s ens33 |awk -F&#39;[ &#x2F;]+&#39; &#39;NR&#x3D;&#x3D;3&#123;print $3&#125;&#39;uptimewhoamidate +%Fsleep 10</code></pre></div></figure><p>分发执行脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m script -a &#39;&#x2F;server&#x2F;scripts&#x2F;ansible-script.sh&#39;172.16.1.7 | CHANGED &#x3D;&gt; &#123;    &quot;changed&quot;: true,....    &quot;stdout_lines&quot;: [        &quot;web01&quot;,        &quot;10.0.0.7 172.16.1.7 &quot;,        &quot;10.0.0.7&quot;,        &quot; 09:49:47 up 1 day, 17:52,  2 users,  load average: 0.00, 0.01, 0.05&quot;,        &quot;root&quot;,        &quot;2024-04-30&quot;    ]172.16.1.31 ....</code></pre></div></figure><h3 id="1-4-2-文件相关的模块"><a href="#1-4-2-文件相关的模块" class="headerlink" title="1.4.2 文件相关的模块"></a>1.4.2 文件相关的模块</h3><h4 id="a-file模块"><a href="#a-file模块" class="headerlink" title="a) file模块"></a>a) file模块</h4><p>作用：</p><ul><li>file模块不仅可以管理文件,还可以管理目录,管理软连接.</li><li>相当于把touch命令,mkdir命令,rm命令,ln -s命令结合在一起了.</li></ul><table><thead><tr><th>file模块</th><th>模块说明</th></tr></thead><tbody><tr><td>path</td><td>路径(目录,文件) 必须要写</td></tr><tr><td>src</td><td>source源,源文件一般用于link(创建软连接模式) 用于指定源文件</td></tr><tr><td>state</td><td>状态(模式) ,具体要做的什么,创建&#x2F;删除,操作文件&#x2F;操作目录 state&#x3D;directory 创建目录 state&#x3D;file (默认) 更新文件,如果文件不存在也不创建 state&#x3D;link 创建软连接 state&#x3D;touch 创建文件</td></tr><tr><td></td><td>state&#x3D;absent 删除 (⚠ 注意如果是目录递归删除目录. )</td></tr><tr><td>mode</td><td>mode&#x3D;755创建并修改权限</td></tr><tr><td>onwer</td><td>onwer&#x3D;root</td></tr><tr><td>group</td><td>group&#x3D;root</td></tr></tbody></table><p>案例1：创建&#x2F;opt&#x2F;test.txt文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m file -a &#39;path&#x3D;&#x2F;opt&#x2F;test.txt state&#x3D;touch&#39;# 查看是否创建成功[root@web01[ &#x2F;upload]#tree &#x2F;opt&#x2F;&#x2F;opt&#x2F;└── test.txt</code></pre></div></figure><p>案例2：创建目录（可以直接多级）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m file -a &#39;path&#x3D;&#x2F;app&#x2F;a&#x2F;b&#x2F;c&#x2F;d state&#x3D;directory&#39;172.16.1.41 | CHANGED &#x3D;&gt; &#123;    &quot;ansible_facts&quot;: &#123;        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;    &#125;,...# 查看是否创建成功[root@web01[ &#x2F;upload]#tree &#x2F;app&#x2F;&#x2F;app&#x2F;└── a    └── b        └── c            └── d</code></pre></div></figure><p>案例3：创建软连接</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># &#x2F;etc&#x2F;hosts软连接到&#x2F;opt下[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m file -a &#39;src&#x3D;&#x2F;etc&#x2F;hosts path&#x3D;&#x2F;opt&#x2F;hosts state&#x3D;link&#39;# 查看是否创建成功[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -a &#39;ls &#x2F;opt -l&#39;172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;total 0lrwxrwxrwx. 1 root root 10 Apr 30 09:58 hosts -&gt; &#x2F;etc&#x2F;hosts-rw-r--r--. 1 root root  0 Apr 30 09:54 test.txt172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;total 0lrwxrwxrwx. 1 root root 10 Apr 30 09:58 hosts -&gt; &#x2F;etc&#x2F;hosts-rw-r--r--. 1 root root  0 Apr 30 09:54 test.txt172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;total 0lrwxrwxrwx. 1 root root 10 Apr 30 09:58 hosts -&gt; &#x2F;etc&#x2F;hosts-rw-r--r--. 1 root root  0 Apr 30 09:54 test.txt</code></pre></div></figure><p>案例4：创建&#x2F;ans-backup目录，所有者是oldboy，权限是700</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ansible all -m file -a &#39;path&#x3D;&#x2F;ans-backup&#x2F;owner&#x3D;oldboy group&#x3D;oldboy mode&#x3D;700 state&#x3D;directory&#39;</code></pre></div></figure><p>案例5：删除&#x2F;ans-backup目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#ansible all -m file -a &#39;path&#x3D;&#x2F;ans-backup&#x2F; state&#x3D;absent&#39;172.16.1.41 | CHANGED &#x3D;&gt; &#123;    &quot;ansible_facts&quot;: &#123;        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;...</code></pre></div></figure><blockquote><p>温馨提示:</p><p>查看模块的帮助,可以通过<code>ansible-doc -s</code>模块名查看，如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;ansible-doc -s file</code></pre></div></figure></blockquote><h4 id="b-copy模块"><a href="#b-copy模块" class="headerlink" title="b) copy模块"></a>b) copy模块</h4><p>批量分发：类似于scp，1个节点(管理节点)发送文件或压缩包到所有被管理端. </p><p>注意：copy是单向的传输。</p><table><thead><tr><th>copy模块</th><th></th></tr></thead><tbody><tr><td>src</td><td>source 源文件,管理端的某个文件.</td></tr><tr><td>dest</td><td>destination 目标,被管理端的目录&#x2F;文件.</td></tr><tr><td>backup</td><td>backup&#x3D;yes 则会在覆盖前进行备份,文件内容要有变化或区别.</td></tr><tr><td>mode</td><td>修改权限</td></tr><tr><td>owner</td><td>修改为指定所有者</td></tr><tr><td>group</td><td>修改为指定用户组</td></tr></tbody></table><p>案例：分发书写好的&#x2F;etc&#x2F;hosts文件，如果文件存在则备份</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看文件内容[root@mn01[ ~]#cat &#x2F;etc&#x2F;hosts127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6172.16.1.7 web01172.16.1.31 nfs01172.16.1.41 backup01# 分发[root@mn01[ ~]#ansible all -m copy -a &#39;src&#x3D;&#x2F;etc&#x2F;hosts dest&#x3D;&#x2F;etc&#x2F;hosts backup&#x3D;yes&#39;172.16.1.7 | CHANGED &#x3D;&gt; &#123;    &quot;ansible_facts&quot;: &#123;        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;    &#125;,    &quot;backup_file&quot;: &quot;&#x2F;etc&#x2F;hosts.28793.2024-04-30@10:11:37~&quot;,....# 查看[root@mn01[ ~]#ansible all -m shell -a &#39;tree &#x2F;etc | grep hosts&#39;172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;├── hosts├── hosts.28793.2024-04-30@10:11:37~...│   │   │   │   │   ├── denyhosts172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;├── hosts├── hosts.39547.2024-04-30@10:11:37~...│   │   │   │   │   ├── denyhosts172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;├── hosts├── hosts.105718.2024-04-30@10:11:37~...</code></pre></div></figure><h4 id="c-lineinfile模块"><a href="#c-lineinfile模块" class="headerlink" title="c) lineinfile模块"></a>c) lineinfile模块</h4><p>未来修改配置文件使用,类似于sed -i ‘sg’和sed ‘cai’.<br>未来使用的时候讲解  </p><h3 id="1-4-3-服务管理模块"><a href="#1-4-3-服务管理模块" class="headerlink" title="1.4.3 服务管理模块"></a>1.4.3 服务管理模块</h3><p>systemd模块相当于是linux systemctl命令：</p><ul><li>开启&#x2F;关闭&#x2F;重启服务</li><li>开机自启动</li></ul><table><thead><tr><th>systemd模块</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>用于指定服务名称</td></tr><tr><td>enabled</td><td>yes开机自启动 (yes&#x2F;no)</td></tr><tr><td>state</td><td>表示服务开,关,重启…. state&#x3D;started 开启 state&#x3D;stopped 关闭 state&#x3D;reloaded 重读配置文件(服务支持) state&#x3D;restarted 重启(关闭再开启)</td></tr><tr><td>daemon-reload</td><td>yes是否重新加载对应的服务的管理配置文件(未来讲解书写systemctl配置文件)</td></tr></tbody></table><p>案例：开启crond服务并设置开机自启动；关闭firewalld服务并不让开机自启动  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#启动服务ansible all -m systemd -a &#39;name&#x3D;crond enabled&#x3D;yes state&#x3D;started&#39;#关闭服务ansible all -m systemd -a &#39;name&#x3D;firewalld enabled&#x3D;no state&#x3D;stopped&#39;#重启sshansible all -m systemd -a &#39;name&#x3D;sshd state&#x3D;restarted&#39;</code></pre></div></figure><blockquote><p>额外扩展:</p><ul><li>systemd模块适用于目前大部分的Linux系统.</li><li>service模块适用于管理旧的Linux系统</li></ul></blockquote><h3 id="1-4-4-软件管理模块"><a href="#1-4-4-软件管理模块" class="headerlink" title="1.4.4 软件管理模块"></a>1.4.4 软件管理模块</h3><p>分为：</p><ul><li>yum模块</li><li>get_url模块，类似于wget命令</li><li>yum_repository模块，yum源配置模块，还是建议通过copy模块分发.</li></ul><h4 id="a-yum模块"><a href="#a-yum模块" class="headerlink" title="a) yum模块"></a>a) yum模块</h4><p>yum模块并不只是yum命令,包含了yum&#x2F;apt命令  </p><table><thead><tr><th>yum模块</th><th></th></tr></thead><tbody><tr><td>name</td><td>指定软件包名字,可以指定多个,通过”,”分割.</td></tr><tr><td>state</td><td>installed 安装(也可以写为present)(默认) removed 删除 (也可以写为absent) lastest 安装或更新</td></tr><tr><td>update_cache</td><td>可以设置为no加加速,表示不更新本地yum缓存.实际应用建议开启</td></tr></tbody></table><p>案例: 安装常用的软件htop,tree,lrzsz,sshpass</p>  <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#ansible all -m yum -a &#39;name&#x3D;htop,tree,lrzsz,sshpass&#39;</code></pre></div></figure><h4 id="b-get-url模块"><a href="#b-get-url模块" class="headerlink" title="b) get_url模块"></a>b) get_url模块</h4><p>相当于是wget命令.所有主机能访问网络才行.<br>推荐在管理节点下载好,使用copy仅分发即可  </p><table><thead><tr><th>get_url下载功能</th><th></th></tr></thead><tbody><tr><td>url</td><td>指定要下载的地址</td></tr><tr><td>dest</td><td>下载到哪个目录</td></tr></tbody></table><p>案例：下载zabbix。。。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建目录[root@mn01[ ~]#ansible all -m file -a &quot;path&#x3D;&#x2F;app&#x2F;tools state&#x3D;directory&quot;[root@mn01[ ~]#ansible all -m get_url -a &#39;url&#x3D;&quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;zabbix&#x2F;zabbix&#x2F;6.0&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-agent-6.0.13-release1.el7.x86_64.rpm&quot; dest&#x3D;&#x2F;app&#x2F;tools&#x2F;&#39;# 后续可以调用yum模块安装本地的软件name&#x3D;&#x2F;app&#x2F;tools&#x2F;xxxxx.rpm即可.# 查看[root@mn01[ ~]#ansible all -a &#39;tree &#x2F;app&#x2F;tools&#39;172.16.1.41 | CHANGED | rc&#x3D;0 &gt;&gt;&#x2F;app&#x2F;tools└── zabbix-agent-6.0.13-release1.el7.x86_64.rpm0 directories, 1 file172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;&#x2F;app&#x2F;tools└── zabbix-agent-6.0.13-release1.el7.x86_64.rpm0 directories, 1 file172.16.1.31 | CHANGED | rc&#x3D;0 &gt;&gt;&#x2F;app&#x2F;tools...└── zabbix-agent-6.0.13-release1.el7.x86_64.rpm</code></pre></div></figure><h4 id="c-yum-repository模块"><a href="#c-yum-repository模块" class="headerlink" title="c) yum_repository模块"></a>c) yum_repository模块</h4><p>了解即可，建议未来书写好yum配置文件,copy分发过去即可  </p><table><thead><tr><th>yum源模块 yum_repository</th><th></th></tr></thead><tbody><tr><td>name</td><td>yum源中名字 [epel]</td></tr><tr><td>description</td><td>yum源的注释说明 对应的 是name的内容</td></tr><tr><td>baseurl</td><td>yum源中 baseurl 下载地址</td></tr><tr><td>enabled</td><td>是否启动这个源 yes&#x2F;no</td></tr><tr><td>gpgcheck</td><td>是否启动gpgcheck功能 no</td></tr><tr><td>file</td><td>指定yum源的文件 自动添加 .repo 默认与模块名字一致.</td></tr></tbody></table><p>例如，以下repo源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@m01 ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo[epel]name&#x3D;Extra Packages for Enterprise Linux 7 -$basearchbaseurl&#x3D;http:Վˌmirrors.aliyun.com&#x2F;epel&#x2F;7&#x2F;$basearchenabled&#x3D;1gpgcheck&#x3D;0</code></pre></div></figure><p>使用ansible配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">-m yum_repository-a &#39;name&#x3D;epel description&#x3D;&quot;Extra Packages for Enterprise Linux7 - $basearch&quot; baseurl&#x3D;&quot;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;epel&#x2F;7&#x2F;$basearch&quot;enabled&#x3D;yesgpgcheck&#x3D;no&#39;</code></pre></div></figure><p>对比如下：</p><table><thead><tr><th>yum配置文件内容</th><th>yum源的模块的选项</th></tr></thead><tbody><tr><td>[epel]</td><td>name&#x3D;epel #默认yum源文件的名字与这个一致.</td></tr><tr><td>name&#x3D;Extra Pxxxxx</td><td>description&#x3D;”Extra xxxxxxx”</td></tr><tr><td>baseurl&#x3D;http:Վˌmirrors.aliyun.com&#x2F;epel&#x2F;7&#x2F;$basea rch</td><td>baseurl&#x3D;”http:Վˌmirrors.aliyun.com&#x2F;epel&#x2F;7&#x2F;$basear ch”</td></tr><tr><td>enabled&#x3D;1</td><td>enabled&#x3D;yes</td></tr><tr><td>gpgcheck&#x3D;0</td><td>gpgcheck&#x3D;no</td></tr></tbody></table><p>案例：给web服务器配置nginx的yum源（http暂用test代替s）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#ansible web01 -m yum_repository -a &#39;name&#x3D;nginx-stable description&#x3D;nginx-stable-repo baseurl&#x3D;http:&#x2F;test gpgcheck&#x3D;yes enabled&#x3D;yes&#39;# 查看效果[root@web01[ &#x2F;upload]#cat &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx-stable.repo[nginx-stable]baseurl &#x3D; http:&#x2F;testenabled &#x3D; 1gpgcheck &#x3D; 1name &#x3D; nginx-stable-repo</code></pre></div></figure><h3 id="1-4-5-用户管理模块"><a href="#1-4-5-用户管理模块" class="headerlink" title="1.4.5 用户管理模块"></a>1.4.5 用户管理模块</h3><p>分为：</p><ul><li>user用户管理：useradd，userdel</li><li>group用户组管理：groupadd</li></ul><h4 id="a-user模块"><a href="#a-user模块" class="headerlink" title="a) user模块"></a>a) user模块</h4><table><thead><tr><th>user模块</th><th></th></tr></thead><tbody><tr><td>name</td><td>wwww 用户名</td></tr><tr><td>uid</td><td>指定uid</td></tr><tr><td>group</td><td>指定用户组,一般用于事先创建好了用户组,通过选项指定下.</td></tr><tr><td>shell</td><td>指定命令解释器:默认是&#x2F;bin&#x2F;bash，可改成如&#x2F;sbin&#x2F;nologin</td></tr><tr><td>create_home</td><td>是否创建家目录(yes&#x2F;no)</td></tr><tr><td>state</td><td>present 添加；absent 删除</td></tr><tr><td>password</td><td>加密的密码.</td></tr></tbody></table><p>案例: 创建www-ans用户uid 2000虚拟用户 </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ansible all -m user -a &#39;name&#x3D;www-ans uid&#x3D;2000 shell&#x3D;&#x2F;sbin&#x2F;nologin create_home&#x3D;no state&#x3D;present&#39;</code></pre></div></figure><p>案例：批量更新密码，更新用户gs的密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ansible all -m user -a &quot;name&#x3D;gs password&#x3D;&#123;&#123;&#39;1&#39; | password_hash(&#39;sha512&#39;, &#39;lidao&#39;) &#125;&#125; state&#x3D;present&quot;</code></pre></div></figure><p>也可以用shell模块更新</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ansible all -m shell -a &#39;echo 1 |passwd --stdin gs&#39;</code></pre></div></figure><blockquote><p>关于<code>&#123;&#123;&#125;&#125;</code>相关的解释：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;&#123;&#123; &#39;1&#39; | password_hash(&#39;sha512&#39;, &#39;lidao&#39;) &#125;&#125;</code></pre></div></figure><p>表示1是密码,经过管道,传递给了password_hash()插件, sha512加密算法，lidao是随机字符用于生成随机加密后的密码  </p></blockquote><h4 id="b-group模块"><a href="#b-group模块" class="headerlink" title="b) group模块"></a>b) group模块</h4><table><thead><tr><th>group</th><th></th></tr></thead><tbody><tr><td>name</td><td>指定用户组名字</td></tr><tr><td>gid</td><td>指定组的gid</td></tr><tr><td>state</td><td>present添加 absent 删除</td></tr></tbody></table><p>案例：添加用户组gs</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加[root@mn01[ ~]#ansible all -m group -a &#39;name&#x3D;gs gid&#x3D;1003 state&#x3D;present&#39;# 查看[root@nfs01[ &#x2F;opt]#cat &#x2F;etc&#x2F;group...gs:x:1003:# 删除[root@mn01[ ~]#ansible all -m group -a &#39;name&#x3D;gs gid&#x3D;1003 state&#x3D;absent&#39;</code></pre></div></figure><h3 id="1-4-6-mount模块"><a href="#1-4-6-mount模块" class="headerlink" title="1.4.6 mount模块"></a>1.4.6 mount模块</h3><p>mount模块，实现mount命令进行挂载可以修改&#x2F;etc&#x2F;fstab实现永久挂载.  </p><table><thead><tr><th>mount选项</th><th>说明</th></tr></thead><tbody><tr><td>fstype</td><td>filesystem type指定文件系统,xfs,ext4,iso9660,nfs</td></tr><tr><td>src</td><td>源地址(nfs地址 eg 172.16.1.31&#x2F;data )</td></tr><tr><td>path</td><td>注意这里不是dest,挂载点(要把源挂载到哪里)</td></tr><tr><td>state</td><td>参考下表</td></tr></tbody></table><table><thead><tr><th>mount模块的state参数可使用的值</th><th></th></tr></thead><tbody><tr><td>absent</td><td>卸载并修改fstab</td></tr><tr><td>unmounted</td><td>卸载不修改&#x2F;etc&#x2F;fstab</td></tr><tr><td>present</td><td>仅修改&#x2F;etc&#x2F;fstab 不挂载</td></tr><tr><td>mounted</td><td>挂载并修改&#x2F;etc&#x2F;fstab</td></tr><tr><td>remounted</td><td>重新挂载</td></tr></tbody></table><p>案例17: 通过ans管理在web01上挂载nfs:&#x2F;data挂载到web01的&#x2F;ans-upload&#x2F;  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#在web服务器上安装nfsansible web01 -m yum -a &#39;name&#x3D;nfs-utils state&#x3D;present&#39;#创建挂载点ansible web01 -m file -a &#39;path&#x3D;&#x2F;ans-upload&#x2F; state&#x3D;directory&#39;#挂载nfsansible web01 -m mount -a &#39;src&#x3D;172.16.1.31:&#x2F;data&#x2F; path&#x3D;&#x2F;ans-upload&#x2F; fstype&#x3D;nfs state&#x3D;mounted &#39;#检查已挂载上[root@mn01[ ~]#ansible web01 -a &#39;df -h&#39;172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;Filesystem               Size  Used Avail Use% Mounted on...172.16.1.31:&#x2F;data         50G  2.5G   48G   5% &#x2F;upload# fstab已写入[root@mn01[ ~]#ansible web01 -a &#39;grep upload &#x2F;etc&#x2F;fstab &#39;172.16.1.7 | CHANGED | rc&#x3D;0 &gt;&gt;172.16.1.31:&#x2F;data&#x2F; &#x2F;ans-upload&#x2F; nfs defaults 0 0</code></pre></div></figure><h3 id="1-4-7-cron模块"><a href="#1-4-7-cron模块" class="headerlink" title="1.4.7 cron模块"></a>1.4.7 cron模块</h3><p>用于管理系统的定时任务,替代了<code>crontab -e</code>功能  </p><table><thead><tr><th>cron模块 选项</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>定时任务名字(一定要加上), 对应下面 注释 的内容</td></tr><tr><td>minute</td><td>分钟 minute&#x3D;”*&#x2F;2”</td></tr><tr><td>hour</td><td>小时</td></tr><tr><td>day</td><td>日期</td></tr><tr><td>month</td><td>月份</td></tr><tr><td>week</td><td>周几</td></tr><tr><td>job</td><td>指定命令或脚本(定向到空) job&#x3D;”&#x2F;sbin&#x2F;ntpdate ntp1.aliyun.com &amp;&gt;&#x2F;dev&#x2F;null”</td></tr><tr><td>state</td><td>present 添加定时任务(默认) absent 删除</td></tr></tbody></table><p>案例: 每3分钟同步时间.  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1. sync time 原写法*&#x2F;3 * * * * &#x2F;sbin&#x2F;ntpdate ntp1.aliyun.com &amp;&gt;&#x2F;dev&#x2F;null# 2.清理已有的定时任务ansible all -a &quot;sed -i &#39;&#x2F;ntpdate&#x2F;d&#39; &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root&quot;# 3.重新添加定时任务ansible all -m cron -a &#39;name&#x3D;&quot;sync time by lidao996&quot; minute&#x3D;&quot;*&#x2F;3&quot; job&#x3D;&quot;&#x2F;sbin&#x2F;ntpdate ntp1.aliyun.com &amp;&gt;&#x2F;dev&#x2F;null&quot; state&#x3D;present&#39;# 4.删除ansible all -m cron -a &#39; name&#x3D;&quot;sync time by lidao996&quot; state&#x3D;absent&#39;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-密钥认证</title>
    <link href="/2024/04/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/06-%E5%AF%86%E9%92%A5%E8%AE%A4%E8%AF%81/"/>
    <url>/2024/04/29/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/06-%E5%AF%86%E9%92%A5%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="一、密钥认证-集群批量管理"><a href="#一、密钥认证-集群批量管理" class="headerlink" title="一、密钥认证-集群批量管理"></a>一、密钥认证-集群批量管理</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>作用：</p><ul><li>使管理更加轻松，两个节点通过密钥形式进行访问，不需要输入密码（单向）</li></ul><p>应用场景：</p><ul><li>一些服务在使用前要求我们做秘钥认证.</li><li>手动写批量管理脚本.</li></ul><p>别名：</p><ul><li>密钥认证</li><li>免密码登录</li><li>双机互信</li></ul><h2 id="1-2-密钥认证的原理"><a href="#1-2-密钥认证的原理" class="headerlink" title="1.2 密钥认证的原理"></a>1.2 密钥认证的原理</h2><p>图示如下：</p><p><img src="/../../../img/image-20240429145442665.png" alt="image-20240429145442665"></p><blockquote><p>什么是密钥对?</p><p>公钥: public key 一般以.pub结尾.<br>私钥: private key 没有特殊的结尾  </p></blockquote><h2 id="1-3-配置密钥认证"><a href="#1-3-配置密钥认证" class="headerlink" title="1.3 配置密钥认证"></a>1.3 配置密钥认证</h2><p>环境准备</p><table><thead><tr><th>角色</th><th>主机名</th><th>ip</th></tr></thead><tbody><tr><td>管理机</td><td>m01</td><td>10.0.0.61</td></tr><tr><td>被管理节点</td><td>nfs01</td><td>10.0.0.31</td></tr><tr><td>被管理节点</td><td>web01</td><td>10.0.0.7</td></tr><tr><td>被管理节点</td><td>backup</td><td>10.0.0.41</td></tr></tbody></table><h3 id="1-3-1-基本检查"><a href="#1-3-1-基本检查" class="headerlink" title="1.3.1 基本检查"></a>1.3.1 基本检查</h3><p>确保对向机器IP和端口正常</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#pingping 172.16.1.41# nmap探测22端口，sshd服务开启或可以访问[root@mn01[ ~]#nmap -p 22 172.16.1.31 172.16.1.7 172.16.1.41Starting Nmap 6.40 ( http:&#x2F;&#x2F;nmap.org ) at 2024-04-29 15:11 CSTNmap scan report for 172.16.1.31Host is up (0.00039s latency).PORT   STATE SERVICE22&#x2F;tcp open  sshMAC Address: 00:0C:29:C7:69:C1 (VMware)Nmap scan report for 172.16.1.7...Nmap scan report for 172.16.1.41...Nmap done: 3 IP addresses (3 hosts up) scanned in 0.47 seconds</code></pre></div></figure><h3 id="1-3-2-创建密钥对"><a href="#1-3-2-创建密钥对" class="headerlink" title="1.3.2 创建密钥对"></a>1.3.2 创建密钥对</h3><p>创建的时候需要按交互提示输入信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa#注意创建的啥时候也可以不加-t, 默认通过rsa方法对数据进行加密.[root@mn01[ ~]#ssh-keygenGenerating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):Created directory &#39;&#x2F;root&#x2F;.ssh&#39;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub.The key fingerprint is:SHA256:ry8yEWh6ZJQ8SUDK7KoQbZW86Y3gScBPO1hJMSfuAGo root@mn01The key&#39;s randomart image is:+---[RSA 2048]----+|..oOo+           ||*.o.@.           ||+E *+o           ||ooB.*o.          ||.o&#x3D;Xo  .S        ||.&#x3D;.+oo.  .       ||o o.o ..  .      ||o     o ..       ||.      o.o.      |+----[SHA256]-----+</code></pre></div></figure><h3 id="1-3-3-分发公钥"><a href="#1-3-3-分发公钥" class="headerlink" title="1.3.3 分发公钥"></a>1.3.3 分发公钥</h3><p>需要按交互提示输入yes &#x2F; no，并输入对向主机密码</p><blockquote><p>yes后会将信息保存到如下文件中：</p><p>[root@mn01[ ~]#ls ~&#x2F;.ssh&#x2F;known_hosts<br>&#x2F;root&#x2F;.ssh&#x2F;known_hosts</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@10.0.0.41&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;&#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub&quot;The authenticity of host &#39;10.0.0.41 (10.0.0.41)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:OVpquCehSKXH4UACbiezs1feEbgyswAvmfM0c1jFOww.ECDSA key fingerprint is MD5:00:f4:c5:99:88:a5:d9:f3:5d:fa:65:d4:57:bd:39:a3.Are you sure you want to continue connecting (yes&#x2F;no)? yes&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@10.0.0.41&#39;s password:Number of key(s) added: 1Now try logging into the machine, with:   &quot;ssh &#39;root@10.0.0.41&#39;&quot;and check to make sure that only the key(s) you wanted were added.</code></pre></div></figure><h3 id="1-3-4-连接测试"><a href="#1-3-4-连接测试" class="headerlink" title="1.3.4 连接测试"></a>1.3.4 连接测试</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#ssh 10.0.0.41 hostname -I10.0.0.41 172.16.1.41</code></pre></div></figure><blockquote><p>温馨提示：</p><p>ssh-copy-id后公钥被存放在对方服务器的用户家目录下面的.ssh下面.</p><p>名字叫:authorized_keys，如果不想被密钥认证了，把该文件删了即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@backup01[ ~]#ls ~&#x2F;.ssh&#x2F;&gt;authorized_keys</code></pre></div></figure></blockquote><h2 id="1-4-自动化创建与分发密钥"><a href="#1-4-自动化创建与分发密钥" class="headerlink" title="1.4 自动化创建与分发密钥"></a>1.4 自动化创建与分发密钥</h2><p>结合2.3节的创建和分发流程，自动化创建和分发主要<font color=red>面临以下问题</font>：</p><ul><li>创建秘钥对需要交互式输入【1.4.1解决】</li><li>分发公钥的时候需要交互式输入：yes&#x2F;no 【1.4.2解决】</li><li>分发公钥的时候需要输入密码  【1.4.2解决】</li></ul><h3 id="1-4-1-自动化创建"><a href="#1-4-1-自动化创建" class="headerlink" title="1.4.1 自动化创建"></a>1.4.1 自动化创建</h3><p>使用选项指定参数，跳过交互式输入环节</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># -f用于指定私钥的位置# -P 密码短语 设置为空# -t 用于指定加密算法，默认rsa，可以省略ssh-keygen -f ~&#x2F;.ssh&#x2F;id_rsa -P &#39;&#39;# 或者ssh-keygen -t rsa -f ~&#x2F;.ssh&#x2F;id_rsa -P &#39;&#39;</code></pre></div></figure><h3 id="1-4-2-自动化分化密钥"><a href="#1-4-2-自动化分化密钥" class="headerlink" title="1.4.2 自动化分化密钥"></a>1.4.2 自动化分化密钥</h3><p>解决输入密码问题，需要使用到<em>sshpass</em>工具，其基本使用如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#安装工具yum install -y sshpass# 先测试对方机器是否需要输入yes &#x2F; no，并输入yes[root@mn01[ ~]#ssh 10.0.0.7 hostname -IThe authenticity of host &#39;10.0.0.7 (10.0.0.7)&#39; can&#39;t be ....Are you sure you want to continue connecting (yes&#x2F;no) yes# 然后使用sshpass测试, -p后面可以指定密码[root@mn01[ ~]#sshpass -p &quot;redhat123&quot; ssh 10.0.0.7 hostname -I10.0.0.7 172.16.1.7# 成功解决交互式输入密码的问题</code></pre></div></figure><p>解决交互书yes &#x2F; no的问题，需要使用到ssh-copy-id的选项</p><p><code>-oStrictHostKeyChecking=no</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ ~]#sshpass -p &quot;redhat123&quot; ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub -oStrictHostKeyChecking&#x3D;no 10.0.0.41&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;&#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub&quot;...Number of key(s) added: 1...and check to make sure that only the key(s) you wanted were added.# 分发成功</code></pre></div></figure><h3 id="1-4-3-自动化创建与分发脚本"><a href="#1-4-3-自动化创建与分发脚本" class="headerlink" title="1.4.3 自动化创建与分发脚本"></a>1.4.3 自动化创建与分发脚本</h3><p>创建和分发密钥脚本<code>/server/scripts/creatkey.sh</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash #desc: 一键创建和分发密钥对#1.varspass&#x3D;&quot;redhat123&quot;ips&#x3D;&quot;10.0.0.7 10.0.0.31 10.0.0.41&quot;# 导入模块. &#x2F;etc&#x2F;init.d&#x2F;functions# 判断是否联网可以使用yum# 加入判断sshpass命令是否存在，如果不存在则安装# 2.创建密钥对if [ -f ~&#x2F;.ssh&#x2F;id_rsa ];then        echo &quot;已经创建过密钥对&quot;else        echo &quot;正在创建密钥对...&quot;        ssh-keygen -t rsa -f ~&#x2F;.ssh&#x2F;id_rsa -P &#39;&#39; &amp;&gt;&#x2F;dev&#x2F;null        if [ $? -eq 0 ];then                action &quot;密钥创建成功&quot;   &#x2F;bin&#x2F;true        else                action &quot;密钥创建失败&quot;   &#x2F;bin&#x2F;false        fifi# 3.使用循环发送公钥for ip in $ipsdo        sshpass -p $&#123;pass&#125; ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub -oStrictHostKeyChecking&#x3D;no $ip &amp;&gt;&#x2F;dev&#x2F;null        if [ $? -eq 0 ];then                action &quot;密钥分发成功&quot;   &#x2F;bin&#x2F;true        else                action &quot;密钥分发失败&quot;   &#x2F;bin&#x2F;false        fidone</code></pre></div></figure><p>分发脚本测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#.&#x2F;createkey.sh正在创建密钥对...密钥创建成功                                               [  OK  ]密钥分发成功                                               [  OK  ]密钥分发成功                                               [  OK  ]密钥分发成功                                               [  OK  ][root@mn01[ &#x2F;server&#x2F;scripts]#.&#x2F;createkey.sh已经创建过密钥对密钥分发成功                                               [  OK  ]密钥分发成功                                               [  OK  ]密钥分发成功                                               [  OK  ]</code></pre></div></figure><p>检查脚本测试<code>/server/scripts/check.sh</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# desc: 批量在所有机器上执行命令for ip in 10.0.0.7 10.0.0.31 10.0.0.41do        ssh $ip hostnamedone</code></pre></div></figure><p>脚本测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@mn01[ &#x2F;server&#x2F;scripts]#.&#x2F;check.shweb01nfs01backup01</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Openssh服务</title>
    <link href="/2024/04/28/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/05-SSHD%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/04/28/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/05-SSHD%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Openssh服务"><a href="#一、Openssh服务" class="headerlink" title="一、Openssh服务"></a>一、Openssh服务</h1><h2 id="1-1-openssh服务介绍"><a href="#1-1-openssh服务介绍" class="headerlink" title="1.1. openssh服务介绍"></a>1.1. openssh服务介绍</h2><ul><li>用于实现加密的远程连接&#x2F;传输数据.<br>openssh-server 服务端（sshd,&#x2F;etc&#x2F;ssh&#x2F;sshd_config）<br>openssh-clients客户端（命令 scp,ssh）</li></ul><h2 id="1-2-telnet-VS-openssh"><a href="#1-2-telnet-VS-openssh" class="headerlink" title="1.2 telnet VS openssh"></a>1.2 telnet VS openssh</h2><table><thead><tr><th>服务</th><th>共同点</th><th>区别</th><th>应用场景</th></tr></thead><tbody><tr><td>openssh 服务</td><td>远程连接</td><td>数据加密的</td><td>默认使用openssh</td></tr><tr><td>telnet 服务</td><td>远程连接</td><td>数据未加密</td><td>升级openssh服务的时候,启动telnet服务即可</td></tr></tbody></table><p>telnet服务的使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装服务yum install -y telnet-server# 启动systemctl start telnet.socket# systemctl disable telnet.socket#本地shell中连接telnet 10.0.0.61 23</code></pre></div></figure><h2 id="1-3-openssh的配置文件（-）"><a href="#1-3-openssh的配置文件（-）" class="headerlink" title="1.3 openssh的配置文件（*）"></a>1.3 openssh的配置文件（*）</h2><p>核心配置文件: <code>/etc/ssh/sshd_config</code></p><table><thead><tr><th>Openssh服务端配置详解</th><th></th></tr></thead><tbody><tr><td>连接加速项目</td><td></td></tr><tr><td>UseDNS no</td><td>是否开启反向解析:ip —&gt; 域名或主机名</td></tr><tr><td>GSSAPIAuthentication no</td><td>GSS认证功能关闭</td></tr><tr><td>安全优化项目</td><td></td></tr><tr><td>Port</td><td>默认是Port 22 端口范围1-65535 推荐1w以上的端口</td></tr><tr><td>PermitRootLogin</td><td>禁用root用户 远程 登录权限. 默认是yes(可以让root远程登录) (ubt系统中默认是no) 使 用建议:先添加普通用户配置sudo权限,然后再禁用.</td></tr><tr><td>ListenAddress</td><td>监听的地址(后面需要指定本地网卡的ip地址) 可以控制用户只能通过内网访问,应用建议:一般配合着堡 垒机,vp</td></tr></tbody></table><blockquote><p>操作建议:未来可以设置公网的端口与局域网端口不同(内外网端口分离)  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;ListenAddress 0.0.0.0:52113 #表示ssh都可以使用52113 无论局域网还是公网&gt;ListenAddress 172.16.1.61:22 #表示ssh只有在172.16.1.61 局域网可以使用22端口&gt;ssh root@172.16.1.61&gt;ssh -p 52113 root@10.0.0.61&gt;ssh -p 22 root@10.0.0.61</code></pre></div></figure></blockquote><h2 id="1-4-Openssh-Clients客户端命令"><a href="#1-4-Openssh-Clients客户端命令" class="headerlink" title="1.4 Openssh-Clients客户端命令"></a>1.4 Openssh-Clients客户端命令</h2><h3 id="1-4-1-scp"><a href="#1-4-1-scp" class="headerlink" title="1.4.1 scp"></a>1.4.1 scp</h3><p>使用方法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scp 文件&#x2F;目录 用户名@ip:路径-r 递归传输,传输目录-p 保持属性信息不变-P(大写) 指定端口号# 案例scp -rp -P 22 &#x2F;etc&#x2F;hostname root@10.0.0.41:&#x2F;tmp&#x2F;</code></pre></div></figure><h3 id="1-4-2-ssh"><a href="#1-4-2-ssh" class="headerlink" title="1.4.2 ssh"></a>1.4.2 ssh</h3><p>用于：</p><ol><li>远程连接.</li><li>远程连接并执行命令或脚本.(不要执行交互式命令)</li></ol><p>案例01: 使用oldboy用户远程连接到10.0.0.41的22端口  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -p 22 oldboy@10.0.0.41</code></pre></div></figure><p>案例02: 使用oldboy用户远程连接到10.0.0.41的22端口并执行whoami命令或ip a 命令  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -p 22 oldboy@10.0.0.41 whoami</code></pre></div></figure><p>案例03: 远程连接10.0.0.31节点并执行多条命令:whoami , pwd, hostname命令  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -p22 nfs01 &quot;whoami &amp;&amp; pwd &amp;&amp; hostname -I &quot;# 或者用分号ssh -p22 nfs01 &quot;whoami ; pwd ; hostname -I &quot;</code></pre></div></figure><blockquote><p>&amp;&amp;并且，命令行中表示前一个命令执行成功再执行后面的命令.<br>; 分号，分隔命令.相当于是1行的结束  </p></blockquote><h3 id="1-4-3-sftp"><a href="#1-4-3-sftp" class="headerlink" title="1.4.3 sftp"></a>1.4.3 sftp</h3><p>ftp文件传输协议,服务和客户端,服务端端口是21和20.<br>openssh (sshd)也提供了,ftp功能,sftp,端口是22.<br>ftp客户端:常用sftp命令,软件xftp,winscp….  </p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Sersync数据实时同步</title>
    <link href="/2024/04/28/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/04-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <url>/2024/04/28/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/04-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Sersync数据实时同步"><a href="#一、Sersync数据实时同步" class="headerlink" title="一、Sersync数据实时同步"></a>一、Sersync数据实时同步</h1><h2 id="1-1-sersync实时同步简介"><a href="#1-1-sersync实时同步简介" class="headerlink" title="1.1. sersync实时同步简介"></a>1.1. sersync实时同步简介</h2><blockquote><p>实时同步的3种方法：</p><ul><li>inotify(bug需要书写脚本,不推荐使用.):是个命令监控指定目录是否发生变化.</li><li>sersync(国产开源,内置inotify+rsync命令,一个命令+一个配置文件) 推荐</li><li>lsyncd(目前一些公司在使用,课后研究.)</li></ul></blockquote><p>实时同步架构如下：</p><p><img src="/../../../img/image-20240428152051277.png" alt="image-20240428152051277"></p><p>sersync实时同步的原理:</p><ul><li>实时同步通过inotify + rsync实现</li><li>inotify监控目录，通过rsync把变化的文件推送走</li></ul><h2 id="1-2-配置Sersync"><a href="#1-2-配置Sersync" class="headerlink" title="1.2 配置Sersync"></a>1.2 配置Sersync</h2><h3 id="1-2-1-rysnc服务准备"><a href="#1-2-1-rysnc服务准备" class="headerlink" title="1.2.1 rysnc服务准备"></a>1.2.1 rysnc服务准备</h3><p>备份服务器（作为服务端）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置rsync服务端[root@backup01[ &#x2F;]#cat &#x2F;etc&#x2F;rsyncd.conf...[nfsbackup]comment &#x3D; 实时同步path &#x3D; &#x2F;nfsbackup# 创建目录[root@backup01[ &#x2F;]#mkdir &#x2F;nfsbackup[root@backup01[ &#x2F;]#chown rsync.rsync &#x2F;nfsbackup&#x2F;</code></pre></div></figure><p>nfs服务器（作为客户端）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo 123 &gt; &#x2F;etc&#x2F;client.rsyncchmod 600 &#x2F;etc&#x2F;client.rsync# 测试传输，可以推送成功[root@nfs01[ &#x2F;]#rsync -av &#x2F;etc&#x2F;hosts rsync_backup@172.16.1.41::nfsbackup --password-file&#x3D;&#x2F;etc&#x2F;client.rsyncsending incremental file listhostssent 247 bytes  received 43 bytes  580.00 bytes&#x2F;sectotal size is 158  speedup is 0.54</code></pre></div></figure><h3 id="1-2-2-sersync部署"><a href="#1-2-2-sersync部署" class="headerlink" title="1.2.2 sersync部署"></a>1.2.2 sersync部署</h3><p>在客户端（nfs）安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># github下载sersynchttps:&#x2F;&#x2F;github.com&#x2F;wsgzao&#x2F;sersync# 解压tar -vxf sersync2.5.4_64bit_binary_stable_final.tar.gz# 创建第三方app专用存放路径&#x2F;app&#x2F;tools&#x2F;sersync&#x2F;&#x2F;app&#x2F;tools&#x2F;sersync&#x2F;bin&#x2F;&#x2F;app&#x2F;tools&#x2F;sersync&#x2F;conf&#x2F;# 把解压后的文件放进去[root@nfs01[ &#x2F;app&#x2F;GNU-Linux-x86]#mv sersync2 &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;bin&#x2F;[root@nfs01[ &#x2F;app&#x2F;GNU-Linux-x86]#mv confxml.xml &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;conf&#x2F;# 设置软链接[root@nfs01[ &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;bin]#ln &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;bin&#x2F;sersync2 -s &#x2F;bin</code></pre></div></figure><p>修改配置文件config.xml</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;sersync&gt;&lt;localpath watch&#x3D;&quot;&#x2F;data&#x2F;&quot;&gt;&lt;remote ip&#x3D;&quot;172.16.1.41&quot; name&#x3D;&quot;nfsbackup&quot;&#x2F;&gt;... &lt;rsync&gt; &lt;commonParams params&#x3D;&quot;-az&quot;&#x2F;&gt; &lt;auth start&#x3D;&quot;true&quot; users&#x3D;&quot;rsync_backup&quot; passwordfile&#x3D;&quot;&#x2F;etc&#x2F;client.rsync&quot;&#x2F;&gt;...&lt;failLog path&#x3D;&quot;&#x2F;var&#x2F;log&#x2F;rsync_fail_log.sh&quot; timeToExecute&#x3D;&quot;60&quot;&#x2F;&gt;&lt;!--default every 60mins execute once--&gt;...</code></pre></div></figure><p>参考如下：</p><p><img src="/../../../img/image-20240428154558329.png" alt="image-20240428154558329"></p><p>配置文件的详细解析：</p><p><img src="/../../../img/image-20240428154638896.png" alt="image-20240428154638896"></p><p>启动sersync</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01[ &#x2F;data]#sersync2 -rdo &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;conf&#x2F;confxml.xmlset the system paramexecute：echo 50000000 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_user_watchesexecute：echo 327679 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_queued_eventsparse the command paramoption: -r      rsync all the local files to the remote servers before the sersync workoption: -d      run as a daemonoption: -o      config xml name：  &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;conf&#x2F;confxml.xmldaemon thread num: 10parse xml config filehost ip : localhost     host port: 8008daemon start，sersync run behind the consoleuse rsync password-file :user is rsync_backuppasswordfile is         &#x2F;etc&#x2F;client.rsyncconfig xml parse successplease set &#x2F;etc&#x2F;rsyncd.conf max connections&#x3D;0 Manuallysersync working thread 12  &#x3D; 1(primary thread) + 1(fail retry thread) + 10(daemon sub threads)Max threads numbers is: 22 &#x3D; 12(Thread pool nums) + 10(Sub threads)please according your cpu ，use -n param to adjust the cpu rate------------------------------------------rsync the directory recursivly to the remote servers onceworking please wait...execute command: cd &#x2F;data &amp;&amp; rsync -az -R --delete .&#x2F; rsync_backup@172.16.1.41::nfsbackup --password-file&#x3D;&#x2F;etc&#x2F;client.rsync &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1run the sersync:watch path is: &#x2F;data</code></pre></div></figure><p>接入nfs服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01[ &#x2F;app&#x2F;tools&#x2F;sersync&#x2F;bin]#cat &#x2F;etc&#x2F;exports&#x2F;data&#x2F;  172.16.1.0&#x2F;24(rw)# 用这个&#x2F;nfsdata&#x2F;       172.16.1.0&#x2F;24(rw,all_squash,anonuid&#x3D;1999,anongid&#x3D;1999)</code></pre></div></figure><p>web服务器挂载nfs盘</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;]#mount -t nfs 172.16.1.31:&#x2F;data &#x2F;upload</code></pre></div></figure><h3 id="1-2-3-联调"><a href="#1-2-3-联调" class="headerlink" title="1.2.3 联调"></a>1.2.3 联调</h3><p>测试实时同步情况</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># web01创建[root@web01[ &#x2F;upload]#&gt;web01.data# backup实时同步Every 2.0s: tree -F &#x2F;nfsbackup  &#x2F;nfsbackup└── web01.data# web01删除[root@web01[ &#x2F;upload]#rm web01.data -fr# backup实时同步Every 2.0s: tree -F &#x2F;nfsbackup                                                                 &#x2F;nfsbackup</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-备份服务介绍</title>
    <link href="/2024/04/26/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/02-%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/04/26/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/02-%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、备份服务介绍"><a href="#一、备份服务介绍" class="headerlink" title="一、备份服务介绍"></a>一、备份服务介绍</h1><p>什么是备份服务？</p><ul><li>定时&#x2F;实时打包重要数据到备份服务器中</li></ul><p>备份服务使用什么实现？</p><ul><li>使用rsyncd服务，在不同主机之间传输数据</li></ul><blockquote><p>虚拟机准备：</p><p>一台存储服务器：nfs01172.16.1.31&#x2F;24</p><p>一台备份服务器：backup01172.16.1.41&#x2F;24</p></blockquote><h2 id="1-1-rsync服务的特点"><a href="#1-1-rsync服务的特点" class="headerlink" title="1.1 rsync服务的特点"></a>1.1 rsync服务的特点</h2><ul><li>rsync既是服务，也是命令</li><li>使用方便，具有多种模式</li><li>传输数据的时候是增量备份，比scp的全量备份效率高</li></ul><h2 id="1-2-rsync服务的企业应用场景"><a href="#1-2-rsync服务的企业应用场景" class="headerlink" title="1.2 rsync服务的企业应用场景"></a>1.2 rsync服务的企业应用场景</h2><table><thead><tr><th>应用场景(业务场景)</th><th>应用建议</th></tr></thead><tbody><tr><td>rsync作为命令使用</td><td>临时拉取,推送数据.未来这个需求可以通过scp命令实现.</td></tr><tr><td>定时备份:rsync服务+定时任务</td><td>定时备份,定期备份案例.(定时任务进行备份+通过rsync传输备份)</td></tr><tr><td>实时同步:rsync服务+sersync&#x2F;lsyncd实现实时同步</td><td>解决存储服务单点问题</td></tr><tr><td>rsync服务与异地容灾</td><td>找一个异地的服务器存放备份</td></tr></tbody></table><blockquote><p>单点问题: 同一个功能&#x2F;同一个服务,只有1台节点.  </p></blockquote><p><img src="/../../../img/image-20240426154942353.png" alt="image-20240426154942353"></p><p><img src="/../../../img/image-20240426154955738.png" alt="image-20240426154955738"></p><p><img src="/../../../img/image-20240426155009161.png" alt="image-20240426155009161"></p><p>![image-20240426155017705](..&#x2F;..&#x2F;..&#x2F;img&#x2F;image-20240426155017705.png</p><h1 id="二、使用Rsync"><a href="#二、使用Rsync" class="headerlink" title="二、使用Rsync"></a>二、使用Rsync</h1><table><thead><tr><th>rsync选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>-rlptgoD -r递归复制 -l复制软连接 -p保持权限不变 -m保持修改时间不变 -o所有者不变 -g用户组不变 -D –devices –specials 设备与特殊文件</td></tr><tr><td>-v</td><td>显示过程</td></tr><tr><td>-z</td><td>传输数据的时候进行压缩(公网)</td></tr><tr><td>-P</td><td>显示每rsync -av . <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#64;&#x31;&#48;&#46;&#x30;&#x2e;&#x30;&#x2e;&#51;&#x31;">&#x72;&#111;&#x6f;&#x74;&#64;&#x31;&#48;&#46;&#x30;&#x2e;&#x30;&#x2e;&#51;&#x31;</a>:&#x2F;tmp&#x2F; –exclude&#x3D;04 rsync -av . <a href="mailto:&#114;&#111;&#111;&#116;&#x40;&#49;&#x30;&#x2e;&#x30;&#x2e;&#x30;&#x2e;&#51;&#x31;">&#114;&#111;&#111;&#116;&#x40;&#49;&#x30;&#x2e;&#x30;&#x2e;&#x30;&#x2e;&#51;&#x31;</a>:&#x2F;mnt –exclude&#x3D;{04,05}个文件传输过程 (进度条) 断点续传 –partial –progress</td></tr><tr><td>–bwlimit</td><td>限速,注意不要与-z一起使用.</td></tr><tr><td>–exclude –exclude-from</td><td>排除</td></tr><tr><td>–delete</td><td>目标目录与源目录保持一致的传输(高度保持2遍一致,实时同步)</td></tr></tbody></table><h2 id="2-1-rsync使用模式"><a href="#2-1-rsync使用模式" class="headerlink" title="2.1 rsync使用模式"></a>2.1 rsync使用模式</h2><table><thead><tr><th>模式</th><th>应用场景</th></tr></thead><tbody><tr><td>本地模式(了解)</td><td>不推荐使用</td></tr><tr><td>远程模式</td><td>传输数据(临时使用可以使用scp替代)</td></tr><tr><td>rsync守护进程模式(daemon)</td><td>传输数据(不需要密码),用于定时备份,定时同步.</td></tr></tbody></table><h2 id="2-2-本地模式"><a href="#2-2-本地模式" class="headerlink" title="2.2 本地模式"></a>2.2 本地模式</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -a &#x2F;etc&#x2F; &#x2F;tmp&#x2F;</code></pre></div></figure><blockquote><p>在rsync对于目录 &#x2F;etc&#x2F; &#x2F;etc 是有区别的.<br>&#x2F;etc &#x2F;etc目录+目录的内容<br>&#x2F;etc&#x2F; &#x2F;etc&#x2F;目录下面的内容  </p></blockquote><h2 id="2-3-远程模式（常用）"><a href="#2-3-远程模式（常用）" class="headerlink" title="2.3 远程模式（常用）"></a>2.3 远程模式（常用）</h2><p>1对1进行远程传输数据  </p><table><thead><tr><th>格式</th><th></th><th></th></tr></thead><tbody><tr><td>rsync -a</td><td>源文件</td><td>目标</td></tr><tr><td>推送:rsync</td><td>&#x2F;etc&#x2F;hostname</td><td><a href="mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#48;&#x2e;&#x30;&#46;&#48;&#46;&#x33;&#x31;">&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#48;&#x2e;&#x30;&#46;&#48;&#46;&#x33;&#x31;</a>:&#x2F;tmp</td></tr><tr><td>拉取:rsync</td><td><a href="mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#48;&#x2e;&#48;&#46;&#48;&#46;&#x33;&#49;">&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#48;&#x2e;&#48;&#46;&#48;&#46;&#x33;&#49;</a>:&#x2F;etc&#x2F;hosts</td><td>&#x2F;opt&#x2F;</td></tr></tbody></table><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#推送&#x2F;etc&#x2F;hostname 到10.0.0.31的&#x2F;tmp&#x2F;目录rsync -a &#x2F;etc&#x2F;hostname root@10.0.0.31:&#x2F;tmp#推送&#x2F;etc 目录及目录内容 到31的 &#x2F;tmp下面#推送第1次 全量rsync -av &#x2F;etc root@10.0.0.31:&#x2F;tmp#推送第2次 发现没有推送rsync -av &#x2F;etc root@10.0.0.31:&#x2F;tmp#创建文件再次推送touch &#x2F;etc&#x2F;lidao.txtrsync -av &#x2F;etc root@10.0.0.31:&#x2F;tmp#通过scp推送 &#x2F;etc 目录及目录内容 到31的 &#x2F;opt下面scp -r &#x2F;etc&#x2F; root@10.0.0.31:&#x2F;opt&#x2F;-r 递归传输</code></pre></div></figure><h2 id="2-4-守护进程模式（常用）"><a href="#2-4-守护进程模式（常用）" class="headerlink" title="2.4 守护进程模式（常用）"></a>2.4 守护进程模式（常用）</h2><p>配置和测试流程</p><h3 id="2-4-1-检查是否安装"><a href="#2-4-1-检查是否安装" class="headerlink" title="2.4.1 检查是否安装"></a>2.4.1 检查是否安装</h3><p>！在备份服务器中安装和配置！</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">检查安装 更新yum install -y rsync检查软件包内容&#x2F;etc&#x2F;rsyncd.conf #配置文件&#x2F;usr&#x2F;bin&#x2F;rsync #命令&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rsyncd.service #systemctl对应的配置文件.</code></pre></div></figure><table><thead><tr><th>软件包内容</th><th></th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;rsyncd.conf</td><td>配置文件(服务端配置文件,守护进程模式)</td></tr><tr><td>&#x2F;usr&#x2F;bin&#x2F;rsync</td><td>rsync命令</td></tr><tr><td>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rsyncd.service</td><td>systemctl控制rsyncd服务的配置文件</td></tr></tbody></table><h3 id="2-4-2-进行配置"><a href="#2-4-2-进行配置" class="headerlink" title="2.4.2 进行配置"></a>2.4.2 进行配置</h3><h4 id="a-配置文件详解"><a href="#a-配置文件详解" class="headerlink" title="a) 配置文件详解"></a>a) 配置文件详解</h4><p><img src="/../../../img/image-20240426155542202.png" alt="image-20240426155542202"></p><h4 id="b-服务端配置"><a href="#b-服务端配置" class="headerlink" title="b) 服务端配置"></a>b) 服务端配置</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup &#x2F;oldboy]# cat &#x2F;etc&#x2F;rsyncd.conf#created by oldboy 15:01 2009-6-5##rsyncd.conf start##fake super &#x3D;yesuid &#x3D; rsyncgid &#x3D; rsyncuse chroot &#x3D; nomax connections &#x3D; 2000timeout &#x3D; 600pid file &#x3D; &#x2F;var&#x2F;run&#x2F;rsyncd.pidlock file &#x3D; &#x2F;var&#x2F;run&#x2F;rsync.locklog file &#x3D; &#x2F;var&#x2F;log&#x2F;rsyncd.logignore errorsread only &#x3D; falselist &#x3D; false#hosts allow &#x3D; 10.0.0.0&#x2F;24#hosts deny &#x3D; 0.0.0.0&#x2F;32auth users &#x3D; rsync_backupsecrets file &#x3D; &#x2F;etc&#x2F;rsync.password#####################################[data]comment &#x3D; www by old0boy 14:18 2012-1-13path &#x3D; data</code></pre></div></figure><h4 id="c-后续配置"><a href="#c-后续配置" class="headerlink" title="c) 后续配置"></a>c) 后续配置</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1.添加虚拟用户useradd -s &#x2F;sbin&#x2F;nologin -M rsync# 检查用户是否创建成功[root@backup01[ ~]#id rsyncuid&#x3D;1001(rsync) gid&#x3D;1001(rsync) groups&#x3D;1001(rsync)#2.创建密码文件密码文件格式: 用户名:密码echo &#39;rsync_backup:123 &#39; &gt;&#x2F;etc&#x2F;rsync.passwordchmod 600 &#x2F;etc&#x2F;rsync.password#3.共享目录与权限mkdir &#x2F;data&#x2F;chown rsync.rsync &#x2F;data</code></pre></div></figure><h4 id="d-启动服务"><a href="#d-启动服务" class="headerlink" title="d) 启动服务"></a>d) 启动服务</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#启动服务systemctl enable rsyncdsystemctl start rsyncd#检查进程ps -ef |grep rsync#检查端口ss -lntup |grep rsync</code></pre></div></figure><h3 id="2-4-3-访问测试"><a href="#2-4-3-访问测试" class="headerlink" title="2.4.3 访问测试"></a>2.4.3 访问测试</h3><table><thead><tr><th>rsync守护进程模式客户端命令</th><th></th><th></th></tr></thead><tbody><tr><td>rsync -avz</td><td>&#x2F;etc&#x2F;hosts</td><td><a href="mailto:&#x72;&#115;&#121;&#110;&#99;&#95;&#98;&#x61;&#x63;&#107;&#117;&#112;&#64;&#49;&#x30;&#46;&#x30;&#x2e;&#48;&#46;&#52;&#x31;">&#x72;&#115;&#121;&#110;&#99;&#95;&#98;&#x61;&#x63;&#107;&#117;&#112;&#64;&#49;&#x30;&#46;&#x30;&#x2e;&#48;&#46;&#52;&#x31;</a>::data</td></tr><tr><td>rsync_backup是服务端配置文件中的认证用户.</td><td></td><td></td></tr><tr><td>data表示模块名字</td><td></td><td></td></tr></tbody></table><h4 id="a-本地测试"><a href="#a-本地测试" class="headerlink" title="a) 本地测试"></a>a) 本地测试</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# rsync -avz &#x2F;etc&#x2F;hostnamersync_backup@10.0.0.41ՎʦdataPassword:sending incremental file listhostnamesent 102 bytes received 43 bytes 41.43 bytes&#x2F;sectotal size is 7 speedup is 0.05[root@backup ~]# ll &#x2F;data&#x2F;total 4-rw-r--r-- 1 rsync rsync 7 Aug 16 16:02 hostname</code></pre></div></figure><h4 id="b-客户端测试"><a href="#b-客户端测试" class="headerlink" title="b) 客户端测试"></a>b) 客户端测试</h4><p>基本测试  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01 ~]# rsync -avz &#x2F;etc&#x2F;hosts rsync_backup@172.16.1.41::dataPassword:sending incremental file listhostssent 214 bytes received 43 bytes 73.43 bytes&#x2F;sectotal size is 329 speedup is 1.28</code></pre></div></figure><p>免密传输</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建密码文件echo 123 &gt;&#x2F;etc&#x2F;client.rsync# 设置文件权限, password file must not be other-accessiblechmod 600 &#x2F;etc&#x2F;client.rsyncrsync -avz &#x2F;etc&#x2F;hosts rsync_backup@172.16.1.41::data --password-file&#x3D;&#x2F;etc&#x2F;client.rsync</code></pre></div></figure><p><img src="/../../../img/image-20240426160154296.png" alt="image-20240426160154296"></p><h3 id="2-4-4-访问控制-安全措施"><a href="#2-4-4-访问控制-安全措施" class="headerlink" title="2.4.4 访问控制-安全措施"></a>2.4.4 访问控制-安全措施</h3><p>IP限制</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置文件修改hosts allow  10.0.0.0&#x2F;24 # 只准许指定的ip或网段访问.hosts deny 0.0.0.0&#x2F;32 # 拒绝  </code></pre></div></figure><p>速度限制</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -aP --bwlimit&#x3D;500kb &#x2F;tmp&#x2F;1g 10.0.0.31:&#x2F;mnt&#x2F;</code></pre></div></figure><p>传输并排除</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -av . root@10.0.0.31:&#x2F;tmp&#x2F; --exclude&#x3D;04rsync -av . root@10.0.0.31:&#x2F;mnt --exclude&#x3D;&#123;04,05&#125;# 通过文件内容进行排除[root@backup &#x2F;oldboy]# cat &#x2F;tmp&#x2F;paichu.txt030510[root@backup &#x2F;oldboy]# rsync -av . root@10.0.0.31:~ --exclude-from&#x3D;&#x2F;tmp&#x2F;paichu.txt</code></pre></div></figure><p>保持源与目标数据一致  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -avP --delete . root@10.0.0.31:&#x2F;tmp&#x2F;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-全网备份项目</title>
    <link href="/2024/04/26/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/03-%E5%85%A8%E7%BD%91%E5%A4%87%E4%BB%BD%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/04/26/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/03-%E5%85%A8%E7%BD%91%E5%A4%87%E4%BB%BD%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、全网备份项目"><a href="#一、全网备份项目" class="headerlink" title="一、全网备份项目"></a>一、全网备份项目</h1><p>网站数据需要备份</p><p>如何备份？打包压缩+定时任务</p><p>如何收集？rsync备份服务器收集备份数据（客户端推送到服务端）</p><h2 id="1-2-项目流程"><a href="#1-2-项目流程" class="headerlink" title="1.2 项目流程"></a>1.2 项目流程</h2><h3 id="1-2-1-环境准备"><a href="#1-2-1-环境准备" class="headerlink" title="1.2.1 环境准备"></a>1.2.1 环境准备</h3><table><thead><tr><th>角色</th><th>主机</th><th>运行服务</th></tr></thead><tbody><tr><td>存放备份 （41）</td><td>backup</td><td>rsync服务端</td></tr><tr><td>生成备份 （31）</td><td>nfs01</td><td>rsync客户端,其他服务</td></tr><tr><td>生成备份 （7）</td><td>web01</td><td>rsync客户端,其他服务</td></tr><tr><td>…..</td><td></td><td></td></tr></tbody></table><h3 id="1-2-2-项目步骤描述"><a href="#1-2-2-项目步骤描述" class="headerlink" title="1.2.2 项目步骤描述"></a>1.2.2 项目步骤描述</h3><table><thead><tr><th>步骤说明</th><th>详细内容</th></tr></thead><tbody><tr><td>1、rsync服务端并调试 ✅</td><td>服务端配置 &#x2F;backup&#x2F;目录</td></tr><tr><td>2、rsync客户端节点配置脚本(备份) ✅</td><td>1备份 2推送 3清理</td></tr><tr><td>3、其他节点匹配值定时任务 ✅</td><td>定时运行脚本</td></tr><tr><td>4、在备份服务器上检查并发送结果邮件 ✅</td><td>1清理备份 2 在rsync服务端检查备份并发送邮件</td></tr></tbody></table><p>架构流程图如下：</p><p><img src="/../../../img/image-20240427103703477.png" alt="image-20240427103703477"></p><h3 id="1-2-3-服务端配置"><a href="#1-2-3-服务端配置" class="headerlink" title="1.2.3 服务端配置"></a>1.2.3 服务端配置</h3><p>修改服务端的<code>/etc/rsyncd.conf</code>配置文件，添加【backup】</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#created by oldboy 15:01 2009-6-5##rsyncd.conf start##fake super &#x3D;yesuid &#x3D; rsyncgid &#x3D; rsyncuse chroot &#x3D; nomax connections &#x3D; 2000timeout &#x3D; 600pid file &#x3D; &#x2F;var&#x2F;run&#x2F;rsyncd.pidlock file &#x3D; &#x2F;var&#x2F;run&#x2F;rsync.locklog file &#x3D; &#x2F;var&#x2F;log&#x2F;rsyncd.logignore errorsread only &#x3D; falselist &#x3D; false#hosts allow &#x3D; 10.0.0.0&#x2F;24#hosts deny &#x3D; 0.0.0.0&#x2F;32auth users &#x3D; rsync_backupsecrets file &#x3D; &#x2F;etc&#x2F;rsync.password#####################################[data]comment &#x3D; www by old0boy 14:18 2012-1-13path &#x3D; &#x2F;data&#x2F;# 新添加backup[backup]comment &#x3D; backup projectpath &#x3D; &#x2F;backup&#x2F;</code></pre></div></figure><p>创建backup目录和设置用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup01[ ~]#mkdir &#x2F;backup[root@backup01[ ~]#chown rsync.rsync &#x2F;backup</code></pre></div></figure><p>远程调试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 客户端传送[root@nfs01[ ~]#rsync -av &#x2F;etc&#x2F;hosts rsync_backup@10.0.0.41::backup --password-file&#x3D;&#x2F;etc&#x2F;client.rsyncsending incremental file listhostssent 247 bytes  received 43 bytes  580.00 bytes&#x2F;sectotal size is 158  speedup is 0.54# 服务器验证[root@backup01[ ~]#tree -F &#x2F;backup&#x2F;&#x2F;backup&#x2F;└── hosts</code></pre></div></figure><h3 id="1-2-4-客户端备份功能"><a href="#1-2-4-客户端备份功能" class="headerlink" title="1.2.4 客户端备份功能"></a>1.2.4 客户端备份功能</h3><blockquote><p>在nfs01和web01进行配置，定时打包数据文件，并上传到backup服务器</p><p>web01需要安装nfs01的设置，进行前期的rsync客户端设置</p></blockquote><p>添加定时备份脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;server&#x2F;scripts]#cat backup.sh#!&#x2F;bin&#x2F;bash#author: lidao996#desc:备份服务器的配置文件# 1、变量ip&#x3D;&#96;hostname -I | awk &#39;&#123;print $2&#125;&#39;&#96;backup_dir&#x3D;&#x2F;backup&#x2F;$&#123;ip&#125;time&#x3D;&#96;date +%F_%w&#96;backup_file&#x3D;conf-$&#123;time&#125;.tar.gzbackup_server&#x3D;172.16.1.41# 2、备份命令mkdir -p $&#123;backup_dir&#125;# 备份etc文件夹tar zcf $&#123;backup_dir&#125;&#x2F;$&#123;backup_file&#125;    &#x2F;etc&#x2F;   &#x2F;var&#x2F;spool&#x2F;cron# 3、推送rsync -a $&#123;backup_dir&#125; rsync_backup@$&#123;backup_server&#125;::backup --password-file&#x3D;&#x2F;etc&#x2F;client.rsync# 4、删除旧的备份find $&#123;backup_dir&#125; -type f -name &quot;*.tar.gz&quot; -mtime +7 | xargs rm -f</code></pre></div></figure><p>添加执行权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 755 backup.sh</code></pre></div></figure><p>测试执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># web01[root@web01[ &#x2F;server&#x2F;scripts]#sh -x backup.sh++ hostname -I++ awk &#39;&#123;print $2&#125;&#39;+ ip&#x3D;172.16.1.7+ backup_dir&#x3D;&#x2F;backup&#x2F;172.16.1.7++ date +%F_%w+ time&#x3D;2024-04-27_6+ backup_file&#x3D;conf-2024-04-27_6.tar.gz+ backup_server&#x3D;172.16.1.41+ mkdir -p &#x2F;backup&#x2F;172.16.1.7+ tar zcf &#x2F;backup&#x2F;172.16.1.7&#x2F;conf-2024-04-27_6.tar.gz &#x2F;etc&#x2F; &#x2F;var&#x2F;spool&#x2F;crontar: Removing leading &#96;&#x2F;&#39; from member names+ rsync -a &#x2F;backup&#x2F;172.16.1.7 rsync_backup@172.16.1.41::backup --password-file&#x3D;&#x2F;etc&#x2F;client.rsync+ find &#x2F;backup&#x2F;172.16.1.7 -type f -name &#39;*.tar.gz&#39; -mtime +7+ xargs rm -f# nfs01[root@nfs01[ &#x2F;server&#x2F;scripts]#sh -x backup.sh++ hostname -I++ awk &#39;&#123;print $2&#125;&#39;+ ip&#x3D;172.16.1.31+ backup_dir&#x3D;&#x2F;backup&#x2F;172.16.1.31++ date +%F_%w+ time&#x3D;2024-04-27_6+ backup_file&#x3D;conf-2024-04-27_6.tar.gz+ backup_server&#x3D;172.16.1.41+ mkdir -p &#x2F;backup&#x2F;172.16.1.31+ tar zcf &#x2F;backup&#x2F;172.16.1.31&#x2F;conf-2024-04-27_6.tar.gz &#x2F;etc&#x2F; &#x2F;var&#x2F;spool&#x2F;crontar: Removing leading &#96;&#x2F;&#39; from member names+ rsync -a &#x2F;backup&#x2F;172.16.1.31 rsync_backup@172.16.1.41::backup --password-file&#x3D;&#x2F;etc&#x2F;client.rsync+ find &#x2F;backup&#x2F;172.16.1.31 -type f -name &#39;*.tar.gz&#39; -mtime +7+ xargs rm -f# backup01查看[root@backup01[ ~]#tree -F &#x2F;backup&#x2F;&#x2F;backup&#x2F;├── 172.16.1.31&#x2F;│   └── conf-2024-04-27_6.tar.gz└── 172.16.1.7&#x2F;    └── conf-2024-04-27_6.tar.gz</code></pre></div></figure><p>添加定时任务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># crontab -e# 测试，每分钟执行一次* * * * * &#x2F;server&#x2F;scripts&#x2F;backup.sh &amp;&gt;&gt;&#x2F;tmp&#x2F;backup.log# 配置：半夜执行00 00 * * * &#x2F;server&#x2F;scripts&#x2F;backup.sh &amp;&gt;&gt;&#x2F;tmp&#x2F;backup.log</code></pre></div></figure><h3 id="1-2-5-服务端检查和清理"><a href="#1-2-5-服务端检查和清理" class="headerlink" title="1.2.5 服务端检查和清理"></a>1.2.5 服务端检查和清理</h3><p>编写脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup01[ &#x2F;server&#x2F;scripts]#cat &#x2F;server&#x2F;scripts&#x2F;check.sh#!&#x2F;bin&#x2F;bash#desc: 检查备份，清理旧的备份文件# 0. 清理旧备份find &#x2F;backup -type f -name &quot;*.tar.gz&quot; -mtime +180 | xargs rm -f# 1. 统计备份结果find &#x2F;backup&#x2F; -type f -name &quot;*.tar.gz&quot; | xargs \ls -lhd | \awk -F&#39;[ &#x2F;]+&#39; &#39;BEGIN&#123;print &quot;ip地址&quot;, &quot;备份文件名字&quot;, &quot;大小&quot;&#125; &#123;print $(NF-1), $NF, $5&#125;&#39; |\column -t &gt; &#x2F;server&#x2F;scripts&#x2F;result.txt# 2.发送邮件mail -s &quot;每日备份结果&quot; 724262366@qq.com &lt;&#x2F;server&#x2F;scripts&#x2F;result.txt</code></pre></div></figure><p>测试执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup01[ &#x2F;server&#x2F;scripts]#sh -x check.sh+ find &#x2F;backup -type f -name &#39;*.tar.gz&#39; -mtime +180+ xargs rm -f+ awk &#39;-F[ &#x2F;]+&#39; &#39;BEGIN&#123;print &quot;ip地址&quot;, &quot;备份文件名字&quot;, &quot;大小&quot;&#125; &#123;print $(NF-1), $NF, $5&#125;&#39;+ column -t+ find &#x2F;backup&#x2F; -type f -name &#39;*.tar.gz&#39;+ xargs ls -lhd+ mail -s 每日备份结果 724262366@qq.com</code></pre></div></figure><p>查看结果和邮件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup01[ &#x2F;server&#x2F;scripts]#cat result.txtip地址       备份文件名字              大小172.16.1.31  conf-2024-04-27_6.tar.gz  11M172.16.1.7   conf-2024-04-27_6.tar.gz  11M</code></pre></div></figure><p><img src="/../../../img/image-20240427113252350.png" alt="image-20240427113252350"></p><p>设置定时任务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置：半夜执行检查配置情况30 00 * * * &#x2F;server&#x2F;scripts&#x2F;check.sh </code></pre></div></figure><h3 id="1-2-6-增加MD5校验功能"><a href="#1-2-6-增加MD5校验功能" class="headerlink" title="1.2.6 增加MD5校验功能"></a>1.2.6 增加MD5校验功能</h3><p>md5检查多个文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#给&#x2F;etc&#x2F;下面所有的文件创建MD5保存到指定文件中find &#x2F;etc&#x2F; -type f | md5sum &gt;etc-all.md5#进行校验md5sum -c etc-all.md5#修改&#x2F;etc&#x2F;下某个文件比如增加个&quot;#&quot;vim &#x2F;etc&#x2F;rsyncd.conf#进行校验md5sum -c etc-all.md5#只显示md5异常的文件md5sum --quiet -c etc-all.md5</code></pre></div></figure><p>具体应用 — 客户端备份时新增MD5校验文件，并上传</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs01[ &#x2F;server&#x2F;scripts]#cat backup.sh...# 2、备份命mkdir -p $&#123;backup_dir&#125;# 备份etc文件夹tar zcf $&#123;backup_dir&#125;&#x2F;$&#123;backup_file&#125;    &#x2F;etc&#x2F;   &#x2F;var&#x2F;spool&#x2F;cron# 追加校验信息到md5校验文件md5sum $&#123;backup_dir&#125;&#x2F;$&#123;backup_file&#125; &gt;&gt; $&#123;backup_dir&#125;&#x2F;check.md5...</code></pre></div></figure><p>具体应用 — 服务端根据MD5文件进行校验，并输出结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup01[ &#x2F;server&#x2F;scripts]#cat check.sh....# 1. 统计备份结果find &#x2F;backup&#x2F; -type f -name &quot;*.tar.gz&quot; | xargs \ls -lhd | \awk -F&#39;[ &#x2F;]+&#39; &#39;BEGIN&#123;print &quot;ip地址&quot;, &quot;备份文件名字&quot;, &quot;大小&quot;&#125; &#123;print $(NF-1), $NF, $5&#125;&#39; |\column -t &gt; $&#123;result_file&#125;# md5校验find &#x2F;backup&#x2F; -name &quot;check.md5&quot; | xargs md5sum -c &gt;&gt; $&#123;result_file&#125;# 2.发送邮件mail -s &quot;每日备份结果&quot; 724262366@qq.com &lt;&#x2F;server&#x2F;scripts&#x2F;result.txt</code></pre></div></figure><p>检验邮件</p><p><img src="/../../../img/image-20240427120346981.png" alt="image-20240427120346981"></p><h1 id="二、存储服务（NFS）"><a href="#二、存储服务（NFS）" class="headerlink" title="二、存储服务（NFS）"></a>二、存储服务（NFS）</h1><h2 id="2-1-什么是存储？"><a href="#2-1-什么是存储？" class="headerlink" title="2.1 什么是存储？"></a>2.1 什么是存储？</h2><p>存储是用于存放数据的介质，如资源充足，推荐使用共享存储，对比图如下：</p><p><img src="/../../../img/image-20240428085411647.png" alt="image-20240428085411647"></p><p><img src="/../../../img/image-20240428085422997.png" alt="image-20240428085422997"></p><h2 id="2-2-存储分类"><a href="#2-2-存储分类" class="headerlink" title="2.2 存储分类"></a>2.2 存储分类</h2><table><thead><tr><th>分类</th><th>说明</th></tr></thead><tbody><tr><td>硬件存储</td><td>硬件存储,硬盘多,使用的时候挂载即可.</td></tr><tr><td>开源软件</td><td>普通存储NFS 分布式存储:GlusterFS,Ceph,…..FastDFS</td></tr><tr><td>云产品</td><td>阿里云OSS(对象存储),七牛云存储,腾讯云COS</td></tr></tbody></table><h2 id="2-3-NFS介绍"><a href="#2-3-NFS介绍" class="headerlink" title="2.3 NFS介绍"></a>2.3 NFS介绍</h2><p>NFS是(Network File System)的简写，即网络文件系统。使用NFS可以实现在网络上与它人共享目录和文件。</p><p>NFS的工作由两个服务组合完成：</p><ul><li>NFS服务</li><li>rpcbind(portmap)服务</li></ul><p>其工作原理如下图所示：</p><p><img src="/../../../img/image-20240428085902420.png" alt="image-20240428085902420"></p><h2 id="2-4-配置NFS服务"><a href="#2-4-配置NFS服务" class="headerlink" title="2.4 配置NFS服务"></a>2.4 配置NFS服务</h2><p>环境准备</p><table><thead><tr><th>环境</th><th>主机</th><th></th></tr></thead><tbody><tr><td>nfs服务端</td><td>nfs01 10.0.0.31&#x2F;172.16.1.31</td><td></td></tr><tr><td>nfs客户端</td><td>web01 10.0.0.7&#x2F;172.16.1.7</td><td>通过挂载使用</td></tr></tbody></table><p>服务端部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装yum install -y rpcbind nfs-utils#启动rpcbind[root@nfs01[ &#x2F;server&#x2F;scripts]#systemctl enable rpcbind[root@nfs01[ &#x2F;server&#x2F;scripts]#systemctl start rpcbind[root@nfs01[ &#x2F;server&#x2F;scripts]#rpcinfo -p   program vers proto   port  service    100000    4   tcp    111  portmapper    100000    3   tcp    111  portmapper    100000    2   tcp    111  portmapper    100000    4   udp    111  portmapper    100000    3   udp    111  portmapper    100000    2   udp    111  portmapper#启动nfs[root@nfs01[ &#x2F;server&#x2F;scripts]#systemctl enable nfsCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;nfs-server.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nfs-server.service.[root@nfs01[ &#x2F;server&#x2F;scripts]#systemctl start nfs[root@nfs01[ &#x2F;server&#x2F;scripts]#rpcinfo -p   program vers proto   port  service    100000    4   tcp    111  portmapper    100000    3   tcp    111  portmapper    100000    2   tcp    111  portmapper    100000    4   udp    111  portmapper    100000    3   udp    111  portmapper    100000    2   udp    111  portmapper    100024    1   udp  58232  status    100024    1   tcp  52888  status    100005    1   udp  20048  mountd    100005    1   tcp  20048  mountd    100005    2   udp  20048  mountd    100005    2   tcp  20048  mountd    100005    3   udp  20048  mountd    100005    3   tcp  20048  mountd    100003    3   tcp   2049  nfs    100003    4   tcp   2049  nfs    100227    3   tcp   2049  nfs_acl    100003    3   udp   2049  nfs    100003    4   udp   2049  nfs    100227    3   udp   2049  nfs_acl    100021    1   udp  38923  nlockmgr    100021    3   udp  38923  nlockmgr    100021    4   udp  38923  nlockmgr    100021    1   tcp  37397  nlockmgr    100021    3   tcp  37397  nlockmgr    100021    4   tcp  37397  nlockmgr# 配置，允许网段cat &#x2F;etc&#x2F;exports&#x2F;data&#x2F; 172.16.1.0&#x2F;24(rw)systemctl reload nfs# 目录与权限chown nfsnobody.nfsnobody &#x2F;data&#x2F;systemctl reload nfs# 挂载到本地mount -t nfs 172.16.1.31:&#x2F;data&#x2F; &#x2F;mnt&#x2F;# 查看挂载情况[root@nfs01[ &#x2F;mnt]#showmount -eExport list for nfs01:&#x2F;data 172.16.1.0&#x2F;24</code></pre></div></figure><p>客户端挂载</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装yum install -y nfs-utils# 挂载mount -t nfs 172.16.1.31:&#x2F;data &#x2F;mnt</code></pre></div></figure><h2 id="2-5-NFS相关的配置文件"><a href="#2-5-NFS相关的配置文件" class="headerlink" title="2.5 NFS相关的配置文件"></a>2.5 NFS相关的配置文件</h2><table><thead><tr><th>nfs服务端或客户端</th><th></th></tr></thead><tbody><tr><td>NFS服务端配置</td><td>&#x2F;etc&#x2F;exports(配置文件里面的) —&gt; &#x2F;var&#x2F;lib&#x2F;nfs&#x2F;etab(当前使用的nfs服务端配置)</td></tr><tr><td>NFS客户端配置</td><td>客户端:mount &#x2F;etc&#x2F;rc.local 或&#x2F;etc&#x2F;fstab —&gt; &#x2F;proc&#x2F;mounts (当前系统的挂载情况)</td></tr></tbody></table><h3 id="2-5-1-服务端配置"><a href="#2-5-1-服务端配置" class="headerlink" title="2.5.1 服务端配置"></a>2.5.1 服务端配置</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># &#x2F;etc&#x2F;exports 的文件格式共享目录 网段(选项)# NFS配置文件中网络配置172.16.1.0&#x2F;24最常用172.16.1.7指定IPbaidu.com指定域名*所有都可以</code></pre></div></figure><p>核心配置</p><table><thead><tr><th>服务端配置选项</th><th>说明</th></tr></thead><tbody><tr><td>rw</td><td>可以读写共享目录</td></tr><tr><td>ro</td><td>只读 read only</td></tr><tr><td>sync</td><td>同步,只要用户上传,就把数据写到磁盘上.</td></tr><tr><td>async</td><td>异步,用户上传的数据,nfs先临时存放到内存中,过一段时间写入到磁盘. 并发高,数据可能丢失.</td></tr></tbody></table><p>服务端用户压缩</p><ul><li>NFS客户端挂载NFS服务端后,创建的文件默认属于nfsnobody,这种操作就叫用户压缩(映射).<br>用户压缩是通过NFS服务端的配置实现.</li></ul><table><thead><tr><th>服务端配置选项-用户压缩系列</th><th>说明</th></tr></thead><tbody><tr><td>root_squash</td><td>如果客户端是root用户访问,则到了nfs服务端会被压缩( 默认的 )</td></tr><tr><td>no_all_squash</td><td>如果客户端不是root用户访问,则不进行压缩(保存原始用户, 默认的 )</td></tr><tr><td>all_squash</td><td>所有用户都进行压缩(不是太安全)</td></tr><tr><td>anonuid 和 anongid</td><td>用于指定压缩的匿名用户(默认是nfsnobody用户) anonuid&#x3D;65534,anongid&#x3D;65534</td></tr></tbody></table><blockquote><p>用户压缩&#x2F;用户映射: NFS客户端访问NFS共享目录的时候变成了什么用户.<br>nfs客户端用户 nfs服务端用户<br>root —&gt; nfsnoboby  </p></blockquote><p>图示：</p><p><img src="/../../../img/image-20240428104718761.png" alt="image-20240428104718761"></p><h2 id="2-6-永久挂载"><a href="#2-6-永久挂载" class="headerlink" title="2.6 永久挂载"></a>2.6 永久挂载</h2><p>永久挂载的方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 方法01 挂载命令写入到&#x2F;etc&#x2F;rc.localchmod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local# 方法02 按照&#x2F;etc&#x2F;fstab格式要求书写设备 挂载点 文件系统类型 挂载参数 是否检查 是否备份172.16.1.31:&#x2F;data&#x2F; &#x2F;upload&#x2F; nfs defaults 0 0</code></pre></div></figure><blockquote><p>温馨提示:<br>如果配置了nfs客户端永久挂载,未来要优先启动nfs服务端  </p></blockquote><h2 id="2-7-用户压缩的案例"><a href="#2-7-用户压缩的案例" class="headerlink" title="2.7 用户压缩的案例"></a>2.7 用户压缩的案例</h2><p>设置&#x2F;nfsdata共享目录,匿名用户为www. 客户端挂载到&#x2F;upload-video&#x2F;<br>www用户的uid,gid:1999 (服务端,客户端)  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1. 所有主机(nfs服务端和nfs客户端)添加用户 www uid统一1999 1999groupadd -g 1999 wwwuseradd -u 1999 -g www -s &#x2F;sbin&#x2F;nologin -M www#2. nfs服务端配置[root@nfs01[ &#x2F;mnt]#cat &#x2F;etc&#x2F;exports&#x2F;data&#x2F;  172.16.1.0&#x2F;24(rw)&#x2F;nfsdata&#x2F;       172.16.1.0&#x2F;24(rw, all_squash, anonuid&#x3D;1999,anongid&#x3D;1999)# 重新reloadsystemctl reload nfs# 修改共享文件夹的用户chown -R www.www &#x2F;nfsdata#3. nfs客户端挂载[root@web01[ &#x2F;mnt]#mount -t nfs 172.16.1.31:&#x2F;nfsdata &#x2F;upload-video&#x2F;# 4、客户端创建文件[root@web01[ &#x2F;mnt]#touch &#x2F;upload-video&#x2F;test-&#123;1..10&#125;.txt# 5、服务端查看，文件确实上传，且所有者都是www[root@nfs01[ &#x2F;mnt]#ll &#x2F;nfsdata&#x2F;total 0-rw-r--r--. 1 www www 0 Apr 28 11:01 test-10.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-1.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-2.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-3.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-4.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-5.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-6.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-7.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-8.txt-rw-r--r--. 1 www www 0 Apr 28 11:01 test-9.txt</code></pre></div></figure><blockquote><p>以上案例，如果客户端www的用户被删除，效果如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@web01[ &#x2F;mnt]#userdel -r www&gt;userdel: www home directory (&#x2F;home&#x2F;www) not found&gt;# 客户端不显示www用户，显示uid和gid&gt;[root@web01[ &#x2F;upload-video]#ll&gt;total 0&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-10.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-1.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-2.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-3.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-4.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-5.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-6.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-7.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-8.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-9.txt&gt;# 因为是all_squash，不影响上传文件&gt;[root@web01[ &#x2F;upload-video]#&gt;testnowww.txt&gt;[root@web01[ &#x2F;upload-video]#ll&gt;total 0&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-10.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-1.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-2.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-3.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-4.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-5.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-6.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-7.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-8.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:01 test-9.txt&gt;-rw-r--r--. 1 1999 1999 0 Apr 28 11:05 testnowww.txt</code></pre></div></figure></blockquote><h2 id="2-8-NFS优化"><a href="#2-8-NFS优化" class="headerlink" title="2.8 NFS优化"></a>2.8 NFS优化</h2><p>NFS优化: 硬件(物理服务器+nfs服务)<br>NFS安全优化: 客户端挂载 只能上传,无法执行.  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01[ &#x2F;]#mount -o noexec,nosuid,nodev -t nfs 172.16.1.31:&#x2F;nfsdata &#x2F;upload-video&#x2F;#这几个是客户端挂载选项noexec 挂载的nfs目录中如果有命令，无法运行。nosuid 带有suid的命令nodev 带有特殊属性的文件。</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-综合架构规划</title>
    <link href="/2024/04/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/01-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92/"/>
    <url>/2024/04/24/07_85%E6%9C%9F%E8%BF%90%E7%BB%B4/02_%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/01-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="一、新建虚拟机"><a href="#一、新建虚拟机" class="headerlink" title="一、新建虚拟机"></a>一、新建虚拟机</h1><h2 id="1-1-创建虚拟机"><a href="#1-1-创建虚拟机" class="headerlink" title="1.1 创建虚拟机"></a>1.1 创建虚拟机</h2><p>VMWARE</p><p>典型配置</p><p>稍后安装操作系统</p><p>Linux-Centos7 64位</p><p>名称-综合架构模板机-10.0.0.210</p><p>硬盘大小100G</p><p>1处理器 2G内存 网络NAT</p><p>硬件-设置镜像-Centos7-DVD-2009</p><h2 id="1-2-安装操作系统"><a href="#1-2-安装操作系统" class="headerlink" title="1.2 安装操作系统"></a>1.2 安装操作系统</h2><p>语言：English</p><p>磁盘分区：自动分区</p><p>Kdump：关掉</p><p>软件：最小化安装（Debugging Tools + Compatibility Lib + Dev Tools + System Admin tools）</p><p>时区：上海</p><p>网卡：</p><ul><li>General设置Automatically，即是onboot，手动IP：10.0.0.210 &#x2F; 24</li><li>网关10.0.0.2，DNS 223.5.5.5, 223.6.6.6</li><li>记得VMWARE的虚拟网卡编辑器也要更改NAT设置</li></ul><h2 id="1-3-添加网卡"><a href="#1-3-添加网卡" class="headerlink" title="1.3 添加网卡"></a>1.3 添加网卡</h2><p>硬件：添加网卡lan区段(172.16.1.0网段)，模仿局域网</p><p>系统：增加配置文件ifcfg-eth1（<strong>网卡名不尽相同，我的是ens33和ens36</strong>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">NMAE&#x3D;eth1DEVICE&#x3D;eth1IPADDR&#x3D;172.16.1.210PREFIX&#x3D;24ONBOOT&#x3D;yesBOOPROTO&#x3D;static# 局域网不上公网，不需要网关，不配DNS重启网络服务：systemctl restart network</code></pre></div></figure><p>配置完：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@muban2[ &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts]#ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1&#x2F;8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1&#x2F;128 scope host       valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link&#x2F;ether 00:0c:29:55:e9:d6 brd ff:ff:ff:ff:ff:ff    inet 10.0.0.210&#x2F;24 brd 10.0.0.255 scope global noprefixroute ens33       valid_lft forever preferred_lft forever    inet6 fe80::f5ee:4fd4:ee7c:b747&#x2F;64 scope link noprefixroute       valid_lft forever preferred_lft forever3: ens36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link&#x2F;ether 00:0c:29:55:e9:e0 brd ff:ff:ff:ff:ff:ff    inet 172.16.1.210&#x2F;24 brd 172.16.1.255 scope global noprefixroute ens36       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:fe55:e9e0&#x2F;64 scope link       valid_lft forever preferred_lft forever</code></pre></div></figure><h2 id="1-4-优化操作"><a href="#1-4-优化操作" class="headerlink" title="1.4 优化操作"></a>1.4 优化操作</h2><p>关闭防火墙</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#firewalldsystemctl stop firewalldsystemctl disable firewalld#selinuxsed -i &#39;s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disable#g&#39; &#x2F;etc&#x2F;selinux&#x2F;configsetenforce 0getenforce #结果只要不是enforcing就表示关闭了</code></pre></div></figure><p>配置yum源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#备份mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup#修改base源 为阿里云curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo#增加epel源curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo#清除缓存yum clean all#查看yum源yum repolist</code></pre></div></figure><p>安装常用工具</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y vim tree wget bash-completion bashcompletion-extras lrzsz net-tools sysstat iotop iftop htop unzip nc nmap telnet bc psmisc httpd-tools bindutils nethogs expect cowsay sl</code></pre></div></figure><p>优化ssh连接速度</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i &#39;&#x2F;^GSSAPIAuthentication&#x2F;s@^@#@g&#39; &#x2F;etc&#x2F;ssh&#x2F;sshd_configcat &gt;&gt;&#x2F;etc&#x2F;ssh&#x2F;sshd_config&lt;&lt;EOFUseDNS no #相当于网络命令的-n选项.GSSAPIAuthentication no #关闭GSS认证.EOFsystemctl restart sshd#检查egrep &#39;^(GSSAPIAuthentication|UseDNS)&#39; &#x2F;etc&#x2F;ssh&#x2F;sshd_config</code></pre></div></figure><p>时间同步</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#修改时区(如果不对)timedatectl status #查看时区 time zone部分timedatectl set-timezone Asia&#x2F;Shanghai #如果时区不对再修改.#配置定时时间同步.yum install -y ntpdatecrontab -l#1. sync time (crontab -e 编辑)*&#x2F;2 * * * * &#x2F;sbin&#x2F;ntpdate ntp1.aliyun.com &amp;&gt;&#x2F;dev&#x2F;null# 重启服务systemctl restart crond</code></pre></div></figure><p>命令行颜色</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">把下面内容PS1是系统环境变量之一,用于控制命令行格式样子.export PS1&#x3D;&#39;[\[\e[34;1m\]\u@\[\e[0m\]\[\e[32;1m\]\H\[\e[0m\]\[\e[31;1m\] \w\[\e[0m\]]\$&#39;写入到&#x2F;etc&#x2F;profile中即可. #如果只想对自己生效修改~&#x2F;.bash_profile 或~&#x2F;.bashrcsource &#x2F;etc&#x2F;profile</code></pre></div></figure><p>修改的效果：</p><p><img src="/../../../img/image-20240424154436310.png" alt="image-20240424154436310"></p><p>主机名与host文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用hostnamectl修改hostnamectl set-hostname muban </code></pre></div></figure><p>hosts解析，方便使用主机名访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># hosts文件案例cat &gt;&gt;&#x2F;etc&#x2F;hosts &lt;&lt;EOF172.16.1.5 lb01172.16.1.6 lb02172.16.1.7 web01172.16.1.8 web02172.16.1.9 web03172.16.1.10 web04172.16.1.31 nfs01172.16.1.41 backup172.16.1.51 db01172.16.1.61 m01EOF</code></pre></div></figure><p>一键修改主机名和ip地址的脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># &#x2F;server&#x2F;scripts&#x2F;change.sh#!&#x2F;bin&#x2F;bash#author: lidao996#desc: change ip and hostname#version: v7.0#升级一些判断#判断参数格式是否为2[ $# -ne 2 ] &amp;&amp; &#123;echo &quot;脚本使用姿势不对&quot;echo &quot;正确姿势:$0 主机名 ip地址&quot;echo &quot;如:$0 muban 211&quot;        exit 1&#125;#获取当前主机ip地址ip&#x3D;&#96;hostname -I |awk &#39;&#123;print $1&#125;&#39;|sed &#39;s#.*\.##g&#39;&#96;#新的ipip_new&#x3D;&#96;echo $2 |sed &#39;s#^.*\.##g&#39;&#96;#新的主机名hostname&#x3D;$1#修改ipsed -i &quot;s#10.0.0.$ip#10.0.0.$ip_new#g&quot; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33sed -i &quot;s#172.16.1.$ip#172.16.1.$ip_new#g&quot; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens36#重启网卡systemctl restart network#修改主机名hostnamectl set-hostname $hostname</code></pre></div></figure><h2 id="1-5-克隆"><a href="#1-5-克隆" class="headerlink" title="1.5 克隆"></a>1.5 克隆</h2><p>创建克隆（链接方式）：backup服务器-10.0.0.41</p><h1 id="二、综合架构详解"><a href="#二、综合架构详解" class="headerlink" title="二、综合架构详解"></a>二、综合架构详解</h1><p>我们分别通过开发,用户,运维角度分析网站架构  </p><table><thead><tr><th>角度</th><th>说明</th><th>相关操作</th></tr></thead><tbody><tr><td>开发角度</td><td>主要关注的书写代码,这些代码需要服务器 (服务)运行.</td><td>代码存放,开发如何提交运维,运维如何部署代码,如何测试代码 (环境),第3个阶段内容.</td></tr><tr><td>用户角 度</td><td>app或浏览器访问网站,整个访问流程中涉及 到的服务,功能.</td><td>整个网站架构的核心,第2个阶段内容.</td></tr><tr><td>运维角度</td><td>如何快速部署环境,自动化部署,自动化监控, 堡垒机,其他Վʡ</td><td>如何自动化维护,监控,故障修复.第2个阶段,第3个阶段.</td></tr></tbody></table><h2 id="2-1-架构图"><a href="#2-1-架构图" class="headerlink" title="2.1 架构图"></a>2.1 架构图</h2><p><img src="/../../../img/image-20240424162115805.png" alt="image-20240424162115805"></p><h2 id="2-2-技术栈"><a href="#2-2-技术栈" class="headerlink" title="2.2 技术栈"></a>2.2 技术栈</h2><table><thead><tr><th align="left">角度</th><th align="left">功能</th><th align="left">服务</th></tr></thead><tbody><tr><td align="left">开发角度</td><td align="left">存放代码</td><td align="left"><strong>Gitlab</strong> ,Gogs,Github,Gitee(码云)</td></tr><tr><td align="left"></td><td align="left">集成，发布</td><td align="left"><strong>Jenkins</strong></td></tr><tr><td align="left"></td><td align="left">代码检查</td><td align="left"><strong>Sonarqube</strong></td></tr><tr><td align="left"></td><td align="left">私服,软件包仓 库(Java)</td><td align="left"><strong>Nexus</strong></td></tr><tr><td align="left">用户角度</td><td align="left">DNS解析</td><td align="left">DNS云解析(阿里) ,Bind9,DNSmasq,CoreDNSՎʡ</td></tr><tr><td align="left"></td><td align="left">CDN缓存</td><td align="left">各种厂商的CDN服务, <strong>CDN(阿里云)</strong> ,蓝汛(专做CDN)…..,七牛CDN</td></tr><tr><td align="left"></td><td align="left">防火墙</td><td align="left">硬件防火墙:深信服,奇安信,华为  软件:firewalld, <strong>iptables ,公有云: 安全组,态势感知,云安全中心</strong></td></tr><tr><td align="left"></td><td align="left">负载均衡</td><td align="left">硬件: F5…   软件: nginx,tengine ,openResty,haproxy, lvs 公有云:….</td></tr><tr><td align="left"></td><td align="left">WEB网站服务 器</td><td align="left">基本:nginx,tengine,openResty <strong>架构 :</strong> LNMP(PHP) Linux,Nginx,MySQL(数据库),PHP LNMT(Java) Linux,Nginx,MySQL,Tomcat LNMP(Python) Linux,Nginx,MySQL,Python LNMG(Golang) Linux,Nginx,MySQL,Golang</td></tr><tr><td align="left"></td><td align="left">缓存服务器</td><td align="left"><strong>Redis,Kafka</strong> ,xxxMQ(RabbitMQ),RocketMQ</td></tr><tr><td align="left"></td><td align="left">数据库服务器</td><td align="left"><strong>MySQL</strong> ,Oracle(甲骨文), <strong>Mariadb</strong> 国产:TiDB,openGauss,OceanBase</td></tr><tr><td align="left"></td><td align="left">存储</td><td align="left">硬件存储 软件存储: NFS ,分布式存储…. 对象存储: <strong>阿里云OSS</strong> ,七牛云对象存储,腾讯COS</td></tr><tr><td align="left"></td><td align="left">实时同步</td><td align="left"><strong>SerSync</strong> ,Lsyncd</td></tr><tr><td align="left"></td><td align="left">备份</td><td align="left"><strong>定时任务,脚本,打包压缩 Rsync</strong></td></tr><tr><td align="left">运维角度</td><td align="left">VPN</td><td align="left">硬件,开源 <strong>OpenVPN</strong></td></tr><tr><td align="left"></td><td align="left">堡垒机</td><td align="left">开源: <strong>Teleprot,Jumpserve</strong>r 商业:硬件,软件.</td></tr><tr><td align="left"></td><td align="left">批量管理</td><td align="left"><strong>Ansible</strong> ,SaltStack,Puppet,Chef,Farbic</td></tr><tr><td align="left"></td><td align="left">监控</td><td align="left"><strong>Zabbix,Grafana,Prometheus (普罗米修斯)</strong></td></tr><tr><td align="left"></td><td align="left">日志收集平台</td><td align="left"><strong>Elastic Stack(ELK,EFK,EBLK, ElasticSearch,Filebeat,Logstash,Kibana)</strong></td></tr><tr><td align="left"></td><td align="left">审计</td><td align="left">SQL审计, <strong>Yearning</strong> ,Archery 操作&#x2F;行为审计(堡垒机)</td></tr><tr><td align="left"></td><td align="left">安全</td><td align="left">商业:AppScan, <strong>Nessus</strong> ,OWASP 开源: <strong>ClamAV</strong> ……</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day08</title>
    <link href="/2024/03/20/04_C++/01_C%E8%AF%AD%E8%A8%80/day08/"/>
    <url>/2024/03/20/04_C++/01_C%E8%AF%AD%E8%A8%80/day08/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day08”</p><h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><p>常用数据结构分为链表、栈、队列、哈希表、红黑树等</p><h2 id="1-1-链表"><a href="#1-1-链表" class="headerlink" title="1.1 链表"></a>1.1 链表</h2><h3 id="1-1-1-单链表的基本操作"><a href="#1-1-1-单链表的基本操作" class="headerlink" title="1.1.1 单链表的基本操作"></a>1.1.1 单链表的基本操作</h3><p>初始化链表：</p><ul><li>创建链表：create_list</li></ul><p>增加节点：</p><ul><li>头插法：add_before_head</li><li>尾插法：add_behind_tail</li><li>根据索引插入：add_node</li></ul><p>删除节点：</p><ul><li>根据索引删除：remove_node</li><li>销毁链表：destroy_list</li></ul><p>查询节点：</p><ul><li>根据数值查询：indexOf</li></ul><p><strong><font color=blue>实现单链表的基本操作</font></strong></p><p>头文件：linklist.h</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdbool.h&gt;&#x2F;&#x2F; 链表的接口typedef struct node_s &#123;int val;struct node_s* next;&#125; Node;typedef struct linkedlist_s &#123;Node* head;Node* tail;int size;&#125; LinkedList;&#x2F;&#x2F; 构造方法: 创建一个空链表LinkedList* create_list();&#x2F;&#x2F; 析构方法：释放堆堆存空间void destroy_list(LinkedList* list);void add_before_head(LinkedList* list, int val);void add_behind_tail(LinkedList* list, int val);void add_node(LinkedList* list, int index, int val);&#x2F;&#x2F; 删除第一个与val相等的结点, 如果没有这样的结点返回falsebool remove_node(LinkedList* list, int val);&#x2F;&#x2F; 找出第一个与val相等结点的索引，如果没有这样的结点, 返回-1int indexOf(LinkedList* list, int val);&#x2F;&#x2F; 打印void print_list(LinkedList* list);</code></pre></div></figure><p>实现：linklist.c</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 链表的实现#include &quot;linklist.h&quot;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;&#x2F;&#x2F; 创建空链表LinkedList* create_list() &#123;return (LinkedList*)calloc(1, sizeof(LinkedList));&#125;&#x2F;&#x2F; 头插法void add_before_head(LinkedList* list, int val) &#123;&#x2F;&#x2F; 创建新结点Node* newNode &#x3D; (Node*)malloc(sizeof(Node));if (newNode &#x3D;&#x3D; NULL) &#123;printf(&quot;Error: malloc failed in add_before_head.\n&quot;);exit(1);&#125;&#x2F;&#x2F; 初始化结点newNode-&gt;val &#x3D; val;newNode-&gt;next &#x3D; list-&gt;head;list-&gt;head &#x3D; newNode;&#x2F;&#x2F; 判断链表是否为空if (list-&gt;tail &#x3D;&#x3D; NULL) &#123;list-&gt;tail &#x3D; newNode;&#125;&#x2F;&#x2F; 更新sizelist-&gt;size++;&#125;&#x2F;&#x2F; 尾插法void add_behind_tail(LinkedList* list, int val) &#123;&#x2F;&#x2F; 创建新结点Node* newNode &#x3D; (Node*)malloc(sizeof(Node));if (newNode &#x3D;&#x3D; NULL) &#123;printf(&quot;Error: malloc failed in add_before_head.\n&quot;);exit(1);&#125;&#x2F;&#x2F; 初始化结点newNode-&gt;val &#x3D; val;newNode-&gt;next &#x3D; NULL;&#x2F;&#x2F; 判断链表是否为空if (list-&gt;size &#x3D;&#x3D; 0) &#123;list-&gt;head &#x3D; newNode;list-&gt;tail &#x3D; newNode;&#125;else &#123;&#x2F;&#x2F; 链接新结点list-&gt;tail-&gt;next &#x3D; newNode;&#x2F;&#x2F; 更新list-&gt;taillist-&gt;tail &#x3D; newNode;&#125;list-&gt;size++;&#125;void add_node(LinkedList* list, int index, int val) &#123;if (index &lt; 0 || index &gt; list-&gt;size) &#123;printf(&quot;Error: Illegal index.\n&quot;);exit(1);&#125;&#x2F;&#x2F; 创建新结点Node* newNode &#x3D; (Node*)malloc(sizeof(Node));if (newNode &#x3D;&#x3D; NULL) &#123;printf(&quot;Error: malloc failed in add_before_head.\n&quot;);exit(1);&#125;newNode-&gt;val &#x3D; val;if (index &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 头插法的逻辑newNode-&gt;next &#x3D; list-&gt;head;list-&gt;head &#x3D; newNode;&#125;else &#123;&#x2F;&#x2F; 找到索引为 indx-1 的结点Node* p &#x3D; list-&gt;head;for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;p &#x3D; p-&gt;next;&#125;newNode-&gt;next &#x3D; p-&gt;next;p-&gt;next &#x3D; newNode;&#125;&#x2F;&#x2F; 更新尾结点if (index &#x3D;&#x3D; list-&gt;size) &#123;list-&gt;tail &#x3D; newNode;&#125;list-&gt;size++;&#125;&#x2F;&#x2F; 删除第一个与val相等的结点, 如果没有这样的结点返回falsebool remove_node(LinkedList* list, int val) &#123;Node* prev &#x3D; NULL;Node* curr &#x3D; list-&gt;head;&#x2F;&#x2F; 寻找前驱结点while (curr !&#x3D; NULL &amp;&amp; curr-&gt;val !&#x3D; val) &#123; &#x2F;&#x2F; 短路原则prev &#x3D; curr;curr &#x3D; curr-&gt;next;&#125;&#x2F;&#x2F; 没有这样的元素if (curr &#x3D;&#x3D; NULL) return false;&#x2F;&#x2F; 删除第一个元素if (prev &#x3D;&#x3D; NULL) &#123;if (list-&gt;size &#x3D;&#x3D; 1) &#123;list-&gt;head &#x3D; list-&gt;tail &#x3D; NULL;&#125;else &#123;list-&gt;head &#x3D; curr-&gt;next;&#125;free(curr);&#125;else &#123;prev-&gt;next &#x3D; curr-&gt;next;if (prev-&gt;next &#x3D;&#x3D; NULL) &#123;list-&gt;tail &#x3D; prev;&#125;free(curr);&#125;list-&gt;size--;return true;&#125;&#x2F;&#x2F; 找出第一个与val相等结点的索引，如果没有这样的结点, 返回-1int indexOf(LinkedList* list, int val) &#123;Node* curr &#x3D; list-&gt;head;for (int i &#x3D; 0; i &lt; list-&gt;size; i++, curr &#x3D; curr-&gt;next) &#123;if (curr-&gt;val &#x3D;&#x3D; val) &#123;return i;&#125;&#125;&#x2F;&#x2F; 没有找到return -1;&#125;void destroy_list(LinkedList* list) &#123;&#x2F;&#x2F; 释放结点空间Node* curr &#x3D; list-&gt;head;while (curr !&#x3D; NULL) &#123;&#x2F;&#x2F; 保存curr后继结点Node* next &#x3D; curr-&gt;next;free(curr);curr &#x3D; next;&#125;&#x2F;&#x2F; 释放LinkedList结构体free(list);&#125;void print_list(LinkedList *list) &#123;if (list &#x3D;&#x3D; NULL) &#123;return;&#125;Node* curr &#x3D; list-&gt;head;printf(&quot;Head: %d\nTail: %d\nSize: %d\n&quot;, list-&gt;head-&gt;val, list-&gt;tail-&gt;val, list-&gt;size);while (curr !&#x3D; NULL) &#123;printf(&quot;%d &quot;, curr-&gt;val);curr &#x3D; curr-&gt;next;&#125;printf(&quot;\n------------------\n&quot;);&#125;</code></pre></div></figure><p>测试：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &quot;linklist.h&quot;&#x2F;&#x2F; 测试int main(void) &#123;&#x2F;&#x2F; 创建链表LinkedList* list &#x3D; create_list();&#x2F;&#x2F; 位置插入add_node(list, 0, 55);&#x2F;&#x2F; 55print_list(list);&#x2F;&#x2F; 头插add_before_head(list, 11);&#x2F;&#x2F; 11 55add_before_head(list, 22);&#x2F;&#x2F; 22 11 55print_list(list);&#x2F;&#x2F; 尾插add_behind_tail(list, 33);&#x2F;&#x2F; 22 11 55 33add_behind_tail(list, 44);&#x2F;&#x2F; 22 11 55 33 44print_list(list);&#x2F;&#x2F; 位置插入add_node(list, 2, 66);&#x2F;&#x2F; 22 11 66 55 33 44print_list(list);add_node(list, 5, 77);&#x2F;&#x2F; 22 11 66 55 33 77 44print_list(list);add_behind_tail(list, 88);&#x2F;&#x2F; 22 11 66 55 33 77 44 88print_list(list);&#x2F;&#x2F; 按值，删除结点remove_node(list, 44);print_list(list);&#x2F;&#x2F; 22 11 66 55 33 77 88remove_node(list, 22);print_list(list);&#x2F;&#x2F; 11 66 55 33 77 88remove_node(list, 33);print_list(list);&#x2F;&#x2F; 11 66 55 77 88remove_node(list, 44);print_list(list);&#x2F;&#x2F; 11 66 55 77 88&#x2F;&#x2F; 查找结点printf(&quot;Index &#x3D; %d\n&quot;, indexOf(list, 66));&#x2F;&#x2F; 1printf(&quot;Index &#x3D; %d\n&quot;, indexOf(list, 11));&#x2F;&#x2F; 0printf(&quot;Index &#x3D; %d\n&quot;, indexOf(list, 44));&#x2F;&#x2F; -1printf(&quot;Index &#x3D; %d\n&quot;, indexOf(list, 55));&#x2F;&#x2F; 2&#x2F;&#x2F; 销毁链表destroy_list(list);printf(&quot;Index &#x3D; %d\n&quot;, indexOf(list, 55));&#x2F;&#x2F; -1return 0;&#125;</code></pre></div></figure><h3 id="1-1-3-双向和单向链表的对比"><a href="#1-1-3-双向和单向链表的对比" class="headerlink" title="1.1.3 双向和单向链表的对比"></a>1.1.3 双向和单向链表的对比</h3><p>时间复杂度对比</p><table><thead><tr><th>对比项</th><th>单向链表</th><th>双向链表</th><th>备注</th></tr></thead><tbody><tr><td>增加结点（在某个结点前面添加）</td><td>O(n)</td><td>O(1)</td><td></td></tr><tr><td>删除结点（</td><td>O(n)</td><td>O(1)</td><td></td></tr><tr><td>查找：前驱结点</td><td>O(n)</td><td>O(1)</td><td></td></tr><tr><td>查找：根据index</td><td>O(n)</td><td>O(n)</td><td>单向链表只能单向遍历，双向链表可以逆向，双向更快</td></tr><tr><td>查找：根据value（大小有序）</td><td>O(n)</td><td>O(n)</td><td></td></tr><tr><td>查找：根据value（大小无序）</td><td>O(n)</td><td>O(n)</td><td></td></tr></tbody></table><h2 id="1-2-链表作业"><a href="#1-2-链表作业" class="headerlink" title="1.2 链表作业"></a>1.2 链表作业</h2><h3 id="1-2-1-求单链表的中间元素"><a href="#1-2-1-求单链表的中间元素" class="headerlink" title="1.2.1 求单链表的中间元素"></a>1.2.1 求单链表的中间元素</h3><p>需求：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int middleElement(Node* list);输入: 1 --&gt; 2 --&gt; 3输出: 2输入: 1 --&gt; 2 --&gt; 3 --&gt; 4输出: 3</code></pre></div></figure><p>实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int middleElement(Node* list) &#123;if (list &#x3D;&#x3D; NULL) &#123;return -1;&#125;Node* slow &#x3D; list;Node* fast &#x3D; list;while (fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL) &#123;slow &#x3D; slow-&gt;next;fast &#x3D; fast-&gt;next-&gt;next;&#125;return slow-&gt;val;&#125;</code></pre></div></figure><h3 id="1-2-2-判断单链表是否有环"><a href="#1-2-2-判断单链表是否有环" class="headerlink" title="1.2.2 判断单链表是否有环"></a>1.2.2 判断单链表是否有环</h3><p>何为有环？</p><p><img src="D:/C++/gsproj.github.io/source/img/image-20240417093524017.png" alt="image-20240417093524017"></p><p>思路：</p><ul><li>使用双指针</li></ul><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool hasCycle(Node* list) &#123;if (list &#x3D;&#x3D; NULL) &#123;return false;&#125;Node* slow &#x3D; list;Node* fast &#x3D; list;do &#123;&#x2F;&#x2F; 如果fast达到了链表末尾if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) &#123;return false;&#125;&#x2F;&#x2F; 快慢指针，慢指针每次一步，快指针每次两步fast &#x3D; fast-&gt;next-&gt;next;slow &#x3D; slow-&gt;next;&#125; while (slow !&#x3D; fast);&#x2F;&#x2F; 如循环结束: fast &#x3D;&#x3D; slow, 说明链表有环return true;&#125;</code></pre></div></figure><h3 id="1-2-3-反转单链表"><a href="#1-2-3-反转单链表" class="headerlink" title="1.2.3 反转单链表"></a>1.2.3 反转单链表</h3><p>需求：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">Node* reverse(Node* list);输入: 1 --&gt; 2 --&gt; 3输出: 3 --&gt; 2 --&gt; 1</code></pre></div></figure><p>思路：</p><ul><li>头插法</li><li>双指针(prev, curr)</li></ul><p>实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">Node* reverse(Node* list) &#123;Node* prev &#x3D; NULL;Node* curr &#x3D; list;while (curr !&#x3D; NULL) &#123;&#x2F;&#x2F; 保留当前节点的下一个节点Node* next &#x3D; curr-&gt;next;        &#x2F;&#x2F; 反转当前节点curr-&gt;next &#x3D; prev;        &#x2F;&#x2F; 后移prev &#x3D; curr;curr &#x3D; next;&#125;&#x2F;&#x2F; 循环结束后，curr&#x3D;&#x3D;NULL，prev成为反转后的第一个结点return prev;&#125;</code></pre></div></figure><p>测试：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">print_list(list);Node *reNode &#x3D; reverse(list-&gt;head);while (reNode !&#x3D; NULL) &#123;    printf(&quot;%d &quot;, reNode-&gt;val);    reNode &#x3D; reNode-&gt;next;&#125;printf(&quot;\n&quot;);输出：Head: 33Tail: 55Size: 433 22 11 55------------------55 11 22 33</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day09</title>
    <link href="/2024/03/20/04_C++/01_C%E8%AF%AD%E8%A8%80/day09/"/>
    <url>/2024/03/20/04_C++/01_C%E8%AF%AD%E8%A8%80/day09/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day09”</p><h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><p>常用数据结构分为链表、栈、队列、哈希表、红黑树等</p><h2 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h2><p>栈是一种先进先出（FIFO）的数据结构，它是一种受限的线性表，只能在栈顶添加和删除元素，图示如下：</p><p><img src="D:/C++/gsproj.github.io/source/img/image-20240417155227522.png" alt="image-20240417155227522"></p><h3 id="1-2-1-栈的作用"><a href="#1-2-1-栈的作用" class="headerlink" title="1.2.1 栈的作用"></a>1.2.1 栈的作用</h3><p>1、函数调用</p><p>2、深度优先遍历</p><p>3、浏览器访问页面的前进和后退</p><p>4、括号匹配问题（※※※）</p><p>5、后缀表达式求值</p><ul><li>前缀表达式：1 + 2 * 3</li><li>后缀表达式：1 2 3 * +</li></ul><h3 id="1-2-2-栈基本操作："><a href="#1-2-2-栈基本操作：" class="headerlink" title="1.2.2 栈基本操作："></a>1.2.2 栈基本操作：</h3><ul><li>入栈（push）</li><li>出栈（pop）</li><li>是否为空（isEmpty）</li><li>查（peek）</li></ul><h3 id="1-2-3-实现栈的基本操作"><a href="#1-2-3-实现栈的基本操作" class="headerlink" title="1.2.3 实现栈的基本操作"></a>1.2.3 实现栈的基本操作</h3><p>栈可以用数组或者链表来实现</p><h4 id="1-2-3-1-用链表实现"><a href="#1-2-3-1-用链表实现" class="headerlink" title="1.2.3.1 用链表实现"></a>1.2.3.1 用链表实现</h4><p>mystack.h</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F; 定义结点结构typedef struct node_s &#123;int val;struct node_s* next;&#125;Node;&#x2F;&#x2F; 方法一：入栈void push(Node** ptr_top, int val);&#x2F;&#x2F; 方法二：判断是否为空bool isEmpty(Node** ptr_top);&#x2F;&#x2F; 方法三：出栈int pop(Node** ptr_top);&#x2F;&#x2F; 方法四：查找int peek(Node* top);</code></pre></div></figure><p>mystack.c</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;stack.h&quot;&#x2F;&#x2F; 方法一：入栈void push(Node** ptr_top, int val) &#123;&#x2F;&#x2F; 创建结点，分配空间Node* newnode &#x3D; (Node*)malloc(sizeof(Node));&#x2F;&#x2F; 容错判断if (newnode &#x3D;&#x3D; NULL) &#123;printf(&quot;Error! malloc failed in push.&quot;);exit(1);&#125;&#x2F;&#x2F; 给新结点赋值newnode-&gt;val &#x3D; val;&#x2F;&#x2F; 追加节点newnode-&gt;next &#x3D; *ptr_top;*(ptr_top) &#x3D; newnode;&#125;&#x2F;&#x2F; 方法二：判断是否为空bool isEmpty(Node* ptr_top) &#123;return ptr_top &#x3D;&#x3D; NULL;&#125;&#x2F;&#x2F; 方法三：出栈int pop(Node** ptr_top) &#123;&#x2F;&#x2F; 容错判断if (isEmpty(*ptr_top)) &#123;printf(&quot;Error! stack is empty!&quot;);exit(1);&#125;&#x2F;&#x2F; 保留弹出结点Node* old_top &#x3D; *ptr_top;int result &#x3D; old_top-&gt;val;&#x2F;&#x2F; 设置新的栈顶*ptr_top &#x3D; (*ptr_top)-&gt;next;&#x2F;&#x2F; 释放旧结点free(old_top);&#x2F;&#x2F; 返回值return result;&#125;&#x2F;&#x2F; 方法四：查找int peek(Node* top) &#123;if (isEmpty(top)) &#123;printf(&quot;Error! stack is empty!&quot;);exit(1);&#125;&#x2F;&#x2F; 返回查找的值return top-&gt;val;&#125;</code></pre></div></figure><p>main.c测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;stack.h&quot;#include &lt;stdio.h&gt;int main() &#123;Node* top &#x3D; NULL;push(&amp;top, 1);push(&amp;top, 2);push(&amp;top, 3);push(&amp;top, 4);printf(&quot;%d\n&quot;, peek(top));&#x2F;&#x2F; 输出4&#x2F;&#x2F; 出栈printf(&quot;%d\n&quot;, pop(&amp;top));&#x2F;&#x2F;4printf(&quot;%d\n&quot;, pop(&amp;top));&#x2F;&#x2F; 3&#x2F;&#x2F; 查找printf(&quot;%d\n&quot;, peek(top));&#x2F;&#x2F; 输出2&#x2F;&#x2F; 查空while (!isEmpty(top)) &#123;printf(&quot;%d\n&quot;, pop(&amp;top));&#x2F;&#x2F; 输出：2，1，停止&#125;return 0;&#125;</code></pre></div></figure><h2 id="1-3-队列"><a href="#1-3-队列" class="headerlink" title="1.3 队列"></a>1.3 队列</h2><p>队列也是一种受限的线性表</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day07</title>
    <link href="/2024/03/18/04_C++/01_C%E8%AF%AD%E8%A8%80/day07/"/>
    <url>/2024/03/18/04_C++/01_C%E8%AF%AD%E8%A8%80/day07/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day07”</p><h1 id="一、命令行参数"><a href="#一、命令行参数" class="headerlink" title="一、命令行参数"></a>一、命令行参数</h1><p>给程序传递参数，以main函数为例子</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;&#x2F;&#x2F; 输出参数的个数printf(&quot;argc &#x3D; %d\n&quot;, argc);&#x2F;&#x2F; 输出每个参数printf(&quot;argv &#x3D; &quot;);for (int i &#x3D; 0; i &lt; argc; i++) &#123;printf(&quot;%s &quot;, argv[i]);&#125;printf(&quot;\n&quot;);return 0;&#125;</code></pre></div></figure><p>以上代码的执行结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">argc &#x3D; 1argv &#x3D; D:\C++\C++学习代码\01-C语言\Day07\x64\Debug\01_命令行参数.exe</code></pre></div></figure><p><strong>默认调用1个参数，即程序本身</strong>，因此默认argc的个数为1，argv为程序本身</p><blockquote><p><strong>注意事项：</strong></p><p>如何在VS中给程序加参数？</p><p><strong>【项目】–【属性】–【调试】–【命令参数】</strong></p><p><img src="/../../../img/image-20240318143111524.png" alt="image-20240318143111524"></p><p>设置之后的运行结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;argc &#x3D; 4&gt;argv &#x3D; D:\C++\C++学习代码\01-C语言\Day07\x64\Debug\01_命令行参数.exe arg1 arg2 arg3</code></pre></div></figure></blockquote><h1 id="二、结构体（※※※）"><a href="#二、结构体（※※※）" class="headerlink" title="二、结构体（※※※）"></a>二、结构体（※※※）</h1><p>C语言的结构体，相当于其它高级语言中的类，但是C语言只能在结构体中定义数据，不能定义方法。</p><p>如表示一个学生：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct student &#123;    int number;&#x2F;&#x2F; 学号    char name[25];&#x2F;&#x2F; 姓名    bool gender;&#x2F;&#x2F; 性别    int chinese;&#x2F;&#x2F; 语文    int math;&#x2F;&#x2F; 数学    int english;&#x2F;&#x2F; 英语&#125;</code></pre></div></figure><p>使用结构体创建对象：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 创建对象struct student stu1 &#x3D; &#123; 1, &quot;大圣&quot;, true, 89, 22, 67 &#125;;</code></pre></div></figure><h2 id="2-1-结构体的内存布局"><a href="#2-1-结构体的内存布局" class="headerlink" title="2.1 结构体的内存布局"></a>2.1 结构体的内存布局</h2><p>以上面的学生数据结构为例，它在内存中的存储布局如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">numbernamegender[...]chinesemathenglish42512444</code></pre></div></figure><p>为何占用44字节空间，而不是42字节？</p><ul><li>多出来的<code>[...]</code>是填充的<code>padding</code>，用于对齐 —- 方便早期CPU寻址</li><li>因为number + name + gender &#x3D; 30，而后面的chinese是4，为方便对齐，前面需要是4的倍数，因此+2</li></ul><h2 id="2-2-结构体对象的初始化"><a href="#2-2-结构体对象的初始化" class="headerlink" title="2.2 结构体对象的初始化"></a>2.2 结构体对象的初始化</h2><p>结构体的初始化方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 1、一次性给所有属性赋值struct student stu1 &#x3D; &#123; 1, &quot;大圣&quot;, true, 89, 22, 67 &#125;;&#x2F;&#x2F; 2、缺省初始化，省略的值自动赋值为0struct student stu2 &#x3D; &#123; 1, &quot;大圣&quot;, true &#125;;&#x2F;&#x2F; 3、按属性赋值stu2.gender &#x3D; 30;</code></pre></div></figure><p>对结构体的操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 1、获取成员stu2.name    &#x2F;&#x2F; 结构体赋值stu3 &#x3D; stu1;&#x2F;&#x2F; 打印结构体的数据（值传递）void printStu(struct student s) &#123;    printf(&quot;name &#x3D; %s\n&quot;, s.name);&#125;</code></pre></div></figure><blockquote><p><strong>注意事项：</strong></p><ul><li><p>当结构体作为参数或返回值时，会拷贝整个结构体的数据（值传递）</p></li><li><p>函数内的修改，不影响实参</p></li><li><p>为了避免拷贝数据，一般会传指针</p></li><li><p>指针传递时，<code>.</code>符号将变为<code>-&gt;</code>符号，<code>s-&gt;name</code>相当于<code>(*s).name</code>的简写</p></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;void printStu(struct student *s) &#123;   printf(&quot;name &#x3D; %s\n&quot;, s-&gt;name);&gt;&#125;</code></pre></div></figure></blockquote><h2 id="2-3-结构体取别名"><a href="#2-3-结构体取别名" class="headerlink" title="2.3 结构体取别名"></a>2.3 结构体取别名</h2><p>如2.1中定义的结构体，当我们使用它时，每次都需要在前面加上<code>struct</code>标识，比较麻烦：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct student stu3 &#x3D; .....</code></pre></div></figure><p>这时候，我们可以用<code>typedef</code>给该结构体取个别名，使用起来会方便一些</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 使用typedef取别名typedef struct student &#123;    int number;&#x2F;&#x2F; 学号    char name[25];&#x2F;&#x2F; 姓名    bool gender;&#x2F;&#x2F; 性别    int chinese;&#x2F;&#x2F; 语文    int math;&#x2F;&#x2F; 数学    int english;&#x2F;&#x2F; 英语&#125; STU;</code></pre></div></figure><p>再使用结构体：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 创建对象STU stu4 &#x3D; &#123;4， &quot;小明&quot;, false, 22, 33, 44&#125;;&#x2F;&#x2F; 函数定义void printStu(STU *s) &#123;    printf(&quot;name &#x3D; %s\n&quot;, s-&gt;name);&#125;</code></pre></div></figure><p><strong>还能再精简</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; student都可以去掉typedef struct &#123;    int number;&#x2F;&#x2F; 学号    char name[25];&#x2F;&#x2F; 姓名    bool gender;&#x2F;&#x2F; 性别    int chinese;&#x2F;&#x2F; 语文    int math;&#x2F;&#x2F; 数学    int english;&#x2F;&#x2F; 英语&#125; STU;</code></pre></div></figure><h1 id="三、枚举"><a href="#三、枚举" class="headerlink" title="三、枚举"></a>三、枚举</h1><h2 id="3-1-枚举类型的使用"><a href="#3-1-枚举类型的使用" class="headerlink" title="3.1 枚举类型的使用"></a>3.1 枚举类型的使用</h2><p>以扑克牌花色为例，如果使用宏定义，代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 宏定义扑克牌花色#define SUIT int#define SPADE 0 &#x2F;&#x2F; 黑#define HEART 1 &#x2F;&#x2F; 红#define CLUB 2&#x2F;&#x2F; 梅#define DIANMOND 3 &#x2F;&#x2F; 方int main(void) &#123;&#x2F;&#x2F; 使用宏定义SUIT suit &#x3D; SPADE;return 0;&#125;</code></pre></div></figure><p>改用枚举的代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 枚举扑克牌花色enum suit &#123; SPADE, HEART, CLUB, DIANMOND &#125;;&#x2F;&#x2F; 使用枚举enum suit s &#x3D; SPADE;</code></pre></div></figure><h2 id="3-2-使用typdedef取别名"><a href="#3-2-使用typdedef取别名" class="headerlink" title="3.2 使用typdedef取别名"></a>3.2 使用typdedef取别名</h2><p>简化枚举的使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 枚举扑克牌花色typedef enum suit&#123;     SPADE,     HEART,     CLUB,     DIANMOND &#125;SUIT;&#x2F;&#x2F; 使用枚举SUIT s2 &#x3D; HEART;</code></pre></div></figure><blockquote><p><strong>注意事项：</strong></p><p>枚举类型的值，本质上都是一些整数，默认从0开始，可以手动指定</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;typedef enum suit&#123;    SPADE &#x3D; 6,    HEART &#x3D; 8,    CLUB &#x3D; 19,    DIANMOND &#x3D; 20 &gt;&#125;SUIT;</code></pre></div></figure><p>如果混合使用，下一个元素的值默认为上一个元素的值+1，案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;typedef enum suit&#123;    SPADE &#x3D; 6,    HEART,&#x2F;&#x2F; 7    CLUB &#x3D; 19,    DIANMOND&#x2F;&#x2F; 20&gt;&#125;SUIT;</code></pre></div></figure></blockquote><h1 id="四、指针的高级应用"><a href="#四、指针的高级应用" class="headerlink" title="四、指针的高级应用"></a>四、指针的高级应用</h1><h2 id="4-1-动态内存分配"><a href="#4-1-动态内存分配" class="headerlink" title="4.1 动态内存分配"></a>4.1 动态内存分配</h2><p>所谓动态内存分配即是在<strong>堆上分配内存</strong>，它在C语言中有举足轻重的地位，因为它是链式结构的基础。在头文件<code>stdlib.h</code>中定义有三个动态内存分配的函数，分别是：</p><ul><li>malloc</li><li>calloc</li><li>realloc</li></ul><h3 id="4-1-1-malloc的使用"><a href="#4-1-1-malloc的使用" class="headerlink" title="4.1.1 malloc的使用"></a>4.1.1 malloc的使用</h3><p>定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void * malloc(size_t size);</code></pre></div></figure><p>作用：</p><ul><li>分配size个字节的内存空间</li><li>内存块不会清零</li><li>若分配不成功，返回空指针</li></ul><p>使用案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; malloc在堆上开辟空间int* p &#x3D; (int*)malloc(sizeof(int));*p &#x3D; 10;printf(&quot;p &#x3D; %d\n&quot;, *p);</code></pre></div></figure><h3 id="4-1-2-calloc的使用"><a href="#4-1-2-calloc的使用" class="headerlink" title="4.1.2 calloc的使用"></a>4.1.2 calloc的使用</h3><p>定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void * calloc(size_t num, size_t size);</code></pre></div></figure><p>作用：</p><ul><li>为num个元素分配内存空间，每个元素的大小为size字节</li><li>对内存块清零</li><li>若分配不成功，返回空指针</li></ul><p>使用案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; calloc开辟空间int* p2 &#x3D; (int*)calloc(4, sizeof(int));p2[0] &#x3D; 12;p2[1] &#x3D; 22;p2[2] &#x3D;32;p2[3] &#x3D; 42;</code></pre></div></figure><h3 id="4-1-3-realloc的使用"><a href="#4-1-3-realloc的使用" class="headerlink" title="4.1.3 realloc的使用"></a>4.1.3 realloc的使用</h3><p>定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void * realloc(void *ptr, size_t new_size);</code></pre></div></figure><p>作用：</p><ul><li>调整先前分配的内存块的大小</li><li>如分配成功，返回新内存的地址</li><li>分配失败，返回空指针</li></ul><p><strong>注意：ptr应指向的先前使用动态内存函数分配的内存块</strong></p><p>使用案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* new_p &#x3D; realloc(p, sizeof(int) * 4);</code></pre></div></figure><h3 id="4-1-4-空指针的概念"><a href="#4-1-4-空指针的概念" class="headerlink" title="4.1.4 空指针的概念"></a>4.1.4 空指针的概念</h3><p>不指向任何对象的指针，称为空指针，用宏NULL表示，其值为0</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *ptr &#x3D; NULL;</code></pre></div></figure><h3 id="4-1-5-案例"><a href="#4-1-5-案例" class="headerlink" title="4.1.5 案例"></a>4.1.5 案例</h3><p>编写一个函数，把两个字符串拼接起来，且不改变其中任何一个字符串</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char* my_strcat(const char *str1, const char *str2) &#123;&#x2F;&#x2F; 开辟空间char* s &#x3D; (char*)malloc(strlen(str1) + strlen(str2));&#x2F;&#x2F; 复制str1strcpy(s, str1);&#x2F;&#x2F; 拼接str2strcat(s, str2);&#x2F;&#x2F; 返回return s;&#125;int main(void) &#123;&#x2F;&#x2F; 拼接字符串案例char *str1 &#x3D; &quot;Hello &quot;;char* str2 &#x3D; &quot;World&quot;;puts(my_strcat(str1, str2));return 0;&#125;</code></pre></div></figure><h2 id="4-2-释放内存空间"><a href="#4-2-释放内存空间" class="headerlink" title="4.2 释放内存空间"></a>4.2 释放内存空间</h2><h3 id="4-2-1-内存泄漏的问题"><a href="#4-2-1-内存泄漏的问题" class="headerlink" title="4.2.1 内存泄漏的问题"></a>4.2.1 内存泄漏的问题</h3><p>如果动态申请的内存没有被释放，则会产生内存泄漏的问题，如以下代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *p &#x3D; (int *)malloc(sizeof(int));int *q &#x3D; (int *)malloc(sizeof(int));p &#x3D; q;</code></pre></div></figure><p>图示为：</p><p><img src="/../../../img/image-20240319094047487.png" alt="image-20240319094047487"></p><p>长时间的内存泄漏，容易造成<code>out of memory</code>的问题。如何释放内存呢？需要使用到free函数。</p><p>定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void *free(void *ptr);</code></pre></div></figure><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* p &#x3D; (int*)malloc(sizeof(int));int* q &#x3D; (int*)malloc(sizeof(int));free(p);p &#x3D; q;free(q);q &#x3D; NULL;</code></pre></div></figure><blockquote><p>Q1：ptr只是指向申请内存块的首地址，那么free函数是如何知道该释放多大的内存？</p><p>因为实际申请的内存空间会稍大一些，里面自带关键信息，比如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;&#x2F;&#x2F; 内存块&gt;| size |     实际内容     |</code></pre></div></figure></blockquote><h3 id="4-2-2-悬空指针的问题"><a href="#4-2-2-悬空指针的问题" class="headerlink" title="4.2.2 悬空指针的问题"></a>4.2.2 悬空指针的问题</h3><p>使用free函数可以避免内存泄漏的问题，但是会引用新的问题：悬空指针，即某指针指向一片内存空间，但是该空间已经被释放，代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* p &#x3D; (int*)malloc(sizeof(int));int* q &#x3D; p;&#x2F;&#x2F; q指针成为悬空指针free(p);p &#x3D; NULL;</code></pre></div></figure><p>图示：</p><p><img src="/../../../img/image-20240319095102994.png" alt="image-20240319095102994"></p><blockquote><p>注意事项：</p><p>悬空指针的问题<strong>非常难发现</strong>，因此使用的时候需注意</p></blockquote><h2 id="4-3-链表"><a href="#4-3-链表" class="headerlink" title="4.3 链表"></a>4.3 链表</h2><p>用一条链，将所有节点串联</p><p><img src="/../../../img/image-20240319103046281.png" alt="image-20240319103046281"></p><h3 id="4-3-1-结点"><a href="#4-3-1-结点" class="headerlink" title="4.3.1 结点"></a>4.3.1 结点</h3><p>链表结点分为：</p><ul><li>数据域：存放数据</li><li>指针域：存放另一个节点的地址</li></ul><p>定义结点代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct nodes &#123;    int val;    struct nodes *next;&#125;Node;</code></pre></div></figure><h3 id="4-3-2-链表分类"><a href="#4-3-2-链表分类" class="headerlink" title="4.3.2 链表分类"></a>4.3.2 链表分类</h3><p>分类如下：</p><ul><li>单向链表</li><li>单向循环链表</li><li>双向链表</li><li>双向循环链表</li></ul><p>循环链表在实际生产中用的比较少，但是在处理环状数据的时候特别有用，像约瑟夫环</p><h3 id="4-3-3-单向链表案例"><a href="#4-3-3-单向链表案例" class="headerlink" title="4.3.3 单向链表案例"></a>4.3.3 单向链表案例</h3><p>如何实现一个单向链表：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"></code></pre></div></figure><h2 id="4-4-二级指针"><a href="#4-4-二级指针" class="headerlink" title="4.4 二级指针"></a>4.4 二级指针</h2><p>二级指针，即指向指针的指针，其定义方式如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num &#x3D; 10;int *p &#x3D; &num;&#x2F;&#x2F; 二级指针int **pp &#x3D; &p;</code></pre></div></figure><p>常用于在函数中修改指针变量的值，比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void add_to_list(Node **ptr_list, int val);</code></pre></div></figure><h2 id="4-5-函数指针"><a href="#4-5-函数指针" class="headerlink" title="4.5 函数指针"></a>4.5 函数指针</h2><p>即指向函数的指针（函数也有地址）</p><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int sum(int a, int b) &#123;return a + b;&#125;int max(int a, int b) &#123;return a &gt; b ? a : b;&#125;&#x2F;&#x2F; 定义函数指针int(*myfunc)(int, int);int main(void) &#123;&#x2F;&#x2F; 调用1myfunc &#x3D; &sum;int num1 &#x3D; (*myfunc)(6, 8);&#x2F;&#x2F; 调用2myfunc &#x3D; &max;int num2 &#x3D; (*myfunc)(6, 8);&#x2F;&#x2F; 输出14, 8printf(&quot;sum &#x3D; %d, max &#x3D; %d\n&quot;, num1, num2);return 0;&#125;</code></pre></div></figure><h2 id="4-6-qsort函数"><a href="#4-6-qsort函数" class="headerlink" title="4.6 qsort函数"></a>4.6 qsort函数</h2><p>可以对任意类型的数组进行排序（不管元素类型是什么）</p><p>排序的目的是什么？</p><ul><li>通过比较来排序，达到方便查找的目的</li></ul><p>qsort函数的定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">qsort(    void*  _Base,&#x2F;&#x2F; 指向要排序的数组    size_t _NumOfElements,&#x2F;&#x2F; 数组中元素的个数    size_t _SizeOfElements,&#x2F;&#x2F; 元素的大小    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction·&#x2F;&#x2F; 比较函数)&#x2F;* *比较函数规则 *第一个参数大于第二个，返回正值 *第一个参数小于第二个，返回负值 *  第一个参数等于第二个，返回0*&#x2F;</code></pre></div></figure><p><strong>案例：给student结构体数组排序</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;&#x2F;&#x2F; 宏定义：计算数组大小#define Size(a) (sizeof(a) &#x2F;  sizeof(a[0]))&#x2F;&#x2F; 定义学生结构体typedef struct student &#123;char name[64];int number;int chinese;int math;int english;&#125;Student;&#x2F;&#x2F; 定义排序方法int mycompare(const void *a, const void *b) &#123;Student* stu1 &#x3D; (Student*)a;Student* stu2 &#x3D; (Student*)b;&#x2F;&#x2F; 计算总分int total1 &#x3D; stu1-&gt;chinese + stu1-&gt;english + stu1-&gt;math;int total2 &#x3D; stu2-&gt;chinese + stu2-&gt;english + stu2-&gt;math;&#x2F;&#x2F; 先对比总分if (total1 !&#x3D; total2)&#123;&#x2F;&#x2F;printf(&quot;%d %d\n&quot;, total1, total2);return total2 - total1;&#125;&#x2F;&#x2F; 再对比语文if (stu1-&gt;chinese !&#x3D; stu2-&gt;chinese) &#123;return stu2-&gt;chinese - stu1-&gt;chinese;&#125;&#x2F;&#x2F; 再对比数学if (stu1-&gt;math !&#x3D; stu2-&gt;math) &#123;return stu2-&gt;math - stu1-&gt;math;&#125;&#x2F;&#x2F; 在对比英语if (stu1-&gt;english !&#x3D; stu2-&gt;english) &#123;return stu2-&gt;english - stu1-&gt;english;&#125;&#x2F;&#x2F; 都相等，对比名字return strcmp(stu1-&gt;name, stu2-&gt;name);&#125;int main(void) &#123;&#x2F;&#x2F; 对比总分&#x2F;&#x2F;Student mystu[5] &#x3D; &#123; &#123;&quot;A1&quot;, 1, 88, 77, 66&#125;, &#123;&quot;A2&quot;, 2, 89, 77, 66&#125;, &#123;&quot;A3&quot;, 3, 88, 77, 66&#125;,&#x2F;&#x2F;&#123;&quot;A4&quot;, 4, 88, 77, 66&#125;, &#123;&quot;A5&quot;, 5, 100, 77, 66&#125; &#125;;&#x2F;&#x2F; 总分相同，对比语文Student mystu[5] &#x3D; &#123; &#123;&quot;A1&quot;, 1, 85, 77, 66&#125;, &#123;&quot;A2&quot;, 2, 88, 77, 66&#125;, &#123;&quot;A3&quot;, 3, 67, 77, 66&#125;,&#123;&quot;A4&quot;, 4, 99, 77, 66&#125;, &#123;&quot;A5&quot;, 5, 33, 77, 66&#125; &#125;;&#x2F;&#x2F; 排序前输出for (int i &#x3D; 0; i &lt; 5; i++) &#123;printf(&quot;%s &quot;, mystu[i].name);&#125;printf(&quot;\n ------------ \n&quot;);&#x2F;&#x2F; 排序qsort(mystu, Size(mystu), sizeof(Student), mycompare);&#x2F;&#x2F; 排序后输出for (int i &#x3D; 0; i &lt; 5; i++) &#123;printf(&quot;%s &quot;, mystu[i].name);&#125;return 0;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day06</title>
    <link href="/2024/03/15/04_C++/01_C%E8%AF%AD%E8%A8%80/day06/"/>
    <url>/2024/03/15/04_C++/01_C%E8%AF%AD%E8%A8%80/day06/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day06”</p><h1 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h1><h2 id="1-1-字符串的字面量"><a href="#1-1-字符串的字面量" class="headerlink" title="1.1 字符串的字面量"></a>1.1 字符串的字面量</h2><p>字符串的字面量概念：</p><ul><li>是用双引号括起来的字符序列，如<code>“I love you”</code>，编译器会自动合并两个相邻的字符串（相邻：仅以空白分割）。</li><li>它是个常量，不能修改</li></ul><p>字符串字面量是如何存储的？</p><ul><li>如字符串”abc”，它会用4个字节存储，存储方式是：abc\0</li><li>最后一个’\0’代表空字符” “</li><li>字面量实际可以理解为<code>const char *</code>类型，无法修改</li></ul><h2 id="1-2-字符串变量"><a href="#1-2-字符串变量" class="headerlink" title="1.2 字符串变量"></a>1.2 字符串变量</h2><p>C语言是没有字符串类型的，都是依赖<code>字符数组</code>来实现，如</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char name[10] &#x3D; &quot;Alex&quot;;&#x2F;&#x2F; 存储方式，不足的会用&#39;\0&#39;填充A l e x \0 \0 \0 \0 \0 \0 </code></pre></div></figure><h2 id="1-3-字符串的初始化"><a href="#1-3-字符串的初始化" class="headerlink" title="1.3 字符串的初始化"></a>1.3 字符串的初始化</h2><p>字符串的初始化分为两种方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char name[] &#x3D; &quot;Alex&quot;;&#x2F;&#x2F; 以数组方式存储 A l e x \0，可以修改char * name &#x3D; &quot;Alex&quot;;&#x2F;&#x2F; 为字符串字面量，无法修改</code></pre></div></figure><p>这两种方式使用区别的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char name[] &#x3D; &quot;Alex&quot;;char* name2 &#x3D; &quot;Alex&quot;;name[1] &#x3D; &#39;L&#39;;name2[1] &#x3D; &#39;L&#39;;&#x2F;&#x2F; Error</code></pre></div></figure><p><img src="/../../../img/image-20240315105832583.png" alt="image-20240315105832583"></p><h2 id="1-4-读写字符串"><a href="#1-4-读写字符串" class="headerlink" title="1.4 读写字符串"></a>1.4 读写字符串</h2><h3 id="1-4-1-写字符串（打印）"><a href="#1-4-1-写字符串（打印）" class="headerlink" title="1.4.1 写字符串（打印）"></a>1.4.1 写字符串（打印）</h3><p>打印字符串有两种方式：<code>%s</code>和<code>puts()</code>，它们的区别如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char name[] &#x3D; &quot;Alex&quot;;&#x2F;&#x2F; 方法一printf(&quot;%s\n&quot;, name);&#x2F;&#x2F; 方法二puts(name);&#x2F;&#x2F; 会自动添加&#39;\n&#39;换行符</code></pre></div></figure><h3 id="1-4-2-读字符串（输入）"><a href="#1-4-2-读字符串（输入）" class="headerlink" title="1.4.2 读字符串（输入）"></a>1.4.2 读字符串（输入）</h3><p>输入字符串有三种方式：<code>scanf()</code>和<code>gets()</code>和<code>get_s()</code>:</p><p><strong>方法一：scanf()</strong><font color=red>【不推荐】</font></p><ul><li>​会跳过前面的空白字符，然后读取字符存入数组，直到再次遇到<em><strong>空白字符</strong></em>为止，最后添加’\0’</li><li>​永远不会包含空白字符</li><li>​scanf不会检测数组越界</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char name[10] &#x3D; &quot;&quot;;scanf(&quot;%s&quot;, &amp;name);</code></pre></div></figure><p><strong>方法二：gets()</strong><font color=red>【推荐】</font></p><ul><li>不跳过前面的空白字符，一直读取字符存入数组，直到遇到<em><strong>换行符</strong></em>为止，最后添加’\0’</li><li>gets不会检查数组是否越界</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">gets(name);</code></pre></div></figure><p>**</p><p><strong>方法三：gets_s()</strong><font color=red>【推荐】</font></p><ul><li>不跳过前面的空白字符，一直读取字符存入数组，直到遇到<em><strong>换行符</strong></em>为止，最后添加’\0’</li><li>gets_s<strong>会检查数组是否越界</strong>，较为安全</li><li>但是存在兼容性问题，使用需注意</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">gets_s(name);</code></pre></div></figure><h2 id="1-5-字符串的库函数"><a href="#1-5-字符串的库函数" class="headerlink" title="1.5 字符串的库函数"></a>1.5 字符串的库函数</h2><h3 id="1-5-1-计算字符串的长度strlen"><a href="#1-5-1-计算字符串的长度strlen" class="headerlink" title="1.5.1 计算字符串的长度strlen"></a>1.5.1 计算字符串的长度<code>strlen</code></h3><p>返回值：</p><ul><li>字符串的长度</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char name1[5] &#x3D; &quot;Alex&quot; ;char name2[6] &#x3D; &quot;Haris&quot;;&#x2F;&#x2F; 计算字符串的长度printf(&quot;name1的长度是%d\n&quot;, strlen(name1));&#x2F;&#x2F; 输出 4</code></pre></div></figure><h3 id="1-5-2-比较两个字符串strcmp"><a href="#1-5-2-比较两个字符串strcmp" class="headerlink" title="1.5.2 比较两个字符串strcmp"></a>1.5.2 比较两个字符串<code>strcmp</code></h3><p>返回值：</p><ul><li>正整数：&gt;</li><li>负整数：&lt;</li><li>零：相等</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 比较两个字符串int result &#x3D; strcmp(name1, name2);if (result &gt; 0) &#123;    printf(&quot;name1 &gt; name2\n&quot;);&#125;else if (result &#x3D;&#x3D; 0) &#123;    printf(&quot;name1 &#x3D;&#x3D; name2\n&quot;);&#125;else &#123;    printf(&quot;name1 &lt; name2\n&quot;);&#125;</code></pre></div></figure><h3 id="1-5-3-字符串复制"><a href="#1-5-3-字符串复制" class="headerlink" title="1.5.3 字符串复制"></a>1.5.3 字符串复制</h3><h4 id="1-5-3-1-普通复制strcpy"><a href="#1-5-3-1-普通复制strcpy" class="headerlink" title="1.5.3.1 普通复制strcpy"></a>1.5.3.1 普通复制<code>strcpy</code></h4><p>参数：</p><ul><li>目的字符串，源字符串</li></ul><p>返回值：</p><ul><li>该函数返回一个指向最终的目标字符串 dest 的指针</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 字符串复制char name3[6];memset(name3, &#39;\0&#39;, sizeof(name3));strcpy(name3, name1);puts(name3);&#x2F;&#x2F; 输出Alex</code></pre></div></figure><h4 id="1-5-3-2-更安全的复制strncpy"><a href="#1-5-3-2-更安全的复制strncpy" class="headerlink" title="1.5.3.2 更安全的复制strncpy"></a>1.5.3.2 更安全的复制<code>strncpy</code></h4><p>参数：</p><ul><li>目的字符串，源字符串，拷贝长度</li></ul><p>返回值：</p><ul><li>该函数返回最终复制的字符串</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 字符串复制char name3[6];memset(name3, &#39;\0&#39;, sizeof(name3));strncpy(name3, name1, 5);puts(name3);&#x2F;&#x2F; 输出Alex</code></pre></div></figure><blockquote><p>strncpy的安全拷贝策略：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;char s1[10];&gt;strncpy(s1, &quot;Hello&quot;, 4);&#x2F;&#x2F; 内存中，H e l l o, 不加&#39;\o&#39;&gt;strncpy(s1, &quot;Hello&quot;, 6);&#x2F;&#x2F; 内存中，H e l l o \o，刚好&gt;strncpy(s1, &quot;Hello&quot;, 8);&#x2F;&#x2F; 内存中，H e l l o \o \o \o，填补</code></pre></div></figure></blockquote><h3 id="1-5-4-字符串拼接"><a href="#1-5-4-字符串拼接" class="headerlink" title="1.5.4 字符串拼接"></a>1.5.4 字符串拼接</h3><h4 id="1-5-4-1-普通拼接strcat"><a href="#1-5-4-1-普通拼接strcat" class="headerlink" title="1.5.4.1 普通拼接strcat"></a>1.5.4.1 普通拼接<code>strcat</code></h4><p>参数：</p><ul><li>目的字符串，源字符串</li></ul><p>返回值：</p><ul><li>返回拼接完的字符串</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 字符串拼接char s1[11] &#x3D; &quot;Hello&quot;;strcat(s1, &quot;World&quot;);puts(s1);&#x2F;&#x2F; 输出HelloWorld</code></pre></div></figure><blockquote><p>注意事项：</p><p>需注意字符串的长度，以上案例中，如s1的数组长度为10，则在编译时会报错，因为拼接完的字符串最后还会加上’\0’，因此需要多留一个长度</p><p><img src="/../../../img/image-20240315141428872.png" alt="image-20240315141428872"></p></blockquote><p>1.5.4.2 更安全的拼接<code>strncat</code></p><p>参数：</p><ul><li>char * dest：目的字符串</li><li>const char * src：源字符串</li><li>size_t count ：拷贝的字符数</li></ul><p>返回值：</p><ul><li>char *</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 安全的字符串拼接char s2[11] &#x3D; &quot;Hello&quot;;strncat(s2, &quot;World&quot;, 4);puts(s2);&#x2F;&#x2F; 输出HelloWorl</code></pre></div></figure><blockquote><p>strncat的安全拼接策略：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;char s1[10] &#x3D; &quot;abc&quot;;&gt;strncat(s1, &quot;def&quot;, 2);&#x2F;&#x2F; a b c d e \0 \0 \0 \0 \0&gt;strncat(s1, &quot;def&quot;, 3);&#x2F;&#x2F; a b c d e f \0 \0 \0 \0&gt;strncat(s1, &quot;def&quot;, 6);&#x2F;&#x2F; a b c d e f \0 \0 \0 \0</code></pre></div></figure><p>因为strncat总会写入’\0’填充，所以我们一般会这样调用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;strncat(s1, s2, sizeof(s1) - sizeof(s1) - 1);&#x2F;&#x2F; 最后的1预留给&#39;\0&#39;</code></pre></div></figure></blockquote><h2 id="1-6-字符串的惯用法-TODO-例子不能跑"><a href="#1-6-字符串的惯用法-TODO-例子不能跑" class="headerlink" title="1.6 字符串的惯用法(TODO 例子不能跑)"></a>1.6 字符串的惯用法(TODO 例子不能跑)</h2><p>1、搜索字符串的末尾（<font color=red>编译错误</font>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">while(*s) &#123;    s++;&#125;</code></pre></div></figure><p>2、赋值字符串，包括空字符（<font color=red>编译错误</font>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">while(*p++ &#x3D; *s++);</code></pre></div></figure><h2 id="1-7-字符串数组"><a href="#1-7-字符串数组" class="headerlink" title="1.7 字符串数组"></a>1.7 字符串数组</h2><p>如何表示字符串数组？</p><p>1、二维数组方式【不推荐，空白空间很多】</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char planets[3][8] &#x3D; &#123; &quot;Mecury&quot;, &quot;Venus&quot;, &quot;Earth&quot; &#125;;for (int i &#x3D; 0; i &lt; 3; i++) &#123;    puts(planets[i]);&#125;</code></pre></div></figure><p>2、字符指针数组【推荐】</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *planets[3] &#x3D; &#123; &quot;Mecury&quot;, &quot;Venus&quot;, &quot;Earth&quot; &#125;;</code></pre></div></figure><h2 id="1-8-练习"><a href="#1-8-练习" class="headerlink" title="1.8 练习"></a>1.8 练习</h2><p>1、编写自己的strlen函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int getlen(const char *arr) &#123;    &#x2F;&#x2F;合法性校验    if (arr &#x3D;&#x3D; NULL) &#123;        return -1;    &#125;int num &#x3D; 0;while (*arr !&#x3D; &#39;\0&#39;) &#123;arr++;num++;&#125;return num;&#125;</code></pre></div></figure><p>2、编写自己的strcat函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char* mycat(char* dest, const char* src) &#123;&#x2F;&#x2F;合法性校验if (dest &#x3D;&#x3D; NULL || src &#x3D;&#x3D; NULL) &#123;return dest;&#125;&#x2F;&#x2F; 临时指针变量char* temp &#x3D; dest;&#x2F;&#x2F; 指针移动到dest的最后一个字符（&#39;\0&#39;之前）while (*temp !&#x3D; &#39;\0&#39;) &#123;temp++;&#125;&#x2F;&#x2F; src指针每后移一个字符，都加到dest后面while (*src !&#x3D; &#39;\0&#39;) &#123;*temp &#x3D; *src;*temp++;src++;&#125;&#x2F;&#x2F; 最后追加&#39;\0&#39;符号*temp &#x3D; &#39;\0&#39;;        &#x2F;&#x2F; 返回合并后的字符串return dest;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day05</title>
    <link href="/2024/03/14/04_C++/01_C%E8%AF%AD%E8%A8%80/day05/"/>
    <url>/2024/03/14/04_C++/01_C%E8%AF%AD%E8%A8%80/day05/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day05”</p><h1 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h1><p>函数的构成</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*返回值类型函数名(形参) ｛xxxx    ｝*&#x2F;    int func(int num) &#123;    return 0;&#125;</code></pre></div></figure><p>其中返回值类型不能为数组</p><h2 id="1-1-值传递和引用传递"><a href="#1-1-值传递和引用传递" class="headerlink" title="1.1 值传递和引用传递"></a>1.1 值传递和引用传递</h2><h3 id="1-1-1-值传递"><a href="#1-1-1-值传递" class="headerlink" title="1.1.1 值传递"></a>1.1.1 值传递</h3><p>值传递分为：</p><ul><li>值传递（值作为形参）</li><li>指针传递（指针作为形参）</li></ul><p><strong>值传递案例一：交换案例</strong></p><p>当我们按以下方法写swap函数，发现swap函数并没有交换成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;&#x2F;&#x2F; 值交换void swap(int a, int b) &#123;&#x2F;&#x2F; 传值int temp &#x3D; 0;temp &#x3D; b;b &#x3D; a;a &#x3D; temp;&#125;int main(void) &#123;int a &#x3D; 10;int b &#x3D; 20;swap(a, b);printf(&quot;a &#x3D; %d, b &#x3D; %d\n&quot;, a, b);&#x2F;&#x2F; a &#x3D; 10, b &#x3D; 20，没有交换成功return 0;&#125;</code></pre></div></figure><p>因为swap函数中的<code>int a和int b</code>实际上是复制了一份，放在栈里（临时存储在内存中），用完即被释放，称为值传递，如何解决这个问题？第一种方法是使用<strong>指针传递</strong>，如下代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;&#x2F;&#x2F; 值交换void swap(int *a, int *b) &#123;&#x2F;&#x2F; 传指针int temp &#x3D; 0;temp &#x3D; *b;&#x2F;&#x2F; 注意，这里也要加“解引用“*b &#x3D; *a;*a &#x3D; temp;&#125;int main(void) &#123;int a &#x3D; 10;int b &#x3D; 20;swap(&amp;a, &amp;b);printf(&quot;a &#x3D; %d, b &#x3D; %d\n&quot;, a, b);&#x2F;&#x2F; a &#x3D; 20, b &#x3D; 10，交换成功return 0;&#125;</code></pre></div></figure><p><strong>值传递案例二：一维数组作为参数</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 一维数组作为参数int sum_array(int arr[], int len) &#123;&#x2F;&#x2F; 此时数组名将退化成指针int sum &#x3D; 0;for (int i &#x3D; 0; i &lt; len; i++) &#123;sum +&#x3D; arr[i];&#125;return sum;&#125;int main(void) &#123;    int arr[] &#x3D; &#123; 1,2,3,4,5 &#125;;    &#x2F;&#x2F; 普通调用    printf(&quot;sum &#x3D; %d\n&quot;, sum_array(arr, 5));&#x2F;&#x2F; sum &#x3D; 15    &#x2F;&#x2F; 还能限制范围，调用更加灵活    printf(&quot;sum &#x3D; %d\n&quot;, sum_array(arr + 3, 2));&#x2F;&#x2F; sum &#x3D; 9     return 0;&#125;</code></pre></div></figure><p><strong>值传递案例二：二维数组作为参数</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 二维数组作为参数int sum_binarray(int arr[][4], int len) &#123;&#x2F;&#x2F; 只能省略行，不能省略列int sum &#x3D; 0;for (int i &#x3D; 0; i &lt; len; i++) &#123;for (int j &#x3D; 0; j &lt; 4; j++) &#123;sum +&#x3D; arr[i][j];&#125;&#125;return sum;&#125;int main(void) &#123;    int binarr[][4] &#x3D; &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125; &#125;;printf(&quot;binsum &#x3D; %d\n&quot;, sum_binarray(binarr, 3));&#x2F;&#x2F; 输出78return 0;&#125;</code></pre></div></figure><h3 id="1-1-2-引用传递"><a href="#1-1-2-引用传递" class="headerlink" title="1.1.2 引用传递"></a>1.1.2 引用传递</h3><p>解决1.1.1值传递交换案例不成功的第二种方法，就是使用引用传递</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 值交换void swap(int &amp;a, int &amp;b) &#123;&#x2F;&#x2F; 传引用int temp &#x3D; 0;temp &#x3D; b;b &#x3D; a;a &#x3D; temp;&#125;int main(void) &#123;int a &#x3D; 10;int b &#x3D; 20;swap(a, b);printf(&quot;a &#x3D; %d, b &#x3D; %d\n&quot;, a, b);&#x2F;&#x2F; a &#x3D; 20, b &#x3D; 10，交换成功return 0;&#125;</code></pre></div></figure><blockquote><p>注意事项：</p><p>在VS中，以上main.c源码文件使用C编译器报错：存在正文时不允许未命名的原型参数</p><p><img src="/../../../img/image-20240314095051031.png" alt="image-20240314095051031"></p><p>解决方法：改成main.cpp</p></blockquote><h2 id="1-2-程序的终止"><a href="#1-2-程序的终止" class="headerlink" title="1.2 程序的终止"></a>1.2 程序的终止</h2><p>程序的开始和结束：</p><ul><li>操作系统调用main函数 —-&gt; 程序的开始</li><li>main函数将状态码返回给操作系统 —–&gt; 程序的终止</li></ul><p>如果不想在main函数终止，如何提前终止呢？</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdlib.h&gt;void foo() &#123;    &#x2F;&#x2F; 提前结束    exit(EXIT_SUCCESS);&#125;int main(void) &#123;    return 0;&#125;</code></pre></div></figure><h1 id="二、局部变量和全局变量"><a href="#二、局部变量和全局变量" class="headerlink" title="二、局部变量和全局变量"></a>二、局部变量和全局变量</h1><h2 id="2-1-定义局部和全局变量"><a href="#2-1-定义局部和全局变量" class="headerlink" title="2.1 定义局部和全局变量"></a>2.1 定义局部和全局变量</h2><p>分为全局和局部（外部）变量：</p><ul><li>局部变量：定义在函数里面的变量（默认在自动存储期限，可以用static指定为静态）</li><li>全局变量：定义在函数外面的变量</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;&#x2F;&#x2F; 全局变量int GLOBAL_NUM &#x3D; 10;void foo() &#123;&#x2F;&#x2F; 局部变量int i &#x3D; 20;printf(&quot;i &#x3D; %d\n&quot;, i);&#125;int main(void) &#123;&#x2F;&#x2F; 全局变量能随意调用和计算printf(&quot;global_num &#x3D; %d\n&quot;, GLOBAL_NUM + 1);&#x2F;&#x2F; 局部变量只能在函数内部调用 &#x2F;&#x2F; i &#x3D; 30;&#x2F;&#x2F; Error!foo();return 0;&#125;</code></pre></div></figure><h2 id="2-2-存储期限（※※※）"><a href="#2-2-存储期限（※※※）" class="headerlink" title="2.2 存储期限（※※※）"></a>2.2 存储期限（※※※）</h2><p>存储期限分为：</p><ul><li>自动存储期限：存在栈里面的数据，变量的生命周期随栈帧的入栈开始，出栈而结束</li><li>静态存储期限：拥有永久的存储时间，在程序整个执行期间都存在</li></ul><p>自动存储单元的案例（<em>该案例仅能在部分Linux中编译执行，实测效果不同</em>）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void foo() &#123;        int i;        printf(&quot;%d\n&quot;, i++);&#125;int main(void) &#123;        foo();        foo();        foo();        return 0;&#125;&#x2F;&#x2F; 输出结果不一致，证明累加生效，临时存储生效655356553665537</code></pre></div></figure><p>如果改成：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void) &#123;        foo();        foo();        foo();        return 0;&#125;&#x2F;&#x2F; 输出结果一致，说明累加不生效了，临时存储被printf打断655356553565535    </code></pre></div></figure><p>再改成静态存储：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void foo() &#123;    &#x2F;&#x2F; 改成静态存储        static int i;        printf(&quot;%d\n&quot;, i++);&#125;int main(void) &#123;        foo();        foo();        foo();        return 0;&#125;&#x2F;&#x2F; 输出结果不一致，证明累加又生效了，静态存储生效655356553665537</code></pre></div></figure><h1 id="三、递归（※※※※）"><a href="#三、递归（※※※※）" class="headerlink" title="三、递归（※※※※）"></a>三、递归（※※※※）</h1><h2 id="3-1-斐波那契数列（TODO-补充递归优化版本）"><a href="#3-1-斐波那契数列（TODO-补充递归优化版本）" class="headerlink" title="3.1 斐波那契数列（TODO 补充递归优化版本）"></a>3.1 斐波那契数列（TODO 补充递归优化版本）</h2><p>斐波那契（Fibnaci）数列，从第三个数开始，后面的数值为前2个数值之和：</p><p>0，1，1，2，3，5，8，13……</p><p>递归实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">long long fib(int n) &#123;if (n &#x3D;&#x3D; 0) return 0;if (n &#x3D;&#x3D; 1) return 1;return fib(n - 1) + fib(n - 2);&#125;</code></pre></div></figure><p>不过递归这样写，算法效率非常低，存在大量重复运算符（如图，同色的为重复运算），时间复杂度是O(2^n)。</p><p><img src="/../../../img/image-20240314140350487.png" alt="image-20240314140350487"></p><p>改良的方法是使用循环实现，时间复杂度是O(n)，效率比递归高很多</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">long long fib2(int n) &#123;if (n &#x3D;&#x3D; 0) return 0;if (n &#x3D;&#x3D; 1) return 1;int a &#x3D; 0, b &#x3D; 1;for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;int tmp &#x3D; a + b;a &#x3D; b;b &#x3D; tmp;&#125;return b;&#125;</code></pre></div></figure><h2 id="3-2-约瑟夫环（TODO）"><a href="#3-2-约瑟夫环（TODO）" class="headerlink" title="3.2 约瑟夫环（TODO）"></a>3.2 约瑟夫环（TODO）</h2><p>给定人数、起点、方向、要跳过的数字</p><h1 id="四、指针（※※※※）"><a href="#四、指针（※※※※）" class="headerlink" title="四、指针（※※※※）"></a>四、指针（※※※※）</h1><h2 id="4-1-指针的基础"><a href="#4-1-指针的基础" class="headerlink" title="4.1 指针的基础"></a>4.1 指针的基础</h2><p>几个基础知识：</p><ul><li>字节：计算机最小的寻址单位</li><li>变量的地址：变量的第一个字节的地址</li><li>指针：指针就是地址</li><li>指针变量：存放地址的变量，有时候吧指针变量称为指针</li></ul><h3 id="4-1-1-通过指针访问对象"><a href="#4-1-1-通过指针访问对象" class="headerlink" title="4.1.1 通过指针访问对象"></a>4.1.1 通过指针访问对象</h3><p>如何通过指针访问到其指向的对象：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num &#x3D; 10;&#x2F;&#x2F; 定义指针int* p &#x3D; &num;&#x2F;&#x2F; 解引用printf(&quot;num &#x3D; %d\n&quot;, *p);</code></pre></div></figure><blockquote><p>注意事项：</p><p>int *p, q;&#x2F;&#x2F; p是指针int*类型，q是int类型</p><p>int *p, *q;&#x2F;&#x2F; p、q都是int*类型</p></blockquote><h3 id="4-1-2-野指针的问题"><a href="#4-1-2-野指针的问题" class="headerlink" title="4.1.2 野指针的问题"></a>4.1.2 野指针的问题</h3><p>什么是野指针？</p><ul><li><p>指向未知区域的指针</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *p &#x3D; 0x7F; &#x2F;&#x2F; 未知区域</code></pre></div></figure></li><li><p>未初始化的指针</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *p;&#x2F;&#x2F; 未初始化</code></pre></div></figure></li></ul><blockquote><p>注意事项：</p><p>对野指针进行解引用行为，将导致编译器报错：如，读取访问权限异常</p></blockquote><h3 id="4-1-3-指针变量的赋值"><a href="#4-1-3-指针变量的赋值" class="headerlink" title="4.1.3 指针变量的赋值"></a>4.1.3 指针变量的赋值</h3><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num &#x3D; 10;int *p1,*p2;p1 &#x3D; &num;&#x2F;&#x2F; 指针变量赋值p2 &#x3D; p1;</code></pre></div></figure><h3 id="4-1-4-指针作为参数（※）"><a href="#4-1-4-指针作为参数（※）" class="headerlink" title="4.1.4 指针作为参数（※）"></a>4.1.4 指针作为参数（※）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 交换2个数的值void swap(int *a, int *b) &#123;    int tmp &#x3D; *a;    *a &#x3D; *b;    *b &#x3D; tmp;&#125;</code></pre></div></figure><p>指针作为参数的好处：</p><ul><li>值传递不能改变实参的值，而指针可以</li></ul><p><strong>练习：找出数组中的最大值和最小值</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;void find_min_max(int arr[], int n, int* min, int* max) &#123;*min &#x3D; arr[0];*max &#x3D; arr[0];for (int i &#x3D; 0; i &lt; n; i++) &#123;if (*min &gt; arr[i]) &#123;*min &#x3D; arr[i];&#125;if (*max &lt; arr[i]) &#123;*max &#x3D; arr[i];&#125;&#125;&#125;int main(void) &#123;int max &#x3D; 0;int min &#x3D; 0;int arr[] &#x3D; &#123; 1,2,3,4,5,5,6,7,8,9 &#125;;find_min_max(arr, 10, &amp;min, &amp;max);printf(&quot;max &#x3D; %d, min &#x3D; %d\n&quot;, max, min);return 0;&#125;</code></pre></div></figure><h2 id="4-2-指针和数组"><a href="#4-2-指针和数组" class="headerlink" title="4.2 指针和数组"></a>4.2 指针和数组</h2><h3 id="4-2-1-指针运算"><a href="#4-2-1-指针运算" class="headerlink" title="4.2.1 指针运算"></a>4.2.1 指针运算</h3><p>指针运算包含：</p><ul><li>指针加上一个整数</li><li>指针减去一个整数</li><li>两个指针相减（指向同一数组里的元素）</li></ul><p>指针运算以元素大小为单位，而不是以字节位单位。案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int arr[] &#x3D; &#123; 0,1,5,3,4,5,6,7,8,9 &#125;;int* p &#x3D; &amp;arr[2];int* q &#x3D; &amp;arr[5];printf(&quot;%d\n&quot;, *(p + 2));&#x2F;&#x2F; 4 等于arr[5]printf(&quot;%d\n&quot;, p - q);&#x2F;&#x2F; -3 代表间隔3个int类型printf(&quot;%d\n&quot;, q - p);&#x2F;&#x2F; 3  </code></pre></div></figure><p>指针变量p1减p2的意义为：</p><ul><li>如果是正值 ， 则表示在内存中p1比p2靠后</li><li>如果是负值 ， 则表示 在内存中 p1比p2靠前</li><li>结果的数字表示 ， 两个地址在内存中间隔多少个指针类型的字节倍数</li></ul><h3 id="4-2-2-使用指针遍历数组"><a href="#4-2-2-使用指针遍历数组" class="headerlink" title="4.2.2 使用指针遍历数组"></a>4.2.2 使用指针遍历数组</h3><p>for循环方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int arr[] &#x3D; &#123; 2,2,3,4,5,6,7,8 &#125;;for (int* p &#x3D; &amp;arr[0]; p &lt; &amp;arr[8]; p++) &#123;    printf(&quot;%d &quot;, *p);&#125;printf(&quot;\n&quot;);</code></pre></div></figure><p>while循环方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int arr[] &#x3D; &#123; 2,2,3,4,5,6,7,8 &#125;;int* p &#x3D; &amp;arr[0];while (p &lt; &amp;arr[8]) &#123;    printf(&quot;%d &quot;, *p);    p++;&#125;printf(&quot;\n&quot;);</code></pre></div></figure><h3 id="4-2-3-和-的组合"><a href="#4-2-3-和-的组合" class="headerlink" title="4.2.3 *和++的组合"></a>4.2.3 *和++的组合</h3><p>四中组合的含义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num[7] &#x3D; &#123;0,5,8,7,3,2,1&#125;;int* p &#x3D; &amp;num[0];</code></pre></div></figure><ul><li><p>**<em>p++ 或 <em>(p++)</em></em>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;%d\n&quot;, *(p++));&#x2F;&#x2F; 表达式的值为*p，输出0printf(&quot;%d\n&quot;, *p); &#x2F;&#x2F;  副作用p自增, 输出5</code></pre></div></figure></li><li><p>**(*p)++**：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;%d\n&quot;, (*p)++);&#x2F;&#x2F; 表达式的值为*p，输出0printf(&quot;%d\n&quot;, *p); &#x2F;&#x2F;  副作用*p自增, 0+1,输出1</code></pre></div></figure></li><li><p>***++p或*(++p)**    ： </p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;%d\n&quot;, *(++p));&#x2F;&#x2F; 表达式的值为*(p+1) &#x3D; p[1]，输出5printf(&quot;%d\n&quot;, *p); &#x2F;&#x2F;  副作用p自增 &#x3D; p[1], 输出5</code></pre></div></figure></li><li><p>**++*p或++(<em>p)</em>*   : </p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;%d\n&quot;, ++(*p));&#x2F;&#x2F; 表达式的值为(*p + 1) &#x3D; 0 + 1, 输出1printf(&quot;%d\n&quot;, *p); &#x2F;&#x2F;  副作用*p自增, 输出1</code></pre></div></figure></li></ul><p>*和–也有类似的组合</p><h3 id="4-2-4-指针作为数组名使用"><a href="#4-2-4-指针作为数组名使用" class="headerlink" title="4.2.4 指针作为数组名使用"></a>4.2.4 指针作为数组名使用</h3><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num[7] &#x3D; &#123;0,5,8,7,3,2,1&#125;;int* p &#x3D; &amp;num[0];printf(&quot;%d\n&quot;, *(p + 4)); &#x2F;&#x2F; 等同于p[4], 输出3</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day04</title>
    <link href="/2024/03/11/04_C++/01_C%E8%AF%AD%E8%A8%80/day04/"/>
    <url>/2024/03/11/04_C++/01_C%E8%AF%AD%E8%A8%80/day04/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day04”</p><h1 id="一、语句"><a href="#一、语句" class="headerlink" title="一、语句"></a>一、语句</h1><h2 id="1-1-选择语句"><a href="#1-1-选择语句" class="headerlink" title="1.1 选择语句"></a>1.1 选择语句</h2><h3 id="1-1-1-if语句"><a href="#1-1-1-if语句" class="headerlink" title="1.1.1 if语句"></a>1.1.1 if语句</h3><p>if语句的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">if (num &#x3D;&#x3D; 0) &#123;    printf(&quot;num &#x3D;&#x3D; 0&quot;);&#125;</code></pre></div></figure><p>if…else if…else语句的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">if (num &#x3D;&#x3D; 0) &#123;printf(&quot;num &#x3D;&#x3D; 0&quot;);&#125;else if (num &#x3D;&#x3D; 1) &#123;printf(&quot;num &#x3D;&#x3D; 1&quot;);&#125;else &#123;printf(&quot;num is error&quot;);&#125;</code></pre></div></figure><h3 id="1-1-2-switch语句"><a href="#1-1-2-switch语句" class="headerlink" title="1.1.2 switch语句"></a>1.1.2 switch语句</h3><p>switch语句的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">switch (grade) &#123;case 0:printf(&quot;0000000&quot;);break;case 1:printf(&quot;1111111&quot;);break;default:&#x2F;&#x2F; 如输入的参数不匹配，缺省值break;&#125;</code></pre></div></figure><blockquote><p>注意事项：</p><p>1、expr（即案例中的grade）的值必须是int类型或者char类型</p><p>2、case后面的值也必须是int类型或者char类型的常量表达式</p><p>3、不能使用重复的标签</p><p>4、多个分支标号可以共用一条语句，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;case 1: case 2: case 3:printf(&quot;1111111&quot;);break;</code></pre></div></figure><p>5、如果缺省<code>break</code>可能出现case穿透的现象，例如</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;switch (grade) &#123;case 0:printf(&quot;0000000&quot;);&#x2F;&#x2F; 省略breakcase 1: case 2: case 3:printf(&quot;1111111&quot;);&#x2F;&#x2F; 省略breakdefault:  printf(&quot;都执行到末尾了！！&quot;);break;&#125;&gt;&#x2F;&#x2F; 执行发生穿透现象，后面的case也继续执行完了&gt;请输入数字: 0&gt;00000001111111都执行到末尾了！！</code></pre></div></figure></blockquote><p><strong>switch语句和if…else语句的比较：</strong></p><ol><li>if…else语句比switch语句更加通用</li><li>但是switch语句比if….else语句可读性高</li><li>switch语句的执行效率优于if…else语句</li></ol><h2 id="1-2-循环语句"><a href="#1-2-循环语句" class="headerlink" title="1.2 循环语句"></a>1.2 循环语句</h2><h3 id="1-2-1-while语句"><a href="#1-2-1-while语句" class="headerlink" title="1.2.1 while语句"></a>1.2.1 while语句</h3><p>while语句的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void) &#123;int num &#x3D; 10;while (num &gt; 0) &#123;&#x2F;&#x2F; while设置条件printf(&quot;%d &quot;, num);num--;&#125;printf(&quot;\n&quot;);return 0;&#125;&#x2F;&#x2F; 执行10 9 8 7 6 5 4 3 2 1</code></pre></div></figure><h3 id="1-2-2-do…while语句"><a href="#1-2-2-do…while语句" class="headerlink" title="1.2.2 do…while语句"></a>1.2.2 do…while语句</h3><p>do..while语句的案例，将while语句的案例重写：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num &#x3D; 10;do &#123;    printf(&quot;%d &quot;, num);    num--;&#125; while (num &gt; 0);printf(&quot;\n&quot;);&#x2F;&#x2F; 执行：10 9 8 7 6 5 4 3 2 1</code></pre></div></figure><p>那么do…while和while的区别是什么？</p><ul><li>唯一区别：当初始条件为假时，do..while语句循环会执行一次，而while语句一次都不会执行，例如：</li></ul><p>do..while会执行一次：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num &#x3D; 10;do &#123;    printf(&quot;%d &quot;, num);    num--;&#125; while (num &gt; 0);printf(&quot;\n&quot;);&#x2F;&#x2F; 执行输出10，说明执行了一次10</code></pre></div></figure><p>while一次也不执行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num &#x3D; 10;while (num &lt; 0) &#123;printf(&quot;%d &quot;, num);num--;&#125;printf(&quot;\n&quot;);&#x2F;&#x2F; 执行输出空白</code></pre></div></figure><h3 id="1-2-3-for语句"><a href="#1-2-3-for语句" class="headerlink" title="1.2.3 for语句"></a>1.2.3 for语句</h3><p>for语句的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void) &#123;for (int i &#x3D; 0; i &lt; 10; i++) &#123;printf(&quot;%d &quot;, i);&#125;printf(&quot;\n&quot;);return 0;&#125;&#x2F;&#x2F; 执行0 1 2 3 4 5 6 7 8 9</code></pre></div></figure><blockquote><p>注意事项：</p><p>for语句的expr1、expr2、expr3都可以省略，若省略expr2，其默认为true</p><p>[不建议单独省略]</p></blockquote><p>for语句的惯用法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 无限循环for (;;) &#123;    printf(&quot;hello\n&quot;);&#125;&#x2F;&#x2F; 效果等同于while(1) &#123;    printf(&quot;hello\n&quot;);&#125;</code></pre></div></figure><h2 id="1-3-跳转语句"><a href="#1-3-跳转语句" class="headerlink" title="1.3 跳转语句"></a>1.3 跳转语句</h2><h3 id="1-3-1-break语句"><a href="#1-3-1-break语句" class="headerlink" title="1.3.1 break语句"></a>1.3.1 break语句</h3><p>用于跳出switch、for、while、do…while、for等语句，例子</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sum &#x3D; 0;for (;;) &#123;    if (sum &#x3D;&#x3D; 5) &#123;        break;&#x2F;&#x2F; 达到条件，跳出循环    &#125;    printf(&quot;hello\n&quot;);    sum++;&#125;&#x2F;&#x2F; 执行：hellohellohellohellohello</code></pre></div></figure><blockquote><p>注意事项：</p><p>当switch、while、do..while、for<strong>语句嵌套时</strong>，break语句<strong>只能跳出包含break的最内层嵌套</strong>，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sum &#x3D; 0;while (1) &#123;for (;;) &#123;if (sum &#x3D;&#x3D; 5) &#123;break;&#x2F;&#x2F; 达到条件只能跳出for的无限循环&#125;printf(&quot;hello\n&quot;);sum++;&#125;printf(&quot;Don&#39;t Break!!\n&quot;);&#x2F;&#x2F; while的无限循环仍会继续。。&#125;</code></pre></div></figure></blockquote><h3 id="1-3-2-continue语句"><a href="#1-3-2-continue语句" class="headerlink" title="1.3.2 continue语句"></a>1.3.2 continue语句</h3><p>continue语句和break语句的区别：</p><ul><li>break可以用于循环语句和switch语句，而continue语句只能用于循环语句</li><li>break<strong>语句是跳出整个循环</strong>（循环彻底结束），而continue<strong>语句是跳转到循环体的末尾</strong>(结束当前循环，开启下一次循环)</li></ul><p>continue语句的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">for (;;) &#123;    if (sum &#x3D;&#x3D; 4) &#123;        continue;&#x2F;&#x2F; 当满足条件num &#x3D;&#x3D; 4后，程序执行被continue截胡，每次都跳过后面的语句，直接回到这里，因此一直卡在这    &#125;    if (sum &#x3D;&#x3D; 5) &#123;        break;&#x2F;&#x2F; 如果只有break，应该输出5次hello    &#125;    printf(&quot;hello %d\n&quot;, sum);    sum++;&#125;&#x2F;&#x2F; 执行hello 0hello 1hello 2hello 3卡住，程序没有结束</code></pre></div></figure><h3 id="1-3-3-go-to语句"><a href="#1-3-3-go-to语句" class="headerlink" title="1.3.3 go to语句"></a>1.3.3 go to语句</h3><p>break语句只能跳转到switch或循环语句的下一条语句，continue只能跳转到循环体的末尾，而go to语句没有上面的限制，<strong>能在同一函数内随意跳转</strong>：</p><p>使用场景一，跳出外层嵌套：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sum &#x3D; 0;while (1) &#123;    for (;;) &#123;        if (sum &#x3D;&#x3D; 4) &#123;            goto loop_done;&#x2F;&#x2F; 跳出到标签处        &#125;        printf(&quot;sum &#x3D; %d\n&quot;, sum);        sum++;    &#125;&#125;loop_done:&#x2F;&#x2F; 自定义标签&#x2F;&#x2F; 执行，能跳出while的无限循环sum &#x3D; 0sum &#x3D; 1sum &#x3D; 2sum &#x3D; 3</code></pre></div></figure><p>使用场景二，用于错误处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">while (1) &#123;for (;;) &#123;if (sum &#x3D;&#x3D; 4) &#123;goto error_handle;&#x2F;&#x2F; 加入发生错误，直接跳转到错误处理&#125;printf(&quot;sum &#x3D; %d\n&quot;, sum);sum++;&#125;&#125;error_handle:&#x2F;&#x2F; 处理错误printf(&quot;发生错误了！&quot;);&#x2F;&#x2F; 执行sum &#x3D; 0sum &#x3D; 1sum &#x3D; 2sum &#x3D; 3发生错误了！</code></pre></div></figure><blockquote><p>注意事项：</p><p>使用go to容易造成，因此需要<strong>尽量少用</strong>，只有当其它方式实现不了时，再来考虑它</p><ul><li>代码可读性差</li><li>很容易出BUG</li></ul></blockquote><h1 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h1><p>数组的模型</p><ul><li>数组是一片连续的内存空间，被划分为大小相等的小空间</li><li>可以随机访问数组元素（在O1的时间复杂度内访问数组任意一元素）</li></ul><h2 id="2-1-关于数组的两个问题"><a href="#2-1-关于数组的两个问题" class="headerlink" title="2.1 关于数组的两个问题"></a>2.1 关于数组的两个问题</h2><p>Q1：为什么大多数语言中，数组的索引都是从0开始？</p><p>如果从1开始，每次寻址会多一次减法运算，浪费CPU资源</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 寻址从0开始i_aadr &#x3D; base_addr + i * sizeof(数据类型)&#x2F;&#x2F; 寻址从1开始i_aadr &#x3D; base_addr + (i-1) * sizeof(数据类型)&#x2F;&#x2F; 多一次减法运算</code></pre></div></figure><p>Q2：为什么数组的效率高于链表？</p><ul><li>数组的内存空间是连续的，而链表是不连续的，数组可以更好的利用CPU高速缓存，有预读效果</li><li>数组只需要存储数据，而链表需要存储数据+指针域，链表的内存占用更高</li></ul><h2 id="2-2-数组的声明和初始化"><a href="#2-2-数组的声明和初始化" class="headerlink" title="2.2 数组的声明和初始化"></a>2.2 数组的声明和初始化</h2><p>声明数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int arr[10];</code></pre></div></figure><blockquote><p>注意事项：</p><p>数组的SIZE必须是是整型的常量表达式，在编译期间能计算数组的大小</p></blockquote><p>数组的初始化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int arr1[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;&#x2F;&#x2F; 标准初始化int arr2[10] &#x3D; &#123; 1,2,3 &#125;;&#x2F;&#x2F; 其余元素会初始化为0int arr3[10] &#x3D; &#123; 0 &#125;;&#x2F;&#x2F; 利用特性，将所有元素初始化为0int arr4[] &#x3D; &#123; 1,2,3,4,5 &#125;;&#x2F;&#x2F; 可以不指定SIZE，长度由编译器决定，这里是5printf(&quot;%d\n&quot;, sizeof(arr4));&#x2F;&#x2F; 20</code></pre></div></figure><blockquote><p>注意事项：</p><p>数组的初始化长度，不能大于数组的长度</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;int arr5[2] &#x3D; &#123; 1,2,3 &#125;;&#x2F;&#x2F; error, 初始值设置项值太多</code></pre></div></figure></blockquote><h2 id="2-3-对于数组使用sizeof计算数组的size"><a href="#2-3-对于数组使用sizeof计算数组的size" class="headerlink" title="2.3 对于数组使用sizeof计算数组的size"></a>2.3 对于数组使用sizeof计算数组的size</h2><p>sizeof使用案例：</p><p>当我们需要对一个数组做循环，普通的操作是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int arr[10] &#x3D; &#123;0&#125;;for (int i &#x3D; 0; i &lt; 10; i++) &#123;    .....&#125;</code></pre></div></figure><p>但如果数组不只一个呢？for循环就要写很多个，修改起来比较麻烦</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int arr[10] &#x3D; &#123;0&#125;;int arr[20] &#x3D; &#123;0&#125;;int arr[30] &#x3D; &#123;0&#125;;for (int i &#x3D; 0; i &lt; 10; i++) &#123;    .....&#125;for (int i &#x3D; 0; i &lt; 20; i++) &#123;    .....&#125;for (int i &#x3D; 0; i &lt; 30; i++) &#123;    .....&#125;&#x2F;&#x2F; 即使使用宏定义，一个个改也较为麻烦#define N1 10#define N2 20#define N3 30</code></pre></div></figure><p>最佳的解决方法，使用sizeof计算数组大小</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define GET_ARRAY_LEN(arr, len) (len &#x3D; sizeof(arr) &#x2F; sizeof(arr[0])) int main(void) &#123;int arr1[2] &#x3D; &#123; 1,2 &#125;;int arr2[4] &#x3D; &#123; 1,2,3,4 &#125;;int arr3[8] &#x3D; &#123; 1,2,3,4,5,6,7,8 &#125;;int len &#x3D; 0;GET_ARRAY_LEN(arr1, len);&#x2F;&#x2F; 明了for (int i &#x3D; 0; i &lt; len; i++) &#123;printf(&quot;%d &quot;, arr1[i]);&#125;printf(&quot;\n&quot;);GET_ARRAY_LEN(arr2, len);for (int i &#x3D; 0; i &lt; len; i++) &#123;printf(&quot;%d &quot;, arr2[i]);&#125;printf(&quot;\n&quot;);GET_ARRAY_LEN(arr3, len);for (int i &#x3D; 0; i &lt; len; i++) &#123;printf(&quot;%d &quot;, arr3[i]);&#125;printf(&quot;\n&quot;);&#125;</code></pre></div></figure><blockquote><p>注意事项：</p><p>记录踩的坑…….</p><p>数组当参数传入的时候，sizeof会计算形参的大小，而不是计算实参的大小。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;void printArr(int *arr) &#123;int len &#x3D; 0;GET_ARRAY_LEN(arr, len);printf(&quot;array size &#x3D; %d\n&quot;, len);&#x2F;&#x2F; 无论实参传入什么数组，输出的array size都是2，因为它只计算这个指针的大小for (int i &#x3D; 0; i &lt; len; i++) &#123;printf(&quot;%d &quot;, arr[i]);&#125;printf(&quot;\n&quot;);&gt;&#125;</code></pre></div></figure><p>arry size &#x3D; 2的来源。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&gt;int *arr &#x3D; NULL;&gt;sizeof(arr) &#x3D; 8;&gt;sizeof(arr[0]) &#x3D; 4;&gt;sizeof(arr) &#x2F; sizeof(arr[0]) &#x3D; 2;</code></pre></div></figure></blockquote><h2 id="2-4-多维数组"><a href="#2-4-多维数组" class="headerlink" title="2.4 多维数组"></a>2.4 多维数组</h2><p>二维、三维、四维….数组，都叫做多维数组，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 定义一个3行4列的数组int matrix[3][4];</code></pre></div></figure><h3 id="2-4-1-二维数组"><a href="#2-4-1-二维数组" class="headerlink" title="2.4.1 二维数组"></a>2.4.1 二维数组</h3><p>二维数组在内存中的状态，以<code>matrix[3][4]</code>为例</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">1,2,3,45,6,7,89,10,11,12  0行  1行 2行  </code></pre></div></figure><p><strong>二维数组的初始化：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int matrix[3][4] &#x3D; &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; </code></pre></div></figure><p>可以省略行，其余的会默认补充为0</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int matrix[3][4] &#x3D; &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;&#125;; &#x2F;&#x2F; 省略一行</code></pre></div></figure><p>也可以省略列，其余元素也会默认补充为0</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int matrix[3][4] &#x3D; &#123;&#123;1,2,3&#125;, &#123;5,6,7&#125;&#125;; &#x2F;&#x2F; 省略一行 + 一列</code></pre></div></figure><p>甚至可以省略大括号【不建议】</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int matrix[3][4] &#x3D; &#123;1,2,3,4, 5,6,7,8, 9,10,11,12&#125;; </code></pre></div></figure><p>全部初始化0：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int matrix[3][4] &#x3D; &#123;0&#125;;</code></pre></div></figure><p><strong>可以由编译器判断行的大小：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int matrix[][4] &#x3D; &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; </code></pre></div></figure><blockquote><p>注意事项：</p><p><strong>不能省略列的大小</strong></p></blockquote><h3 id="2-4-2-常量数组"><a href="#2-4-2-常量数组" class="headerlink" title="2.4.2 常量数组"></a>2.4.2 常量数组</h3><p>常量数组的元素不会发生改变，案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">const int matrix[][4] &#x3D; &#123;&#123;1,2,3,4&#125;, &#123;2,2,3,4&#125;&#125;;matrix[1][0] &#x3D; 3; &#x2F;&#x2F; Error!元素不能修改</code></pre></div></figure><h2 id="2-5-数组实战：随机发牌小程序"><a href="#2-5-数组实战：随机发牌小程序" class="headerlink" title="2.5 数组实战：随机发牌小程序"></a>2.5 数组实战：随机发牌小程序</h2><p>用户指定发几张牌，程序打印出手牌（52张，去除大小鬼），使用效果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">请输入需要发的牌数:22h4 h9 cT hJ sT dK s7 d9 s6 dA h8 h7 cK cA hT c8 cQ c4 s4 s5 sQ h6</code></pre></div></figure><p>案例代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;&#x2F;&#x2F; 用于bool#include &lt;stdlib.h&gt;&#x2F;&#x2F; 用于srand&#x2F;&#x2F; 定义花色数量#define NUM_SUITS 4&#x2F;&#x2F; 定义牌号数量#define NUM_RANKS 13int main(void) &#123;&#x2F;&#x2F; 定义牌组和花色：黑桃（Spade）、红桃（Heart）、方块（Diamond）、梅花（Club）const char suits[NUM_SUITS] &#x3D; &#123; &#39;s&#39;, &#39;h&#39;, &#39;d&#39;, &#39;c&#39; &#125;;const char ranks[NUM_RANKS] &#x3D; &#123; &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;T&#39;,&#39;J&#39;, &#39;Q&#39;, &#39;K&#39;&#125;;&#x2F;&#x2F; 手里已有的牌组，全部初始化为false，表示都没有bool inhand[NUM_SUITS][NUM_RANKS] &#x3D; &#123; false &#125;;&#x2F;&#x2F; 提示输入printf(&quot;请输入需要发的牌数:&quot;);int n &#x3D; 0;scanf(&quot;%d&quot;, &amp;n);&#x2F;&#x2F; 随机数种子srand((unsigned)time(NULL));&#x2F;&#x2F; 发牌while (n &gt; 0) &#123;&#x2F;&#x2F; 产生随机花色、牌号int suit &#x3D; rand() % NUM_SUITS; &#x2F;&#x2F; %控制范围0-3int rank &#x3D; rand() % NUM_RANKS; &#x2F;&#x2F; %控制范围0-12&#x2F;&#x2F; 判断手牌是否存在if (inhand[suit][rank] &#x3D;&#x3D; false) &#123;&#x2F;&#x2F; 不存在，则插入手牌inhand[suit][rank] &#x3D; true;n--;&#x2F;&#x2F; 打印手牌printf(&quot;%c%c &quot;, suits[suit], ranks[rank]);&#125;&#125;printf(&quot;\n&quot;);&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day03</title>
    <link href="/2024/03/07/04_C++/01_C%E8%AF%AD%E8%A8%80/day03/"/>
    <url>/2024/03/07/04_C++/01_C%E8%AF%AD%E8%A8%80/day03/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day03”</p><h1 id="一、类型转换"><a href="#一、类型转换" class="headerlink" title="一、类型转换"></a>一、类型转换</h1><p>为什么需要类型转换？</p><ul><li>计算机硬件只能对“相同类型”的数据进行运算</li></ul><p>何时会发生类型转换？</p><ul><li>当给定的数据类型和需要的数据类型不匹配时</li></ul><p>如何进行类型转换？</p><ul><li>隐式类型转换：编译器做的类型转换</li><li>显示类型转换：又叫强制类型转换，是程序员手动进行的转换</li></ul><h2 id="1-1-隐式类型转换"><a href="#1-1-隐式类型转换" class="headerlink" title="1.1 隐式类型转换"></a>1.1 隐式类型转换</h2><p>隐式类型转换默认存在两条规则</p><p>第一条：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">short,char --&gt; int --&gt; long --&gt; long long --&gt; float --&gt; double</code></pre></div></figure><p>第二条:</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">signed --&gt; unsigned</code></pre></div></figure><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int i &#x3D; -1;unsigned int u &#x3D; 100;if (i &lt; u) &#123;    printf(&quot;i  is less than u\n&quot;);&#125;else &#123;    printf(&quot;i  is greater than u\n&quot;); &#x2F;&#x2F; 是它 why?&#125;</code></pre></div></figure><p>此案例的结果输出为”i  is greater than u”，因为当<code>变量i</code>去和<code>unsigned int类型的变量u</code>对比时，<code>变量i</code>会隐式转换为<code>unsigned int类型</code>：i十六进制表示为0xFFFFFFFF，u的十六进制表示为0x00000064，因此i比u大</p><p><strong>避免这样使用！</strong></p><h2 id="1-2-强制类型转换"><a href="#1-2-强制类型转换" class="headerlink" title="1.2 强制类型转换"></a>1.2 强制类型转换</h2><p>让程序员更精确地控制类型转换</p><p><strong>案例一：计算浮点数的小数部分</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">double d &#x3D; 3.14, fraction;fraction &#x3D; d - (int)d;&#x2F;&#x2F; 强转为int类型printf(&quot;fration &#x3D; %.2lf\n&quot;, fraction);&#x2F;&#x2F; 输出0.14</code></pre></div></figure><p><strong>案例二：使代码可读性更高</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">float f &#x3D; 3.14f;int i &#x3D; (int)f;&#x2F;&#x2F; 一目了然</code></pre></div></figure><p><strong>案例三：对类型转换进行更精确的控制</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int d1 &#x3D; 4, d2 &#x3D; 3;double q;q &#x3D; d1 &#x2F; d2; printf(&quot;q &#x3D; %lf\n&quot;, q); &#x2F;&#x2F; 输出1.000000q &#x3D; (double)d1 &#x2F; d2;printf(&quot;q &#x3D; %lf\n&quot;, q); &#x2F;&#x2F; 输出1.333333</code></pre></div></figure><p><strong>案例四：避免数据溢出)</strong>(计算一天多少毫秒，多少纳秒</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 一天多少毫秒long long millisPerday &#x3D; 24 * 60 * 60 * 1000;&#x2F;&#x2F; 一天多少纳秒long long nanosPersday &#x3D; 24 * 60 * 60 * 1000 * 1000 * 1000;printf(&quot;%lld\n&quot;, nanosPersday &#x2F; millisPerday);&#x2F;&#x2F; 结果不是10000，居然是-21？？</code></pre></div></figure><p>为什么结果是-21？</p><p>因为24、60、1000都是int类型的，相乘后<strong>也是int类型</strong>，在nanosPerday的乘法计算后，已经超出了int的范围（-2147483648到2147483647）</p><p>解决方法：强转为long long类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 一天多少纳秒long long nanosPersday &#x3D; (long long)24 * 60 * 60 * 1000 * 1000 * 1000;</code></pre></div></figure><h1 id="二、运算符"><a href="#二、运算符" class="headerlink" title="二、运算符"></a>二、运算符</h1><h2 id="2-1-typedef（TODO可以补充）"><a href="#2-1-typedef（TODO可以补充）" class="headerlink" title="2.1 typedef（TODO可以补充）"></a>2.1 typedef（TODO可以补充）</h2><p>typedef用于给类型起别名，例如</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;&#x2F;&#x2F; 给int起别名Booltypedef int Bool; &#x2F;&#x2F; 其实也能用宏定义来起别名#define Bool2 intint main(void) &#123;Bool b &#x3D; 1;printf(&quot;b &#x3D; %d\n&quot;, b);Bool2 b2 &#x3D; 200;printf(&quot;b2 &#x3D; %d\n&quot;, b2);return 0;&#125;</code></pre></div></figure><blockquote><p>Q1：当定义别名时，使用typdef和使用宏定义的区别是什么？</p><p>宏定义是在预处理阶段做<strong>简单的文本替换</strong>，因此当编译器识别宏定义，当错误发生时不能给出一些友好的提示，而typedef定义的别名，是在编译阶段生效，可以在错误发生时给出提示</p><p><strong>因此：定义类型的时候，请使用typedef</strong></p></blockquote><p>使用变量起别名的好处：</p><ul><li>增强代码可读性</li><li>增强大码可移植性</li></ul><h2 id="2-2-sizeof运算符"><a href="#2-2-sizeof运算符" class="headerlink" title="2.2 sizeof运算符"></a>2.2 sizeof运算符</h2><p>sizeof运算符用于计算某个数据类型所占的空间大小（单位：字节）</p><p>注意事项：</p><ol><li>sizeof是运算符，不是函数</li><li>sizeof在编译期间进行计算，他是一个常量表达式，可以表示数组的长度，例如</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int i &#x3D; 3;int arr[sizeof(i)];</code></pre></div></figure><h2 id="2-3-算术运算符-TODO公式有问题"><a href="#2-3-算术运算符-TODO公式有问题" class="headerlink" title="2.3 算术运算符(TODO公式有问题)"></a>2.3 算术运算符(TODO公式有问题)</h2><p>加(+)减(-)乘(*)除(&#x2F;)、以及取模(%)</p><p>注意事项：</p><ol><li>其中加减乘除可以用于浮点数，但是取模要求两个操作数都是整数</li><li>两个整数相除，其结果也是整数</li><li><code>i%j</code>的结果可能为负数，符号与<code>i</code>的符号相同，满足公式：<code>（缺失）</code>，比如：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">4 % 3 &#x3D; 1;-4 % 3 &#x3D; -1;4 % -3 &#x3D; 1;-4 % -3 &#x3D; -1;</code></pre></div></figure><p>取余的案例：判断一个数字是否为奇数</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool is_odd(int n) &#123;&#x2F;&#x2F; return n % 2 &#x3D;&#x3D; 1;&#x2F;&#x2F; 不推荐，不严谨，当n为负数时会出问题return n % 2 !&#x3D; 0;&#x2F;&#x2F; 推荐return n &amp; 1; &#x2F;&#x2F; 推荐，代码量最少，可读性较差&#125;</code></pre></div></figure><h2 id="2-4-赋值运算符"><a href="#2-4-赋值运算符" class="headerlink" title="2.4 赋值运算符"></a>2.4 赋值运算符</h2><h3 id="2-4-1-简单赋值"><a href="#2-4-1-简单赋值" class="headerlink" title="2.4.1 简单赋值"></a>2.4.1 简单赋值</h3><p>案例</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">float f;int i;f &#x3D; i &#x3D; 3.14f;输出: f &#x3D; 3.0 i &#x3D; 3</code></pre></div></figure><blockquote><p>注意事项：</p><ol><li>赋值过程中可能有隐式转换，例如<code>int i = 3.14;</code>，隐式转换为int类型</li><li>赋值是从右到左的，例如：<code>a = b = 30;</code></li></ol></blockquote><h3 id="2-4-2-复合赋值"><a href="#2-4-2-复合赋值" class="headerlink" title="2.4.2 复合赋值"></a>2.4.2 复合赋值</h3><p>+&#x3D;-&#x3D;*&#x3D;&#x2F;&#x3D;</p><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">a +&#x3D; b&#x2F;&#x2F; 等同于a &#x3D; a + b</code></pre></div></figure><h2 id="2-5-自增和自减运算符"><a href="#2-5-自增和自减运算符" class="headerlink" title="2.5 自增和自减运算符"></a>2.5 自增和自减运算符</h2><p>自增表示为++，自减表示为–：</p><ul><li>i++：表达式的值为i，副作用是i自增</li><li>++i：表达式的值为（i++），副作用是i自增</li></ul><p>自增的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int i, j, k;i &#x3D; 1;j &#x3D; 2;k &#x3D; ++i + j++;printf(&quot;i &#x3D; %d, j &#x3D; %d, k &#x3D; %d\n&quot;, i, j, k);&#x2F;&#x2F; 2 3 4</code></pre></div></figure><h2 id="2-6-关系运算符"><a href="#2-6-关系运算符" class="headerlink" title="2.6 关系运算符"></a>2.6 关系运算符</h2><p>包含：小于&lt;，大于，大于等于&gt;&#x3D;，小于等于&lt;&#x3D;</p><blockquote><p>注意事项：</p><p><code>i &lt; j &lt; k</code>怎么计算？</p><p>先计算（i &lt; j），得到的结果（0&#x2F;1）后，再计算（0&#x2F;1）&lt; k，因此，</p><p>正确的写法是：<code>j &lt; i &amp;&amp; j&lt; k;</code></p></blockquote><h2 id="2-7-判等运算符"><a href="#2-7-判等运算符" class="headerlink" title="2.7 判等运算符"></a>2.7 判等运算符</h2><p>包含：&#x3D;&#x3D;，!&#x3D;</p><p>其运算结果要么为0，要么为1</p><h2 id="2-8-逻辑运算符"><a href="#2-8-逻辑运算符" class="headerlink" title="2.8 逻辑运算符"></a>2.8 逻辑运算符</h2><p>包含：与&amp;&amp;，或||，非！</p><blockquote><p>注意事项：</p><p><code>&amp;&amp;</code>和<code>||</code>会发生短路现象，例如：</p><ol><li><code>e1 &amp;&amp; e2</code>：先计算e1表达式，若e1为false，则不再计算e2</li><li><code>e1 || e2</code>：先计算e1表达式，若e1为true，则不再计算e2</li></ol></blockquote><h2 id="2-9-位运算符（TODO需要补充位运算的知识）"><a href="#2-9-位运算符（TODO需要补充位运算的知识）" class="headerlink" title="2.9 位运算符（TODO需要补充位运算的知识）"></a>2.9 位运算符（TODO需要补充位运算的知识）</h2><p>分为：</p><ul><li>左移&lt;&lt;</li><li>右移&gt;&gt;</li><li>与</li><li>或|</li><li>非^</li><li>异或~：相同为0，不同为1</li></ul><h3 id="2-9-1-左移右移"><a href="#2-9-1-左移右移" class="headerlink" title="2.9.1 左移右移"></a>2.9.1 左移右移</h3><p>1、左移案例：</p><p><code> i &lt;&lt; j</code>，表示将i左移j位，在右边补0</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">short s &#x3D; 13;printf(&quot;%d\n&quot;, s &lt;&lt; 2);&#x2F;&#x2F; 输出52</code></pre></div></figure><p>二进制数13，用位表示：00001101，左移2位之后，是00110100，转换后为4+16+32 &#x3D; 52，若没有发生溢出，<strong>左移j位，相当于乘以2^j</strong>，如13左移2位 &#x3D; 13 * 2 ^ 2 &#x3D; 13 * 4 &#x3D; 52</p><p>2、右移案例</p><p><code>i &gt;&gt; j</code>，表示将i右移j位，若<strong>i为无符号数，或者非负数</strong>，则左补0，<strong>若i为负数</strong>，它的行为由实现定义，有的左补0，有的左补1</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">short s &#x3D; 13;printf(&quot;%d\n&quot;, s &gt;&gt; 2);&#x2F;&#x2F; 输出3</code></pre></div></figure><h3 id="2-9-2-按位运算"><a href="#2-9-2-按位运算" class="headerlink" title="2.9.2 按位运算"></a>2.9.2 按位运算</h3><p><strong>1、按位取反(~)</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">short i &#x3D; 3, j &#x3D; 4;printf(&quot;i &#x3D; %d, j &#x3D; %d\n&quot;, ~i, ~j);&#x2F;&#x2F; -4 -5</code></pre></div></figure><p>以i为例：0000 0000 0000 0000 0011，取反之后为 1111 1111 1111 1100，结果是-4（TODO 我不知道怎么算的，而且怎么一下是8位，一下是16位！！）</p><p><strong>2、异或的几个特性</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">a ^ 0 &#x3D; a;a ^ a &#x3D; a;a ^ b &#x3D; b ^ a;&#x2F;&#x2F; 交换性a ^ ( b ^ c ) &#x3D; ( a ^ b ) ^ c &#x2F;&#x2F; 结合性</code></pre></div></figure><p><strong>3、使用案例：</strong></p><p><em>案例1</em>：如何判断一个数是否是奇数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool is_odd(int a) &#123;return a &amp; 0x1;&#x2F;&#x2F; 与1按位与&#125;</code></pre></div></figure><p><em>案例2</em>：判断一个数是否为2的幂数【TODO 补充方法1】</p><p>方法1：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool isPowerOf2(unsigned int num) </code></pre></div></figure><p>方法2：利用特性，2的幂次只有1一个1</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool isPowerOf2_2(unsigned int num) &#123;return (num &amp; num - 1) &#x3D;&#x3D; 0;&#125;</code></pre></div></figure><p><em>案例3</em>：给定一个不为0的整数，找出值为1，且权重最低的位，如输入0011 0100，输出4</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 两种方法都可以((n ^ n - 1) + 1) &gt;&gt; 1n &amp; (-n)</code></pre></div></figure><p><em>案例4</em>：给定一个整数数组，里面的数都是成对的，只有一个数例外，请找出它：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int findSigleNum(int arr[], int n) &#123;int sigleNum &#x3D; 0;for (int i &#x3D; 0; i &lt; n; i++) &#123;sigleNum ^&#x3D; arr[i];&#125;return sigleNum;&#125;&#x2F;&#x2F; 测试int arr[10] &#x3D; &#123; 1,1,2,2,4,5,5,6,6 &#125;;printf(&quot;%d\n&quot;, findSigleNum(arr, 10));&#x2F;&#x2F; 4</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day02</title>
    <link href="/2024/03/06/04_C++/01_C%E8%AF%AD%E8%A8%80/day02/"/>
    <url>/2024/03/06/04_C++/01_C%E8%AF%AD%E8%A8%80/day02/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day02”</p><h1 id="一、格式化输入和输出"><a href="#一、格式化输入和输出" class="headerlink" title="一、格式化输入和输出"></a>一、格式化输入和输出</h1><h2 id="1-1-格式化输出"><a href="#1-1-格式化输出" class="headerlink" title="1.1 格式化输出"></a>1.1 格式化输出</h2><p>格式化输出代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">int num &#x3D; 10;printf(&quot;num &#x3D;  %d\n&quot;, num);</code></pre></div></figure><p>其中<code>%d</code>代表以整型形式解释这篇内存空间，并以十进制方式输出</p><h3 id="1-1-1-格式化输出的转换说明"><a href="#1-1-1-格式化输出的转换说明" class="headerlink" title="1.1.1 格式化输出的转换说明"></a>1.1.1 格式化输出的转换说明</h3><p>格式：<code>%m.pX</code></p><p>X：以何种方式解释这片内存空间，如%d, %f</p><p>m：最大字段宽度，可以省略不写</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;%4d\n&quot;, 1234);&#x2F;&#x2F; 输出：1234，正常按字段宽度输出printf(&quot;%4d\n&quot;, 123);&#x2F;&#x2F; 输出： 123，默认右对齐输出，少的字段用空格填充printf(&quot;%-4d\n&quot;, 123);&#x2F;&#x2F; 输出：123，改为左对齐输出printf(&quot;%4d\n&quot;, 12345);&#x2F;&#x2F; 输出：12345，可以自动扩展宽度</code></pre></div></figure><p>p：精度，用于控制浮点数的小数位</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;%f\n&quot;, 3.1415926);&#x2F;&#x2F; 输出: 3.141592, 默认6位小数printf(&quot;%.0f\n&quot;, 3.1415926); &#x2F;&#x2F; 输出：3printf(&quot;%.3f\n&quot;, 3.1415926); &#x2F;&#x2F; 输出：3.141</code></pre></div></figure><h2 id="1-2-格式化输入"><a href="#1-2-格式化输入" class="headerlink" title="1.2 格式化输入"></a>1.2 格式化输入</h2><p>使用<code>scanf</code>格式化输入的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int num &#x3D; 0;int success &#x3D; 0;printf(&quot;请输入一个整数: &quot;);success &#x3D; scanf(&quot;%d&quot;, &amp;num);&#x2F;&#x2F; 返回值为处理成功的个数</code></pre></div></figure><p>对于字符串：</p><ul><li>普通字符：精确匹配</li><li>空白字符：可以匹配任意多个【前置】空白字符，包括0个</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char name[60] &#x3D; &quot;&quot;;printf(&quot;请输入一串字符: &quot;);scanf(&quot;%s&quot;, &amp;name);printf(&quot;name &#x3D; %s\n&quot;, name);</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">输入：haris输出：name &#x3D; haris    输入：haris gong输出：name &#x3D; haris&#x2F;&#x2F; 空格后面的内容被忽略了输入：             haris输出：name &#x3D; haris&#x2F;&#x2F; 前面的空格不影响</code></pre></div></figure><h3 id="1-2-1-格式化输入的练习"><a href="#1-2-1-格式化输入的练习" class="headerlink" title="1.2.1 格式化输入的练习"></a>1.2.1 格式化输入的练习</h3><p>练习一：了解分割</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">scanf(&quot;%d%d%f%f&quot;, &amp;i, &amp;j, &amp;f, &amp;g);printf(&quot;i &#x3D; %d, j &#x3D; %d, f &#x3D; %f, g &#x3D; %f\n&quot;, i, j, f, g);&#x2F;&#x2F; 输入1-20.3-4.0e3    &#x2F;&#x2F; 输出i &#x3D; 1, j &#x3D; -20, f &#x3D; 0.300000, g &#x3D; -4000.000000</code></pre></div></figure><p>练习二：空格的影响</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int i, j;scanf(&quot;%d%d&quot;, &amp;i, &amp;j);printf(&quot;i &#x3D; %d, j &#x3D; %d&quot;, i, j);&#x2F;&#x2F; 输入 5 &#x2F; 96     &#x2F;&#x2F; 输出i &#x3D; 5, j &#x3D; -858993460</code></pre></div></figure><p>为什么j的值会异常？因为scanf只匹配前面的空白字符，<code>空5空/空96</code>在第二个<code>空</code>时已经没有匹配上了，此时scanf函数已返回，后面的字符也不会匹配</p><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="2-1-整数类型"><a href="#2-1-整数类型" class="headerlink" title="2.1 整数类型"></a>2.1 整数类型</h2><p>整数类型分为：</p><p>​有符号整数：short、int、long、long long 等</p><p>​无符号整数：unsigned short、unsigned int、等</p><blockquote><p>注意事项：</p><p>​1、在C语言中不明确规定个类型的字节大小，跟随机器不同有所变化</p><p>​2、但C语言规定了各种类型的最小大小，如int类型，最小2字节</p><p>​3、正常整型类型的大小排序符合基本规则：short &lt; int &lt; long &lt; long long</p></blockquote><p>在C语言中定义一个整数的代码:</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 有符号整数int num  &#x3D; -10;&#x2F;&#x2F; 无符号整数unsigned int num &#x3D; 10;</code></pre></div></figure><h3 id="2-1-1-整数编码（重要）"><a href="#2-1-1-整数编码（重要）" class="headerlink" title="2.1.1 整数编码（重要）"></a>2.1.1 整数编码（重要）</h3><p>编码：1001 0011</p><p>对于无符号(unsigned)整数，该编码代表147</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">2^7 + 0 + 0 + 2^4 + 0 + 0 + 2^1 + 2^0 &#x3D; 147</code></pre></div></figure><p>对于有符号整数，该编码代表-109</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">1001 0011&#x2F;&#x2F; 第一个1代表负号权重    -2^7 + 0 + 0 + 2^4 + 0 + 0 + 2^1 + 2^0 &#x3D; -109</code></pre></div></figure><p>为什么有符号整数会采用补码的方式？有利于CPU计算</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">可以利用加法器做减法运算：a - b &#x3D; a + (-b)</code></pre></div></figure><h3 id="2-1-2-整数的读写"><a href="#2-1-2-整数的读写" class="headerlink" title="2.1.2 整数的读写"></a>2.1.2 整数的读写</h3><p>读写整数：</p><ul><li>%u无符号十进制整数</li><li>%o无符号八进制整数</li><li>%x 无符号十六进制整数</li><li>%d有符号十进制整数</li></ul><p>读写短整数：</p><ul><li>在u、o、x、d前面加h，如<code>%hd</code></li></ul><p>读写长整数：</p><ul><li>在u、o、x、d前面加l，如<code>%ld</code></li></ul><p>读写长整数：</p><ul><li>在u、o、x、d前面加ll，如<code>%lld</code></li></ul><h2 id="2-2-浮点数类型"><a href="#2-2-浮点数类型" class="headerlink" title="2.2 浮点数类型"></a>2.2 浮点数类型</h2><p>浮点类型分为：</p><ul><li>float单精度</li><li>double 双精度</li><li>long double用于高精度计算，一般用不到</li></ul><h3 id="2-2-1-浮点常量"><a href="#2-2-1-浮点常量" class="headerlink" title="2.2.1 浮点常量"></a>2.2.1 浮点常量</h3><p>浮点数有多种表示方式，要么包含小数点，要么包含字母，如</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">57.057.5.70e1.57e2570e-1</code></pre></div></figure><p>浮点常量默认是double类型，如需要表示float，需要在后面加上<code>f</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">float f;f &#x3D; 1.0f;&#x2F;&#x2F; 不加f默认就是double类型</code></pre></div></figure><h3 id="2-2-2-浮点数的读写"><a href="#2-2-2-浮点数的读写" class="headerlink" title="2.2.2 浮点数的读写"></a>2.2.2 浮点数的读写</h3><ul><li>%ffloat类型读写</li><li>%lfdouble类型读写</li></ul><h2 id="2-3-字符类型"><a href="#2-3-字符类型" class="headerlink" title="2.3 字符类型"></a>2.3 字符类型</h2><p>字符类型的定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char c &#x3D; &#39;a&#39;;</code></pre></div></figure><p>char类型大小为1字节，并采用ASC码表示</p><blockquote><p>注意事项：</p><p>​C语言把字符类型当做整型来使用，因此可以进行算术计算，如</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char c &#x3D; &#39;a&#39;;printf(&quot;%d\n&quot;, c);&#x2F;&#x2F; 输出97printf(&quot;%d\n&quot;, c + 8);&#x2F;&#x2F; 输出105printf(&quot;%c\n&quot;, c + 8);&#x2F;&#x2F; 输出&#39;i&#39;,对标ASC码</code></pre></div></figure></blockquote><h3 id="2-3-1-转义序列"><a href="#2-3-1-转义序列" class="headerlink" title="2.3.1 转义序列"></a>2.3.1 转义序列</h3><p>转义序列，是不能直接输入的字符，带有特殊功能，分为两种：</p><p>字符转义序列：</p><ul><li>\aalert</li><li>\n newline</li><li>\bbackspce</li></ul><p>数字转义序列：</p><ul><li>八进制表示形式，以<code>\</code>开头，后面最多接3个8进制数</li><li>十六进制表示形式，以<code>\x</code>开头，后面接十六进制数</li></ul><h3 id="2-3-2-读写字符"><a href="#2-3-2-读写字符" class="headerlink" title="2.3.2 读写字符"></a>2.3.2 读写字符</h3><p><strong>方法一：</strong>使用<code>scanf</code>和<code>prinf</code>函数输入输出</p><p>字符的读写使用<code>%c</code>，使用的时候注意它默认不会忽略空格</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char c &#x3D; &#39;a&#39;;&#x2F;&#x2F; 一般用法scanf(&quot;%c&quot;, &amp;c);&#x2F;&#x2F; 输入:空格空格t， 输出：空格&#x2F;&#x2F; 推荐用法scanf(&quot; %c&quot;, &amp;c);&#x2F;&#x2F; 输入:空格空格t， 输出：t， 将自动忽略前面的空格</code></pre></div></figure><p><strong>方法二：</strong>使用<code>getchar</code>和<code>putchar</code>函数输入输出</p><p>一般使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char c &#x3D; &#39;a&#39;;c &#x3D; getchar();&#x2F;&#x2F; 注意，也不会忽视前面的空格putchar(c);</code></pre></div></figure><p>惯用法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">while(getchar() !&#x3D; &#39;\n&#39;); &#x2F;&#x2F; 用于读取一行剩余的字符</code></pre></div></figure><h2 id="2-4-布尔类型"><a href="#2-4-布尔类型" class="headerlink" title="2.4 布尔类型"></a>2.4 布尔类型</h2><p>布尔类型从C99开始定义，放在<code>&lt;stdbool.h&gt;</code>头文件中</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdbool.h&gt;int main(void) &#123;bool flag1, flag2, flag3, flag4, flag5;&#x2F;&#x2F; 正常赋值flag1 &#x3D; true;&#x2F;&#x2F; 1flag2 &#x3D; false;&#x2F;&#x2F; 0&#x2F;&#x2F; 赋值数字会怎样？flag3 &#x3D; 1999;&#x2F;&#x2F; 1flag4 &#x3D; -19321;&#x2F;&#x2F; 1flag5 &#x3D; 0;&#x2F;&#x2F; 0&#125;</code></pre></div></figure><blockquote><p>注意事项：</p><p>​bool类型赋值，如赋值非零数，则为true，只有当赋值为0时，才是false</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鲲鹏服务器性能测试最佳实践</title>
    <link href="/2024/01/30/02_%E6%B5%8B%E8%AF%95/08_%E9%B2%B2%E9%B9%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/01/30/02_%E6%B5%8B%E8%AF%95/08_%E9%B2%B2%E9%B9%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="鲲鹏服务器性能测试最佳实践"><a href="#鲲鹏服务器性能测试最佳实践" class="headerlink" title="鲲鹏服务器性能测试最佳实践"></a>鲲鹏服务器性能测试最佳实践</h1><h1 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h1><p>操作系统：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ceshi]# cat &#x2F;etc&#x2F;openEuler-releaseopenEuler release 22.03 LTS#uname -aLinux localhost.localdomain 5.10.0-60.18.0.50.oe2203.aarch64 #1 SMP Wed Mar 30 02:43:08 UTC 2022 aarch64 aarch64 aarch64 GNU&#x2F;Linux</code></pre></div></figure><p>CPU信息（鲲鹏920 &#x2F; 128核）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Architecture:           aarch64  CPU op-mode(s):       64-bit  Byte Order:           Little EndianCPU(s):                 128  On-line CPU(s) list:  0-127Vendor ID:              HiSilicon  BIOS Vendor ID:       HiSilicon  Model name:           Kunpeng-920    BIOS Model name:    Kunpeng 920-6426    Model:              0    Thread(s) per core: 1    Core(s) per socket: 64    Socket(s):          2    Stepping:           0x1    BogoMIPS:           200.00    Flags:              fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimddp asimdfhmCaches (sum of all):  L1d:                  8 MiB (128 instances)  L1i:                  8 MiB (128 instances)  L2:                   64 MiB (128 instances)  L3:                   256 MiB (4 instances)NUMA:  NUMA node(s):         4  NUMA node0 CPU(s):    0-31  NUMA node1 CPU(s):    32-63  NUMA node2 CPU(s):    64-95  NUMA node3 CPU(s):    96-127Vulnerabilities:  Itlb multihit:        Not affected  L1tf:                 Not affected  Mds:                  Not affected  Meltdown:             Not affected  Spec store bypass:    Vulnerable  Spectre v1:           Mitigation; __user pointer sanitization  Spectre v2:           Not affected  Srbds:                Not affected  Tsx async abort:      Not affected</code></pre></div></figure><p>测试服务器软件配置清单</p><table><thead><tr><th>软件项</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>SPEC CPU2017</td><td>1.0.5</td><td></td></tr></tbody></table><p>内存512G（16 x 32G）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ceshi]# free -m               total        used        free      shared  buff&#x2F;cache   availableMem:          513391        9983      502466          27         941      501290Swap:           4095           0        4095[root@localhost ceshi]# dmidecode  | grep -i mem | grep 2666        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s        Configured Memory Speed: 2666 MT&#x2F;s[root@localhost ceshi]# dmidecode  | grep -i mem | grep 2666 | wc -l16</code></pre></div></figure><h1 id="1、SPEC-CPU2017测试"><a href="#1、SPEC-CPU2017测试" class="headerlink" title="1、SPEC CPU2017测试"></a>1、SPEC CPU2017测试</h1><h2 id="1-1-整型rate测试"><a href="#1-1-整型rate测试" class="headerlink" title="1.1 整型rate测试"></a>1.1 整型rate测试</h2><p>准备测试工具</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">spec镜像文件:cpu2017-1.0.5.isoopenEuler镜像文件:毕昇编译器:spec2017配置文件:</code></pre></div></figure><p>安装SPEC CPU 2017的依赖（如已有则忽略）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"></code></pre></div></figure><p>挂载镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mount cpu2017-1.0.5.iso &#x2F;mnt</code></pre></div></figure><p>安装SPEC 2017，指定安装到<code>/home/spec2017</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;mnt.&#x2F;install.sh -d &#x2F;ceshi&#x2F;SPEC2017&#x2F;spectest</code></pre></div></figure><p>安装毕昇编译器（1.3.3版本）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载地址https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;kunpeng&#x2F;archive&#x2F;compiler&#x2F;bisheng_compiler&#x2F;bisheng-compiler-1.3.3-aarch64-linux.tar.gz# 解压安装包tar -vxf bisheng-compiler-1.3.3-aarch64-linux.tar.gz# 查看目录[root@localhost spectest]# ls &#x2F;usr&#x2F;local&#x2F;BSC133&#x2F;bin  include  lib  libexec  share</code></pre></div></figure><p>设置编译器环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LLVM_DIR&#x3D;&#x2F;usr&#x2F;local&#x2F;BSC133&#x2F;</code></pre></div></figure><p>安装鲲鹏数学库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载地址 https:&#x2F;&#x2F;www.hikunpeng.com&#x2F;developer&#x2F;boostkit&#x2F;library&#x2F;math# 安装[root@localhost iso]# rpm -ivh boostkit-kml-2.2.0-1.aarch64.rpmVerifying...                          ################################# [100%]Preparing...                          ################################# [100%]</code></pre></div></figure><p>安装大页内存编译包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载地址https:&#x2F;&#x2F;repo.almalinux.org&#x2F;almalinux&#x2F;8&#x2F;BaseOS&#x2F;aarch64&#x2F;os&#x2F;Packages&#x2F;libhugetlbfs-2.21-17.el8.aarch64.rpm# 安装rpm -ivh libhugetlbfs-2.21-17.el8.aarch64.rpm</code></pre></div></figure><p>安装jemalloc</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压源码包tar -xf jemalloc-5.3.0.tar.gz # 编译cd jemalloc-5.3.0 bash autogen.sh mkdir build cd build ..&#x2F;configure  CFLAGS&#x3D;&quot;-march&#x3D;armv8.2-a+crc+fp+crypto -flto&#x3D;32&quot; CXXFLAGS&#x3D;&quot;-march&#x3D;armv8.2-a+crc+fp+crypto -flto&#x3D;32&quot; make -j # 安装make install</code></pre></div></figure><p>安装optimized-routines优化库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压源码包tar -xf optimized-routines-23.01.tar.gz cd optimized-routines-23.01&#x2F;# 编译make ARCH&#x3D;aarch64 -j 8# 拷贝库文件cp -a build&#x2F;lib&#x2F;lib* &#x2F;usr&#x2F;local&#x2F;lib</code></pre></div></figure><p>拷贝cpu2017配置文件到config目录中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># rate配置文件cp cpu2017-kunpeng920-128-rate.cfg &#x2F;ceshi&#x2F;SPEC2017&#x2F;spectest&#x2F;config </code></pre></div></figure><p>拷贝flag文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp Bisheng-compiler-flags.xml &#x2F;ceshi&#x2F;SPEC2017&#x2F;spectest&#x2F;config&#x2F;flag</code></pre></div></figure><p>开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 测试前优化source shrcecho 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_cachesulimit -s unlimited# rate测试nohup runcpu -c cpu2017-kunpeng920-128-rate.cfg  --rebuild --copies 128 --reportable --define fastmath&#x3D;0 --define jemalloc&#x3D;1 --define hugepages&#x3D;0 --nopower --runmode rate --tune base --size refrate intrate &amp;</code></pre></div></figure><h2 id="1-2-浮点测试"><a href="#1-2-浮点测试" class="headerlink" title="1.2 浮点测试"></a>1.2 浮点测试</h2><h2 id="1-3-测试数据"><a href="#1-3-测试数据" class="headerlink" title="1.3 测试数据"></a>1.3 测试数据</h2><table><thead><tr><th>芯片&#x2F;测试项</th><th>intrate</th><th>fprate</th><th>intspeed</th><th>fpspeed</th><th>备注</th></tr></thead><tbody><tr><td>鲲鹏920(128核)</td><td>347（官方数据389）</td><td>266</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="2、SPEC-CPU2006测试"><a href="#2、SPEC-CPU2006测试" class="headerlink" title="2、SPEC CPU2006测试"></a>2、SPEC CPU2006测试</h1>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>海光服务器性能测试最佳实践</title>
    <link href="/2023/12/21/02_%E6%B5%8B%E8%AF%95/07_%E6%B5%B7%E5%85%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/12/21/02_%E6%B5%8B%E8%AF%95/07_%E6%B5%B7%E5%85%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="海光服务器性能测试最佳实践"><a href="#海光服务器性能测试最佳实践" class="headerlink" title="海光服务器性能测试最佳实践"></a>海光服务器性能测试最佳实践</h1><h1 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h1><p>操作系统：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">阿里云OS:AliOS7U2-4.19-x86-64.1.265#uname -aLinux localhost.localdomain 4.19.91-007.ali4000.alios7.x86_64 #1 SMP Wed Apr 8 16:17:43 CST 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linux</code></pre></div></figure><p>CPU信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#lscpu Architecture:          x86_64CPU op-mode(s):        32-bit, 64-bitByte Order:            Little EndianCPU(s):                128On-line CPU(s) list:   0-127Thread(s) per core:    2Core(s) per socket:    32Socket(s):             2NUMA node(s):          8Vendor ID:             HygonGenuineCPU family:            24Model:                 2Model name:            Hygon C86 7380 32-core ProcessorStepping:              2CPU MHz:               2197.285CPU max MHz:           2200.0000CPU min MHz:           1200.0000BogoMIPS:              4399.97Virtualization:        AMD-VL1d cache:             32KL1i cache:             64KL2 cache:              512KL3 cache:              8192KNUMA node0 CPU(s):     0-7,64-71NUMA node1 CPU(s):     8-15,72-79NUMA node2 CPU(s):     16-23,80-87NUMA node3 CPU(s):     24-31,88-95NUMA node4 CPU(s):     32-39,96-103NUMA node5 CPU(s):     40-47,104-111NUMA node6 CPU(s):     48-55,112-119NUMA node7 CPU(s):     56-63,120-127Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid amd_dcm aperfmperf pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb hw_pstate sme ssbd sev ibpb vmmcall fsgsbase bmi1 avx2 smep bmi2 rdseed adx smap clflushopt sha_ni xsaveopt xsavec xgetbv1 xsaves clzero irperf xsaveerptr arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif overflow_recov succor smca</code></pre></div></figure><p>测试服务器软件配置清单</p><table><thead><tr><th>软件项</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>SPEC CPU2017</td><td>1.0.5</td><td></td></tr></tbody></table><h1 id="1、SPEC-CPU2017测试"><a href="#1、SPEC-CPU2017测试" class="headerlink" title="1、SPEC CPU2017测试"></a>1、SPEC CPU2017测试</h1><p>安装SPEC CPU 2017的依赖（如已有则忽略）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install libnsl gcc gcc-c++ glibc.x86_64 glibc.i686 glibc-devel.i686 glibc-devel.x86_64 libstdc++-devel.i686 libstdc++-devel.x86_64 libgcc.i686 libgcc.x86_64 libxml2.i686 libxml2.x86_64 libgfortran libhugetlbfs libnsl.i686 libnsl2.i686 libnsl2 tar perl vim numactl bzip2</code></pre></div></figure><p>挂载镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mount cpu2017-1.0.5.iso &#x2F;mnt</code></pre></div></figure><p>安装SPEC 2017，指定安装到<code>/home/spec2017</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh &#x2F;mnt&#x2F;install.sh -d &#x2F;home&#x2F;cpu2017</code></pre></div></figure><p>上传并解压AOCC优化包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -xf hygon-speccpu2017-aocc2.2.0-20230411.tar.gz -C &#x2F;home&#x2F;cpu2017</code></pre></div></figure><p>上传并解压优化库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -xf libs_opt.tar.gz -C &#x2F;opt</code></pre></div></figure><p>开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;home&#x2F;cpu2017# 根据测试需求调整run.sh中的runcpu测试命令。nohup sh run.sh &amp;</code></pre></div></figure><p>防止fpspeed 628题编译不过</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改&#x2F;home&#x2F;spec2017&#x2F;config文件夹中的speed配置，注释编译选项#-------------------------- fpseed tuning flags ---------------------------------fpspeed:CXX                      &#x3D; clang++ -std&#x3D;c++98LDCFLAGS                 &#x3D; -L$[GLIBC64_DIR] -Wl,-rpath&#x3D;$[GLIBC64_DIR] -Wl,--dynamic-linker&#x3D;$[GLIBC64_DIR]&#x2F;ld-linux-x86-64.so.2LDCXXFLAGS               &#x3D; -L$[GLIBC64_2_30_DIR] -Wl,-rpath&#x3D;$[GLIBC64_2_30_DIR] -Wl,--dynamic-linker&#x3D;$[GLIBC64_2_30_DIR]&#x2F;ld-linux-x86-64.so.2 -Wl,-mllvm -Wl,-suppress-fmasLDFFLAGS                 &#x3D; -L$[GLIBC64_DIR] -Wl,-rpath&#x3D;$[GLIBC64_DIR] -Wl,--dynamic-linker&#x3D;$[GLIBC64_DIR]&#x2F;ld-linux-x86-64.so.2 -ffast-math \                           # 防止628编译不过                           #-Wl,-mllvm -Wl,-inline-recursion&#x3D;4 \                           #-Wl,-mllvm -Wl,-lsr-in-nested-loop \                           #-Wl,-mllvm -Wl,-enable-iv-split</code></pre></div></figure><p>测试数据</p><table><thead><tr><th>芯片&#x2F;测试项</th><th>intrate</th><th>fprate</th><th>intspeed</th><th>fpspeed</th><th>备注</th></tr></thead><tbody><tr><td>7380 (2.2Ghz 单核32核，双路64核，超线程128核，共8个NUMA)</td><td>274 (128 copies)</td><td>256（128 copies）</td><td>6.99（128 threads）</td><td>92.5（64 threads）</td><td>内存32 x 32G，共1024G</td></tr><tr><td>7380 (2.2Ghz 单核32核，双路64核，超线程128核，共8个NUMA)</td><td>211 (128 copies)</td><td>174 (128 copies)</td><td>5.29  (128 threads)</td><td>77.9 (64 threads)</td><td>内存12 x 32G，共384G</td></tr><tr><td>7360  (2.5Ghz 单核24核，双路48核，超线程96核，共8个NUMA)</td><td>231 (96 copies)</td><td>252 (96 copies)</td><td>6.05 (96 threads)</td><td>93.9 (48 threads)</td><td>内存 16 x 32，共512G</td></tr><tr><td>5380 (2.4Ghz 单核16核，双路32核，超线程64核，共4个NUMA)</td><td>110 (64 copies)</td><td>84.6 (64 copies)</td><td>5.32 (64 threads)</td><td>41.7 (32 threads)</td><td>内存12 x 32G，共384G</td></tr></tbody></table><h1 id="2、SPEC-CPU2006测试"><a href="#2、SPEC-CPU2006测试" class="headerlink" title="2、SPEC CPU2006测试"></a>2、SPEC CPU2006测试</h1><h2 id="2-1-实验测试环境"><a href="#2-1-实验测试环境" class="headerlink" title="2.1 实验测试环境"></a>2.1 实验测试环境</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># CPU 海光5380#lscpu Architecture:          x86_64CPU op-mode(s):        32-bit, 64-bitByte Order:            Little EndianCPU(s):                64On-line CPU(s) list:   0-63Thread(s) per core:    2Core(s) per socket:    16Socket(s):             2NUMA node(s):          4Vendor ID:             HygonGenuineCPU family:            24Model:                 2Model name:            Hygon C86 5380 16-core ProcessorStepping:              2CPU MHz:               2496.997BogoMIPS:              5000.21Virtualization:        AMD-VL1d cache:             32KL1i cache:             64KL2 cache:              512KL3 cache:              8192KNUMA node0 CPU(s):     0-7,32-39NUMA node1 CPU(s):     8-15,40-47NUMA node2 CPU(s):     16-23,48-55NUMA node3 CPU(s):     24-31,56-63Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid amd_dcm aperfmperf pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb hw_pstate sme ssbd sev ibpb vmmcall fsgsbase bmi1 avx2 smep bmi2 rdseed adx smap clflushopt sha_ni xsaveopt xsavec xgetbv1 xsaves clzero irperf xsaveerptr arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif overflow_recov succor smca# 内存384G 12 * 32G DDR4 2933#free -m              total        used        free      shared  buff&#x2F;cache   availableMem:         386316        1067      383900           1        1348      383380Swap:          2047           0        2047</code></pre></div></figure><h2 id="2-2-准备测试工具"><a href="#2-2-准备测试工具" class="headerlink" title="2.2 准备测试工具"></a>2.2 准备测试工具</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、SPEC CPU2006的安装镜像cpu2006-1.2.1.iso# 2、海光测试工具包Hygon编译包.rar&#x2F;&#x2F; 建议先在windows改成zip再上传</code></pre></div></figure><h2 id="2-3-安装CPU2006测试工具"><a href="#2-3-安装CPU2006测试工具" class="headerlink" title="2.3 安装CPU2006测试工具"></a>2.3 安装CPU2006测试工具</h2><p>cpu2006的安装路径：<font color=red>**&#x2F;cpu2006-1.2 （写死的！一定要安装到这） **</font></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、将 iso 镜像挂载到&#x2F;mnt路径mount –o loop cpu2006-1.2.iso &#x2F;mnt# 2、进入挂载目录cd &#x2F;mnt# 3、安装： .&#x2F;install.sh –d &#x2F;cpu2006-1.2  </code></pre></div></figure><h2 id="2-4-安装依赖包"><a href="#2-4-安装依赖包" class="headerlink" title="2.4 安装依赖包"></a>2.4 安装依赖包</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ubuntu 系统:apt install libc6:i386 libc6-dev-i386:amd64apt install libc6:amd64 libc6-dev:amd64Centos 系统：yum install -y libstdc++.i686 libstdc++.x86_64 libstdc++-devel.i686 libstdc++-devel.x86_64glibc-devel.i686 glibc-utils.x86_64 numactl</code></pre></div></figure><h2 id="2-5-安装jemalloc库和smartheap库"><a href="#2-5-安装jemalloc库和smartheap库" class="headerlink" title="2.5 安装jemalloc库和smartheap库"></a>2.5 安装jemalloc库和smartheap库</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、将 jemalloc.64-32bit.tar.gz 和 SmartHeap.tar.gz 拷贝到&#x2F;root 路径下cp jemalloc.64-32bit.tar.gz SmartHeap.tar.gz &#x2F;root# 2、解压 tar -xvf jemalloc.64-32bit.tar.gz tar -xvf SmartHeap.tar.gz # 3、创建: smartheap.confvim &#x2F;etc&#x2F;ld.so.conf.d&#x2F;smartheap.conf添加内容： &#x2F;root&#x2F;SmartHeap# 4、创建: jemalloc.conf : vim &#x2F;etc&#x2F;ld.so.conf.d&#x2F;jemalloc.conf添加内容:&#x2F;root&#x2F;jemalloc&#x2F;lib64&#x2F;lib&#x2F;root&#x2F;jemalloc&#x2F;lib32&#x2F;lib# 5、执行生效命令： ldconfig</code></pre></div></figure><h2 id="2-6-binary-安装-（会把已编译好的执行文件拷贝进去）"><a href="#2-6-binary-安装-（会把已编译好的执行文件拷贝进去）" class="headerlink" title="2.6 binary 安装 （会把已编译好的执行文件拷贝进去）"></a>2.6 binary 安装 （会把已编译好的执行文件拷贝进去）</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">将 SPECcpu2006_hygon_Open64_617306_001.tar.gz 拷贝到 Specpu2006 安装路径下tar –xvf SPECcpu2006_hygon_Open64_617306_001.tar.gz 进行解压</code></pre></div></figure><h2 id="2-7-设置测试迭代次数"><a href="#2-7-设置测试迭代次数" class="headerlink" title="2.7 设置测试迭代次数"></a>2.7 设置测试迭代次数</h2><p>解压 binary 包后在 hygon-run-int-fp-rate-20201118cfg.sh 文件内进行配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如需跑3次，并生成正式报告，约测试 35h，按如下配置 #run benchmarksrunspec --config&#x3D;Hygon-open64-hygon-binary-20201118.cfg --action&#x3D;run --tune&#x3D;all --size&#x3D;all --reportable int  runspec --config&#x3D;Hygon-open64-hygon-binary-20201118.cfg --action&#x3D;run --tune&#x3D;all --size&#x3D;all --reportable fp # 如只需跑1次，不生成正式报告，约测试 12h，按如下配置  runspec --config&#x3D;Hygon-open64-hygon-binary-20201118.cfg --action&#x3D;run --tune&#x3D;all --size&#x3D;all --iterations&#x3D;1 --noreportable int  runspec --config&#x3D;Hygon-open64-hygon-binary-20201118.cfg --action&#x3D;run --tune&#x3D;all --size&#x3D;all --iterations&#x3D;1 --noreportable fp </code></pre></div></figure><h2 id="2-8-选择测试模式-Rate-or-Speed"><a href="#2-8-选择测试模式-Rate-or-Speed" class="headerlink" title="2.8 选择测试模式(Rate or Speed)"></a>2.8 选择测试模式(Rate or Speed)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">解压 binary 包后进入到 config 文件夹， vim Hygon-open64-hygon-binary-20201118.cfg 修改配置文件Rate 模式 rate&#x3D;1， Speed 模式 rate&#x3D;0# 第51行....  49 teerunout          &#x3D; yes  50 post_setup         &#x3D; sync  51 rate               &#x3D; 1....</code></pre></div></figure><h2 id="2-9-修改配置参数-生成的报告中记录的信息"><a href="#2-9-修改配置参数-生成的报告中记录的信息" class="headerlink" title="2.9 修改配置参数 (生成的报告中记录的信息)"></a>2.9 修改配置参数 (生成的报告中记录的信息)</h2><p><font color=red>其中内存大小一定要设置好</font>，不然会跑不起来</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">解压 binary 包后进入到 config 文件夹， vim Hygon-open64-hygon-binary-20201118.cfg 修改配置文件， 修改说明如下：%define num_sockets：芯片数量(1 or 2)%define cores_per_socket 单颗 CPU 物理核数%define nodes_per_socket 单颗 CPU node 节点数量%define memory_size 内存总量# 测试机器是384G内存，改成256%define memory_freq 内存额定频率%define memory_freq_actual 内存实际频率</code></pre></div></figure><h1 id="2-10-开始测试"><a href="#2-10-开始测试" class="headerlink" title="2.10 开始测试"></a>2.10 开始测试</h1><p>执行命令后台测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup .&#x2F;hygon-run-int-fp-rate-20201118cfg.sh &amp;</code></pre></div></figure><p>正常运行输出如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">....run_peak_test_hygon-rate-revB.0057, run_peak_test_hygon-rate-revB.0058, run_peak_test_hygon-rate-revB.0059, run_peak_test_hygon-rate-revB.0060, run_peak_test_hygon-rate-revB.0061, run_peak_test_hygon-rate-revB.0062, run_peak_test_hygon-rate-revB.0063)syncRunning Benchmarks  Running 400.perlbench test base hygon-rate-revB default (64 copies)&#x2F;cpu2006-1.2&#x2F;bin&#x2F;specinvoke -d &#x2F;cpu2006-1.2&#x2F;benchspec&#x2F;CPU2006&#x2F;400.perlbench&#x2F;run&#x2F;run_base_test_hygon-rate-revB.0000 -e speccmds.err -o speccmds.stdout -f speccmds.cmd -C -q&#x2F;cpu2006-1.2&#x2F;bin&#x2F;specinvoke -E -d &#x2F;cpu2006-1.2&#x2F;benchspec&#x2F;CPU2006&#x2F;400.perlbench&#x2F;run&#x2F;run_base_test_hygon-rate-revB.0000 -c 64 -e compare.err -o compare.stdout -f compare.cmd.....</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EF860服务器宕机案例</title>
    <link href="/2023/11/20/02_%E6%B5%8B%E8%AF%95/05_EF860%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%95%E6%9C%BA%E6%A1%88%E4%BE%8B/"/>
    <url>/2023/11/20/02_%E6%B5%8B%E8%AF%95/05_EF860%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%95%E6%9C%BA%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="EF860服务器宕机案例"><a href="#EF860服务器宕机案例" class="headerlink" title="EF860服务器宕机案例"></a>EF860服务器宕机案例</h1><h2 id="1、麒麟系统Audit服务导致宕机"><a href="#1、麒麟系统Audit服务导致宕机" class="headerlink" title="1、麒麟系统Audit服务导致宕机"></a>1、麒麟系统Audit服务导致宕机</h2><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>该台服务器于10月7日凌晨4点38左右宕机，从message日志可以见到大量audit服务的日志：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Oct  7 03:08:05 NFDW4-ARMTSTACK-JSQ-COM102 systemd[1]: session-67676.scope: Succeeded.Oct  7 03:08:05 NFDW4-ARMTSTACK-JSQ-COM102 audit[3418956]: CRED_DISP pid&#x3D;3418956 uid&#x3D;0 auid&#x3D;0 ses&#x3D;67675 msg&#x3D;&#39;op&#x3D;PAM:setcred grantors&#x3D;pam_kysec,pam_env,pam_tally2,pam_faillock,pam_unix acct&#x3D;&quot;root&quot; exe&#x3D;&quot;&#x2F;usr&#x2F;sbin&#x2F;crond&quot; hostname&#x3D;? addr&#x3D;? terminal&#x3D;cron res&#x3D;success&#39;Oct  7 03:08:05 NFDW4-ARMTSTACK-JSQ-COM102 audit[3418956]: USER_END pid&#x3D;3418956 uid&#x3D;0 auid&#x3D;0 ses&#x3D;67675 msg&#x3D;&#39;op&#x3D;PAM:session_close grantors&#x3D;pam_loginuid,pam_keyinit,pam_limits,pam_systemd acct&#x3D;&quot;root&quot; exe&#x3D;&quot;&#x2F;usr&#x2F;sbin&#x2F;crond&quot; hostname&#x3D;? addr&#x3D;? terminal&#x3D;cron res&#x3D;success&#39;Oct  7 03:08:05 NFDW4-ARMTSTACK-JSQ-COM102 auditd[3959]: AUDIT:bfree&#x3D;0,threshold_size&#x3D;75,fs_space_warning&#x3D;1Oct  7 03:08:05 NFDW4-ARMTSTACK-JSQ-COM102 systemd[1]: session-67675.scope: Succeeded.</code></pre></div></figure><p>该问题由系统BUG导致，audit服务将不停吃系统内存，最终导致宕机</p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>方法一：升级audit服务</p><p>方法二：禁用auditd服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl stop auditdsudo systemctl disable auditd</code></pre></div></figure><h2 id="2、内存ECC问题"><a href="#2、内存ECC问题" class="headerlink" title="2、内存ECC问题"></a>2、内存ECC问题</h2><h3 id="2-1-lum-log文件"><a href="#2-1-lum-log文件" class="headerlink" title="2.1 lum.log文件"></a>2.1 lum.log文件</h3><p>查看lum.log文件，如果<code>ecc_corrected_bit_num</code>有值，说明存在内存CE错误，可建议做一次内存ECC校验</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[&#123;&quot;LMU&quot;:&#123;&quot;CPU0&quot;:&#123;&quot;LMU0&quot;:&#123;&quot;ECCCLR&quot;:&#123;&quot;description&quot;:&#123;&quot;ecc_clr_corr_err&quot;:&quot;0&quot;,&quot;ecc_clr_corr_err_cnt&quot;:&quot;0&quot;,&quot;ecc_clr_uncorr_err&quot;:&quot;0&quot;,&quot;ecc_corr_err_cnt&quot;:&quot;0&quot;,&quot;ecc_uncorr_err_cnt&quot;:&quot;0&quot;&#125;,&quot;value&quot;:&quot;00000000&quot;&#125;,&quot;ECCERRCNT&quot;:&#123;&quot;description&quot;:&#123;&quot;ecc_corr_err_cnt&quot;:&quot;0&quot;,&quot;ecc_uncorr_err_cnt&quot;:&quot;0&quot;&#125;,&quot;value&quot;:&quot;00000000&quot;&#125;,&quot;ECCSTAT&quot;:&#123;&quot;description&quot;:&#123;&quot;ecc_corrected_bit_num&quot;:&quot;83&quot;,&quot;ecc_corrected_err&quot;:&quot;38&quot;,&quot;ecc_uncorrected_err&quot;:&quot;0&quot;&#125;,&quot;value&quot;:&quot;00002653&quot;&#125;&#125;,&quot;LMU1&quot;:&#123;&quot;ECCCLR&quot;:&#123;&quot;description&quot;:&#123;&quot;ecc_clr_corr_err&quot;:&quot;0&quot;,&quot;ecc_clr_corr_err_cnt&quot;:&quot;0&quot;,&quot;ecc_clr_uncorr_err&quot;:&quot;0&quot;,&quot;ecc_corr_err_cnt&quot;:&quot;0&quot;,&quot;ecc_uncorr_err_cnt&quot;:&quot;0&quot;&#125;,&quot;value&quot;:&quot;00000000&quot;&#125;,&quot;ECCERRCNT&quot;:&#123;&quot;description&quot;:&#123;&quot;ecc_corr_err_cnt&quot;:&quot;0&quot;,&quot;ecc_uncorr_err_cnt&quot;:&quot;0&quot;&#125;,&quot;value&quot;:&quot;00000000&quot;&#125;,&quot;ECCSTAT&quot;:&#123;&quot;description&quot;:&#123;&quot;ecc_corrected_bit_num&quot;:&quot;0&quot;,&quot;ecc_corrected_err&quot;:&quot;0&quot;,&quot;ecc_uncorrected_err&quot;:&quot;0&quot;&#125;,&quot;value&quot;:&quot;00000000&quot;&#125;&#125;,&quot;LMU2&quot;:&#123;&quot;ECCCLR&quot;:&#123;&quot;description&quot;:&#123;&quot;ecc_clr_corr_err&quot;:&quot;0&quot;,&quot;ecc_clr_corr_err_cnt&quot;:&quot;0&quot;,</code></pre></div></figure><p>2.2 </p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>长城S2500服务器性能测试最佳实践</title>
    <link href="/2023/11/20/02_%E6%B5%8B%E8%AF%95/06_S2500%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/11/20/02_%E6%B5%8B%E8%AF%95/06_S2500%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="长城S2500服务器性能测试最佳实践"><a href="#长城S2500服务器性能测试最佳实践" class="headerlink" title="长城S2500服务器性能测试最佳实践"></a>长城S2500服务器性能测试最佳实践</h1><h1 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h1><p>操作系统：</p><p>​Kylin V10 SP3 2303 服务器版</p><p>​镜像名：Kylin-Server-V10-SP3-General-Release-2303-ARM64.iso</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# cat &#x2F;etc&#x2F;.kyinfo [dist]name&#x3D;Kylinmilestone&#x3D;Server-V10-SP3-General-Release-2303arch&#x3D;arm64beta&#x3D;Falsetime&#x3D;2023-03-24 14:51:29dist_id&#x3D;Kylin-Server-V10-SP3-General-Release-2303-arm64-2023-03-24 14:51:29[servicekey]key&#x3D;0239033[os]to&#x3D;term&#x3D;2024-07-01</code></pre></div></figure><p>硬盘：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"></code></pre></div></figure><p>网卡：</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">0000:03:00.0 Ethernet controller: Intel Corporation Ethernet Controller X710 for 10GbE SFP+ (rev 02)0000:03:00.1 Ethernet controller: Intel Corporation Ethernet Controller X710 for 10GbE SFP+ (rev 02)</code></pre></div></figure><p>测试服务器软件配置清单</p><table><thead><tr><th>软件项</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>LmBench</td><td>lmbench3.tar.gz</td><td></td></tr><tr><td>SPEC CPU2006</td><td>1.2</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="1、Lmbench测试（约1个半小时）"><a href="#1、Lmbench测试（约1个半小时）" class="headerlink" title="1、Lmbench测试（约1个半小时）"></a>1、Lmbench测试（约1个半小时）</h1><p>解压源码包：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -vxf lmbench3.tar.gz</code></pre></div></figure><p>解决报错问题</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解决1：缺少SCCS报错cd lmbench3mkdir SCCStouch SCCS&#x2F;s.ChangeSet# 解决2：未找到llseekvim src&#x2F;disk.c # 将测试工具的disk.c源码文件中的llseek接口函数全部替换成lseek64# 解决3: 未找到rpc.h报错sudo yum -y install libtirpc libtirpc-develcp -rf &#x2F;usr&#x2F;include&#x2F;tirpc&#x2F;rpc&#x2F;* &#x2F;usr&#x2F;include&#x2F;rpc&#x2F;# 解决4：未找到netconfig.h问题ln -s &#x2F;usr&#x2F;include&#x2F;tirpc&#x2F;netconfig.h &#x2F;usr&#x2F;include# 解决5：行30: ..&#x2F;..&#x2F;results&#x2F;&#x2F;localhost.localdomain.0: 没有那个文件或目录原因：scripts&#x2F;gnu-os脚本中未将aarch64架构的系统作为识别选项。解决办法：将aarch64架构系统添加到识别选项中，修改scripts&#x2F;gnu-os，添加下面内容第928行后添加aarch64:Linux:*:*)        echo aarch64-unknown-linux-gnu        exit 0 ;;</code></pre></div></figure><p>调优方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">修改 Makefile 文件第 114、115 和 139 行，将 O 修改成 O2，使用 O2 编译可使性能优化。  cd lmbench-3.0-a9&#x2F;src&#x2F; vim Makefile</code></pre></div></figure><p>执行测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd lmbench3make results LDFLAGS&#x3D;-ltirpc（1）MULTIPLE COPIES,选择默认（2）Job placement selection 选1（3）MB:建议不超过1G（4）其余选项选择默认（5）Mail results ，选择no注：服务器内存大小指定为16384，桌面采用默认大小即可。make see查看结果，results目录下。make rerun再次运行，不需要重新配置。（注：测试多次时执行）</code></pre></div></figure><h1 id="2、Unixbench测试"><a href="#2、Unixbench测试" class="headerlink" title="2、Unixbench测试"></a>2、Unixbench测试</h1><p>使用麒麟提供的Unixbench测试包</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">和终端机测试的通用</code></pre></div></figure><p>使用GCC9.3.1</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># gcc931-phytium.tgz# 解压到&#x2F;opt文件夹中#!&#x2F;bin&#x2F;bashexport PATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;bin:$PATHexport CPATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;include:$CPATHexport LD_LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;lib64:$LD_LIBRARY_PATHexport LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;LIB64:$LIBRARY_PATH</code></pre></div></figure><p>调优方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、将Unixbench文件夹放到&#x2F;dev&#x2F;shm# 2、修改源码文件bufsize为8192</code></pre></div></figure><p>编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make clean &amp;&amp; make -j 8</code></pre></div></figure><p>开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;Run -c 1 -c 128</code></pre></div></figure><p>S2500测试分数</p><table><thead><tr><th>单核</th><th>多核</th></tr></thead><tbody><tr><td>1594.3</td><td>13421.9</td></tr></tbody></table><h1 id="3、SPECJVM测试"><a href="#3、SPECJVM测试" class="headerlink" title="3、SPECJVM测试"></a>3、SPECJVM测试</h1><p>下载软件包：</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">https:&#x2F;&#x2F;www.spec.org&#x2F;jvm2008&#x2F;</code></pre></div></figure><p>安装依赖：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install java-1.8.0* -y</code></pre></div></figure><p>安装工具：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -jar SPECjvm2008_1_01_setup.jar -i console回车即可</code></pre></div></figure><p>设置JDK环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdkCLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:&#x2F;lib.dt.jarPATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport JAVA_HOME CLASSPATH PATH</code></pre></div></figure><p>优化操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">JAVA_OPTS&#x3D;&quot;-Xms8192M -Xmx131072M -XX:PermSize&#x3D;512M -XX:MaxPermSize&#x3D;1g -Dspecjvm.benchmark.threads.scimark.fft.large&#x3D;1&quot;export JAVA_OPTS</code></pre></div></figure><p>开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;SPECjvm2008sudo java -jar SPECjvm2008.jar --base -ikvsudo java -Xms1024m -Xmx349525m -jar SPECjvm2008.jar --peak -ikv</code></pre></div></figure><p>测试分数</p><table><thead><tr><th>测试次数</th><th>base</th><th>peak</th></tr></thead><tbody><tr><td>第一次</td><td>846.59 ops&#x2F;m</td><td>851.89 ops&#x2F;m</td></tr></tbody></table><h1 id="4、stream测试"><a href="#4、stream测试" class="headerlink" title="4、stream测试"></a>4、stream测试</h1><p>使用飞腾提供的GCC10.3.1</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashexport PATH&#x3D;&#x2F;opt&#x2F;gcc1031&#x2F;bin:$PATHexport CPATH&#x3D;&#x2F;opt&#x2F;gcc1031&#x2F;include:$CPATHexport LD_LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gcc1031&#x2F;lib64:$LD_LIBRARY_PATHexport LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gcc1031&#x2F;LIB64:$LIBRARY_PATH</code></pre></div></figure><p>编辑stream的ArraySize，设置2000万</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#ifndef STREAM_ARRAY_SIZE#   define STREAM_ARRAY_SIZE    2000000#endif</code></pre></div></figure><p>优化操作：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">将stream文件夹放到&#x2F;dev&#x2F;shm中执行</code></pre></div></figure><p>多线程编译测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export OMP_NUM_THREADS&#x3D;128export GOMP_CPU_AFFINITY&#x3D;0-127echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches gcc -O3 -fopenmp -mcmodel&#x3D;large -DNTIME&#x3D;10 stream.c -o stream.duo.&#x2F;stream.duo</code></pre></div></figure><p>单线程编译测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -O3 -mcmodel&#x3D;large -DNTIME&#x3D;10 stream.c -o stream.dan.&#x2F;stream.dan</code></pre></div></figure><p>S2500测试分数</p><table><thead><tr><th>单核</th><th>多核</th></tr></thead><tbody><tr><td>Copy:        7037.7918<br/>Scale:       7187.7967<br/>Add:         6741.4476<br/>Triad:       6792.1660</td><td>Copy:          164785.4<br/>Scale:         173542.4<br/>Add:           151658.4<br/>Triad:         148328.7</td></tr></tbody></table><h1 id="5、IOZone测试"><a href="#5、IOZone测试" class="headerlink" title="5、IOZone测试"></a>5、IOZone测试</h1><p>解压工具包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -vxf iozone3_489.tar</code></pre></div></figure><p>编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make linux-arm</code></pre></div></figure><p>开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashecho 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches# 块大小16M，文件大小为物理内存1倍（测试机器内存为512G的情况下）.&#x2F;iozone -i 0 -i 1 -i 2 -s 512g -r 16m -f &#x2F;iotest&#x2F;iozone.tmpfile -Rb .&#x2F;report&#x2F;iotest_512G_0.xlssleep 20echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches# 块大小16M，文件大小为物理内存0.5倍（测试机器内存为512G的情况下）.&#x2F;iozone -i 0 -i 1 -i 2 -s 256g -r 16m -f &#x2F;iotest&#x2F;iozone.tmpfile -Rb .&#x2F;report&#x2F;iotest_256G_0.xlssleep 20echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches# 块大小16M，文件大小为物理内存2倍（测试机器内存为512G的情况下）.&#x2F;iozone -i 0 -i 1 -i 2 -s 800g -r 16m -f &#x2F;iotest&#x2F;iozone.tmpfile -Rb .&#x2F;report&#x2F;iotest_800G_0.xls</code></pre></div></figure><h1 id="6、SPEC-CPU2006测试（单核多核三遍约40小时）"><a href="#6、SPEC-CPU2006测试（单核多核三遍约40小时）" class="headerlink" title="6、SPEC CPU2006测试（单核多核三遍约40小时）"></a>6、SPEC CPU2006测试（单核多核三遍约40小时）</h1><p>使用工具：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 研发提供的2006测试包benchmark_tools.tar.gz</code></pre></div></figure><p>测试方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、解压文件2、执行.&#x2F;00_stopsrv.sh3、将ISO文件放到root目录下，注意修改文件名或脚本保持文件名与脚本对应：&#x2F;root&#x2F;Kylin-Server-10-SP1-aarch64-Release-Build01-2500-20200727.iso4、执行.&#x2F;install_rpm.sh5、执行.&#x2F;06_install_speccpu2006.sh6、执行.&#x2F;07_build_speccpu2006_tools.sh7、执行.&#x2F;08_build_speccpu2006_test.sh8、执行.&#x2F;11_run_spec.sh</code></pre></div></figure><p>测试结果：</p><table><thead><tr><th>测试项</th><th>测试分数</th></tr></thead><tbody><tr><td>单核整型</td><td>15.1</td></tr><tr><td>128核整型</td><td>1070</td></tr><tr><td>单核浮点</td><td>13</td></tr><tr><td>128核浮点</td><td>885</td></tr></tbody></table><h1 id="7、SPEC-CPU2017测试"><a href="#7、SPEC-CPU2017测试" class="headerlink" title="7、SPEC CPU2017测试"></a>7、SPEC CPU2017测试</h1><p>挂载ISO镜像文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;mnt&#x2F;spec2017mount cpu2017-1_0_5.iso &#x2F;mnt&#x2F;cpu2017&#x2F;</code></pre></div></figure><p>安装SPEC 2017，指定安装到<code>/spec2017</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost cpu2017]# cd &#x2F;mnt&#x2F;cpu2017[root@localhost cpu2017]# .&#x2F;install.sh SPEC CPU2017 InstallationTop of the CPU2017 tree is &#39;&#x2F;mnt&#x2F;cpu2017&#39;Enter the directory you wish to install to (e.g. &#x2F;usr&#x2F;cpu2017)&#x2F;spec2017Installing FROM &#x2F;mnt&#x2F;cpu2017Installing TO &#x2F;spec2017Is this correct? (Please enter &#39;yes&#39; or &#39;no&#39;) yes....</code></pre></div></figure><p>设置gcc环境变量，使用GCC9.3.1 </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost mnt]# source &#x2F;opt&#x2F;gcc931&#x2F;env.sh [root@localhost mnt]# cat &#x2F;opt&#x2F;gcc931&#x2F;env.sh #!&#x2F;bin&#x2F;bashexport PATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;bin:$PATHexport CPATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;include:$CPATHexport LD_LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;lib64:$LD_LIBRARY_PATHexport LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gcc931&#x2F;LIB64:$LIBRARY_PATH</code></pre></div></figure><p>将配置文件，拷贝到config文件夹中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;spec2017mv phytium2017.cfg config&#x2F;</code></pre></div></figure><p>修改配置文件GCC路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># vim config&#x2F;phytium2017.cfg128 #      WARNING: See section129 #      &quot;Known Limitations with GCC 4&quot;130 #131 %ifndef %&#123;gcc_dir&#125;132 %   define  gcc_dir        &#x2F;opt&#x2F;gcc931  # EDIT (see above)133 134 %endif135 136 # EDIT if needed: the preENV line adds library directories to the runtime</code></pre></div></figure><p>测试前的准备</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source shrcecho 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_cachesulimit -s unlimited</code></pre></div></figure><p>开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 128核测试（三遍，生成不加水印的报告）runcpu -c phytium2017.cfg -T base -s -C 128 -n 3 -i ref intrate fprate# 单核测试runcpu -c phytium2017.cfg -T base -s -C 1 -n 3 -i ref intspeed fpspeed</code></pre></div></figure><p>测试数据</p><table><thead><tr><th>测试项</th><th>测试分数</th><th>备注</th></tr></thead><tbody><tr><td>128核整型</td><td>179</td><td></td></tr><tr><td>128核浮点</td><td></td><td></td></tr><tr><td>单核整型</td><td></td><td></td></tr><tr><td>单核浮点</td><td></td><td></td></tr></tbody></table><h1 id="8、netperf测试"><a href="#8、netperf测试" class="headerlink" title="8、netperf测试"></a>8、netperf测试</h1><p>准备两台机器，如机器A（192.168.0.1），机器B（192.168.0.2）</p><p>A、B都编译安装netperf</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --build&#x3D;armmake -j 8</code></pre></div></figure><p>机器A开启服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;src.&#x2F;netserver</code></pre></div></figure><p>优化操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 设置网卡mtu为9000ifconfig enP1p4s0f1 mtu 9000</code></pre></div></figure><p>机器B开启客户端，开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;netperf -H 192.168.0.1 -l 60 -t TCP_STREAM .&#x2F;netperf -H 192.168.0.1 -l 60 -t UDP_STREAM .&#x2F;netperf -H 192.168.0.1 -l 120 -t TCP_RR .&#x2F;netperf -H 192.168.0.1 -l 120 -t UDP_RR</code></pre></div></figure><p>记录测试结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>甲骨云服务器恢复密码</title>
    <link href="/2023/10/20/06_%E6%9D%82%E8%AE%B0/%E7%94%B2%E9%AA%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%81%A2%E5%A4%8D%E5%AF%86%E7%A0%81/"/>
    <url>/2023/10/20/06_%E6%9D%82%E8%AE%B0/%E7%94%B2%E9%AA%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%81%A2%E5%A4%8D%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="甲骨云服务器恢复密码"><a href="#甲骨云服务器恢复密码" class="headerlink" title="甲骨云服务器恢复密码"></a>甲骨云服务器恢复密码</h1><p>安装的Centos8系统，在boot界面进入单用户模式后，密码无法修改成功，故记录下来。</p><h1 id="1-进入单用户模式的方法"><a href="#1-进入单用户模式的方法" class="headerlink" title="1 进入单用户模式的方法"></a>1 进入单用户模式的方法</h1><p>在boot界面按”e”编辑第一个启动项，而后修改启动参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ro 改成rw inti&#x3D;&#x2F;bin&#x2F;bash</code></pre></div></figure><h1 id="2-修改密码"><a href="#2-修改密码" class="headerlink" title="2 修改密码"></a>2 修改密码</h1><p>按正常方法修改密码，报如下错：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost &#x2F;]# passwdChanging password for user root.New password: Retype new password: passwd: Authentication token manipulation error</code></pre></div></figure><p>原因是默认挂载的&#x2F;没有写权限，解决方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 重新挂载&#x2F;分区，改成rw权限[root@localhost &#x2F;]# mount -o remount,rw &#x2F;# 再次修改，成功[root@localhost &#x2F;]# passwd rootChanging password for user root.New password: Retype new password: passwd: all authentication tokens updated successfully.</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>甲骨云服务器初始设置</title>
    <link href="/2023/10/20/06_%E6%9D%82%E8%AE%B0/%E7%94%B2%E9%AA%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/10/20/06_%E6%9D%82%E8%AE%B0/%E7%94%B2%E9%AA%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="甲骨云服务器初始设置"><a href="#甲骨云服务器初始设置" class="headerlink" title="甲骨云服务器初始设置"></a>甲骨云服务器初始设置</h1><p>​Oracle Cloud的服务器刚创建完是不能直接使用的，需要做一系列设置方能使用第三方ssh工具登录</p><h1 id="1-使用私钥文件登录"><a href="#1-使用私钥文件登录" class="headerlink" title="1 使用私钥文件登录"></a>1 使用私钥文件登录</h1><p><font color=red><strong>在创建实例的时候</strong></font>，保存实例私钥，</p><p><img src="/../../../source/img/image-20231101150103214.png" alt="image-20231101150103214"></p><p>使用xshell创建SSH登录会话</p><p><img src="/../../../source/img/image-20231101150247095.png" alt="image-20231101150247095"></p><p>选择接受</p><p><img src="/../../../source/img/image-20231101150336377.png" alt="image-20231101150336377"></p><p>输入默认用户（centos系统默认opc，ubuntu系统默认为ubuntu）</p><p><img src="/../../../source/img/image-20231101150427127.png" alt="image-20231101150427127"></p><p>选择私钥进行连接</p><p><img src="/../../../source/img/image-20231101150513350.png" alt="image-20231101150513350"></p><p>登录成功</p><p><img src="/../../../source/img/image-20231101152306146.png" alt="image-20231101152306146"></p><h1 id="2-修改ssh服务"><a href="#2-修改ssh服务" class="headerlink" title="2 修改ssh服务"></a>2 修改ssh服务</h1><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、切换到root用户sudo su# 2、关闭SElinux。否则修改sshd端口会报错没权限setenforce 0# 永久关闭vim &#x2F;etc&#x2F;selinux&#x2F;config# 改成disabled# This file controls the state of SELinux on the system.# SELINUX&#x3D; can take one of these three values:#     enforcing - SELinux security policy is enforced.#     permissive - SELinux prints warnings instead of enforcing.#     disabled - No SELinux policy is loaded.SELINUX&#x3D;disabled# SELINUXTYPE&#x3D; can take one of these three values:#     targeted - Targeted processes are protected,#     minimum - Modification of targeted policy. Only selected processes are protected. #     mls - Multi Level Security protection.SELINUXTYPE&#x3D;targeted# 2、编辑sshd_config文件vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config# 主要修改：Port：8822 # 防止简单端口扫描PermitRootLogin yes # 允许root登录PasswordAuthentication yes# 允许使用密码登录# 重启服务systemctl restart ssh</code></pre></div></figure><h1 id="3-iptables设置开放端口"><a href="#3-iptables设置开放端口" class="headerlink" title="3 iptables设置开放端口"></a>3 iptables设置开放端口</h1><p>oracle的ubuntu系统默认带了iptables，需要放开</p><p><img src="/../../../source/img/image-20231101153023460.png" alt="image-20231101153023460"></p><p>执行命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、全部放开sudo iptables -P INPUT ACCEPTsudo iptables -P FORWARD ACCEPTsudo iptables -P OUTPUT ACCEPTsudo iptables -F# 2、卸载iptalbes相关应用apt-get purge netfilter-persistent# 3、卸载oracle cloud监控程序snap remove oracle-cloud-agentiptables -L# 3、重启reboot</code></pre></div></figure><h1 id="4、修改密码"><a href="#4、修改密码" class="headerlink" title="4、修改密码"></a>4、修改密码</h1><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;ubuntu:xxxxx&quot; | chpasswdecho &quot;root:xxxxx&quot; | chpasswdhistory -c</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>母盘ISO定制步骤</title>
    <link href="/2023/05/24/06_%E6%9D%82%E8%AE%B0/ISO%E5%AE%9A%E5%88%B6%E6%AD%A5%E9%AA%A4/"/>
    <url>/2023/05/24/06_%E6%9D%82%E8%AE%B0/ISO%E5%AE%9A%E5%88%B6%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="母盘ISO定制步骤"><a href="#母盘ISO定制步骤" class="headerlink" title="母盘ISO定制步骤"></a>母盘ISO定制步骤</h1><h1 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h1><h2 id="1-1-镜像文件和操作系统"><a href="#1-1-镜像文件和操作系统" class="headerlink" title="1.1 镜像文件和操作系统"></a>1.1 镜像文件和操作系统</h2><p>ISO修改环境的操作系统和需要定制修改的操作系统ISO镜像：</p><p><strong>Kylin-Desktop-V10-SP1-General-Release-2203-ARM64.iso</strong></p><p>进入操作系统，操作以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 切换到root用户sudo su # 安装必要软件sudo apt-get install squashfs-tools genisoimage# 切换到&#x2F;opt目录，创建四个文件夹# &#x2F;opt&#x2F;mnt - 挂载镜像文件# &#x2F;opt&#x2F;livecd - 镜像文件内容拷贝，用于最后打包成新镜像# &#x2F;opt&#x2F;mylivecd - 镜像文件内容拷贝，用于将软件、补丁集成到镜像中，生成filesystem.squashfs等文件# &#x2F;opt&#x2F;tool - 用于存放镜像ISO等文件cd &#x2F;opt&amp;&amp; mkdir mnt livecd tool mylivecd # 挂载需要修改的镜像文件，到&#x2F;opt&#x2F;mntmount -o loop &#x2F;opt&#x2F;tool&#x2F;Kylin-Desktop-V10-SP1-General-Release-2203-ARM64.iso  &#x2F;opt&#x2F;mnt&#x2F;# 将镜像内的文件拷贝出来rsync -av &#x2F;opt&#x2F;mnt&#x2F; &#x2F;opt&#x2F;livecd&#x2F;rsync -av &#x2F;opt&#x2F;mnt&#x2F; &#x2F;opt&#x2F;mylivecd&#x2F;# 取消挂载ISO镜像umount &#x2F;opt&#x2F;mnt&#x2F;</code></pre></div></figure><h1 id="二、修改镜像文件"><a href="#二、修改镜像文件" class="headerlink" title="二、修改镜像文件"></a>二、修改镜像文件</h1><p>先执行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 切换到mylivecd目录cd &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;# 执行unsquashfs命令unsquashfs filesystem.squashfs</code></pre></div></figure><h2 id="2-1-导入补丁和预装软件包"><a href="#2-1-导入补丁和预装软件包" class="headerlink" title="2.1 导入补丁和预装软件包"></a>2.1 导入补丁和预装软件包</h2><p>安装1107补丁、PKS补丁及预装软件deb包</p><p>1、分别创建三个文件夹，并将需要安装的补丁、软件拷贝到三个文件夹中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;livecd &amp;&amp; mkdir 1107 option pks # &#x2F;opt&#x2F;livecd&#x2F;1107 - 存放1107补丁# &#x2F;opt&#x2F;livecd&#x2F;pks - 存放PKS补丁# &#x2F;opt&#x2F;livecd&#x2F;option - 存放定制软件deb包，如数科OFD、金山WPS等</code></pre></div></figure><p>2、修改.kylin-post-actions文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;opt&#x2F;livecd&#x2F;.kylin-post-actions</code></pre></div></figure><p>修改后的内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashrm -rf &#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;00recommendsrm -rf &#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;00securerm -rf &#x2F;etc&#x2F;modules-load.d&#x2F;cups-filters.confcat &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list &lt;&lt;EOFdeb http:&#x2F;&#x2F;archive.kylinos.cn&#x2F;kylin&#x2F;KYLIN-ALL 10.1 main restricted universe multiversedeb http:&#x2F;&#x2F;archive.kylinos.cn&#x2F;kylin&#x2F;KYLIN-ALL 10.1-2203-updates main restricted universe multiversedeb http:&#x2F;&#x2F;archive2.kylinos.cn&#x2F;deb&#x2F;kylin&#x2F;production&#x2F;PART-V10-SP1&#x2F;custom&#x2F;partner&#x2F;V10-SP1 default allEOFrm -rf &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;*rm -rf &#x2F;etc&#x2F;apt&#x2F;preferences.d&#x2F;*#解决网络安装后不能设置IP bug.mv &#x2F;opt&#x2F;interfaces &#x2F;etc&#x2F;network&#x2F;mkdir -p &#x2F;etc&#x2F;apt&#x2F;preferences.d&#x2F;mkdir -p &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;##解决xrdp远程桌面ssl文件访问权限问题，后续要查清楚原因，用脚本改感觉有安全漏洞##包列表新增xrdp、xorgxrdp,kylin.chroot脚本增加.xsessionchmod -R a+x &#x2F;etc&#x2F;ssl&#x2F;privatechmod -R a+r &#x2F;etc&#x2F;ssl&#x2F;privatechmod a+r &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;ssl-cert-snakeoil.key# 移除社区内核dpkg -P linux-headers-5.4.0-29 linux-headers-5.4.0-29-generic linux-image-5.4.0-29-generic linux-modules-5.4.0-29-generic linux-modules-extra-5.4.0-29-generic#安装奇安信杀毒#dpkg -i &#x2F;opt&#x2F;QAXS&#x2F;*.deb#rm &#x2F;opt&#x2F;QAXS -rf# sshd 服务异常， 缺少key文件，dpkg-reconfigure openssh-server 能解决问题。dpkg-reconfigure openssh-server# 第三方包因安装后过大，后置安装dpkg -i &#x2F;opt&#x2F;third&#x2F;*.debrm &#x2F;opt&#x2F;third -rf# ----制作母盘修改 start----# 1、补丁集安装，后置安装bash &#x2F;tmp&#x2F;k-i&#x2F;1108&#x2F;other.sh hn123123rm &#x2F;tmp&#x2F;k-i&#x2F;1107 -rf# 2、pks补丁安装，后置安装sudo dpkg -i &#x2F;tmp&#x2F;k-i&#x2F;pks&#x2F;libblkid1_2.34-0.1kylin18_arm64.deb &amp;&amp;sudo dpkg -i &#x2F;tmp&#x2F;k-i&#x2F;pks&#x2F;1&#x2F;*.deb### 1、删除sudo mv &#x2F;etc&#x2F;resolv.conf &#x2F;etc&#x2F;resolv.conf.bak### 2、创建软连接sudo ln -s &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;resolv.conf &#x2F;etc&#x2F;resolv.confrm &#x2F;tmp&#x2F;k-i&#x2F;pks -rf# 3、第三方包安装dpkg -i &#x2F;tmp&#x2F;k-i&#x2F;option&#x2F;*.debrm &#x2F;tmp&#x2F;k-i&#x2F;option -rf# ----制作母盘修改 end----# （本次dpkg，放在本脚本的最后执行）# 安全默认开启包安装20210604，bjca包在安装时安装20210611dpkg -i &#x2F;opt&#x2F;kscset&#x2F;*.debrm &#x2F;opt&#x2F;kscset -rfdpkg -P ksc-set#关闭sshd服务systemctl disable sshd</code></pre></div></figure><h2 id="2-2-导入办公桌面"><a href="#2-2-导入办公桌面" class="headerlink" title="2.2  导入办公桌面"></a>2.2  导入办公桌面</h2><p>1、将<strong>办公桌面deb安装包</strong>和<strong>PKS-C1使用指导</strong>拷贝到镜像文件夹</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp officedesktop_ft2000_kylinv10sp1_cec_0.0.8.91-a20_20230324.run  &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;squashfs-root&#x2F;home&#x2F;cp PKS-C1项目用户使用指导.pdf  &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;squashfs-root&#x2F;home&#x2F;</code></pre></div></figure><p>2、拷贝办公桌面<strong>rc.local</strong>文件到虚拟镜像，用于自动安装办公桌面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp rc.local  &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;squashfs-root&#x2F;etc&#x2F; chmod 755 &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;squashfs-root&#x2F;etc&#x2F;rc.local </code></pre></div></figure><p>rc.local文件内容如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashstat&#x3D;&#96;getstatus|grep exec|awk -F &#39; &#39; &#39;&#123;print $3&#125;&#39;&#96;if [ &quot;$stat&quot; &#x3D; &quot;off&quot; ];then        echo &quot;已经是关闭状态&quot;else        setsignstatus offfisudo su - root#if [ -f ];then#       dpkg -i#       sleep 3#fi##办公桌面安装if [ -f &#x2F;home&#x2F;officedesktop_ft2000_kylinv10sp1_cec_0.0.8.91-a20_20230324.run ] ;then        chmod +x &#x2F;home&#x2F;officedesktop_ft2000_kylinv10sp1_cec_0.0.8.91-a20_20230324.run        &#x2F;home&#x2F;officedesktop_ft2000_kylinv10sp1_cec_0.0.8.91-a20_20230324.run -c -p all -V        if [ $? -eq 0 ];then                rm -f &#x2F;home&#x2F;officedesktop_ft2000_kylinv10sp1_cec_0.0.8.91-a20_20230324.run                cp &#x2F;home&#x2F;*.pdf &#x2F;home&#x2F;greatwall&#x2F;桌面&#x2F;                rm -f &#x2F;home&#x2F;*.pdf                cd  &#x2F;usr&#x2F;share&#x2F;applications&#x2F; &amp;&amp; cp qaxbrowser-safe.desktop officedesktop.desktop cn.lanxin.desktop qaxbrowser-safe.desktop wps-office-et.desktop wps-office-official.desktop wps-office-pdf.desktop wps-office-wpp.desktop wps-office-wps.desktop &#x2F;home&#x2F;greatwall&#x2F;桌面&#x2F; &amp;&amp; chmod 755 &#x2F;home&#x2F;greatwall&#x2F;桌面&#x2F;*.desktop                setsignstatus on        fifiif [ -f &#x2F;etc&#x2F;rc.local ];then        at now+5 minutes &lt;&lt;&lt; &quot;find &#x2F;etc&#x2F; -name rc.local -exec rm -rf &#123;&#125; \;&quot;fi</code></pre></div></figure><p>3、编辑z.sh文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;squashfs-root&#x2F;usr&#x2F;share&#x2F;kylin-os-installer&#x2F;scripts&#x2F;z.sh</code></pre></div></figure><p>修改第56行：执行post脚本项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">....# 执行 post 脚本do_cdrom_post_actions() &#123;  if [[ -f &#x2F;cdrom&#x2F;.kylin-post-actions ]] &amp;&amp; [[ &quot;$&#123;is_ghost&#125;&quot; !&#x3D; &quot;true&quot; ]]; then    cp &#x2F;cdrom&#x2F;.kylin-post-actions &#x2F;target&#x2F;$&#123;IN_TARGET&#125;    cp -r &#x2F;cdrom&#x2F;option &#x2F;target&#x2F;$&#123;IN_TARGET&#125;# 新增    cp -r &#x2F;cdrom&#x2F;pks &#x2F;target&#x2F;$&#123;IN_TARGET&#125;# 新增    cp -r &#x2F;cdrom&#x2F;1108 &#x2F;target&#x2F;$&#123;IN_TARGET&#125;# 新增    chroot &#x2F;target bash $&#123;IN_TARGET&#125;&#x2F;.kylin-post-actions &gt;&gt;$&#123;LOG_FILE&#125; 2&gt;&amp;1  fi  if [[ -f &#x2F;cdrom&#x2F;.kylin-post-actions-nochroot ]] &amp;&amp; [[ &quot;$&#123;is_ghost&#125;&quot; !&#x3D; &quot;true&quot; ]]; then    bash &#x2F;cdrom&#x2F;.kylin-post-actions-nochroot &gt;&gt;$&#123;LOG_FILE&#125; 2&gt;&amp;1  fi&#125;....</code></pre></div></figure><h2 id="2-3-其他文件拷贝"><a href="#2-3-其他文件拷贝" class="headerlink" title="2.3 其他文件拷贝"></a>2.3 其他文件拷贝</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 拷贝pwquality.conf，该文件需事先准备，内容可见附录cp &#x2F;opt&#x2F;tool&#x2F;pwquality.conf &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;squashfs-root&#x2F;etc&#x2F;security&#x2F;# 清空.bash_history，这里拷贝了一个文件过去，文件内容为空cp &#x2F;opt&#x2F;tool&#x2F;.bash_history &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;squashfs-root&#x2F;root&#x2F;# 删除filesystem.squashfs文件cd &#x2F;opt&#x2F;mylivecd&#x2F;casperrm -rf filesystem.squashfs # 打包squashfs-rootmksquashfs squashfs-root filesystem.squashfs -comp xz# 输出文件系统大小printf $(du -sx --block-size&#x3D;1 squashfs-root |cut -f1) &gt;filesystem.size# 进到虚拟root环境，将已安装的软件列表导出chroot squashfs-root&#x2F; dpkg-query -W &gt;filesystem.manifest# 执行拷贝文件操作cp &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;filesystem.squashfs &#x2F;opt&#x2F;livecd&#x2F;casper&#x2F;cp &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;filesystem.size &#x2F;opt&#x2F;livecd&#x2F;casper&#x2F;cp &#x2F;opt&#x2F;mylivecd&#x2F;casper&#x2F;filesystem.manifest &#x2F;opt&#x2F;livecd&#x2F;casper&#x2F;# 切换到livecd目录cd &#x2F;opt&#x2F;livecd&#x2F;# 重新生成md5文件rm -rf md5sum.txtfind -type f -print0 | xargs -0 md5sum|grep -v isolinux&#x2F;boot.cat |tee md5sum.txt</code></pre></div></figure><h1 id="三、打包ISO镜像"><a href="#三、打包ISO镜像" class="headerlink" title="三、打包ISO镜像"></a>三、打包ISO镜像</h1><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进到livecd目录cd &#x2F;opt&#x2F;livecd&#x2F;# 执行打包命令mkisofs -J -r -T -joliet-long -V &quot;Kylin-Desktop-V10-SP1&quot; -eltorito-alt-boot -e boot&#x2F;grub&#x2F;efi.img -no-emul-boot -o  &#x2F;opt&#x2F;tool&#x2F;Kylin-Desktop-V10-SP1-CC-PKS-1107.iso &#x2F;opt&#x2F;livecd&#x2F;</code></pre></div></figure><h1 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h1><p>1、pwquality.conf文件内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Configuration for systemwide password quality limits# Defaults:## Number of characters in the new password that must not be present in the# old password.# difok &#x3D; 1## Minimum acceptable size for the new password (plus one if# credits are not disabled which is the default). (See pam_cracklib manual.)# Cannot be set to lower value than 6.minlen &#x3D; 6## The maximum credit for having digits in the new password. If less than 0# it is the minimum number of digits in the new password.dcredit &#x3D; 0## The maximum credit for having uppercase characters in the new password.# If less than 0 it is the minimum number of uppercase characters in the new# password.ucredit &#x3D; 0## The maximum credit for having lowercase characters in the new password.# If less than 0 it is the minimum number of lowercase characters in the new# password.lcredit &#x3D; 0## The maximum credit for having other characters in the new password.# If less than 0 it is the minimum number of other characters in the new# password.ocredit &#x3D; 0## The minimum number of required classes of characters for the new# password (digits, uppercase, lowercase, others).minclass &#x3D; 1## The maximum number of allowed consecutive same characters in the new password.# The check is disabled if the value is 0.maxrepeat &#x3D; 0## The maximum number of allowed serial characters of the same class in the# new password.# The check is disabled if the value is 0.maxsequence &#x3D; 0## The maximum number of allowed consecutive characters of the same class in the# new password.# The check is disabled if the value is 0.maxclassrepeat &#x3D; 0## Whether to check for the words from the passwd entry GECOS string of the user.# The check is enabled if the value is not 0.# gecoscheck &#x3D; 0## Whether to check for the words from the cracklib dictionary.# The check is enabled if the value is not 0.dictcheck &#x3D; 1## Whether to check if it contains the user name in some form.# The check is enabled if the value is not 0.usercheck &#x3D; 1## Whether the check is enforced by the PAM module and possibly other# applications.# The new password is rejected if it fails the check and the value is not 0.# enforcing &#x3D; 1## Path to the cracklib dictionaries. Default is to use the cracklib default.dictpath &#x3D; &#x2F;var&#x2F;cache&#x2F;cracklib&#x2F;cracklib_dict## Prompt user at most N times before returning with error. The default is 1.# retry &#x3D; 1## Enforces pwquality checks on the root user password.# Enabled if the option is present.enforce_for_root## Skip testing the password quality for users that are not present in the# &#x2F;etc&#x2F;passwd file.# Enabled if the option is present.# local_users_only## Whether to check the new password is a palindromic or not# Enabled if the option is presentpalindrome## Whether to check the new password is simliar with old one# Check include only case changes and rotated# Disabled if the option is presentno_similar_check</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言-Day01</title>
    <link href="/2022/12/02/04_C++/01_C%E8%AF%AD%E8%A8%80/day01/"/>
    <url>/2022/12/02/04_C++/01_C%E8%AF%AD%E8%A8%80/day01/</url>
    
    <content type="html"><![CDATA[<p>“C语言部分-Day01”</p><h1 id="一、第一个C程序"><a href="#一、第一个C程序" class="headerlink" title="一、第一个C程序"></a>一、第一个C程序</h1><h2 id="1-1-C语言Hello-World"><a href="#1-1-C语言Hello-World" class="headerlink" title="1.1 C语言Hello World"></a>1.1 C语言Hello World</h2><p>源码：helloword.c</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; &#x2F;&#x2F; 预处理指令，用于包含头文件int main(void) &#123;printf(&quot;HelloWorld\n&quot;);return 0;&#125;</code></pre></div></figure><h2 id="1-2-文件分类"><a href="#1-2-文件分类" class="headerlink" title="1.2 文件分类"></a>1.2 文件分类</h2><p>主要文件分类：</p><p>​头文件：如stdio.h</p><p>​源文件: 如main.c</p><p>​配置文件</p><p>​音视频文件</p><p>​图片</p><p>​…</p><blockquote><p>Q1：</p><p>头文件指令<code>&lt;&gt;</code>和<code>&quot;&quot;</code>的区别</p><p>&lt;xxx.h&gt;  到系统目录寻找头文件，适用于系统带的头文件</p><p>“xxx.h” 先到当前目录寻找头文件，再到系统目录寻找，适用于自己写的头文件</p></blockquote><h2 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h2><p>C语言的注释方式，分为单行注释和多行注释</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 单行注释&#x2F;*   这是多行注释   这是多行注释   这是多行注释   这是多行注释*&#x2F;</code></pre></div></figure><h2 id="1-4-C程序的编译"><a href="#1-4-C程序的编译" class="headerlink" title="1.4 C程序的编译"></a>1.4 C程序的编译</h2><p>在Linux中，C源码的编译指令如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 编译gcc helloworld.c -o a.out</code></pre></div></figure><p>其实编译共分为四个步骤，只不过上面的指令一次性执行完成了，按细分如下：</p><p>1、预处理阶段：将头文件代码合入源码文件中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -E helloworld.c -o hello.i</code></pre></div></figure><p>2、编译阶段：通过c语言文件，生成汇编代码文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -S hello.i -o hello.s</code></pre></div></figure><p>3、汇编阶段：将汇编代码文件翻译成二进制语言指令，再将指令打包成二进制目标文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -C hello.s -o hello.o</code></pre></div></figure><p>4、链接阶段：将多个目标文件和标准库函数文件合并成一个可执行目标文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc hello.o -o hello</code></pre></div></figure><h2 id="1-5-Visual-Studio-调试程序的方法"><a href="#1-5-Visual-Studio-调试程序的方法" class="headerlink" title="1.5 Visual Studio 调试程序的方法"></a>1.5 Visual Studio 调试程序的方法</h2><p>1、打断点</p><p>2、F5开始调试</p><p>3、F10逐过程：一行行执行，如函数内没有断点，遇到函数会直接把函数执行完。</p><p>4、F11逐语句：一行行执行，遇到函数会进入</p><p>5、shift + F11跳出：在当前函数跳出，回到函数开始的位置</p><p>6、继续</p><p>如后续有断点，运行到下一个断点</p><p>如后续没有断点，执行完整个程序</p><h1 id="二、变量和常量"><a href="#二、变量和常量" class="headerlink" title="二、变量和常量"></a>二、变量和常量</h1><h2 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h2><p>变量是运行过程中可以改变的量，在C语言中定义变量的方式如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 定义一个变量int num &#x3D; 10;</code></pre></div></figure><p>计算机看到<code>int</code>类型，会分配4个字节的存储区用来存储整型数据</p><h3 id="1-2-1-变量的初始化"><a href="#1-2-1-变量的初始化" class="headerlink" title="1.2.1 变量的初始化"></a>1.2.1 变量的初始化</h3><p>在定义变量的时候，给变量赋值，叫做变量的初始化</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 单个变量初始化int num1 &#x3D; 10;int num2;num2 &#x3D; 20;&#x2F;&#x2F; 多个变量的初始化int num3,num4,num5;num3 &#x3D; 30;num4 &#x3D; 40;num5 &#x3D; 50;&#x2F;&#x2F; 多个变量连续初始化int num6,num7,num8;num6 &#x3D; num7 &#x3D; num8 &#x3D; 30;</code></pre></div></figure><h3 id="1-2-2-大小端问题"><a href="#1-2-2-大小端问题" class="headerlink" title="1.2.2 大小端问题"></a>1.2.2 大小端问题</h3><p><strong>小端表示法</strong>：低地址存放低有效位，在x86架构中，通常使用此表示法</p><p><strong>大端表示法</strong>：高地址存放低有效位</p><p>案例：假设有一个变量<code>int i = 1</code>, 一般占用4字节，它的真值为1，用机器码表示为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">00 00 00 01</code></pre></div></figure><p>使用小端表示法，在内存中的布局为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">      01 00 00 00地址：低→ 高</code></pre></div></figure><p>使用大端表示法，在内存中的布局为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">      00 00 00 01地址：低→ 高</code></pre></div></figure><h2 id="2-2-常量"><a href="#2-2-常量" class="headerlink" title="2.2 常量"></a>2.2 常量</h2><p>常量是程序在运行期间不可发生改变的量，其定义方式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 使用const关键字定义常量const int num &#x3D; 10;</code></pre></div></figure><p>常量 和 <strong>常量表达式</strong> 的区别</p><table><thead><tr><th>对比项</th><th>常量</th><th>常量表达式</th></tr></thead><tbody><tr><td>代码</td><td>const int num &#x3D; 10</td><td>#define N 5</td></tr><tr><td>能否用于指定数组长度</td><td>不行</td><td>可以</td></tr><tr><td>能否用于switch语句</td><td>不行</td><td>可以</td></tr></tbody></table><p>常量表达式用于指定数组的长度</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define N 5int nums[N]; &#x2F;&#x2F; ok</code></pre></div></figure><p>常量表达式用于switch语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int i &#x3D; 0;switch (i)&#123;    case N:        printf(&quot;Hall&quot;);    default:        break;&#125;</code></pre></div></figure><h2 id="2-3-常量指针和指针常量"><a href="#2-3-常量指针和指针常量" class="headerlink" title="2.3 常量指针和指针常量"></a>2.3 常量指针和指针常量</h2><p>常量指针和指针常量是两个概念，容易混淆</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">const int *p; &#x2F;&#x2F; 指针常量cont * int p; &#x2F;&#x2F; 常量指针&#x2F;&#x2F; 记忆法：倒过来念</code></pre></div></figure><p>他们的对比如下：</p><table><thead><tr><th></th><th>指针常量</th><th>常量指针</th></tr></thead><tbody><tr><td>代码</td><td>const int *p;</td><td>int * const p;</td></tr><tr><td>修改指针指向的对象的值</td><td>不允许</td><td>允许</td></tr><tr><td>修改指针指向的对象</td><td>允许</td><td>不允许</td></tr></tbody></table><p>例子如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 指针常量const int* p1 &#x3D; &num1; &#x2F;&#x2F; *p1 &#x3D; 20;&#x2F;&#x2F; Errorp1 &#x3D; &num2; num1 &#x3D; 20; &#x2F;&#x2F; 常量指针int * const p2 &#x3D; &num2; *p2 &#x3D; 30; &#x2F;&#x2F; p2 &#x3D; &num1; &#x2F;&#x2F; Errornum2 &#x3D;  30; </code></pre></div></figure><h1 id="三、预处理指令"><a href="#三、预处理指令" class="headerlink" title="三、预处理指令"></a>三、预处理指令</h1><h2 id="3-1-什么是预处理指令"><a href="#3-1-什么是预处理指令" class="headerlink" title="3.1 什么是预处理指令"></a>3.1 什么是预处理指令</h2><p>预处理指令是以<code>#</code>号开头的指令，如</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 包含头文件#include &lt;stdio.h&gt;&#x2F;&#x2F; 宏定义变量#define N 5&#x2F;&#x2F; 宏函数#define Foo(x) 1 + x</code></pre></div></figure><p>在VS中如何生成预处理文件？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">项目 - 属性 - C&#x2F;C++ - 预处理器 - 预处理到文件 - 是</code></pre></div></figure><h2 id="3-2-宏函数的使用注意事项（重要）"><a href="#3-2-宏函数的使用注意事项（重要）" class="headerlink" title="3.2 宏函数的使用注意事项（重要）"></a>3.2 宏函数的使用注意事项（重要）</h2><p>如下宏函数的例子，可见通过<code>Foo(num)</code>调用可以得到正确的结果31</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;&#x2F;&#x2F; 宏函数#define Foo(x) 1 + x + x * x int main(void) &#123;int num &#x3D; 5;int sum &#x3D; Foo(num); &#x2F;&#x2F; 调用宏函数printf(&quot;sum &#x3D; %d\n&quot;, sum);&#x2F;&#x2F; 输出31return 0;&#125;</code></pre></div></figure><p><strong>注意事项一：宏函数需要括号</strong></p><p>问题：如以上宏函数调用方式修改，则会出问题</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void) &#123;int num &#x3D; 5;int sum &#x3D; 3 * Foo(num); &#x2F;&#x2F; 此处修改printf(&quot;sum &#x3D; %d\n&quot;, sum);&#x2F;&#x2F; 输出33，并非想得到的3 * 31 &#x3D; 93return 0;&#125;</code></pre></div></figure><p>原因：这是因为宏函数只是做简单的文本替换，原语句替换后为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sum &#x3D; 3 * 1 + 5 + 5 * 5 &#x3D; 31</code></pre></div></figure><p>解决方法：对宏函数加括号</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define Foo(x) (1 + x + x * x) &#x2F;&#x2F; 宏函数实现加上括号</code></pre></div></figure><p><strong>注意事项二：宏函数的参数也需要括号</strong></p><p>问题：以上写法还是有问题，如果调用方式再次改变：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sum &#x3D; Foo(num + 1);printf(&quot;sum &#x3D; %d\n&quot;, sum); &#x2F;&#x2F; 输出18，而非想得到的Foo(6) &#x3D; 43</code></pre></div></figure><p>原因：原语句替换后为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">int sum &#x3D; 1 + 5 + 1 + 5 + 1 * 5 + 1 &#x3D; 18</code></pre></div></figure><p>解决方法：为每个变量都加上括号</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define Foo(x) (1 + (x) + (x) * (x)) &#x2F;&#x2F; 变量加上括号</code></pre></div></figure><p><strong>注意事项三：多次++引起的副作用</strong></p><p>问题：警惕宏函数导致的多次副作用</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#define Foo(x) (1 + (x) + (x) * (x))int main(void) &#123;int i &#x3D; 1;int sum &#x3D; Foo(++i);&#x2F;&#x2F; ++i 会导致什么？printf(&quot;sum &#x3D; %d, i &#x3D; %d\n&quot;, sum, i );return 0;&#125;</code></pre></div></figure><p>原因：输出结果为21，并非想得到的Foo(2) &#x3D; 7，因为原语句替换后：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 此处会先++完，然后再进行数学计算int sum &#x3D; 1 + (++i) + (++i) * (++i) &#x3D; 1 + 4 + 4 * 4 &#x3D; 21</code></pre></div></figure><p>解决方法：避免这样使用宏函数</p><p><strong>注意事项四：定义完备的多语句宏函数</strong></p><p>问题：以下代码，按道理应该不会输出，但实际情况还会输出“World\n”</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#define Foo() printf(&quot;Hello\n&quot;);  \printf(&quot;Wrold\n&quot;); int main(void) &#123;if(0)Foo();return 0;&#125;&#x2F;&#x2F; 将输出&quot;World\n&quot;</code></pre></div></figure><p>原因：宏函数展开后</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(0)    #define Foo() printf(&quot;Hello\n&quot;);  \&#x2F;&#x2F; 此段受到if限制，未执行printf(&quot;Wrold\n&quot;); &#x2F;&#x2F; 此段未受到if限制，所以仍输出</code></pre></div></figure><p>解决方法：将宏函数改成do…while语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define Foo() do &#123; printf(&quot;Hello\n&quot;);  \printf(&quot;Wrold\n&quot;); &#125; while(0);</code></pre></div></figure><h2 id="3-3-为什么要使用宏函数？"><a href="#3-3-为什么要使用宏函数？" class="headerlink" title="3.3 为什么要使用宏函数？"></a>3.3 为什么要使用宏函数？</h2><p>宏函数如此麻烦为什么还要用它呢？</p><p>效率高！</p><p>普通函数调用会有额外的开销，像调用函数，会保存寄存器的值，传参…..，像函数返回，会传返回值，恢复寄存器的值…，而这些操作宏函数都没有</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>01_C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-冒泡排序</title>
    <link href="/2022/11/22/05_%E7%AE%97%E6%B3%95/01-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/11/22/05_%E7%AE%97%E6%B3%95/01-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>“冒泡排序解析”</p><h1 id="一、冒泡排序实现"><a href="#一、冒泡排序实现" class="headerlink" title="一、冒泡排序实现"></a>一、冒泡排序实现</h1><p>使用C语言实现冒泡排序，输出： -2 3 7 8 20</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main() &#123;    &#x2F;&#x2F; 定义数组    int num[] &#x3D; &#123;8, 20, -2, 3, 7&#125;;   &#x2F;&#x2F; 定义需要用到的参数    int i &#x3D; 0; &#x2F;&#x2F; 记录循环回合数    int j &#x3D; 0; &#x2F;&#x2F; 记录对比数的下标    int tmp &#x3D; 0; &#x2F;&#x2F; 用来交换的中间数   int n &#x3D; sizeof(num) &#x2F; sizeof(num[0]); &#x2F;&#x2F; 记录数组大小        &#x2F;&#x2F; 外循环，记录回合数(总共需要对比n-1回合)    for (i &#x3D; 0; i &lt; n - 1; i++) &#123;        &#x2F;&#x2F; 内循环，轮流对比两个数，并交换位置        for (j &#x3D; 0; j &lt; n - i - 1; j++) &#123;            if (num[j] &gt; num[j+1]) &#123;            tmp &#x3D; num[j];                num[j] &#x3D; num[j+1];                num[j+1] &#x3D; tmp;            &#125;        &#125;    &#125;        &#x2F;&#x2F; 遍历输出    for (i &#x3D; 0; i &lt; n; i++) &#123;        printf(&quot;%d &quot;, num[i]);    &#125;    printf(&quot;\n&quot;);        return 0;&#125;</code></pre></div></figure><h1 id="二、排序解释"><a href="#二、排序解释" class="headerlink" title="二、排序解释"></a>二、排序解释</h1><p>冒牌排序的排序方法，分为外循环和内循环，外循环为<code>回合数</code>，内循环为<code>挑选元素</code>与<code>下一个元素</code>的比较，</p><h2 id="2-1-外循环"><a href="#2-1-外循环" class="headerlink" title="2.1 外循环"></a>2.1 外循环</h2><p>如上面例子中的数组的外循环回合：</p><table><thead><tr><th>原数据</th><th>8</th><th>20</th><th>-2</th><th>3</th><th>7</th></tr></thead><tbody><tr><td>第一回合</td><td>8</td><td>-2</td><td>3</td><td>7</td><td>20</td></tr><tr><td>第二回合</td><td>-2</td><td>3</td><td>7</td><td>8</td><td>20</td></tr><tr><td>第三回合</td><td>-2</td><td>3</td><td>7</td><td>8</td><td>20</td></tr><tr><td>第四回合</td><td>-2</td><td>3</td><td>7</td><td>8</td><td>20</td></tr></tbody></table><p>像这个数组总共有5个元素，需要对比4个回合，即代码中的<code>(n-1)</code></p><h2 id="2-1-内循环"><a href="#2-1-内循环" class="headerlink" title="2.1 内循环"></a>2.1 内循环</h2><p>内循环：挑选一个数<code>num[j]</code>与它的下一个数<code>num[j+1]</code>比大小，如果前者比后者大，就互换位置</p><p><strong>外循环第一回合中的内循环：</strong></p><p>内循环第一次：8 与 20 比，不调换位置：{8,  20,  -2,  3,  7}</p><p>内循环第二次：20与-2比：调换位置：{8，-2，20，3，7}</p><p>内循环第三次：20与3比，调换位置：{8，-2，3，20，7}</p><p>内循环第四次：20与7比，调换位置：{8，-2，3，7，20}</p><p><strong>外循环第二回合中的内循环：</strong></p><p>内循环第一次：8 与 -2 比，调换位置：{-2，8，3，7，20}</p><p>内循环第二次：8与3比：调换位置：{-2，3，8，7，20}</p><p>内循环第三次：8与7比，调换位置：{-2，3，7，8，20}</p><p>经第一轮循环，最后一个已经是最大的，内循环四不需要</p><p><strong>虽然此时排序已经完成了，但是循环仍然会再走2次</strong></p><p>四个回合的内循环次数分别是：4、3、2、1，即代码中的<code>(n - i - 1)</code></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day66-图书管理系统-01</title>
    <link href="/2022/11/17/03_Python/05_Django/day66%E7%AC%94%E8%AE%B0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-01/"/>
    <url>/2022/11/17/03_Python/05_Django/day66%E7%AC%94%E8%AE%B0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-01/</url>
    
    <content type="html"><![CDATA[<p>“Day66 图书管理系统（一） 学习笔记”</p><h1 id="今日内容概述"><a href="#今日内容概述" class="headerlink" title="今日内容概述"></a>今日内容概述</h1><ul><li>项目准备</li><li>图书管理–图书增删改查</li><li>choices参数（数据库字段设计常见）</li><li>MTV与MVC模型</li><li>多对多关系的三种创建方式</li><li>Ajax操作（重点）</li><li>前后端传输数据编码格式</li><li>ajax发送json格式数据</li><li>ajax发送文件</li><li>django自带的序列化功能（了解，后面讲路飞学城的时候会将更加牛逼的序列化drf）</li><li>ajax结合sweetalert实现删除按钮的二次确认操作</li></ul><h1 id="一、项目准备"><a href="#一、项目准备" class="headerlink" title="一、项目准备"></a>一、项目准备</h1><h2 id="1-1-创建day66-BMS项目"><a href="#1-1-创建day66-BMS项目" class="headerlink" title="1.1 创建day66_BMS项目"></a>1.1 创建<code>day66_BMS</code>项目</h2><p><img src="/../../../img/image-20221117104513853.png" alt="image-20221117104513853"></p><h2 id="1-2-创建数据库"><a href="#1-2-创建数据库" class="headerlink" title="1.2 创建数据库"></a>1.2 创建数据库</h2><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; create database day66;Query OK, 1 row affected (0.01 sec)</code></pre></div></figure><h2 id="1-3-配置连接数据库"><a href="#1-3-配置连接数据库" class="headerlink" title="1.3 配置连接数据库"></a>1.3 配置连接数据库</h2><p>编辑<code>app01/init.,py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymysqlpymysql.install_as_MySQLdb()</code></pre></div></figure><p>编辑<code>settings.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">DATABASES &#x3D; &#123;    &#39;default&#39;: &#123;        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;NAME&#39;: &#39;day66&#39;,        &#39;HOST&#39;:&#39;127.0.0.1&#39;,        &#39;PORT&#39;:3306,        &#39;USER&#39;:&#39;root&#39;,        &#39;PASSWORD&#39;:&#39;123123&#39;,        &#39;CHARSET&#39;:&#39;utf8&#39;    &#125;&#125;</code></pre></div></figure><h2 id="1-4-创建数据表模型"><a href="#1-4-创建数据表模型" class="headerlink" title="1.4 创建数据表模型"></a>1.4 创建数据表模型</h2><p>编辑<code>models.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models# Create your models here.# 创建数据表对象class Book(models.Model):    title &#x3D; models.CharField(max_length&#x3D;32)    price &#x3D; models.DecimalField(max_digits&#x3D;8,decimal_places&#x3D;2)    publish_date &#x3D; models.DateField(auto_now_add&#x3D;True)    # 一对多    publish &#x3D; models.ForeignKey(to&#x3D;&#39;Publish&#39;, on_delete&#x3D;models.CASCADE)    # 多对多    authors &#x3D; models.ManyToManyField(to&#x3D;&#39;Author&#39;)    def __str__(self):        return self.titleclass Publish(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    addr &#x3D; models.CharField(max_length&#x3D;64)    email &#x3D; models.EmailField()    # varchar(254)  该字段类型不是给models看的 而是给后面我们会学到的校验性组件看的    def __str__(self):        return &#39;对象:%s&#39;%self.nameclass Author(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.IntegerField()    # 一对一    author_detail &#x3D; models.OneToOneField(to&#x3D;&#39;AuthorDetail&#39;, on_delete&#x3D;models.CASCADE)class AuthorDetail(models.Model):    phone &#x3D; models.BigIntegerField()  # 电话号码用BigIntegerField或者直接用CharField    addr &#x3D; models.CharField(max_length&#x3D;64)</code></pre></div></figure><p>执行同步数据库操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">python .\manage.py makemigrationspython .\manage.py migrate</code></pre></div></figure><p>确保数据表已经创建</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show tables;+----------------------------+| Tables_in_day66            |+----------------------------+| app01_author               || app01_authordetail         || app01_book                 || app01_book_authors         || app01_publish              || auth_group                 || auth_group_permissions     || auth_permission            || auth_user                  || auth_user_groups           || auth_user_user_permissions || django_admin_log           || django_content_type        || django_migrations          || django_session             |+----------------------------+15 rows in set (0.00 sec)</code></pre></div></figure><h2 id="1-5-数据库添加数据"><a href="#1-5-数据库添加数据" class="headerlink" title="1.5 数据库添加数据"></a>1.5 数据库添加数据</h2><p>使用<code>navicat</code>给数据库添加数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 作者信息表mysql&gt; select * from app01_authordetail;+----+-------+------+| id | phone | addr |+----+-------+------+|  1 | 11111 | 一区 ||  2 | 22222 | 二区 ||  3 | 33333 | 二区 ||  4 | 44444 | 四区 |+----+-------+------+# 作者表mysql&gt; select * from app01_author;+----+--------+-----+------------------+| id | name   | age | author_detail_id |+----+--------+-----+------------------+|  1 | 老一头 |  11 |                1 ||  2 | 老二头 |  22 |                2 ||  3 | 老三头 |  33 |                3 ||  4 | 老四头 |  44 |                4 |+----+--------+-----+------------------+# 出版社表mysql&gt; select * from app01_publish;+----+------------+------+------------+| id | name       | addr | email      |+----+------------+------+------------+|  1 | 浪迹出版社 | 北京 | 123@qq.com ||  2 | 天涯出版社 | 深圳 | 234@qq.com ||  3 | 落花出版社 | 上海 | 456@qq,com ||  4 | 流水出版社 | 广州 | 678@qq,com |+----+------------+------+------------+# 书表mysql&gt; select * from app01_book;+----+----------+--------+--------------+------------+| id | title    | price  | publish_date | publish_id |+----+----------+--------+--------------+------------+|  1 | 红楼梦   | 128.00 | 2022-11-17   |          3 ||  2 | 水浒传   |  68.00 | 2022-11-01   |          2 ||  3 | 西游记   | 200.00 | 2022-11-02   |          1 ||  4 | 三国演义 |  60.00 | 2022-11-18   |          4 |+----+----------+--------+--------------+------------+# 书—作者表mysql&gt; select * from app01_book_authors;+----+---------+-----------+| id | book_id | author_id |+----+---------+-----------+|  1 |       1 |         2 ||  2 |       1 |         3 ||  4 |       2 |         1 ||  7 |       2 |         2 ||  3 |       2 |         4 ||  5 |       3 |         3 ||  6 |       4 |         2 |+----+---------+-----------+</code></pre></div></figure><h2 id="1-6-添加首页"><a href="#1-6-添加首页" class="headerlink" title="1.6 添加首页"></a>1.6 添加首页</h2><p>编辑<code>views.py</code>, 定义页面view</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render# Create your views here.def home(request):    return render(request, &#39;home.html&#39;)</code></pre></div></figure><p>编辑<code>urls.py</code>添加解析</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import pathfrom app01 import viewsurlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    # 首页    path(r&#39;^S&#39;, views.home, name&#x3D;&#39;home&#39;)]</code></pre></div></figure><p>新建文件<code>template/home.html</code>添加首页</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;    &#123;% block css %&#125;    &#123;% endblock %&#125;&lt;&#x2F;head&gt;&lt;body&gt;&lt;nav class&#x3D;&quot;navbar navbar-inverse&quot;&gt;  &lt;div class&#x3D;&quot;container-fluid&quot;&gt;    &lt;!-- Brand and toggle get grouped for better mobile display --&gt;    &lt;div class&#x3D;&quot;navbar-header&quot;&gt;      &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;navbar-toggle collapsed&quot; data-toggle&#x3D;&quot;collapse&quot; data-target&#x3D;&quot;#bs-example-navbar-collapse-1&quot; aria-expanded&#x3D;&quot;false&quot;&gt;        &lt;span class&#x3D;&quot;sr-only&quot;&gt;Toggle navigation&lt;&#x2F;span&gt;        &lt;span class&#x3D;&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;        &lt;span class&#x3D;&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;        &lt;span class&#x3D;&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;      &lt;&#x2F;button&gt;      &lt;a class&#x3D;&quot;navbar-brand&quot; href&#x3D;&quot;#&quot;&gt;图书管理系统&lt;&#x2F;a&gt;    &lt;&#x2F;div&gt;    &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;    &lt;div class&#x3D;&quot;collapse navbar-collapse&quot; id&#x3D;&quot;bs-example-navbar-collapse-1&quot;&gt;      &lt;ul class&#x3D;&quot;nav navbar-nav&quot;&gt;        &lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;图书 &lt;span class&#x3D;&quot;sr-only&quot;&gt;(current)&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;        &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;作者&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;        &lt;li class&#x3D;&quot;dropdown&quot;&gt;          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;dropdown-toggle&quot; data-toggle&#x3D;&quot;dropdown&quot; role&#x3D;&quot;button&quot; aria-haspopup&#x3D;&quot;true&quot; aria-expanded&#x3D;&quot;false&quot;&gt;更多 &lt;span class&#x3D;&quot;caret&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;          &lt;ul class&#x3D;&quot;dropdown-menu&quot;&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Action&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Another action&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Something else here&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;            &lt;li role&#x3D;&quot;separator&quot; class&#x3D;&quot;divider&quot;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Separated link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;            &lt;li role&#x3D;&quot;separator&quot; class&#x3D;&quot;divider&quot;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;One more separated link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;          &lt;&#x2F;ul&gt;        &lt;&#x2F;li&gt;      &lt;&#x2F;ul&gt;      &lt;form class&#x3D;&quot;navbar-form navbar-left&quot;&gt;        &lt;div class&#x3D;&quot;form-group&quot;&gt;          &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;Search&quot;&gt;        &lt;&#x2F;div&gt;        &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-default&quot;&gt;Submit&lt;&#x2F;button&gt;      &lt;&#x2F;form&gt;      &lt;ul class&#x3D;&quot;nav navbar-nav navbar-right&quot;&gt;        &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Jason&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;        &lt;li class&#x3D;&quot;dropdown&quot;&gt;          &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;dropdown-toggle&quot; data-toggle&#x3D;&quot;dropdown&quot; role&#x3D;&quot;button&quot; aria-haspopup&#x3D;&quot;true&quot; aria-expanded&#x3D;&quot;false&quot;&gt;更多操作 &lt;span class&#x3D;&quot;caret&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;          &lt;ul class&#x3D;&quot;dropdown-menu&quot;&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Action&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Another action&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Something else here&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;            &lt;li role&#x3D;&quot;separator&quot; class&#x3D;&quot;divider&quot;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Separated link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;          &lt;&#x2F;ul&gt;        &lt;&#x2F;li&gt;      &lt;&#x2F;ul&gt;    &lt;&#x2F;div&gt;&lt;!-- &#x2F;.navbar-collapse --&gt;  &lt;&#x2F;div&gt;&lt;!-- &#x2F;.container-fluid --&gt;&lt;&#x2F;nav&gt;&lt;div class&#x3D;&quot;container-fluid&quot;&gt;    &lt;div class&#x3D;&quot;row&quot;&gt;        &lt;div class&#x3D;&quot;col-md-3&quot;&gt;                &lt;div class&#x3D;&quot;list-group&quot;&gt;                  &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;list-group-item active&quot;&gt;                    首页                  &lt;&#x2F;a&gt;                  &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;list-group-item&quot;&gt;图书列表&lt;&#x2F;a&gt;                  &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;list-group-item&quot;&gt;出版社列表&lt;&#x2F;a&gt;                  &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;list-group-item&quot;&gt;作者列表&lt;&#x2F;a&gt;                  &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;list-group-item&quot;&gt;更多&lt;&#x2F;a&gt;                &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;col-md-9&quot;&gt;        &lt;div class&#x3D;&quot;panel panel-primary&quot;&gt;          &lt;div class&#x3D;&quot;panel-heading&quot;&gt;            &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;BMS&lt;&#x2F;h3&gt;          &lt;&#x2F;div&gt;          &lt;div class&#x3D;&quot;panel-body&quot;&gt;              &#123;% block content %&#125;                &lt;div class&#x3D;&quot;jumbotron&quot;&gt;                  &lt;h1&gt;欢迎来到亚洲最大的线上读书平台!&lt;&#x2F;h1&gt;                  &lt;p&gt;这里有的没有的书籍都有&lt;&#x2F;p&gt;                  &lt;p&gt;&lt;a class&#x3D;&quot;btn btn-primary btn-lg&quot; href&#x3D;&quot;#&quot; role&#x3D;&quot;button&quot;&gt;点击有你好看哟～&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;                &lt;&#x2F;div&gt;                &lt;div class&#x3D;&quot;row&quot;&gt;                  &lt;div class&#x3D;&quot;col-sm-6 col-md-4&quot;&gt;                    &lt;div class&#x3D;&quot;thumbnail&quot;&gt;                      &lt;img src&#x3D;&quot;data:image&#x2F;jpeg;base64,&#x2F;9j&#x2F;4AAQSkZJRgABAQAAAQABAAD&#x2F;2wCEABsbGxscGx4hIR4qLSgtKj04MzM4PV1CR0JHQl2NWGdYWGdYjX2Xe3N7l33gsJycsOD&#x2F;2c7Z&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;8BGxsbGxwbHiEhHiotKC0qPTgzMzg9XUJHQkdCXY1YZ1hYZ1iNfZd7c3uXfeCwnJyw4P&#x2F;Zztn&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;CABEIALkAsAMBIgACEQEDEQH&#x2F;xAAZAAEAAwEBAAAAAAAAAAAAAAAAAgMEAQX&#x2F;2gAIAQEAAAAAzAAAAAAAAAAADvAAAC2vhKaMDs6wE7K2uzqPMadUQC&#x2F;s9FF8a7qqY0gC+23sc7RLsK6KgGyyblFFWnWVdxRBZqrvlG67zqN&#x2F;I4uQAG6&#x2F;T0z30ZcQAL&#x2F;Wnh1TzaWLzQAetfLPZCadfigA1782fdb5rd51AADW324K80AABr9BHyIgAErb&#x2F;Zr75WeqIAd2XOTuoj1Tj4AbrQAz5AF21R24A86IHoT5XKYOdZsoLdznQHOo+cDZe50BzpgrD0ZudAc6Y87&#x2F;xAAZAQEBAQEBAQAAAAAAAAAAAAAAAwIBBAX&#x2F;2gAKAgIQAxAAAACH0wAAAOOgAAMT7uec80prmd0AxmMstMurUpsOI4liub4jqO70proCEbzCW63ABF1NZhYAOOcQV7voA4ljGbwnvNa730CGJ444DT1W6OPJEOAPRSuiWfPMACuvRT&#x2F;&#x2F;xAAxEAACAQMCBQIEBAcAAAAAAAABAgMAETESIQQQMEFREyAyYXFyBRRAkRUiIzNCYIH&#x2F;2gAIAQEAAT8A&#x2F;wBGtsT1bG1+imDRFibY9gR2wpNehL4FehJ4FGKQf4n2KLkCn2UDoxnciiAaKG5tSxsxtikhRe1z5NEgZIHNWVxdWBFMiuNxRjIOa0AHegCBa96c3PSU3HJBdvpyng9cINVrHkyh1ZT3BFQQiFCoJO9yeTpfccma316aQyZ2WjG3kUoCi1XGL076B5JxWp2O7N+9qV3HwuT9dxSPrGLEZFb+ORRTRgjOCQaeFk3yOiiCIXO7UrFifZMCGU2JBstOzQt&#x2F;URwGwTQ4hNXcKMVwzo5azb+O9h7HU3uKQt3x5NPbU2nF9vfEQJATTAZLqKMyICF&#x2F;mNISyKT3HIlydMa3b54H1qLhxGS7MXkOWNOiupVlBB7Gn&#x2F;DEO6OVr+GSjEy0sTogDPqPc2tyfZH+00ssiiwamkd8npwm8Y+W1Kuo0Bb2Hi+GvYShvtBagQygg3BFxTpbcVObRn57dXh2sxXzSrpHKaHgYV1yoNzk3ZqjVVRQhJXtc3rYjsQaPEKnErwwQ7rnkRepuFZxcPuBsOrw6hIEKi5YXNK4aiQBcmwqT8vOND2YXp5I4gutgoOwJxXrwJpRGVjhUTenlRDYneklRzYHemJAq5jVndsdWDifTGhxdaSSJt1cVO5Z7dhVj571AxZCp7VpWNGKKo27C1G5796Fx3p50RAzZIwKmneY+FGB1gSCCMigwk3HxdxQBJsBUMZRd8miLgg08LqcEiiNIu+wqRzI1&#x2F;2H6AEjcVHxbrswvXqeVr1B4NF3ONqZ2c3Y&#x2F;oFR2wpNDh3OSBUUSxsGO5BBoxRSjUO&#x2F;cUeFHZzQgjTd2qeJJXd12JYmjw7jBBpkdcqR1FUsQAN6SBV3O55kUkrx4JFfm5bfEtPKz5YtQvk83hRsbGiCpIPSij0L8zn3WHj3cQlxrHbPRgTU1zheXenmKOVKgi1QyFw1wBbo52NOuhivQjTQgHLualj9QC2RSIEWw957fXnxC4b&#x2F;AIffAuqQeBvzGT0W5uupWXyPfw62S&#x2F;nmvRbB9ky6ZG90X9tPtHNcdFvhPs4j4x9vP&#x2F;&#x2F;EACQRAAEEAAUFAQEAAAAAAAAAAAEAAgMREBIgMVETISJAQTBx&#x2F;9oACAECAQE&#x2F;APYuiVYRl4C6rkJT9CzBXZ0uqu5RcKTbBFbrIeU6yTe6Dk1zdB7AogEcuwjYdygGqSP6DhldVGtWS3nhDArp+YI9PuP4swVk7LbW6XhGRx+oTRncG0+W6yighK5NeHaZXfEGk7IijWhpykHQTQJRNlAkGwib0xG21jKfH8Ij5Yf&#x2F;xAAiEQEAAgEEAgIDAAAAAAAAAAABAAIREBIgITAxA0ETQFH&#x2F;2gAIAQMBAT8A&#x2F;YVraFiN5vYXm8gtnjYNHQ0rg49J&#x2F;XRY7vqVX7NMOMcrdMdCVTPfOwmcw+PJ3ERxPxmIVXwZQ6jlcytrPgbRVmy56t1KFhyuWb2CPGz9QM8Rw8HwVetbevBX3p&#x2F;&#x2F;2Q&#x3D;&#x3D;&quot; alt&#x3D;&quot;...&quot;&gt;                      &lt;div class&#x3D;&quot;caption&quot;&gt;                        &lt;h3&gt;Thumbnail label&lt;&#x2F;h3&gt;                        &lt;p&gt;...&lt;&#x2F;p&gt;                        &lt;p&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-primary&quot; role&#x3D;&quot;button&quot;&gt;Button&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-default&quot; role&#x3D;&quot;button&quot;&gt;Button&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;                      &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                  &lt;&#x2F;div&gt;                  &lt;div class&#x3D;&quot;col-sm-6 col-md-4&quot;&gt;                    &lt;div class&#x3D;&quot;thumbnail&quot;&gt;                      &lt;img src&#x3D;&quot;data:image&#x2F;jpeg;base64,&#x2F;9j&#x2F;4AAQSkZJRgABAQAAAQABAAD&#x2F;2wCEABsbGxscGx4hIR4qLSgtKj04MzM4PV1CR0JHQl2NWGdYWGdYjX2Xe3N7l33gsJycsOD&#x2F;2c7Z&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;8BGxsbGxwbHiEhHiotKC0qPTgzMzg9XUJHQkdCXY1YZ1hYZ1iNfZd7c3uXfeCwnJyw4P&#x2F;Zztn&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;CABEIALkAsQMBIgACEQEDEQH&#x2F;xAAaAAACAwEBAAAAAAAAAAAAAAADBAECBQAG&#x2F;9oACAEBAAAAAMfulrdwWSHLdNLVrkKsNOijMbdIUuK3BbyoC7eWkZ16Iuza&#x2F;RmdBCcIElFlkffDwWht1qPh1vFa1Gxnj3BhlZ+G02qIAu31JJcSU6NO44y2AXgJjegCBHTpmZm&#x2F;Q3WlYtVWx6BEU8jiaFL3cIJGKgIzVO7F4Wpa1qMLFg4A0EXpizHCrRwogEXMTlYgVoibzA9KawrS0zZdhYw1GaAcsE7dxgHDS4grDtpQQVJKLMd0DiGMekqjSgn7ZW3eKqKA0g69b07NbWWV0S1ytM8hHnG0MjeZZGHBmlBaDNcorAwiu+TO1NI895SKj7QYXQiI6Hjzm62ra&#x2F;eVilY0yJLTWsdr9TO0nTTTErTo0zZArRFSa1KZjDDA6Apa5XRZNZiOZ0KBzjQTp6&#x2F;oBiaxs6O6IdaumgSevLO7o589k5cU6Z0nj4Kc3m1vaTCQe7LRXNeNw3Y+dxOm3tegOVfpErF3WWF8TN4ndHuolXMETpJIzmMLAz6mt3f&#x2F;xAAYAQEBAQEBAAAAAAAAAAAAAAABAAIDBP&#x2F;aAAoCAhADEAAAAO&#x2F;Mc3PtjVMXTFkSaaHOqqk3gJE25NJlQ1EI5N51MUg0Mym+OOlCkwapHMFPbjXLvaDWHOOmsPO1o6c98uHq59K68XPD0OdY7Ypy5z1yzrkPD0FHp405o1I65Z3jeVOuc2sTI1rlnqJRNWdg1Tg6CUTG8OTROeHbqTVf&#x2F;8QANhAAAgIBAgQEAwYGAgMAAAAAAQIAEQMSIQQxQVEQEyJxBTJhFCBCgZGxIzNTYnKCFVI0Y6H&#x2F;2gAIAQEAAT8Al0ItUTYsdIZwCa+JX+0EzMLxZPaJvlaAese0Y17xBVCIdz7xjYimg&#x2F;e7jg6jUxPrQNcz&#x2F;JH2acmisfTOGO7TVGMo9pl4d8TaPm7UJi+F58gtyEEX4Pg6vkM&#x2F;4vhf7&#x2F;1mLgeHwtqQEN3uPjYqRYNiYsZ81wZopiYE9RMWAbmHlHFNqjCiGHKYn8tq&#x2F;CeUZgyzMtExvmi&#x2F;KJwwFtK+s0iaBF2YQOw6zzhNYMLQOLmFafMxj5d9oHJ6RWlwtcbw0CIByuZsVqYy7ReU4TGWDQ4py6y&#x2F;rEJ5mIxMq8gvvNXQzK2hZgU1rPNv2mktrvq5JnlqIyj7hE0iHGx5GFXTeIdazMuhjE9dATCgxrMvEDkIA55AzRl+kxZhyNg9jMZ5zfXF5TJqyPpgYrQqEgXUy8RRoC5k4nJiNMoMxcQmXlzgO3gTvAVHMwMIQpEVNJNTix6x7ThMQJLEbCNXKAheSgTUe81Q8NiyA2oszHw5wMdzRh9XSNaKID6tUDgwrtH08iJlw4n52Jj4dMZGljzgWhCI+oaQBzO57TiWdMhCs1CqmI59IammPLexBB7HwyocmQCOAiKByiY8jAUIFxnYsbnldiDNDdjFZg2lukBDCEgdIXB2M0IN5akgAbDfwfGGG8OIRUHQQYiRHxlYy9pZERm6CeWW5wYBBix6qYC4+JVddR9Aj5wo9MAGYll27npEZkYqTNZ7zMuoahzEV9hGaG7s7CNkZwdALV2EwE6STsZqheO8xKdOo9YDH3EY1zEVdUVFHhcztQDdRHOtFN7iJsppKPeKjhQFEbHYBcmx22mgdz+sbkfaJUuBR1FmCgJloGFjCxjbmeawAEGb6xeIUHczNkVwKmJ6EGQTzBHy1BqIsrFFMFPKA2YI7iqM1r3nm3qGg8vfnAaMBgNQvULNlygIL8DGIU2eUV0cbMDCBKHgsuFqBMRiTZiepfpGRStVUAqF6jtZ8CgGT8RAhimNlFR8ndgJiz8JhQ+sk9TUbjuHyZdgVvq3g66oqHDk1fhmq1Wk17bkECFnsacRA66iBUfJlU6A1t7THegXzhjtyF9YFTymoxDsIWhNRzcPg6FQGHOMeo&#x2F;MdRC8Ds7EKDQ6xwbJuNss4TFrPmP8oPpHczXvEzJkLAHccxGW4cf0hRj3i46gNTLlVBZiZXzcShPIGwJnZ1x6lNFTf5GYMmvGrDqJcYnwcvdLKy9zFyJlHp59VmVN47AGmBPtC5TGa1b9NNRmBEKnI4QHnFAAAAoAUBGJG4jsycRqBptUx5BkW+vhUNAWZkznkn6zJ6UZ236ThTWT8pkGrHkHdDPh&#x2F;EUTib3WavAJtcqVFy1U+12Kaj9TC6C6aNk7maz+U4BbTNkb2gmxPOFi3q63cxvVTzXEOZuwjEtzMagCZlyHIw7DlOFT1EmA713mK9VjpMOUZUDRL+kG8yYQw9LFfafZn&#x2F;qvL3hNxmMdunhwxIxVfMkzrMx04chrmK&#x2F;WCJmK&#x2F;UT7Yv8ATMbi2PJAIeJzH8VQsx5sTMKaiSeQmJQvKA+tfeINI&#x2F;OcJpUsgJugTYiL1gl&#x2F;cPfxwisae0AnGHSiL3JMEI+7gT+CD3JMFiKfUPeBixqcKhbIMg&#x2F;6BXEAIggBIvp3PKWn9RP18DG7eKClHtKO04s3krsAIPA&#x2F;cClAijooEO8NgMfoZiNODMWUiiGKsOTROLz8mCGfaMx5BRDdB8zmp5uDs0uMYBCJUAiDcTK2t2buT4344l15ca92EYmz4Oax5P8AAwbERWq5jzd4vEaAKazHz6jdkn6zzW8DvAu0y4XRcbMpAdbExcHlfS1oOR3MfGQ1AdJqKjIT0Uw+B5D7nCD+OD2DGFgQR4ZjWHJ9aEMT1AfpFJBIgN8oLEsfWUTAlkACyTQAnDfDseMKco1PPi6WmJ5wwJxYgLsoJ5JBPcipmasDV+N68TOkPhwY3yt2AEJBoxELXOIPoA7t+3hjPMQj1t4Bb5zTEwu50opY&#x2F;ScDwQwDXkAOT9vD4mL4U+4mFQFrsAP0nEP5eF26hTX57TLwpZAi2SFsQCzGFeIUmMtTgMWvG&#x2F;1aeQ40U60OQIgxlVrSL+k4lGUJY6tKi7NH2aXA30mpf+sVVUUoAHYePHgnhv8AdZrZXNd5l9SoGbnkH&#x2F;yzC1OP8RONxaM7Ho&#x2F;qjix4KsEbfacJj8jhsasKZhZm7EDtBfPrPiROtAe1w9BOprvGFwbiAXNDdvucRWij1M1Mtm4mda&#x2F;iKaEGXXqYiuoH0hbHlATImoA7RuE4ZrCsymP8Ly3aOrQ8FxQoeTF4E882UL&#x2F;avqMxomEEYl0tys7tGQPpgGkaVAAEyjS3uJ8T&#x2F;nIP&#x2F;WJzaLBKINw33M37nxHOcZyWPyPvPwz8OL&#x2F;ExOkf5T7ROSQ&#x2F;Pm9x+0PziL8x95+IewmT+Yv+v7zP8yz4j&#x2F;5X+iwdZ0nfw6eH&#x2F;8QAIBEAAgICAgMBAQAAAAAAAAAAAAEQEQIxEiADITAiUf&#x2F;aAAgBAgEBPwC0ckN2NyoxmizF7LvLsnDh6E6TMdXH5qErH6ELK2y40Nl&#x2F;CoyafwU0yyhYIfiv2j2vThmGNs8mPFwoeAsEUaPIoowVGauEy10Yziv4UhaGZbin8ctjRxZxUWWtX2fS44PnY5UPqtxQ1QkP0eJ&#x2F;tdf&#x2F;xAAiEQACAgICAwEAAwAAAAAAAAAAAQIREDESIQMgQTIiYnH&#x2F;2gAIAQMBAT8AooSF6telHkSVUcUoW9+zGLC2NXJHk7aQju8N0LtDHFJJji18x+kJHGu&#x2F;uH6Ltl0l1bHL58P4kLWF60iWui7Ol2zmhLEpti8qj0yLT&#x2F;xnH+w6JyqLPFLlHvEnhTHN&#x2F;Bm2ePVZ8jtM8Tq8NWcXmWhbNHJlkn2Q+i1i1mRFesNMTo5L4jk8UNNkdZeniOvbkuFCeW+hojperxYnY3SF3sn+GLQ8&#x2F;wD&#x2F;2Q&#x3D;&#x3D;&quot; alt&#x3D;&quot;...&quot;&gt;                      &lt;div class&#x3D;&quot;caption&quot;&gt;                        &lt;h3&gt;Thumbnail label&lt;&#x2F;h3&gt;                        &lt;p&gt;...&lt;&#x2F;p&gt;                        &lt;p&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-primary&quot; role&#x3D;&quot;button&quot;&gt;Button&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-default&quot; role&#x3D;&quot;button&quot;&gt;Button&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;                      &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                  &lt;&#x2F;div&gt;                  &lt;div class&#x3D;&quot;col-sm-6 col-md-4&quot;&gt;                    &lt;div class&#x3D;&quot;thumbnail&quot;&gt;                      &lt;img src&#x3D;&quot;data:image&#x2F;jpeg;base64,&#x2F;9j&#x2F;4AAQSkZJRgABAQAAAQABAAD&#x2F;2wCEABsbGxscGx4hIR4qLSgtKj04MzM4PV1CR0JHQl2NWGdYWGdYjX2Xe3N7l33gsJycsOD&#x2F;2c7Z&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;8BGxsbGxwbHiEhHiotKC0qPTgzMzg9XUJHQkdCXY1YZ1hYZ1iNfZd7c3uXfeCwnJyw4P&#x2F;Zztn&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;CABEIALkAsAMBIgACEQEDEQH&#x2F;xAAaAAEAAwEBAQAAAAAAAAAAAAAAAgMEAQUG&#x2F;9oACAEBAAAAAPPAAAAAd4AAOJ6bXaO0VgAX35M1SzXqYQA088+EXHO7PT8&#x2F;gCy&#x2F;zYiLnO79&#x2F;mgNuKuRyKEeT9zDSDu&#x2F;FyXUYcjCLfr80F98rW3leJzFm5f7HkA0X+jZMjGumGHz7vd8QE&#x2F;V28WRgjVGHjPe8MHPY1OaI1c5THvl1+p5YH0sYQ1xprU8nilb5oOfSzhKNNvYVVx5TLz+A922Mqs+mfM9bubuIDdvo7oqZtddbkMMQJezPD5tcPW9XLDLkAC&#x2F;1LclbV2qjzwAJ79kYcjmxAAJT9CNcZ56HAA0+r5VuqmqvN3fhiAc365YaOR5drozQAJ3V7dkYc7XghyIBqsxz9G+POYMV92bjj&#x2F;&#x2F;xAAZAQEBAQEBAQAAAAAAAAAAAAAAAQIDBAX&#x2F;2gAKAgIQAxAAAADpkCCgADFxss1NZoDGueqEWzpioOHVRKsl689SJeHZYtS5s3jpmDh3m5FpnWN46Zg4emWCmV6Z68IOPozVRQ7cN4DG+XbWZc3pz6cqAM64dzWe&#x2F;FACXzd&#x2F;RzlOG&#x2F;TwsAutPmek1Po+bBD&#x2F;xAA2EAACAQMDAAkCAwcFAAAAAAABAgADESEEEjEQEyAwMkFRcYFhkSIzQgUUNENygqFAUFKx0f&#x2F;aAAgBAQABPwD&#x2F;AGAKzcKTCCORb&#x2F;RKjNwItEjhb&#x2F;4gpi34j8cwikDyBLUjm+76HMq0w35agQUFFgw+Y1J1YjaYQQbEWPe06JOSPj&#x2F;2F0ojJF&#x2F;pH1bMTtwI9Zz+ozeYKrDzi6motrGUte45iaujVwSVPkZVo7kDAg28xCLd3RpcO3xK1fbdVjsW6bS0t0AzT6l6bDManTrpuXBjKVJB5Hc0k3tK9TYLCMSZaFZtm2WzCJaWgmlrbTNVSDoKiDI7miNlLceTmVCWabYFhWbZtgXMK8zbCJbmUjZppahamBNRT6uobeE5Xtou9lX1MrGwAlswrNsKm82G3E2m0CwiWhHM9YviE0dSx+ZrKeD9LMPY9ugv4ryucyjpXfJwsNHTocvc+gm0ubUqXyZ1Sek6lPSVaIKHYBeWUYqUyJ1Wnbh7e8bS4uDKlJk5E8ujTmxmqzT90Pb05G5R6tFXrdWqHK5J+IaPWfmn2QYAgpUl4RewZgw0aR5RYdPTGUJU&#x2F;Qwq&#x2F;D2YesraYAErDi4lDxTUC1FD7dumdrqfrNKoNd6g4NOEy8B6TLwmFoTDNWu2sZpsuJqfAF+ghySe3+zxUCPuUhbDbHdEIDOoJ9TLi1wYDnoMMvDCR6iA9GtH4hNGCayia17qQD6Qm57VrkD1Mpbm3348oaaqxIUXPJjIp8s+owYlw4U&#x2F;B6DHwILvgH3MNJDyu7+rMajSP8tYqbTybfWGV031FESmlLgXYzFQbGHMOCR2jKBuzN5FBb5jdAtC58oatuYCGlgBGhMJl4QCYXybRDci&#x2F;IMJuSfU9vRODpgfMDaYWtOsEBvHJWHcTKZ2qAZvEJjGGDoLDcbRz1dMk+JsDuNA9ndPJl&#x2F;yI8&#x2F;F5SjqqZqdSyuKnpGq0eC1veGpQH6xN6nw3PsI9dFfZkt6CKDbMfo4iujXswj1KVO&#x2F;BPoI7tUYs3cI5R1ccgxXVwGHBgE11AvaomGEGo1gTNZ&#x2F;nM&#x2F;ftX5VD9hDX1lY7OtqNu8rzR6YUucseTDxH56NTU&#x2F;lj+7vKNc0jY5UxHDAEG4mGFo9EZBRWUnIIxDR0540yj5aJRRPCgETEZ4ZWrdWMeL&#x2F;AK76nUamcfaU9Sp+hgYGECG0vLypqQMJk+sJJNz3yo7i4GPXynVqOW+0poqom0HK35hqMvIMNYehnWMYHG0q6hgZVFIJcJbMweDCpXkd5paArud3gXmOqtT2WAFsW8o6FSVYSjX2AK4uBwZ1lB&#x2F;1D5xGpLyCIV28kfeGpTHLX9pUc1CMWA4Ep0y5+nnLBl2sMSohRivd0qjUUCj3IiV1f6GOi1BYiPQdeBcdBEKiBb8C8TTE5bAgQAWAsI9YDC5MZi+ScjuqalnUAXjcxmtKFfADn2PQVB5AMNOn&#x2F;wAF+06umP0L9pYRiFFybSpW3kL+mGAEmw7rRfxK&#x2F;wBLTU&#x2F;xD+8fiL4R7TTeA+8PQejU&#x2F;mf2w+Nffo03jaN4m9z2f&#x2F;&#x2F;EACMRAAICAQQBBQEAAAAAAAAAAAECABEgAxASMSETIjBBUlH&#x2F;2gAIAQIBAT8A+YtUszz&#x2F;AGWYGyZqyVqNHEmzLly9zFNjc9ZXDE6wIo5fUTr49M94MKO1SjvRMVeIwdbnUsQnZF+8+HLdasSqyIZlPHuaeo+ixVwanp6ep5Vp6B&#x2F;c4pp+WaFn1W9olEAX3ije7jX1cdF1BRjDgxAM5N+jNNebUTEQKKEJtyN&#x2F;&#x2F;8QAIhEAAQQCAgEFAAAAAAAAAAAAAQACESAQIRJBMQMTMFFh&#x2F;9oACAEDAQE&#x2F;APmAUBaUBEWAsRUDShQoyEcjzYjDvNG7UV7TvNO8RRokr1gBFGGW4kqUMBwG09&#x2F;M0Y6McSoAw93Vw4jLuXVxEiUWh4kLk5uiF7n4pc&#x2F;QCADBtGJ1WNSmuLTIQMhQPpOPEIkk7RGhn&#x2F;&#x2F;Z&quot; alt&#x3D;&quot;...&quot;&gt;                      &lt;div class&#x3D;&quot;caption&quot;&gt;                        &lt;h3&gt;Thumbnail label&lt;&#x2F;h3&gt;                        &lt;p&gt;...&lt;&#x2F;p&gt;                        &lt;p&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-primary&quot; role&#x3D;&quot;button&quot;&gt;Button&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-default&quot; role&#x3D;&quot;button&quot;&gt;Button&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;                      &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                  &lt;&#x2F;div&gt;                &lt;&#x2F;div&gt;              &#123;% endblock %&#125;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&#123;% block js %&#125;&#123;% endblock %&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>运行后的界面如下:</p><p><img src="/../../../img/image-20221117144310521.png" alt="image-20221117144310521"></p><h1 id="二、图书管理系统的增删改查"><a href="#二、图书管理系统的增删改查" class="headerlink" title="二、图书管理系统的增删改查"></a>二、图书管理系统的增删改查</h1><h2 id="2-1-图书列表展示页面"><a href="#2-1-图书列表展示页面" class="headerlink" title="2.1 图书列表展示页面"></a>2.1 图书列表展示页面</h2><blockquote><p>实现功能：点击“图书列表”展示当前已有的图书</p></blockquote><p>1、编辑<code>urls.py</code>添加url</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    # 首页    path(&#39;&#39;, views.home, name&#x3D;&#39;home&#39;),    # 添加图书展示页    path(&#39;book&#x2F;list&#x2F;&#39;, views.book_list, name&#x3D;&quot;book_list&quot;)]</code></pre></div></figure><p>2、编辑<code>views.py</code>添加view</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import renderfrom app01 import models  # 导入模块# Create your views here.def home(request):    return render(request, &#39;home.html&#39;)# 创建书籍展示页的viewdef book_list(request):    # 先查询出所有的书籍信息 传递给html页面    book_queryset &#x3D; models.Book.objects.all()    return render(request, &#39;book_list.html&#39;, locals())</code></pre></div></figure><p>3、创建书籍展示页的html文件<code>templates/book_list.html</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;#继承home页面#&#125;&#123;% extends &#39;home.html&#39; %&#125;&#123;#重写已定义的content块#&#125;&#123;% block content %&#125;&#123;#    添加按钮#&#125;    &lt;a href&#x3D;&quot;&quot; class&#x3D;&quot;btn btn-success&quot;&gt;添加&lt;&#x2F;a&gt;    &lt;br&gt; &#123;#    添加空格#&#125;    &lt;br&gt;&#123;#    创建表格,使用bootstrp的模板#&#125;    &lt;table class&#x3D;&quot;table table-hover tabular-stripped&quot;&gt;        &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;ID&lt;&#x2F;th&gt;            &lt;th&gt;书名&lt;&#x2F;th&gt;            &lt;th&gt;价格&lt;&#x2F;th&gt;            &lt;th&gt;出版日期&lt;&#x2F;th&gt;            &lt;th&gt;出版社&lt;&#x2F;th&gt;            &lt;th&gt;作者&lt;&#x2F;th&gt;            &lt;th&gt;操作&lt;&#x2F;th&gt;        &lt;&#x2F;tr&gt;        &lt;&#x2F;thead&gt;        &lt;tbody&gt;            &#123;% for book_obj in book_queryset %&#125;                &lt;tr&gt;                    &lt;td&gt;&#123;&#123; book_obj.pk &#125;&#125;&lt;&#x2F;td&gt;                    &lt;td&gt;&#123;&#123; book_obj.title &#125;&#125;&lt;&#x2F;td&gt;                    &lt;td&gt;&#123;&#123; book_obj.price &#125;&#125;&lt;&#x2F;td&gt;                    &lt;td&gt;&#123;&#123; book_obj.publish_date | date:&#39;Y-m-d&#39;&#125;&#125;&lt;&#x2F;td&gt;                    &lt;td&gt;&#123;&#123; book_obj.publish.name &#125;&#125;&lt;&#x2F;td&gt;                    &lt;td&gt;                        &#123;% for author_obj in book_obj.authors.all %&#125;                            &#123;% if author_obj.last %&#125;                                &#123;&#123; author_obj.name &#125;&#125;                            &#123;% else %&#125;                                &#123;&#123; author_obj.name &#125;&#125;、                            &#123;% endif %&#125;                        &#123;% endfor %&#125;                    &lt;&#x2F;td&gt;                    &lt;td&gt;                        &lt;a href&#x3D;&quot;&quot; class&#x3D;&quot;btn btn-primary btn-sm&quot;&gt;编辑&lt;&#x2F;a&gt;                        &lt;a href&#x3D;&quot;&quot; class&#x3D;&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;&#x2F;a&gt;                    &lt;&#x2F;td&gt;                &lt;&#x2F;tr&gt;            &#123;% endfor %&#125;        &lt;&#x2F;tbody&gt;    &lt;&#x2F;table&gt;&#123;% endblock %&#125;</code></pre></div></figure><p>4、给<code>图书列表</code>按钮添加链接，修改<code>home.html</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 75行&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;list-group-item&quot;&gt;图书列表&lt;&#x2F;a&gt;# 改为&lt;a href&#x3D;&quot;&#123;% url &#39;book_list&#39; %&#125;&quot; class&#x3D;&quot;list-group-item&quot;&gt;图书列表&lt;&#x2F;a&gt;</code></pre></div></figure><p>5、点击<code>图书列表</code>查看效果</p><p><img src="/../../../img/image-20221117151215258.png" alt="image-20221117151215258"></p><h2 id="2-2-书籍的添加"><a href="#2-2-书籍的添加" class="headerlink" title="2.2 书籍的添加"></a>2.2 书籍的添加</h2><h2 id="2-3-书籍的编辑"><a href="#2-3-书籍的编辑" class="headerlink" title="2.3 书籍的编辑"></a>2.3 书籍的编辑</h2><h2 id="2-4-书籍的删除"><a href="#2-4-书籍的删除" class="headerlink" title="2.4 书籍的删除"></a>2.4 书籍的删除</h2><h1 id="三、Choies参数"><a href="#三、Choies参数" class="headerlink" title="三、Choies参数"></a>三、Choies参数</h1><h1 id="四、MTV与MVC模型"><a href="#四、MTV与MVC模型" class="headerlink" title="四、MTV与MVC模型"></a>四、MTV与MVC模型</h1><h1 id="五、多对多的三种创建方式"><a href="#五、多对多的三种创建方式" class="headerlink" title="五、多对多的三种创建方式"></a>五、多对多的三种创建方式</h1><h1 id="六、Ajax"><a href="#六、Ajax" class="headerlink" title="六、Ajax"></a>六、Ajax</h1>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day65-DjangoORM进阶-02</title>
    <link href="/2022/11/16/03_Python/05_Django/day65%E7%AC%94%E8%AE%B0-DjangoORM%E8%BF%9B%E9%98%B6-02/"/>
    <url>/2022/11/16/03_Python/05_Django/day65%E7%AC%94%E8%AE%B0-DjangoORM%E8%BF%9B%E9%98%B6-02/</url>
    
    <content type="html"><![CDATA[<p>“Day65 Django ORM 操作数据库 进阶用法（二）  学习笔记”</p><h1 id="今日考题"><a href="#今日考题" class="headerlink" title="今日考题"></a>今日考题</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;今日考题1.必知必会N条都有哪些，每个都是干啥使的2.简述神奇的双下划线查询都有哪些方法，作用是什么3.针对多对多外键字段的增删改查方法有哪些，各有什么特点？4.什么是正反向的概念，及查询口诀，你能否总结一下正反向查询不同情况下点击不同字段的规律&quot;&quot;&quot;</code></pre></div></figure><h1 id="上周内容回顾"><a href="#上周内容回顾" class="headerlink" title="上周内容回顾"></a>上周内容回顾</h1><ul><li><p>单表的增删改查</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 增1.create()2.对象.save()# 查1.all()查所有2.filter()筛选条件，括号内多个参数之间逗号隔开并且默认是and关系3.get()筛选条件，条件不存在直接报错 所以不推荐使用# 改1.update() queryset对象帮你封装的批量更新2.对象.save()# 删1.delete()queryset对象帮你封装的批量删除2.对象.delete()&quot;&quot;&quot;在实际的项目中 数据是不可能真正删除的 一般情况下都用一个字段来标记是否删除&quot;&quot;&quot;</code></pre></div></figure></li><li><p>测试环境准备</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 你如果只想测试django某一个py文件(大部分情况下就是models.py)# 在应用下的tests.py或者自己新建一个任意名称py文件(tests.py)&quot;&quot;&quot;1.去manage.py拷贝前四行2.自己书写两行import djangodjango.setup()&quot;&quot;&quot;</code></pre></div></figure></li><li><p>如何查看orm内部的sql语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.queryset对象可以直接点query查看queryset对象.query# 2.配置文件配置日志相关代码即可(不要记 直接拷贝使用即可)参考笔记或者博客自己保存好</code></pre></div></figure></li><li><p>必知必会N多条</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.all()# 2.filter()我们在利用数据的主键字段筛选数据的时候，可以不考虑主键字段叫什么，直接使用pk代替# 3.get()# 4.values()获取指定字段对应的数据 返回的结果是一个queryset对象(列表套字典的形式)# 5.values_list()获取指定字段对应的数据 返回的结果是一个queryset对象(列表套元祖的形式)# 6.count()统计查询出来的数据个数  # 7.first()# 8.last()# 9.order_by()默认是升序，你可以在字段前面加一个负改为降序# 10.reverse()前面必须是已经排讯过了 才能生效# 11.exclude()排除...在外 # 12.distinct()去重(主键一定不要忘了)# 13.exists()判断数据集是否有值 返回布尔值</code></pre></div></figure></li><li><p>神奇的双下划线查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 价格大于 小于 大于等于 小于等于price__gtprice__ltprice__gteprice__lte# 成员查询price__in# 范围查询price__range# 模糊查询title__contains默认是区分大小写的title__icontains忽略大小写# 只按照年份或者月份或者...create_time__yearcraete_time__month</code></pre></div></figure></li><li><p>外键字段的增删改查</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 一对多publish_id &#x3D; 1punlish &#x3D; publish_obj# 多对多addremove上述两个方法括号内即可以传数字也可以传对象并且都支持多个set括号内必须传一个可迭代对象 可迭代对象里面的元素可以数字也可以对象并且都支持多个clear括号内无需给任何参数，直接清空对应的关系数据</code></pre></div></figure></li><li><p>多表查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 正反向的概念正向  外键字段就在我手中  反向  外键字段不再我手中# 小口诀正向查询按外键字段  反向查询按表名小写  _set    .all()# 温馨提示书写orm语句跟书写sql语句一样，不要试图一次性写完，可以分步书写  &quot;&quot;&quot;多表操作1.子查询2.联表操作inner joinleft joinright joinunionDjango orm中1.基于对象的跨表查询子查询1.先拿到一个数据对象2.对象点点点 2.基于双下划线的跨表查询联表操作&quot;&quot;&quot;1.基于对象的跨表查询book_obj.publish  book_obj.authors.all()  author_obj.author_detail    publish_obj.book_set  # App01.Book.None  publish_obj.book_set.all()  author_obj.book_set.all()  author_detail.author2.基于双下划线的跨表查询models.Book.objects.filter(pk&#x3D;1).values(&#39;title&#39;,&#39;publish__name&#39;)  models.Publish.objects.filter(book__id&#x3D;1).values(&#39;book__title&#39;,&#39;name&#39;)    # 利用双下划线的跨表查询可以帮助你跨N多张表，只要有外键字段  models.Book.objects.filter(pk&#x3D;1).values(&#39;authors__author_detail__phone&#39;)  # 图书管理系统 图书的增删改查</code></pre></div></figure></li></ul><h1 id="今日内容概要"><a href="#今日内容概要" class="headerlink" title="今日内容概要"></a>今日内容概要</h1><ul><li><p>聚合查询(聚合函数的使用)aggregate</p><p>max、min、sum、count、avg</p></li><li><p>分组查询(group by的使用)annotate</p></li><li><p>F与Q查询</p></li><li><p>django中如何开启事务</p></li><li><p>orm中常用字段及参数</p></li><li><p>数据库查询优化(only与defer、select_related与prefetch_related)</p></li><li><p>图书管理系统作业讲解</p></li></ul><h1 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h1><h2 id="1-1-创建数据库"><a href="#1-1-创建数据库" class="headerlink" title="1.1 创建数据库"></a>1.1 创建数据库</h2><p>参考<code>day64</code>的<code>1.1</code>节创建Django项目、数据库、app应用</p><p><a href="http://localhost:4000/2022/09/15/03_Python/05_Django/day64%E7%AC%94%E8%AE%B0-DjangoORM%E8%BF%9B%E9%98%B6-01/#1-1-%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87">http://localhost:4000/2022/09/15/03_Python/05_Django/day64%E7%AC%94%E8%AE%B0-DjangoORM%E8%BF%9B%E9%98%B6-01/#1-1-%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87</a></p><h2 id="1-2-创建测试脚本"><a href="#1-2-创建测试脚本" class="headerlink" title="1.2 创建测试脚本"></a>1.2 创建测试脚本</h2><p>编辑<code>test.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.test import TestCase# Create your tests here.import osimport sysif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &#39;day65_DjangoORM_02.settings&#39;)    import django    django.setup()    # 在这个代码块的下面就可以测试django里面的单个py文件了    # 所有的代码必须等环境准备完毕之后才能书写    from app01 import models    models.User.objects.all()</code></pre></div></figure><h2 id="1-3-创建数据表"><a href="#1-3-创建数据表" class="headerlink" title="1.3 创建数据表"></a>1.3 创建数据表</h2><p>编辑<code>models.py</code>创建ORM对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Book(models.Model):    title &#x3D; models.CharField(max_length&#x3D;32)    price &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)    publish_date &#x3D; models.DateField(auto_now&#x3D;True)    # 添加表关系    # 一对多    publish &#x3D; models.ForeignKey(to&#x3D;&#39;Publish&#39;, on_delete&#x3D;models.CASCADE)    # 多对多    author &#x3D; models.ManyToManyField(to&#x3D;&#39;Author&#39;)class Publish(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    addr &#x3D; models.CharField(max_length&#x3D;64)    email &#x3D; models.EmailField()  # 默认是varchar(254)class Author(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.IntegerField()    # 添加表关系：一对一    author_detail &#x3D; models.OneToOneField(to&#x3D;&#39;AuthorDetail&#39;, on_delete&#x3D;models.CASCADE)class AuthorDetail(models.Model):    phone &#x3D; models.BigIntegerField()    addr &#x3D; models.CharField(max_length&#x3D;64)</code></pre></div></figure><h2 id="1-4-插入数据"><a href="#1-4-插入数据" class="headerlink" title="1.4 插入数据"></a>1.4 插入数据</h2><p><strong>author表:</strong></p><p><img src="/../../../img/image-20221116092148284.png" alt="image-20221116092148284"></p><p><strong>authordetail表：</strong></p><p><img src="/../../../img/image-20221116092240066.png" alt="image-20221116092240066"></p><p><strong>book表：</strong></p><p><img src="/../../../img/image-20221116092256005.png" alt="image-20221116092256005"></p><p><strong>book_author表：</strong></p><p><img src="/../../../img/image-20221116092422348.png" alt="image-20221116092422348"></p><p><strong>publish表：</strong></p><p><img src="/../../../img/image-20221116092433875.png" alt="image-20221116092433875"></p><h1 id="二、查询方法"><a href="#二、查询方法" class="headerlink" title="二、查询方法"></a>二、查询方法</h1><h2 id="2-1-聚合查询（agreegate）"><a href="#2-1-聚合查询（agreegate）" class="headerlink" title="2.1 聚合查询（agreegate）"></a>2.1 聚合查询（agreegate）</h2><blockquote><p>聚合查询通常情况下都是配合分组一起使用的，只要是跟数据库相关的模块 </p><p>基本上都在<code>django.db.models</code>里面</p><p>如果上述没有那么应该在<code>django.db</code>里面</p></blockquote><p>案例一：查询所有书的平均价格 （在<code>test.py</code>中测试）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from app01 import modelsfrom django.db.models import Avg# 查询所有书的平均价格res &#x3D; models.Book.objects.aggregate(Avg(&#39;price&#39;))print(res)# 输出&#123;&#39;price__avg&#39;: Decimal(&#39;948.500000&#39;)&#125;</code></pre></div></figure><p>案例二：使用多种方法一起查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from app01 import modelsfrom django.db.models import Max,Min,Sum,Count,Avg# 多种方法一起上res &#x3D; models.Book.objects.aggregate(Max(&#39;price&#39;), Min(&#39;price&#39;), Sum(&#39;price&#39;), Count(&#39;price&#39;), Avg(&#39;price&#39;))print(res)# 输出：&#123;&#39;price__max&#39;: Decimal(&#39;3000.00&#39;), &#39;price__min&#39;: Decimal(&#39;66.00&#39;), &#39;price__sum&#39;: Decimal(&#39;3794.00&#39;), &#39;price__count&#39;: 4, &#39;price__avg&#39;: Decimal(&#39;948.500000&#39;)&#125;</code></pre></div></figure><h2 id="2-2-分组查询（annotate）"><a href="#2-2-分组查询（annotate）" class="headerlink" title="2.2 分组查询（annotate）"></a>2.2 分组查询（annotate）</h2><blockquote><p>MySQL分组查询都有哪些特点</p><p>分组之后默认只能获取到分组的依据 组内其他字段都无法直接获取了</p><p>严格模式：ONLY_FULL_GROUP_BY</p></blockquote><p><strong>案例一：统计每一本书的作者个数</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import Max, Min, Sum, Count, Avg&quot;&quot;&quot;models后面点什么 就是按什么分组author_num是我们自己定义的字段 用来存储统计出来的每本书对应的作者个数&quot;&quot;&quot;# 按Book分组，统计每一本书的author数量res &#x3D; models.Book.objects.annotate(author_num&#x3D;Count(&#39;author&#39;)).values(&#39;title&#39;, &#39;author_num&#39;)# 按Book分组，统计每一本书的author__id数量res1 &#x3D; models.Book.objects.annotate(author_num&#x3D;Count(&#39;author__id&#39;)).values(&#39;title&#39;, &#39;author_num&#39;)print(res)print(res1)# 输出&lt;QuerySet [&#123;&#39;title&#39;: &#39;一楼梦&#39;, &#39;author_num&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;二国志&#39;, &#39;author_num&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;三游记&#39;, &#39;author_num&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;四虎传&#39;, &#39;author_num&#39;: 1&#125;]&gt;&lt;QuerySet [&#123;&#39;title&#39;: &#39;一楼梦&#39;, &#39;author_num&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;二国志&#39;, &#39;author_num&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;三游记&#39;, &#39;author_num&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;四虎传&#39;, &#39;author_num&#39;: 1&#125;]&gt;</code></pre></div></figure><p><strong>案例二：统计每个出版社卖的最便宜的书的价格</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import Max, Min, Sum, Count, Avgres &#x3D; models.Publish.objects.annotate(min_price&#x3D;Min(&#39;book__price&#39;)).values(&#39;name&#39;, &#39;min_price&#39;)print(res)# 输出&lt;QuerySet [&#123;&#39;name&#39;: &#39;还OK出版社&#39;, &#39;min_price&#39;: Decimal(&#39;128.00&#39;)&#125;, &#123;&#39;name&#39;: &#39;不高兴出版社&#39;, &#39;min_price&#39;: Decimal(&#39;600.00&#39;)&#125;, &#123;&#39;name&#39;: &#39;没头脑出版社&#39;, &#39;min_price&#39;: Decimal(&#39;66.00&#39;)&#125;]&gt;</code></pre></div></figure><p><strong>案例三：统计不止一个作者的书</strong></p><p>先修改数据库数据，给id为1、2的书添加作者</p><p><img src="/../../../img/image-20221116095908737.png" alt="image-20221116095908737"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;思路1.先按照图书分组 求每一本书对应的作者个数(Count)2.过滤出不止一个作者的图书(filter)&quot;&quot;&quot;from app01 import modelsfrom django.db.models import Max, Min, Sum, Count, Avgres &#x3D; models.Book.objects.annotate(author_num&#x3D;Count(&#39;author&#39;)).filter(author_num__gt&#x3D;1).values(&#39;title&#39;, &#39;author_num&#39;)print(res)# 输出&lt;QuerySet [&#123;&#39;title&#39;: &#39;一楼梦&#39;, &#39;author_num&#39;: 3&#125;, &#123;&#39;title&#39;: &#39;二国志&#39;, &#39;author_num&#39;: 2&#125;]&gt;# 补充# 只要你的orm语句得出的结果还是一个queryset对象# 那么它就可以继续无限制的点queryset对象封装的方法</code></pre></div></figure><p><strong>案例四：查询每个作者出的书的总价格</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from app01 import modelsfrom django.db.models import Max, Min, Sum, Count, Avgres &#x3D; models.Author.objects.annotate(sum_price&#x3D;Sum(&#39;book__price&#39;)).values(&#39;name&#39;, &#39;sum_price&#39;)print(res)# 输出&lt;QuerySet [&#123;&#39;name&#39;: &#39;刘一&#39;, &#39;sum_price&#39;: Decimal(&#39;728.00&#39;)&#125;, &#123;&#39;name&#39;: &#39;赵二&#39;, &#39;sum_price&#39;: Decimal(&#39;128.00&#39;)&#125;, &#123;&#39;name&#39;: &#39;张三&#39;, &#39;sum_price&#39;: Decimal(&#39;666.00&#39;)&#125;, &#123;&#39;name&#39;: &#39;李四&#39;, &#39;sum_price&#39;: Decimal(&#39;3600.00&#39;)&#125;]&gt;</code></pre></div></figure><blockquote><p>补充：</p><p>1、如果我想按照指定的字段分组该如何处理呢？</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;models.Book.objects.values(&#39;price&#39;).annotate()</code></pre></div></figure><p>后续BBS作业会使用</p><p>2、机器上如果出现分组查询报错的情况<br>需要修改数据库严格模式</p></blockquote><h2 id="2-3-F查询"><a href="#2-3-F查询" class="headerlink" title="2.3 F查询"></a>2.3 F查询</h2><blockquote><p>F查询能直接获取到表中某个字段对应的数据</p></blockquote><p>案例一：查询卖出数大于库存数的书籍</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import Fres &#x3D; models.Book.objects.filter(maichu__gt&#x3D;F(&#39;kucun&#39;)).values(&#39;title&#39;, &#39;kucun&#39;, &#39;maichu&#39;)print(res)# 输出&lt;QuerySet [&#123;&#39;title&#39;: &#39;四虎传&#39;, &#39;kucun&#39;: 9, &#39;maichu&#39;: 100&#125;]&gt;</code></pre></div></figure><p>案例二：将所有书籍的价格提高500块</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import Fres &#x3D; models.Book.objects.update(price &#x3D; F(&#39;price&#39;) + 500)print(res)# 查询数据库显示价格已调整mysql&gt; select * from app01_book;+----+--------+---------+--------------+------------+-------+--------+| id | title  | price   | publish_date | publish_id | kucun | maichu |+----+--------+---------+--------------+------------+-------+--------+|  1 | 一楼梦 | 1100.00 | 2022-11-16   |          2 |  1980 |     20 ||  2 | 二国志 |  628.00 | 2022-11-08   |          1 |    30 |      1 ||  3 | 三游记 |  566.00 | 2022-11-01   |          3 |  6000 |   2000 ||  4 | 四虎传 | 3500.00 | 2022-11-25   |          1 |     9 |    100 |+----+--------+---------+--------------+------------+-------+--------+4 rows in set (0.00 sec)</code></pre></div></figure><p>案例三：将所有书名后面加上“爆款”两个字</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import Max, Min, Sum, Count, Avgfrom django.db.models.functions import Concatfrom django.db.models import F, Value# 注意：不能直接使用&quot;+&quot;号追加，需要使用Concat和Value# 如果models.Book.objects.update(title&#x3D;F(&#39;title&#39;) + &#39;爆款&#39;)  # 所有的名称会全部变成空白res &#x3D; models.Book.objects.update(title&#x3D;Concat(F(&#39;title&#39;), Value(&#39;爆款&#39;)))print(res)# 查询数据库，确实加上了mysql&gt; select * from app01_book;+----+------------+---------+--------------+------------+-------+--------+| id | title      | price   | publish_date | publish_id | kucun | maichu |+----+------------+---------+--------------+------------+-------+--------+|  1 | 一楼梦爆款 | 1100.00 | 2022-11-16   |          2 |  1980 |     20 ||  2 | 二国志爆款 |  628.00 | 2022-11-08   |          1 |    30 |      1 ||  3 | 三游记爆款 |  566.00 | 2022-11-01   |          3 |  6000 |   2000 ||  4 | 四虎传爆款 | 3500.00 | 2022-11-25   |          1 |     9 |    100 |+----+------------+---------+--------------+------------+-------+--------+4 rows in set (0.00 sec)</code></pre></div></figure><h2 id="2-4-Q查询"><a href="#2-4-Q查询" class="headerlink" title="2.4 Q查询"></a>2.4 Q查询</h2><blockquote><p>让过滤指定多个条件时，可以使用与、或、非  </p></blockquote><p>基本使用案例：查询卖出数大于100或者价格小于600的书籍</p><p>filter基本功能，括号内的多个参数是<code>and</code>关系</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(maichu__gt&#x3D;100, price__lt&#x3D;600).values(&#39;title&#39;)print(res)# 默认是“与”# 输出&lt;QuerySet [&#123;&#39;title&#39;: &#39;三游记爆款&#39;&#125;]&gt;</code></pre></div></figure><p>使用Q查询，也使用<code>and</code>关系</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(Q(maichu__gt&#x3D;100), Q(price__lt&#x3D;600)).values(&#39;title&#39;)# 输出&lt;QuerySet [&#123;&#39;title&#39;: &#39;三游记爆款&#39;&#125;]&gt;</code></pre></div></figure><p>使用Q查询，改成<code>or</code>关系</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(Q(maichu__gt&#x3D;100) | Q(price__lt&#x3D;600)).values(&#39;title&#39;)# 输出&lt;QuerySet [&#123;&#39;title&#39;: &#39;三游记爆款&#39;&#125;]&gt;</code></pre></div></figure><p>使用Q查询，改成’not’关系，查询卖出数<code>非&gt;100</code>即<code>&lt;=100</code>的书</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(~Q(maichu__gt&#x3D;100)).values(&#39;title&#39;)# 输出&lt;QuerySet [&#123;&#39;title&#39;: &#39;一楼梦爆款&#39;&#125;, &#123;&#39;title&#39;: &#39;二国志爆款&#39;&#125;, &#123;&#39;title&#39;: &#39;四虎传爆款&#39;&#125;]&gt;</code></pre></div></figure><p>高阶使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Q的高阶用法  能够将查询条件的左边也变成字符串的形式q &#x3D; Q()q.connector &#x3D; &#39;or&#39;q.children.append((&#39;maichu__gt&#39;,100))q.children.append((&#39;price__lt&#39;,600))res &#x3D; models.Book.objects.filter(q)  # 默认还是and关系print(res)# 输出&lt;QuerySet [&lt;Book: Book object (2)&gt;, &lt;Book: Book object (3)&gt;, &lt;Book: Book object (4)&gt;]&gt;</code></pre></div></figure><h1 id="三、Django中如何开启事务"><a href="#三、Django中如何开启事务" class="headerlink" title="三、Django中如何开启事务"></a>三、Django中如何开启事务</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;事务ACID原子性不可分割的最小单位一致性跟原子性是相辅相成隔离性事务之间互相不干扰持久性事务一旦确认永久生效事务的回滚 rollback事务的确认commit&quot;&quot;&quot;# 目前你只需要掌握Django中如何简单的开启事务# 事务    from django.db import transaction    try:        with transaction.atomic():            # sql1            # sql2            ...            # 在with代码快内书写的所有orm操作都是属于同一个事务    except Exception as e:        print(e)    print(&#39;执行其他操作&#39;)</code></pre></div></figure><h1 id="四、orm中常用字段及参数"><a href="#四、orm中常用字段及参数" class="headerlink" title="四、orm中常用字段及参数"></a>四、orm中常用字段及参数</h1><h2 id="4-1-常用字段"><a href="#4-1-常用字段" class="headerlink" title="4.1 常用字段"></a>4.1 常用字段</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">AutoField主键字段 primary_key&#x3D;True  CharFieldvarcharverbose_name字段的注释  max_length长度  IntegerFieldintBigIntegerFieldbigintDecimalFieldmax_digits&#x3D;8  decimal_places&#x3D;2EmailFiledvarchar(254)DateFielddateDateTimeFielddatetimeauto_now:每次修改数据的时候都会自动更新当前时间  auto_now_add:只在创建数据的时候记录创建时间后续不会自动修改了    BooleanField(Field)- 布尔值类型该字段传布尔值(False&#x2F;True) 数据库里面存0&#x2F;1TextField(Field)- 文本类型该字段可以用来存大段内容(文章、博客...)  没有字数限制  后面的bbs作业 文章字段用的就是TextFieldFileField(Field)- 字符类型   upload_to &#x3D; &quot;&#x2F;data&quot;  给该字段传一个文件对象，会自动将文件保存到&#x2F;data目录下然后将文件路径保存到数据库中  &#x2F;data&#x2F;a.txt  后面bbs作业也会涉及# 外键字段及参数unique&#x3D;TrueForeignKey(unique&#x3D;True)   &#x3D;&#x3D;&#x3D;OneToOneField()  # 你在用前面字段创建一对一 orm会有一个提示信息 orm推荐你使用后者但是前者也能用  db_index如果db_index&#x3D;True 则代表着为此字段设置索引  (复习索引是什么)to_field设置要关联的表的字段  默认不写关联的就是另外一张的主键字段on_delete当删除关联表中的数据时，当前表与其关联的行的行为。  &quot;&quot;&quot;  django2.X及以上版本 需要你自己指定外键字段的级联更新级联删除  &quot;&quot;&quot;</code></pre></div></figure><p>更多字段可以参考：<a href="https://www.cnblogs.com/Dominic-Ji/p/9203990.html">https://www.cnblogs.com/Dominic-Ji/p/9203990.html</a></p><h2 id="4-2-自定义字段"><a href="#4-2-自定义字段" class="headerlink" title="4.2 自定义字段"></a>4.2 自定义字段</h2><p>django除了给你提供了很多字段类型之外 还支持你自定义字段</p><p>定义方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MyCharField(models.Field):    def __init__(self,max_length,*args,**kwargs):        self.max_length &#x3D; max_length        # 调用父类的init方法        super().__init__(max_length&#x3D;max_length,*args,**kwargs)  # 一定要是关键字的形式传入    def db_type(self, connection):        &quot;&quot;&quot;        返回真正的数据类型及各种约束条件        :param connection:        :return:        &quot;&quot;&quot;        return &#39;char(%s)&#39;%self.max_length</code></pre></div></figure><p>使用自定义字段：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 自定义字段使用myfield &#x3D; MyCharField(max_length&#x3D;16,null&#x3D;True)</code></pre></div></figure><h1 id="五、数据库查询优化"><a href="#五、数据库查询优化" class="headerlink" title="五、数据库查询优化"></a>五、数据库查询优化</h1><p>为了展示效果，需要先设置显示SQL语句，编辑<code>settings.py</code>文件，加入</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">LOGGING &#x3D; &#123;    &#39;version&#39;: 1,    &#39;disable_existing_loggers&#39;: False,    &#39;handlers&#39;: &#123;        &#39;console&#39;:&#123;            &#39;level&#39;:&#39;DEBUG&#39;,            &#39;class&#39;:&#39;logging.StreamHandler&#39;,        &#125;,    &#125;,    &#39;loggers&#39;: &#123;        &#39;django.db.backends&#39;: &#123;            &#39;handlers&#39;: [&#39;console&#39;],            &#39;propagate&#39;: True,            &#39;level&#39;:&#39;DEBUG&#39;,        &#125;,    &#125;&#125;</code></pre></div></figure><h2 id="5-1-ORM语句的特点"><a href="#5-1-ORM语句的特点" class="headerlink" title="5.1 ORM语句的特点"></a>5.1 ORM语句的特点</h2><p><strong>特点：惰性查询</strong></p><p>如果仅是写了orm语句，在后面根本没有用到该语句所查询出来的参数，那么orm会自动识别，直接不执行</p><p>案例：只写查询语句，不调用，并没有执行查询操作（惰性了）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.all()</code></pre></div></figure><p>如图：</p><p><img src="/../../../img/image-20221116141000606.png" alt="image-20221116141000606"></p><p>增加<code>print</code>可以看到查询语句才执行了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.all()print(res)  # 要用数据了才会走数据库</code></pre></div></figure><p>如图：</p><p><img src="/../../../img/image-20221116141026313.png" alt="image-20221116141026313"></p><h2 id="5-2-only与defer"><a href="#5-2-only与defer" class="headerlink" title="5.2 only与defer"></a>5.2 only与defer</h2><h3 id="5-2-1-only和defer的基本使用"><a href="#5-2-1-only和defer的基本使用" class="headerlink" title="5.2.1 only和defer的基本使用"></a>5.2.1 only和defer的基本使用</h3><p>想要获取书籍表中<code>所有书的名字</code>，一般是这样查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.values(&#39;title&#39;)for i in res:    print(i.get(&#39;title&#39;))    # 输出：一楼梦爆款二国志爆款三游记爆款四虎传爆款</code></pre></div></figure><p>改用<code>only</code>，不用<code>get</code>可以直接用<code>.</code>获取</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.only(&#39;title&#39;)for i in res:    print(i.title)    # 输出相同</code></pre></div></figure><p>改用<code>defer</code>，不用<code>get</code>可以直接用<code>.</code>获取</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.defer(&#39;title&#39;)for i in res:    print(i.title)   # 输出相同</code></pre></div></figure><p>并且可以输出非指定的字段</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.only(&#39;title&#39;)for i in res:    print(i.price)res &#x3D; models.Book.objects.defer(&#39;title&#39;)for i in res:    print(i.price)    # 正常输出1100.00628.00566.003500.00</code></pre></div></figure><h3 id="5-2-2-only、defer和all的区别"><a href="#5-2-2-only、defer和all的区别" class="headerlink" title="5.2.2 only、defer和all的区别"></a>5.2.2 only、defer和all的区别</h3><p><code>all()</code>查询，每次都要重新走一遍数据库</p><p><code>only()</code>查询，查询only()内指定的字段不会走数据库，而查询以外的会重新走一遍数据库</p><p><code>defer()</code>查询，和<code>only</code>正好相反，查询defer()内指定的字段会重走一遍数据库，而查询以外的不会重走</p><h2 id="5-3-select-related与prefetch-related"><a href="#5-3-select-related与prefetch-related" class="headerlink" title="5.3 select_related与prefetch_related"></a>5.3 select_related与prefetch_related</h2><blockquote><p>多用于跨表操作</p></blockquote><h3 id="5-3-1-普通查询"><a href="#5-3-1-普通查询" class="headerlink" title="5.3.1 普通查询"></a>5.3.1 普通查询</h3><p>每循环一次就要走一次数据库，浪费资源</p><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查询res &#x3D; models.Book.objects.all()    for i in res:         print(i.publish.name)  # 每循环一次就要走一次数据库查询            # 输出(0.000)                 SELECT VERSION(),                       @@sql_mode,                       @@default_storage_engine,                       @@sql_auto_is_null,                       @@lower_case_table_names,                       CONVERT_TZ(&#39;2001-01-01 01:00:00&#39;, &#39;UTC&#39;, &#39;UTC&#39;) IS NOT NULL            ; args&#x3D;None(0.000) SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; args&#x3D;None(0.000) SELECT &#96;app01_book&#96;.&#96;id&#96;, &#96;app01_book&#96;.&#96;title&#96;, &#96;app01_book&#96;.&#96;price&#96;, &#96;app01_book&#96;.&#96;publish_date&#96;, &#96;app01_book&#96;.&#96;kucun&#96;, &#96;app01_book&#96;.&#96;maichu&#96;, &#96;app01_book&#96;.&#96;publish_id&#96; FROM &#96;app01_book&#96;; args&#x3D;()(0.016) SELECT &#96;app01_publish&#96;.&#96;id&#96;, &#96;app01_publish&#96;.&#96;name&#96;, &#96;app01_publish&#96;.&#96;addr&#96;, &#96;app01_publish&#96;.&#96;email&#96; FROM &#96;app01_publish&#96; WHERE &#96;app01_publish&#96;.&#96;id&#96; &#x3D; 2 LIMIT 21; args&#x3D;(2,)(0.000) SELECT &#96;app01_publish&#96;.&#96;id&#96;, &#96;app01_publish&#96;.&#96;name&#96;, &#96;app01_publish&#96;.&#96;addr&#96;, &#96;app01_publish&#96;.&#96;email&#96; FROM &#96;app01_publish&#96; WHERE &#96;app01_publish&#96;.&#96;id&#96; &#x3D; 1 LIMIT 21; args&#x3D;(1,)(0.000) SELECT &#96;app01_publish&#96;.&#96;id&#96;, &#96;app01_publish&#96;.&#96;name&#96;, &#96;app01_publish&#96;.&#96;addr&#96;, &#96;app01_publish&#96;.&#96;email&#96; FROM &#96;app01_publish&#96; WHERE &#96;app01_publish&#96;.&#96;id&#96; &#x3D; 3 LIMIT 21; args&#x3D;(3,)(0.000) SELECT &#96;app01_publish&#96;.&#96;id&#96;, &#96;app01_publish&#96;.&#96;name&#96;, &#96;app01_publish&#96;.&#96;addr&#96;, &#96;app01_publish&#96;.&#96;email&#96; FROM &#96;app01_publish&#96; WHERE &#96;app01_publish&#96;.&#96;id&#96; &#x3D; 1 LIMIT 21; args&#x3D;(1,)不高兴出版社还OK出版社没头脑出版社还OK出版社Process finished with exit code 0</code></pre></div></figure><h3 id="5-3-2-select-related查询（内联查询）"><a href="#5-3-2-select-related查询（内联查询）" class="headerlink" title="5.3.2 select_related查询（内联查询）"></a>5.3.2 select_related查询（内联查询）</h3><p>效率优于普通查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查询res &#x3D; models.Book.objects.select_related(&#39;publish&#39;)  # INNER JOINfor i in res:    print(i.publish.name)    # 输出(0.000)                 SELECT VERSION(),                       @@sql_mode,                       @@default_storage_engine,                       @@sql_auto_is_null,                       @@lower_case_table_names,                       CONVERT_TZ(&#39;2001-01-01 01:00:00&#39;, &#39;UTC&#39;, &#39;UTC&#39;) IS NOT NULL            ; args&#x3D;None(0.000) SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; args&#x3D;None(0.000) SELECT &#96;app01_book&#96;.&#96;id&#96;, &#96;app01_book&#96;.&#96;title&#96;, &#96;app01_book&#96;.&#96;price&#96;, &#96;app01_book&#96;.&#96;publish_date&#96;, &#96;app01_book&#96;.&#96;kucun&#96;, &#96;app01_book&#96;.&#96;maichu&#96;, &#96;app01_book&#96;.&#96;publish_id&#96;, &#96;app01_publish&#96;.&#96;id&#96;, &#96;app01_publish&#96;.&#96;name&#96;, &#96;app01_publish&#96;.&#96;addr&#96;, &#96;app01_publish&#96;.&#96;email&#96; FROM &#96;app01_book&#96; INNER JOIN &#96;app01_publish&#96; ON (&#96;app01_book&#96;.&#96;publish_id&#96; &#x3D; &#96;app01_publish&#96;.&#96;id&#96;); args&#x3D;()还OK出版社还OK出版社不高兴出版社没头脑出版社&quot;&quot;&quot;    select_related内部直接先将book与publish连起来 然后一次性将大表里面的所有数据    全部封装给查询出来的对象        这个时候对象无论是点击book表的数据还是publish的数据都无需再走数据库查询了    select_related括号内只能放外键字段    一对多 一对一        多对多也不行&quot;&quot;&quot;</code></pre></div></figure><h3 id="5-3-3-prefetch-related查询（子查询）"><a href="#5-3-3-prefetch-related查询（子查询）" class="headerlink" title="5.3.3 prefetch_related查询（子查询）"></a>5.3.3 prefetch_related查询（子查询）</h3><p>效率优于普通查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查询res &#x3D; models.Book.objects.prefetch_related(&#39;publish&#39;)  # 子查询&quot;&quot;&quot;    prefetch_related该方法内部其实就是子查询        将子查询查询出来的所有结果也给你封装到对象中        给你的感觉好像也是一次性搞定的    &quot;&quot;&quot;for i in res:    print(i.publish.name) # 输出(0.000)                 SELECT VERSION(),                       @@sql_mode,                       @@default_storage_engine,                       @@sql_auto_is_null,                       @@lower_case_table_names,                       CONVERT_TZ(&#39;2001-01-01 01:00:00&#39;, &#39;UTC&#39;, &#39;UTC&#39;) IS NOT NULL            ; args&#x3D;None(0.000) SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; args&#x3D;None(0.000) SELECT &#96;app01_book&#96;.&#96;id&#96;, &#96;app01_book&#96;.&#96;title&#96;, &#96;app01_book&#96;.&#96;price&#96;, &#96;app01_book&#96;.&#96;publish_date&#96;, &#96;app01_book&#96;.&#96;kucun&#96;, &#96;app01_book&#96;.&#96;maichu&#96;, &#96;app01_book&#96;.&#96;publish_id&#96; FROM &#96;app01_book&#96;; args&#x3D;()(0.015) SELECT &#96;app01_publish&#96;.&#96;id&#96;, &#96;app01_publish&#96;.&#96;name&#96;, &#96;app01_publish&#96;.&#96;addr&#96;, &#96;app01_publish&#96;.&#96;email&#96; FROM &#96;app01_publish&#96; WHERE &#96;app01_publish&#96;.&#96;id&#96; IN (1, 2, 3); args&#x3D;(1, 2, 3)不高兴出版社还OK出版社没头脑出版社还OK出版社</code></pre></div></figure><h1 id="六、作业"><a href="#六、作业" class="headerlink" title="六、作业"></a>六、作业</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1.整理今日内容到博客2.熟练掌握数据库常用字段及参数以及应用场景3.总结数据库查询优化的两组方法，尝试用自己的语言表述4.完成图书管理系统书籍表的增删改查(尽量将之前的知识点全部融入进去)&quot;&quot;&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day72-BBS项目-01</title>
    <link href="/2022/11/09/03_Python/05_Django/day72%E7%AC%94%E8%AE%B0-BBS%E9%A1%B9%E7%9B%AE-01/"/>
    <url>/2022/11/09/03_Python/05_Django/day72%E7%AC%94%E8%AE%B0-BBS%E9%A1%B9%E7%9B%AE-01/</url>
    
    <content type="html"><![CDATA[<p>“第72天BBS项目01学习笔记”</p><h1 id="一、数据库创建及表同步"><a href="#一、数据库创建及表同步" class="headerlink" title="一、数据库创建及表同步"></a>一、数据库创建及表同步</h1><blockquote><p>使用mysql替代自带的sqlite库</p></blockquote><h2 id="1-1-PyCharm创建项目"><a href="#1-1-PyCharm创建项目" class="headerlink" title="1.1 PyCharm创建项目"></a>1.1 PyCharm创建项目</h2><p>填写项目名</p><p><img src="/../../../img/image-20221109090600388.png" alt="image-20221109090600388"></p><p> 填写创建的app名，点击create创建</p><p><img src="/../../../img/image-20221109090626941.png" alt="image-20221109090626941"></p><h2 id="1-2-Navicat创建数据库"><a href="#1-2-Navicat创建数据库" class="headerlink" title="1.2 Navicat创建数据库"></a>1.2 Navicat创建数据库</h2><p>新建数据库，填写完点击确定</p><p><img src="/../../../img/image-20221109090922485.png" alt="image-20221109090922485"></p><h2 id="1-3-项目数据库配置"><a href="#1-3-项目数据库配置" class="headerlink" title="1.3 项目数据库配置"></a>1.3 项目数据库配置</h2><p>数据表整体设计</p><p><img src="/../../../img/BBS%E8%A1%A8%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3.png" alt="BBS表关系图解"></p><h3 id="1-3-1-设置数据库参数"><a href="#1-3-1-设置数据库参数" class="headerlink" title="1.3.1 设置数据库参数"></a>1.3.1 设置数据库参数</h3><p>编辑<code>settings.py</code>文件</p><p><img src="/../../../img/image-20221109091153564.png" alt="image-20221109091153564"></p><p>编辑<code>__init__.py</code>文件</p><p><img src="/../../../img/image-20221109091320409.png" alt="image-20221109091320409"></p><h3 id="1-3-2-创建数据库模型-Models"><a href="#1-3-2-创建数据库模型-Models" class="headerlink" title="1.3.2 创建数据库模型(Models)"></a>1.3.2 创建数据库模型(Models)</h3><p>编辑<code>models.py</code>创建<code>UserInfo</code>表字段（用户表）</p><p><img src="/../../../img/image-20221109092251182.png" alt="image-20221109092251182"></p><p>往<code>create_time...</code>下面补充</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">blog &#x3D; models.OneToOneField(to&#x3D;&#39;Blog&#39;, null&#x3D;True)</code></pre></div></figure><p>编辑<code>setting.py</code>配置</p><p><img src="/../../../img/image-20221109092349880.png" alt="image-20221109092349880"></p><p>编辑<code>models.py</code>文件分别创建<code>Blog、Category、Tag、Article、UpAndDown、Comment</code>表字段</p><p><img src="/../../../img/image-20221109093918925.png" alt="image-20221109093918925"></p><p><img src="/../../../img/image-20221109094221737.png" alt="image-20221109094221737"></p><p>Category和Tag<code>两个下</code>都要补充</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">blog &#x3D; models.ForeignKey(to&#x3D;&#39;Blog&#39;, null&#x3D;True)</code></pre></div></figure><p><img src="/../../../img/image-20221109094400029.png" alt="image-20221109094400029"></p><p>Article往下补充外键字段</p><p><img src="/../../../img/image-20221109095451851.png" alt="image-20221109095451851"></p><p><img src="/../../../img/image-20221109095256704.png" alt="image-20221109095256704"></p><p><img src="/../../../img/image-20221109094705148.png" alt="image-20221109094705148"></p><h3 id="1-3-2-迁移数据库创建表"><a href="#1-3-2-迁移数据库创建表" class="headerlink" title="1.3.2 迁移数据库创建表"></a>1.3.2 迁移数据库创建表</h3><p>make migrations</p><p>make migrate</p><h2 id="1-4-foms组件代码编写"><a href="#1-4-foms组件代码编写" class="headerlink" title="1.4 foms组件代码编写"></a>1.4 foms组件代码编写</h2><blockquote><p>如果你的项目至始至终只用到一个fomrs组件，那么写一个py文件即可，但是如果要用多个forms.py组件，那么可以创建一个文件夹，在文件夹内根据forms组件的功能的不同创建不同的py文件</p></blockquote><p>编辑<code>urls.py</code>文件</p><p><img src="/../../../img/image-20221109103140977.png" alt="image-20221109103140977"></p><p>编辑<code>views.py</code>文件</p><p><img src="/../../../img/image-20221109103245373.png" alt="image-20221109103245373"></p><p><code>templates</code>文件夹新建<code>注册页面</code></p><p><img src="/../../../img/image-20221109103459697.png" alt="image-20221109103459697"></p><p>新建<code>myforms.py</code>文件，针对用户表的<code>forms</code>组件代码（为了 解耦合）</p><p><img src="/../../../img/image-20221109111008637.png" alt="image-20221109111008637"></p><p><img src="/../../../img/image-20221109111027000.png" alt="image-20221109111027000"></p><p><img src="/../../../img/image-20221109111037630.png" alt="image-20221109111037630"></p><p><img src="/../../../img/image-20221109111137936.png" alt="image-20221109111137936"></p><p><img src="/../../../img/image-20221109111253596.png" alt="image-20221109111253596"></p><p><img src="/../../../img/image-20221109111443463.png" alt="image-20221109111443463"></p><p><img src="/../../../img/image-20221109111557020.png" alt="image-20221109111557020"></p><h2 id="1-5-搭建注册页面"><a href="#1-5-搭建注册页面" class="headerlink" title="1.5 搭建注册页面"></a>1.5 搭建注册页面</h2><p>导入forms组件</p><p><img src="/../../../img/image-20221109111819195.png" alt="image-20221109111819195"></p><p>编辑注册页面<code>register.html</code></p><p><img src="/../../../img/image-20221109112150247.png" alt="image-20221109112150247"></p><p>再加</p><p><img src="/../../../img/image-20221109112408844.png" alt="image-20221109112408844"></p><h2 id="1-6-用户头像实时展示"><a href="#1-6-用户头像实时展示" class="headerlink" title="1.6 用户头像实时展示"></a>1.6 用户头像实时展示</h2><p>修改上传图片的标签</p><p><img src="/../../../img/image-20221109134014152.png" alt="image-20221109134014152"></p><p>效果</p><p><img src="/../../../img/image-20221109133928395.png" alt="image-20221109133928395"></p><p>但是选择图片，头像不实时显示，需要再改</p><p><img src="/../../../img/image-20221109134852217.png" alt="image-20221109134852217"></p><p><img src="/../../../img/image-20221109134910917.png" alt="image-20221109134910917"></p><p>效果：</p><p><img src="/../../../img/image-20221109141438049.png" alt="image-20221109141438049"></p><h2 id="1-7-注册事件初步实现"><a href="#1-7-注册事件初步实现" class="headerlink" title="1.7 注册事件初步实现"></a>1.7 注册事件初步实现</h2><p>编辑<code>views.py</code></p><p><img src="/../../../img/image-20221110164642073.png" alt="image-20221110164642073"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day64-DjangoORM进阶-01</title>
    <link href="/2022/09/15/03_Python/05_Django/day64%E7%AC%94%E8%AE%B0-DjangoORM%E8%BF%9B%E9%98%B6-01/"/>
    <url>/2022/09/15/03_Python/05_Django/day64%E7%AC%94%E8%AE%B0-DjangoORM%E8%BF%9B%E9%98%B6-01/</url>
    
    <content type="html"><![CDATA[<p>“Day64 Django ORM 操作数据库 进阶用法 学习笔记”</p><h1 id="今日内容概要-重要"><a href="#今日内容概要-重要" class="headerlink" title="今日内容概要(重要)"></a>今日内容概要(重要)</h1><p>模型层(ORM语法):跟数据库打交道的</p><ul><li>单表查询(增删改查)</li><li>常见的十几种查询方法</li><li>神奇的双下划线查询</li><li>多表操作</li><li>外键字段的增删改查</li><li>跨表查询(重点)<ul><li>子查询</li><li>联表查询</li></ul></li><li>聚合查询</li><li>分组查询</li><li>F与Q查询</li></ul><h1 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h1><p>准备实验环境</p><h2 id="1-1-基础准备"><a href="#1-1-基础准备" class="headerlink" title="1.1 基础准备"></a>1.1 基础准备</h2><p>1、创建数据库<code>day64</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 修改root密码:mysql&gt; use mysql;Database changedmysql&gt; alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123123&#39;;Query OK, 0 rows affected (0.01 sec)# 创建数据库mysql&gt; create database day64;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| day61              || day64              || information_schema || mysql              || performance_schema || sys                || test               |+--------------------+7 rows in set (0.00 sec)</code></pre></div></figure><p>2、创建Django项目</p><p>3、设置<code>setting.py</code>，连接Mysql的参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">DATABASES &#x3D; &#123;    &#39;default&#39;: &#123;        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;NAME&#39;: &#39;day64&#39;,        &#39;USER&#39;: &#39;root&#39;,        &#39;PASSWORD&#39;: &#39;123123&#39;,        &#39;HOST&#39;: &#39;127.0.0.1&#39;,        &#39;PORT&#39;: 3306,        &#39;CHARSET&#39;: &#39;utf8&#39;,    &#125;&#125;</code></pre></div></figure><p>4、设置<code>__init__.py</code>文件，导入pymysql</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymysqlpymysql.install_as_MySQLdb()</code></pre></div></figure><p>5、创建app01应用，并在<code>settings.py</code>中注册应用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python manage.py startapp app01# setting.pyINSTALLED_APPS &#x3D; [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;app01&#39;]</code></pre></div></figure><p>6、编辑<code>app01</code>中的<code>models.py</code>，创建ORM模型</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models# Create your models here.class User(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.IntegerField()    register_time &#x3D; models.DateField()&#39;&#39;&#39;    DateFiled    DateTimeFiled        两个重要参数        auto_now : 每次操作数据的时候，该字段会自动将时间更新        auto_now_add: 在创建数据的时候会自动将当前创建时间记录下来，只要不人为的改变，就一直不变&#39;&#39;&#39;</code></pre></div></figure><p>7、执行创建表操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 本地记录python manage.py makemigrations# 同步到数据库python manage.py migrate</code></pre></div></figure><h2 id="1-2-测试脚本"><a href="#1-2-测试脚本" class="headerlink" title="1.2 测试脚本"></a>1.2 测试脚本</h2><blockquote><p>🌟 当你只是想测试django中的某一个py文件内容，那么你可以不用书写前后端交互的形式而是直接写一个测试脚本即可，脚本代码无论是写在应用下的tests.py还是自己单独开设py文件都可以</p></blockquote><p>编辑<code>test.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.test import TestCase# Create your tests here.import osimport sysif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &#39;day64_ORM进阶.settings&#39;)    import django    django.setup()    # 在这个代码块的下面就可以测试django里面的单个py文件了    # 所有的代码必须等环境准备完毕之后才能书写    from app01 import models    models.User.objects.all()</code></pre></div></figure><h1 id="二、单表操作"><a href="#二、单表操作" class="headerlink" title="二、单表操作"></a>二、单表操作</h1><p>单表的ORM操作</p><p>PS: 案例中的代码都是写在<code>test.py</code>中执行</p><h2 id="2-1-增删改查"><a href="#2-1-增删改查" class="headerlink" title="2.1 增删改查"></a>2.1 增删改查</h2><h3 id="2-1-1-增"><a href="#2-1-1-增" class="headerlink" title="2.1.1 增"></a>2.1.1 增</h3><p>增有两种方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方式一res &#x3D; models.User.objects.create(name&#x3D;&#39;jason&#39;, age&#x3D;18, register_time&#x3D;&#39;2022-09-27&#39;)print(res)# 方式二import datetimectime &#x3D; datetime.datetime.now()user_obj &#x3D; models.User(name&#x3D;&#39;tank&#39;, age&#x3D;38, register_time&#x3D;ctime)user_obj.save()</code></pre></div></figure><p>查看结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_user;+----+-------+-----+---------------+| id | name  | age | register_time |+----+-------+-----+---------------+|  1 | jason |  18 | 2022-09-27    ||  2 | tank  |  38 | 2022-09-27    |+----+-------+-----+---------------+2 rows in set (0.00 sec)</code></pre></div></figure><h3 id="2-1-2-删"><a href="#2-1-2-删" class="headerlink" title="2.1.2 删"></a>2.1.2 删</h3><p>删除也有两种方式，通过主键删除数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方式一res &#x3D; models.User.objects.filter(pk&#x3D;1).delete()print(res)# 方式二user_obj &#x3D; models.User.objects.filter(pk&#x3D;2).first()user_obj.delete()</code></pre></div></figure><p>为什么用<code>pk</code>?</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;pk会自动查找到当前表的主键字段 指代的就是当前表的主键字段用了pk之后 你就不需要指代当前表的主键字段到底叫什么了    uid    pid    sid    ...&quot;&quot;&quot;</code></pre></div></figure><h3 id="2-1-3-改"><a href="#2-1-3-改" class="headerlink" title="2.1.3 改"></a>2.1.3 改</h3><p>原表信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select * from app01_user;+----+-------+-----+---------------+| id | name  | age | register_time |+----+-------+-----+---------------+|  5 | jason |  18 | 2022-09-27    ||  6 | tank  |  38 | 2022-09-27    |+----+-------+-----+---------------+2 rows in set (0.00 sec)</code></pre></div></figure><p>ORM修改数据表的三种方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方式一res &#x3D; models.User.objects.filter(pk&#x3D;5).update(name&#x3D;&#39;laosb&#39;)# 方式二user_obj &#x3D; models.User.objects.get(pk&#x3D;6)user_obj.name &#x3D; &#39;马有铁&#39;user_obj.save()# 方式三user_obj2 &#x3D; models.User.objects.filter(pk&#x3D;5).first()user_obj2.age &#x3D; 898user_obj2.save()</code></pre></div></figure><blockquote><p>PS:  <code>get</code>和<code>filter</code>的区别</p><p>get方法：</p><p>​返回的直接就是当前数据对象</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">但是该方法不推荐使用</code></pre></div></figure><p>​    一旦数据不存在该方法会直接报错</p><p>而filter则不会</p><p>​    所以我们还是用filter</p></blockquote><p>查看结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_user;+----+--------+-----+---------------+| id | name   | age | register_time |+----+--------+-----+---------------+|  5 | laosb  | 898 | 2022-09-27    ||  6 | 马有铁 |  38 | 2022-09-27    |+----+--------+-----+---------------+2 rows in set (0.00 sec)</code></pre></div></figure><h3 id="2-1-4-查"><a href="#2-1-4-查" class="headerlink" title="2.1.4 查"></a>2.1.4 查</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 拿到所有数据res &#x3D; models.User.objects.all()# 遍历查询for i in res:    print(&quot;id: &quot;, i.id, &quot;name:&quot;, i.name, &quot;age:&quot;, i.age, &quot;register_time: &quot;, i.register_time)</code></pre></div></figure><p>输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">id:  5 name: laosb age: 898 register_time:  2022-09-27id:  6 name: 马有铁 age: 38 register_time:  2022-09-27</code></pre></div></figure><h2 id="2-2-必知必会13条"><a href="#2-2-必知必会13条" class="headerlink" title="2.2 必知必会13条"></a>2.2 必知必会13条</h2><h3 id="2-2-1-查询所有数据"><a href="#2-2-1-查询所有数据" class="headerlink" title="2.2.1 查询所有数据"></a>2.2.1 查询所有数据</h3><p><code>all()</code>方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">models.User.objects.all()</code></pre></div></figure><h3 id="2-2-2带有过滤条件的查询"><a href="#2-2-2带有过滤条件的查询" class="headerlink" title="2.2.2带有过滤条件的查询"></a>2.2.2带有过滤条件的查询</h3><p><code>filter()</code>方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查询姓名是“马有铁”的数据, 默认是集合序列，需要加first()取出来第一个res2 &#x3D; models.User.objects.filter(name&#x3D;&quot;马有铁&quot;).first()print(&quot;id: &quot;, res2.id, &quot;name:&quot;, res2.name, &quot;age:&quot;, res2.age, &quot;register_time: &quot;, res2.register_time)</code></pre></div></figure><p>输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">id:  6 name: 马有铁 age: 38 register_time:  2022-09-27</code></pre></div></figure><h4 id="2-2-2-1-双下划线查询"><a href="#2-2-2-1-双下划线查询" class="headerlink" title="2.2.2.1 双下划线查询"></a>2.2.2.1 双下划线查询</h4><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1 年龄大于35岁的数据# res &#x3D; models.User.objects.filter(age__gt&#x3D;35)# print(res)# 2 年龄小于35岁的数据# res &#x3D; models.User.objects.filter(age__lt&#x3D;35)# print(res)# 大于等于 小于等于# res &#x3D; models.User.objects.filter(age__gte&#x3D;32)# print(res)# res &#x3D; models.User.objects.filter(age__lte&#x3D;32)# print(res)# 年龄是18 或者 32 或者40# res &#x3D; models.User.objects.filter(age__in&#x3D;[18,32,40])# print(res)# 年龄在18到40岁之间的  首尾都要# res &#x3D; models.User.objects.filter(age__range&#x3D;[18,40])# print(res)# 查询出名字里面含有s的数据  模糊查询# res &#x3D; models.User.objects.filter(name__contains&#x3D;&#39;s&#39;)# print(res)## 是否区分大小写  查询出名字里面含有p的数据  区分大小写# res &#x3D; models.User.objects.filter(name__contains&#x3D;&#39;p&#39;)# print(res)# 忽略大小写# res &#x3D; models.User.objects.filter(name__icontains&#x3D;&#39;p&#39;)# print(res)# res &#x3D; models.User.objects.filter(name__startswith&#x3D;&#39;j&#39;)# res1 &#x3D; models.User.objects.filter(name__endswith&#x3D;&#39;j&#39;)## print(res,res1)# 查询出注册时间是 2020 1月# res &#x3D; models.User.objects.filter(register_time__month&#x3D;&#39;1&#39;)# res &#x3D; models.User.objects.filter(register_time__year&#x3D;&#39;2020&#39;)</code></pre></div></figure><h3 id="2-2-3-直接拿数据对象"><a href="#2-2-3-直接拿数据对象" class="headerlink" title="2.2.3 直接拿数据对象"></a>2.2.3 直接拿数据对象</h3><p><code>get()</code>方法</p><p>使用此方法，当条件不存在时，将直接报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 拿到名称是“马有铁”的数据对象myt_obj &#x3D; models.User.objects.filter(name&#x3D;&quot;马有铁&quot;).get()# 输出对象值print(myt_obj.name)</code></pre></div></figure><h3 id="2-2-4-拿第一个-最后一个元素"><a href="#2-2-4-拿第一个-最后一个元素" class="headerlink" title="2.2.4 拿第一个&#x2F;最后一个元素"></a>2.2.4 拿第一个&#x2F;最后一个元素</h3><p>新增一条数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.User.objects.create(name&#x3D;&quot;张三&quot;, age&#x3D;12, register_time&#x3D;datetime.datetime.now())</code></pre></div></figure><p><code>first()</code>方法拿第一个元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res3 &#x3D; models.User.objects.first()print(res3.id, res3.name)# 输出5 laosb</code></pre></div></figure><p><code>last()</code>方法拿最有一个元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res3 &#x3D; models.User.objects.last()print(res3.id, res3.name)# 输出7 张三</code></pre></div></figure><h3 id="2-2-5-获取指定的数据字段"><a href="#2-2-5-获取指定的数据字段" class="headerlink" title="2.2.5 获取指定的数据字段"></a>2.2.5 获取指定的数据字段</h3><p><code>values()</code>获取name和age字段，<strong>列表套字典</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res4 &#x3D; models.User.objects.values(&#39;name&#39;, &#39;age&#39;)print(res4)# 输出&lt;QuerySet [&#123;&#39;name&#39;: &#39;laosb&#39;, &#39;age&#39;: 898&#125;, &#123;&#39;name&#39;: &#39;马有铁&#39;, &#39;age&#39;: 38&#125;, &#123;&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: 12&#125;]&gt;</code></pre></div></figure><p><code>values_list()</code>获取name和age字段，<strong>列表套元组</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res5 &#x3D; models.User.objects.values_list(&#39;name&#39;, &#39;age&#39;)print(res5)# 输出&lt;QuerySet [(&#39;laosb&#39;, 898), (&#39;马有铁&#39;, 38), (&#39;张三&#39;, 12)]&gt;</code></pre></div></figure><h3 id="2-2-6-去重"><a href="#2-2-6-去重" class="headerlink" title="2.2.6 去重"></a>2.2.6 去重</h3><p>当前数据如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">+----+--------+-----+---------------+| id | name   | age | register_time |+----+--------+-----+---------------+|  5 | laosb  | 898 | 2022-09-27    ||  6 | 马有铁 |  38 | 2022-09-27    ||  7 | 张三   |  12 | 2022-09-27    ||  8 | 张三   |  12 | 2022-09-27    |+----+--------+-----+---------------+</code></pre></div></figure><p>没有去重之前查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res5 &#x3D; models.User.objects.values_list(&#39;name&#39;, &#39;age&#39;)# 输出&lt;QuerySet [(&#39;laosb&#39;, 898), (&#39;马有铁&#39;, 38), (&#39;张三&#39;, 12), (&#39;张三&#39;, 12)]&gt;</code></pre></div></figure><p>使用<code>distinct()</code>去重</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res5 &#x3D; models.User.objects.values_list(&#39;name&#39;, &#39;age&#39;).distinct()print(res5)# 输出&lt;QuerySet [(&#39;laosb&#39;, 898), (&#39;马有铁&#39;, 38), (&#39;张三&#39;, 12)]&gt;</code></pre></div></figure><h3 id="2-2-7-排序"><a href="#2-2-7-排序" class="headerlink" title="2.2.7 排序"></a>2.2.7 排序</h3><p><code>order_by()</code>排序（升）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res6 &#x3D; models.User.objects.order_by(&#39;age&#39;)for i in res6:    print(&quot;id: &quot;, i.id, &quot;name:&quot;, i.name, &quot;age:&quot;, i.age, &quot;register_time: &quot;, i.register_time)    # 输出id:  7 name: 张三 age: 12 register_time:  2022-09-27id:  8 name: 张三 age: 12 register_time:  2022-09-27id:  6 name: 马有铁 age: 38 register_time:  2022-09-27id:  5 name: laosb age: 898 register_time:  2022-09-27</code></pre></div></figure><p><code>order_by()</code>排序（降）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res6 &#x3D; models.User.objects.order_by(&#39;-age&#39;)</code></pre></div></figure><h3 id="2-2-9-反转"><a href="#2-2-9-反转" class="headerlink" title="2.2.9 反转"></a>2.2.9 反转</h3><p><code>reverse()</code>反转的前提是数据已经排序过</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res6 &#x3D; models.User.objects.order_by(&#39;age&#39;).reverse()for i in res6:    print(&quot;id: &quot;, i.id, &quot;name:&quot;, i.name, &quot;age:&quot;, i.age, &quot;register_time: &quot;, i.register_time)    # 输出，升序已经反转成降序了id:  5 name: laosb age: 898 register_time:  2022-09-27id:  6 name: 马有铁 age: 38 register_time:  2022-09-27id:  7 name: 张三 age: 12 register_time:  2022-09-27id:  8 name: 张三 age: 12 register_time:  2022-09-27</code></pre></div></figure><h3 id="2-2-10-统计当前数据的个数"><a href="#2-2-10-统计当前数据的个数" class="headerlink" title="2.2.10 统计当前数据的个数"></a>2.2.10 统计当前数据的个数</h3><p><code>count()</code>统计个数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res6 &#x3D; models.User.objects.order_by(&#39;age&#39;).reverse().count()print(res6)# 输出4</code></pre></div></figure><h3 id="2-2-10-排除数据"><a href="#2-2-10-排除数据" class="headerlink" title="2.2.10 排除数据"></a>2.2.10 排除数据</h3><p><code>exclude()</code>将name&#x3D;’张三’的数据排除在外</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res6 &#x3D; models.User.objects.exclude(name&#x3D;&#39;张三&#39;).all()for i in res6:    print(&quot;id: &quot;, i.id, &quot;name:&quot;, i.name, &quot;age:&quot;, i.age, &quot;register_time: &quot;, i.register_time)</code></pre></div></figure><p>输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">id:  5 name: laosb age: 898 register_time:  2022-09-27id:  6 name: 马有铁 age: 38 register_time:  2022-09-27</code></pre></div></figure><h3 id="2-2-10-查询数据是否存在"><a href="#2-2-10-查询数据是否存在" class="headerlink" title="2.2.10 查询数据是否存在"></a>2.2.10 查询数据是否存在</h3><p><code>exists()</code>查询数据是否存在</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res6 &#x3D; models.User.objects.filter(pk&#x3D;10).exists()print(res6)res7 &#x3D; models.User.objects.filter(pk&#x3D;6).exists()print(res6)# 输出FalseTrue</code></pre></div></figure><h2 id="2-3-查看内部sql语句的方式"><a href="#2-3-查看内部sql语句的方式" class="headerlink" title="2.3 查看内部sql语句的方式"></a>2.3 查看内部sql语句的方式</h2><h3 id="2-3-1-方式一"><a href="#2-3-1-方式一" class="headerlink" title="2.3.1 方式一"></a>2.3.1 方式一</h3><p>queryset对象能够点击query查看内部的sql语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res6 &#x3D; models.User.objects.values_list(&#39;name&#39;, &#39;age&#39;)print(res6.query)# 输出SELECT &#96;app01_user&#96;.&#96;name&#96;, &#96;app01_user&#96;.&#96;age&#96; FROM &#96;app01_user&#96;</code></pre></div></figure><h3 id="2-3-2-方式二"><a href="#2-3-2-方式二" class="headerlink" title="2.3.2 方式二"></a>2.3.2 方式二</h3><p>所有的sql语句都能查看，在<code>settings.py</code>中添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">LOGGING &#x3D; &#123;    &#39;version&#39;: 1,    &#39;disable_existing_loggers&#39;: False,    &#39;handlers&#39;: &#123;        &#39;console&#39;:&#123;            &#39;level&#39;:&#39;DEBUG&#39;,            &#39;class&#39;:&#39;logging.StreamHandler&#39;,        &#125;,    &#125;,    &#39;loggers&#39;: &#123;        &#39;django.db.backends&#39;: &#123;            &#39;handlers&#39;: [&#39;console&#39;],            &#39;propagate&#39;: True,            &#39;level&#39;:&#39;DEBUG&#39;,        &#125;,    &#125;&#125;</code></pre></div></figure><p>尝试查询数据的输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">...(0.000) SELECT &#96;app01_user&#96;.&#96;id&#96;, &#96;app01_user&#96;.&#96;name&#96;, &#96;app01_user&#96;.&#96;age&#96;, &#96;app01_user&#96;.&#96;register_time&#96; FROM &#96;app01_user&#96; ORDER BY &#96;app01_user&#96;.&#96;id&#96; DESC LIMIT 1; args&#x3D;()</code></pre></div></figure><h1 id="三、多表操作"><a href="#三、多表操作" class="headerlink" title="三、多表操作"></a>三、多表操作</h1><h2 id="3-1-前期准备"><a href="#3-1-前期准备" class="headerlink" title="3.1 前期准备"></a>3.1 前期准备</h2><p>编辑<code>models.py</code>创建ORM对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Book(models.Model):    title &#x3D; models.CharField(max_length&#x3D;32)    price &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)    publish_date &#x3D; models.DateField(auto_now&#x3D;True)    # 添加表关系    # 一对多    publish &#x3D; models.ForeignKey(to&#x3D;&#39;Publish&#39;, on_delete&#x3D;models.CASCADE)    # 多对多    author &#x3D; models.ManyToManyField(to&#x3D;&#39;Author&#39;)class Publish(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    addr &#x3D; models.CharField(max_length&#x3D;64)    email &#x3D; models.EmailField()  # 默认是varchar(254)class Author(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.IntegerField()    # 添加表关系：一对一    author_detail &#x3D; models.OneToOneField(to&#x3D;&#39;AuthorDetail&#39;, on_delete&#x3D;models.CASCADE)class AuthorDetail(models.Model):    phone &#x3D; models.BigIntegerField()    addr &#x3D; models.CharField(max_length&#x3D;64)</code></pre></div></figure><p>同步到数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">python manage.py makemigrationspython manage.py migrate</code></pre></div></figure><p>查看数据库，确定创建成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show tables;+----------------------------+| Tables_in_day64            |+----------------------------+| app01_author# 作者表            | app01_authordetail# 作者信息     | app01_book# 书表                | app01_book_author# 书、作者（虚拟表）        | app01_publish# 出版社表              ...</code></pre></div></figure><h2 id="3-2-一对多外键增删改"><a href="#3-2-一对多外键增删改" class="headerlink" title="3.2 一对多外键增删改"></a>3.2 一对多外键增删改</h2><h3 id="3-2-1-增"><a href="#3-2-1-增" class="headerlink" title="3.2.1 增"></a>3.2.1 增</h3><p>准备出版社数据，案例：一个Publish对应多本Book</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select * from app01_publish;+----+----------------+--------------+-----------------+| id | name           | addr         | email           |+----+----------------+--------------+-----------------+|  1 | 朝阳群众出版社 | 北京市朝阳区 | 123@qq.com      ||  2 | 不明所以出版社 | 湖南省长沙市 | 456@163.com     ||  3 | 一本正经出版社 | 广东省深圳市 | 666@hotmail.com ||  4 | 没头脑出版社   | 银河系土星   | tx@666.com      |+----+----------------+--------------+-----------------+</code></pre></div></figure><p>增之前先修改<code>setting.py</code>取消外键检测</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">DATABASES &#x3D; &#123;    &#39;default&#39;: &#123;        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;NAME&#39;: &#39;day64&#39;,        &#39;USER&#39;: &#39;root&#39;,        &#39;PASSWORD&#39;: &#39;123123&#39;,        &#39;HOST&#39;: &#39;127.0.0.1&#39;,        &#39;PORT&#39;: 3306,        &#39;CHARSET&#39;: &#39;utf8&#39;,        # 新增        &#39;OPTIONS&#39;: &#123;            &quot;init_command&quot; : &quot;SET foreign_key_checks &#x3D; 0;&quot;,        &#125;    &#125;&#125;</code></pre></div></figure><p>增数据的两种方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方式一，直接写实际字段idmodels.Book.objects.create(title&#x3D;&#39;论语&#39;,price&#x3D;899.23,publish_id&#x3D;1)models.Book.objects.create(title&#x3D;&#39;聊斋&#39;,price&#x3D;444.23,publish_id&#x3D;2)models.Book.objects.create(title&#x3D;&#39;老子&#39;,price&#x3D;333.66,publish_id&#x3D;1)# 方式二，使用虚拟字段和对象新增publish_obj &#x3D; models.Publish.objects.filter(pk&#x3D;2).first()# 这个必须能获取到对象，否则后面会报错models.Book.objects.create(title&#x3D;&#39;红楼梦&#39;, price&#x3D;666.23, publish&#x3D;publish_obj)</code></pre></div></figure><p>查询数据库，已写入成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select * from app01_book;+----+--------+--------+--------------+------------+| id | title  | price  | publish_date | publish_id |+----+--------+--------+--------------+------------+|  6 | 论语   | 899.23 | 2022-09-27   |          1 ||  7 | 聊斋   | 444.23 | 2022-09-27   |          2 ||  8 | 老子   | 333.66 | 2022-09-27   |          1 ||  9 | 红楼梦 | 666.23 | 2022-09-27   |          2 |+----+--------+--------+--------------+------------+5 rows in set (0.00 sec)</code></pre></div></figure><h3 id="3-2-2-删"><a href="#3-2-2-删" class="headerlink" title="3.2.2 删"></a>3.2.2 删</h3><p>删除主键为<code>1</code>的出版社</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">models.Publish.objects.filter(pk&#x3D;1).delete()</code></pre></div></figure><p>查询，因为是<code>级联更新，级联删除</code>，删除出版社后，对应的书也删除了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select * from app01_publish;+----+----------------+--------------+-----------------+| id | name           | addr         | email           |+----+----------------+--------------+-----------------+|  2 | 不明所以出版社 | 湖南省长沙市 | 456@163.com     ||  3 | 一本正经出版社 | 广东省深圳市 | 666@hotmail.com ||  4 | 没头脑出版社   | 银河系土星   | tx@666.com      |+----+----------------+--------------+-----------------+3 rows in set (0.00 sec)mysql&gt; select * from app01_book;+----+--------+--------+--------------+------------+| id | title  | price  | publish_date | publish_id |+----+--------+--------+--------------+------------+|  7 | 聊斋   | 444.23 | 2022-09-27   |          2 ||  9 | 红楼梦 | 666.23 | 2022-09-27   |          2 |+----+--------+--------+--------------+------------+</code></pre></div></figure><h3 id="3-2-3-改"><a href="#3-2-3-改" class="headerlink" title="3.2.3 改"></a>3.2.3 改</h3><p>修改数据的两种方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方式一models.Book.objects.filter(pk&#x3D;7).update(publish_id&#x3D;1)# 方式二# 获取出版社对象publish_obj &#x3D; models.Publish.objects.filter(pk&#x3D;3).first()# 将出版设和书绑定models.Book.objects.filter(pk&#x3D;9).update(publish&#x3D;publish_obj)</code></pre></div></figure><p>查询数据库，修改成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_book;+----+--------+--------+--------------+------------+| id | title  | price  | publish_date | publish_id |+----+--------+--------+--------------+------------+|  7 | 聊斋   | 444.23 | 2022-09-27   |          1 ||  9 | 红楼梦 | 666.23 | 2022-09-27   |          3 |+----+--------+--------+--------------+------------+</code></pre></div></figure><h2 id="3-3-多对多外键增删改查"><a href="#3-3-多对多外键增删改查" class="headerlink" title="3.3 多对多外键增删改查"></a>3.3 多对多外键增删改查</h2><p>多对多的案例：一本书有多个作者</p><p>添加作者，和作者描述</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_author;+----+------+-----+------------------+| id | name | age | author_detail_id |+----+------+-----+------------------+|  1 | 张三 |  11 |                1 ||  2 | 李四 |  28 |                2 ||  3 | 王五 |  80 |                3 |+----+------+-----+------------------+mysql&gt; select * from app01_authordetail;+----+--------+------+| id | phone  | addr |+----+--------+------+|  1 | 123456 | 长沙 ||  2 | 234567 | 深圳 ||  3 | 345678 | 北京 |+----+--------+------+3 rows in set (0.00 sec)</code></pre></div></figure><h3 id="3-3-1-增"><a href="#3-3-1-增" class="headerlink" title="3.3.1 增"></a>3.3.1 增</h3><p>给书籍增加作者，两种方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方式一book_obj &#x3D; models.Book.objects.filter(pk&#x3D;7).first()print(book_obj.author) # 类似于已经到了第三张表（虚拟的book_author表）book_obj.author.add(2, 3)    # 绑定主键为2,3的作者# 方式二# 获取三个作者的对象author_obj1 &#x3D; models.Author.objects.filter(pk&#x3D;1).first()author_obj2 &#x3D; models.Author.objects.filter(pk&#x3D;2).first()author_obj3 &#x3D; models.Author.objects.filter(pk&#x3D;3).first()# 将作者关联到书book_obj.author.add(author_obj1)</code></pre></div></figure><p>查询数据，关联成功，虚拟表更新</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_book_author;+----+---------+-----------+| id | book_id | author_id |+----+---------+-----------+|  5 |       7 |         1 ||  1 |       7 |         2 ||  2 |       7 |         3 |+----+---------+-----------+3 rows in set (0.00 sec)</code></pre></div></figure><h3 id="3-3-2-删"><a href="#3-3-2-删" class="headerlink" title="3.3.2 删"></a>3.3.2 删</h3><p>删除的两种方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方法一book_obj &#x3D; models.Book.objects.filter(pk&#x3D;7).first()book_obj.author.remove(2,3)# 方法二author_obj &#x3D; models.Author.objects.filter(pk&#x3D;2).first()author_obj1 &#x3D; models.Author.objects.filter(pk&#x3D;3).first()book_obj.authors.remove(author_obj,author_obj1)</code></pre></div></figure><p>查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_book_author;+----+---------+-----------+| id | book_id | author_id |+----+---------+-----------+|  5 |       7 |         1 |+----+---------+-----------+1 row in set (0.00 sec)</code></pre></div></figure><h3 id="3-3-3-改"><a href="#3-3-3-改" class="headerlink" title="3.3.3 改"></a>3.3.3 改</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方法一book_obj.authors.set([1,2])  # 括号内必须给一个可迭代对象book_obj.authors.set([3])  # 括号内必须给一个可迭代对象# 方法二author_obj &#x3D; models.Author.objects.filter(pk&#x3D;2).first()author_obj1 &#x3D; models.Author.objects.filter(pk&#x3D;3).first()book_obj.authors.set([author_obj,author_obj1])  # 括号内必须给一个可迭代对象</code></pre></div></figure><p>查询</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_book_author;+----+---------+-----------+| id | book_id | author_id |+----+---------+-----------+|  6 |       7 |         2 ||  7 |       7 |         3 |+----+---------+-----------+</code></pre></div></figure><h3 id="3-3-4-清空"><a href="#3-3-4-清空" class="headerlink" title="3.3.4 清空"></a>3.3.4 清空</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">book_obj.authors.clear()</code></pre></div></figure><h2 id="3-4-正反向的概念"><a href="#3-4-正反向的概念" class="headerlink" title="3.4 正反向的概念"></a>3.4 正反向的概念</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 正向外键字段在我手上那么，我查你就是正向# 反向外键字段如果不在手上，我查你就是反向  book &gt;&gt;&gt;外键字段在书那儿(正向)&gt;&gt;&gt; publishpublish&gt;&gt;&gt;外键字段在书那儿(反向)&gt;&gt;&gt;book  一对一和多对多正反向的判断也是如此  &quot;&quot;&quot;正向查询按字段反向查询按表名小写_set...&quot;&quot;&quot;</code></pre></div></figure><h1 id="四、多表（跨表）查询"><a href="#四、多表（跨表）查询" class="headerlink" title="四、多表（跨表）查询"></a>四、多表（跨表）查询</h1><h2 id="4-1-对象查询（子查询）"><a href="#4-1-对象查询（子查询）" class="headerlink" title="4.1 对象查询（子查询）"></a>4.1 对象查询（子查询）</h2><blockquote><p>在书写orm语句的时候跟写sql语句一样的<br>不要企图一次性将orm语句写完 如果比较复杂 就写一点看一点</p><p>正向什么时候需要加.all()<br>   当你的结果可能有多个的时候就需要加.all()<br>   如果是一个则直接拿到数据对象<br>       book_obj.publish<br>       book_obj.authors.all()<br>       author_obj.author_detail</p></blockquote><p>案例一：查询书籍主键为9的出版社</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">book_obj &#x3D; models.Book.objects.filter(pk&#x3D;9).first()res &#x3D; book_obj.publishprint(res.name)print(res.addr)# 输出一本正经出版社广东省深圳市</code></pre></div></figure><p>案例二：查询书籍主键为7的作者</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">book_obj &#x3D; models.Book.objects.filter(pk&#x3D;7).first()res &#x3D; book_obj.author.all()for i in res:    print(i.name)# 输出李四王五</code></pre></div></figure><p>案例三：查询作者”张三”的电话</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">author_obj &#x3D; models.Author.objects.filter(name&#x3D;&#39;张三&#39;).first()res &#x3D; author_obj.author_detailprint(res.phone)# 输出123456</code></pre></div></figure><p>案例四、查询出版社是“没头脑出版社“的书</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 先给”没头脑出版社“关联两本书models.Book.objects.create(title&#x3D;&#39;大话西游&#39;, price&#x3D;343.2, publish_id&#x3D;4)models.Book.objects.create(title&#x3D;&#39;进化论&#39;, price&#x3D;3222, publish_id&#x3D;4)# 查询publish_obj &#x3D; models.Publish.objects.filter(name&#x3D;&#39;没头脑出版社&#39;).first()res &#x3D; publish_obj.book_set.all()# 反向需要加_setfor i in res:    print(i.title, i.price)    # 输出大话西游 343.20进化论 3222.00</code></pre></div></figure><p>案例五、查询作者‘李四’写过的书</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">author_obj &#x3D; models.Author.objects.filter(name&#x3D;&#39;李四&#39;).first()res &#x3D; author_obj.book_set.all()for i in res:    print(i.title)    # 输出聊斋</code></pre></div></figure><p>案例六：查询手机号是’234567’的作者姓名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">authordetail_obj &#x3D; models.AuthorDetail.objects.filter(phone&#x3D;234567).first()res &#x3D; authordetail_obj.authorprint(res.name)# 输出李四</code></pre></div></figure><h2 id="4-2-双下划线查询（联表查询）"><a href="#4-2-双下划线查询（联表查询）" class="headerlink" title="4.2 双下划线查询（联表查询）"></a>4.2 双下划线查询（联表查询）</h2><p>案例一：查询作者’张三’的手机号和年龄</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 正向res &#x3D; models.Author.objects.filter(name&#x3D;&#39;张三&#39;).values(&#39;author_detail__phone&#39;, &#39;age&#39;)print(res)# 反向res2 &#x3D; models.AuthorDetail.objects.filter(author__name&#x3D;&#39;张三&#39;).values(&#39;phone&#39;, &#39;author__age&#39;)print(res2)</code></pre></div></figure><p>案例二：查询书籍主键为9的出版社名称和书的名称</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 正向res &#x3D; models.Book.objects.filter(pk&#x3D;9).values(&#39;publish__name&#39;, &#39;title&#39;)print(res)# 反向res2 &#x3D; models.Publish.objects.filter(book__id&#x3D;9).values(&#39;name&#39;, &#39;book__title&#39;)print(res2)# 输出&lt;QuerySet [&#123;&#39;publish__name&#39;: &#39;一本正经出版社&#39;, &#39;title&#39;: &#39;红楼梦&#39;&#125;]&gt;&lt;QuerySet [&#123;&#39;name&#39;: &#39;一本正经出版社&#39;, &#39;book__title&#39;: &#39;红楼梦&#39;&#125;]&gt;</code></pre></div></figure><p>案例三：查询书籍主键为7的作者姓名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 正向res &#x3D; models.Book.objects.filter(pk&#x3D;7).values(&#39;author__name&#39;)print(res)# 反向res2 &#x3D; models.Author.objects.filter(book__id&#x3D;7).values(&#39;name&#39;)print(res2)# 输出&lt;QuerySet [&#123;&#39;author__name&#39;: &#39;李四&#39;&#125;, &#123;&#39;author__name&#39;: &#39;王五&#39;&#125;]&gt;&lt;QuerySet [&#123;&#39;name&#39;: &#39;李四&#39;&#125;, &#123;&#39;name&#39;: &#39;王五&#39;&#125;]&gt;</code></pre></div></figure><p>案例四：查询书籍主键市7的作者的手机号</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 正向res &#x3D; models.Book.objects.filter(pk&#x3D;7).values(&#39;author__author_detail__phone&#39;)print(res)# 反向报错！不能这样写#res2 &#x3D; models.AuthorDetail.objects.filter(book__id&#x3D;7).values(&#39;phone&#39;)#print(res2)# 输出&lt;QuerySet [&#123;&#39;author__author_detail__phone&#39;: 234567&#125;, &#123;&#39;author__author_detail__phone&#39;: 345678&#125;]&gt;</code></pre></div></figure><h1 id="五、周末作业"><a href="#五、周末作业" class="headerlink" title="五、周末作业"></a>五、周末作业</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;今日作业必做题1.整理今日内容 用自己的话术整理到博客中(切勿直接复制粘贴)独立完成以下任务2.自己手动创建图书管理系统表及数据录入  3.独立完成单表查询N条方法，双下划线方法4.将课上orm题目摘出来，自己完成orm语句书写，体会orm简便之处选做题1.图书管理系统图书表的增删改查（只需要完成图书表的就可以）&quot;&quot;&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day63-模板语法</title>
    <link href="/2022/09/15/03_Python/05_Django/day63%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/09/15/03_Python/05_Django/day63%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>“Day63 模板语法 学习笔记”</p><h1 id="一、模板语法"><a href="#一、模板语法" class="headerlink" title="一、模板语法"></a>一、模板语法</h1><p>什么是模板语法？</p><p>模板语法是一种写在HTML中的标记语法，常用有两种方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123;&#123;  &#125;&#125;# 双括号形式，主要用于变量相关&#123;%  %&#125;  # 括号+%形式，主要用于逻辑相关</code></pre></div></figure><p>作用： </p><ul><li>将后端定义的变量传递给前端</li><li>处理后端传过来的数据</li></ul><h2 id="1-1-模板语法传值"><a href="#1-1-模板语法传值" class="headerlink" title="1.1 模板语法传值"></a>1.1 模板语法传值</h2><h3 id="1-1-1-传递基本数据类型"><a href="#1-1-1-传递基本数据类型" class="headerlink" title="1.1.1 传递基本数据类型"></a>1.1.1 传递基本数据类型</h3><p>模板语法可接收后端传递过来的所有基本数据类型。</p><p>案例如下：</p><p>后端<code>views.py</code>定义变量，并传递给前端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render# Create your views here.def index(request):    # 传递基本数据类型    n &#x3D; 123# 整型    f &#x3D; 11.11# 浮点    s &#x3D; &#39;我是谁，我在哪？&#39;# 字符串    b &#x3D; True# 布尔    l &#x3D; [&#39;小一&#39;, &#39;小儿&#39;, &#39;小啊啊&#39;]# 列表    t &#x3D; (&#39;锄禾&#39;, &#39;日&#39;, &#39;当午&#39;)# 元组    d &#x3D; &#123;&#39;aa&#39;: &#39;A&#39;, &#39;bb&#39;: &#39;B&#39;&#125;# 字典    s &#x3D; &#123;1, &#39;左右&#39;, 3&#125;# 集合    # 返回Index页面, 并将变量传递给前端    # 传递的方法一：一个个传    # (可以给变量起别名，比如将&#39;s&#39;改名为&#39;my_set&#39;, 前端使用&#123;&#123; my_set &#125;&#125;调用)    # return render(request, &#39;index.html&#39;, &#123;&#39;n&#39;: n, &#39;my_set&#39;: s&#125;)    # 传递方法二：传所有    return render(request, &#39;index.html&#39;, locals())</code></pre></div></figure><p>前端使用<code>模板语法</code>调用</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&#123;#接收基本数据类型#&#125;&lt;p&gt;&#123;&#123; n &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; f &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; s &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; b &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; l &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; d &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; t &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; se &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>HTML页面输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">12311.11&#123;1, &#39;左右&#39;, 3&#125;True[&#39;小一&#39;, &#39;小儿&#39;, &#39;小啊啊&#39;]&#123;&#39;aa&#39;: &#39;A&#39;, &#39;bb&#39;: &#39;B&#39;&#125;(&#39;锄禾&#39;, &#39;日&#39;, &#39;当午&#39;)</code></pre></div></figure><h3 id="1-1-2-传递类方法"><a href="#1-1-2-传递类方法" class="headerlink" title="1.1.2 传递类方法"></a>1.1.2 传递类方法</h3><p>模板语法可接收后端传递过来的类方法返回值，但是调用类方法<code>不能传参数</code></p><p>案例如下：</p><p>后端<code>views.py</code>定义变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render# Create your views here.def index(request):    # 定义类    class My_Class(object):        def get_self(self):# 普通类方法            return &#39;self&#39;        @staticmethod# 静态方法        def get_func():            return &#39;func&#39;        @classmethod# 类方法        def get_class(self):            return &#39;class&#39;        def __str__(self):# 魔法方法            return &quot;__str__显示&quot;    # 实例化    obj &#x3D; My_Class()    # 传递所有    return render(request, &#39;index.html&#39;, locals())</code></pre></div></figure><p>前端使用<code>模板语法</code>调用</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&#123;#接收基本数据类型#&#125;&lt;p&gt;&#123;&#123; obj &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; obj.get_self &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; obj.get_func &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; obj.get_class &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>HTML页面输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">__str__显示selffuncclass</code></pre></div></figure><h3 id="1-1-3-通过-获取值"><a href="#1-1-3-通过-获取值" class="headerlink" title="1.1.3 通过.获取值"></a>1.1.3 通过<code>.</code>获取值</h3><p>Django模版语法的取值是<code>固定的格式</code>，只能采用“句点符” <code>.</code></p><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># views.pyfrom django.shortcuts import render# Create your views here.def index(request):    my_dict &#x3D; &#123;&#39;aa&#39;: &#39;A&#39;, &#39;bb&#39;: [1, 2, &#39;牛逼Plus&#39;]&#125;    # 传递方法二：传所有    return render(request, &#39;index.html&#39;, locals())</code></pre></div></figure><p>怎么通过模板语法，从里面拿到”牛逼Plus”?</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p&gt;&#123;&#123; my_dict.bb.2 &#125;&#125;&lt;&#x2F;p&gt;</code></pre></div></figure><p>先拿到字典键’bb’的值，再从里面取下标为2的值。即可以点键也可以点索引 还可以两者混用</p><h2 id="1-2-模板语法过滤器"><a href="#1-2-模板语法过滤器" class="headerlink" title="1.2 模板语法过滤器"></a>1.2 模板语法过滤器</h2><p>可以理解为<code>shell中的管道</code>，对数据进行二次处理。</p><p>Django内置有60多种过滤器，这里介绍10个左右</p><p>案例如下：</p><p>变量定义与传递<code>views.py</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import renderfrom datetime import datetime# Create your views here.def index(request):    # 定义变量    aa &#x3D; &#39;str12345&#39;    bb &#x3D; False    cc &#x3D; 1000000    dd &#x3D; datetime.now()    ee &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]    ff &#x3D; &#39;长空 破浪 会 有时&#39;    gg &#x3D; &#39;abcd1234&#39;    hh &#x3D; &#39;&lt;h1&gt;你好&lt;&#x2F;h1&gt;&#39;    # 传递变量    return render(request, &#39;index.html&#39;, locals())</code></pre></div></figure><p>HTML获取值</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&#123;#过滤器的使用#&#125;&lt;p&gt;统计长度：&#123;&#123; aa | length &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;设置默认值：&#123;&#123; bb | default:&#39;默认值&#39; &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;文件大小：&#123; cc | filesizeformat &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;日期格式化：&#123;&#123; dd | date:&#39;Y-m-d H:i:s&#39; &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;切片操作：&#123;&#123; ee | slice:&#39;0:4:2&#39; &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;切取单词（按空格分割）:&#123;&#123; ff | truncatewords:3 &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;切取字符： &#123;&#123; gg | truncatechars:4 &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;拼接操作(分隔符)：&#123;&#123; gg | join:&quot;$&quot; &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;拼接操作(加法-用于数字)：&#123;&#123; bb | add:20 &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;拼接操作(加法-用于字符串)：&#123;&#123; ff | add:gg &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;转义：&#123;&#123; hh | safe &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>测试访问：</p><p><img src="/../../../img/image-20220915143537762.png" alt="image-20220915143537762"></p><h3 id="1-2-1-转义补充"><a href="#1-2-1-转义补充" class="headerlink" title="1.2.1 转义补充"></a>1.2.1 转义补充</h3><p>除了前端可以使用<code>|safe</code>过滤器转义，Django后端也可以转义</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 后端views.pyfrom django.utils.safestring import mark_safeii &#x3D; &#39;&lt;h2&gt;我是后端的转义&lt;&#x2F;h2&gt;&#39;res &#x3D; mark_safe(ii)# 前端调用&#123;&#123; res &#125;&#125;</code></pre></div></figure><p>页面效果：</p><p><img src="/../../../img/image-20220915143944351.png" alt="image-20220915143944351"></p><h2 id="1-3-标签"><a href="#1-3-标签" class="headerlink" title="1.3 标签"></a>1.3 标签</h2><h3 id="1-3-1-for循环"><a href="#1-3-1-for循环" class="headerlink" title="1.3.1 for循环"></a>1.3.1 for循环</h3><p>后端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 后端my_list &#x3D; [&#39;11&#39;, &#39;22&#39;, &#39;33&#39;, &#39;44&#39;]</code></pre></div></figure><p>前端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;% for i in my_list %&#125;    &lt;p&gt;&#123;&#123; forloop &#125;&#125;&lt;&#x2F;p&gt;# 显示本次循环的信息    &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;&#x2F;p&gt;# 输出值&#123;% endfor %&#125;</code></pre></div></figure><p>结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123;&#39;parentloop&#39;: &#123;&#125;, &#39;counter0&#39;: 0, &#39;counter&#39;: 1, &#39;revcounter&#39;: 4, &#39;revcounter0&#39;: 3, &#39;first&#39;: True, &#39;last&#39;: False&#125;11&#123;&#39;parentloop&#39;: &#123;&#125;, &#39;counter0&#39;: 1, &#39;counter&#39;: 2, &#39;revcounter&#39;: 3, &#39;revcounter0&#39;: 2, &#39;first&#39;: False, &#39;last&#39;: False&#125;22&#123;&#39;parentloop&#39;: &#123;&#125;, &#39;counter0&#39;: 2, &#39;counter&#39;: 3, &#39;revcounter&#39;: 2, &#39;revcounter0&#39;: 1, &#39;first&#39;: False, &#39;last&#39;: False&#125;33&#123;&#39;parentloop&#39;: &#123;&#125;, &#39;counter0&#39;: 3, &#39;counter&#39;: 4, &#39;revcounter&#39;: 1, &#39;revcounter0&#39;: 0, &#39;first&#39;: False, &#39;last&#39;: True&#125;44</code></pre></div></figure><h3 id="1-3-2-if判断"><a href="#1-3-2-if判断" class="headerlink" title="1.3.2 if判断"></a>1.3.2 if判断</h3><p>后端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">old_zhao &#x3D; Falseold_wang &#x3D; True</code></pre></div></figure><p>前端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;% if old_zhao %&#125;    &lt;p&gt;今晚不行&lt;&#x2F;p&gt;&#123;% elif old_wang %&#125;    &lt;p&gt;可以可以！&lt;&#x2F;p&gt;&#123;% else %&#125;    &lt;p&gt;也还凑合&lt;&#x2F;p&gt;&#123;% endif %&#125;</code></pre></div></figure><p>页面输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">可以可以！</code></pre></div></figure><h3 id="1-3-3-标签混用"><a href="#1-3-3-标签混用" class="headerlink" title="1.3.3 标签混用"></a>1.3.3 标签混用</h3><p>前端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;% for foo in my_list %&#125;    &#123;% if forloop.first %&#125;        &lt;p&gt;这是我的第一次&lt;&#x2F;p&gt;    &#123;% elif forloop.last %&#125;        &lt;p&gt;最后一次，下不为例&lt;&#x2F;p&gt;    &#123;% else %&#125;        &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;&#x2F;p&gt;    &#123;% endif %&#125;    &#123;%  empty %&#125;        &lt;p&gt;for循环的可迭代对象内部没有元素 根本没法循环&lt;&#x2F;p&gt;&#123;% endfor %&#125;</code></pre></div></figure><p>页面输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">这是我的第一次2233最后一次，下不为例</code></pre></div></figure><h3 id="1-3-4-处理字典"><a href="#1-3-4-处理字典" class="headerlink" title="1.3.4 处理字典"></a>1.3.4 处理字典</h3><p>后端定义字典：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_dic &#x3D; &#123;&#39;烟&#39;: &#39;芙蓉王&#39;, &#39;酒&#39;: &#39;茅台&#39;, &#39;家电&#39;: [&#39;冰箱&#39;, &#39;洗衣机&#39;, &#39;热水器&#39;]&#125;</code></pre></div></figure><p>前端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123;#输出键#&#125;&#123;% for i in my_dic.keys %&#125;    &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;&#x2F;p&gt;&#123;% endfor %&#125;&lt;p&gt;--------&lt;&#x2F;p&gt;&#123;#输出值#&#125;&#123;% for i in my_dic.values %&#125;    &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;&#x2F;p&gt;&#123;% endfor %&#125;&lt;p&gt;--------&lt;&#x2F;p&gt;&#123;#输出键值对#&#125;&#123;% for i in my_dic.items %&#125;    &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;&#x2F;p&gt;&#123;% endfor %&#125;</code></pre></div></figure><p>页面输出：</p><p><img src="/../../../img/image-20220915214232918.png" alt="image-20220915214232918"></p><h3 id="1-3-5-with起别名"><a href="#1-3-5-with起别名" class="headerlink" title="1.3.5 with起别名"></a>1.3.5 with起别名</h3><p>我们过滤<em>1.3.4</em>节的字典，比如从里面获取’热水器’这个值，一般的写法是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123;&#123; my_dic.家电.2 &#125;&#125;# 补充：没看错，家电确实不要加&#39;引号&#39;</code></pre></div></figure><p>如果觉得这么写太长，可以给它取个别名：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;% with my_dic.家电.2 as 别名 %&#125;    &lt;p&gt;&#123;&#123; 别名 &#125;&#125;&lt;&#x2F;p&gt;&#123;% endwith %&#125;</code></pre></div></figure><p>照样输出<code>热水器</code></p><h2 id="1-4-自定义过滤器、标签、Inclusion-tag"><a href="#1-4-自定义过滤器、标签、Inclusion-tag" class="headerlink" title="1.4 自定义过滤器、标签、Inclusion_tag"></a>1.4 自定义过滤器、标签、Inclusion_tag</h2><h3 id="1-4-1-准备工作"><a href="#1-4-1-准备工作" class="headerlink" title="1.4.1 准备工作"></a>1.4.1 准备工作</h3><p>无论是自定义过滤器、标签还是inclusion_tag，都需要进行如下准备工作：</p><p>1、在应用下创建名叫<code>templatetags</code>的文件夹（必须这个名字）</p><p>2、在该文件夹内，创建任意的<code>py</code>文件</p><p>3、在<code>py</code>文件中，需要导入模块</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django import templateregister &#x3D; template.Library()</code></pre></div></figure><h3 id="1-4-1-自定义过滤器"><a href="#1-4-1-自定义过滤器" class="headerlink" title="1.4.1 自定义过滤器"></a>1.4.1 自定义过滤器</h3><p>后端定义过滤器，实现两个数相加的功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 导入模块from django import templateregister &#x3D; template.Library()# 自定义过滤器@register.filter(name&#x3D;&quot;baby&quot;)def my_sum(x, y):    return x + y</code></pre></div></figure><p>前端调用</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;% load my_temp %&#125;# 加载模块&#123;&#123; cc|baby:666 &#125;&#125;</code></pre></div></figure><h3 id="1-4-2-自定义标签"><a href="#1-4-2-自定义标签" class="headerlink" title="1.4.2 自定义标签"></a>1.4.2 自定义标签</h3><p>后端定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 自定义标签@register.simple_tag(name&#x3D;&#39;plus&#39;)def index(a, b, c, d):    return &#39;%s-%s-%s-%s&#39; % (a, b, c, d)</code></pre></div></figure><p>前端调用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;p&gt;&#123;% plus &#39;goodman&#39; 332 678 &#39;NB&#39; %&#125;&lt;&#x2F;p&gt;</code></pre></div></figure><p>页面输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">goodman-332-678-NB</code></pre></div></figure><h3 id="1-4-3-自定义inclusion-tag"><a href="#1-4-3-自定义inclusion-tag" class="headerlink" title="1.4.3 自定义inclusion_tag"></a>1.4.3 自定义inclusion_tag</h3><p>作用：</p><p>当html页面某一个地方的页面（<code>局部页面</code>）需要传参数才能够<code>动态的渲染</code>出来，并且在多</p><p>个页面上都需要使用到该局部页面，那么就考虑将该局部页面做成inclusion_tag形式</p><p>内部原理：</p><ul><li>先定义一个方法 </li><li>在页面上调用该方法 并且可以传值</li><li>该方法会生成一些数据然后传递给一个html页面</li><li>之后将渲染好的结果放到调用的位置</li></ul><p>图解：</p><p><img src="/../../../img/image-20220915223520493.png" alt="image-20220915223520493"></p><p><strong>案例：</strong></p><p>后端定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">@register.inclusion_tag(&#39;left_menu.html&#39;)def left(n):    data &#x3D; [&#39;第&#123;&#125;项&#39;.format(i) for i in range(n)]    # 第一种    # return &#123;&#39;data&#39;:data&#125;  # 将data传递给left_menu.html    # 第二种    return locals()  # 将data传递给left_menu.html</code></pre></div></figure><p>局部页面：<code>left_menu.html</code>定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;ul&gt;    &#123;% for foo in data %&#125;        &lt;li&gt;&#123;&#123; foo &#125;&#125;&lt;&#x2F;li&gt;    &#123;% endfor %&#125;&lt;&#x2F;ul&gt;</code></pre></div></figure><p>主页面调用（既将局部页面插入主页面）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;% left 5 %&#125;</code></pre></div></figure><p>效果（主页面中插入了left_menu.html页面）：</p><p><img src="/../../../img/image-20220915224735224.png" alt="image-20220915224735224"></p><h2 id="1-5-模板的继承-TODO"><a href="#1-5-模板的继承-TODO" class="headerlink" title="1.5 模板的继承(TODO)"></a>1.5 模板的继承(TODO)</h2><p>这里有个例子要做（TODO）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;你们有没有见过一些网站这些网站页面整体都大差不差 只是某一些局部在做变化&quot;&quot;&quot;# 模版的继承 你自己先选好一个你要想继承的模版页面&#123;% extends &#39;home.html&#39; %&#125;# 继承了之后子页面跟模版页面长的是一模一样的 你需要在模版页面上提前划定可以被修改的区域&#123;% block content %&#125;模版内容&#123;% endblock %&#125;# 子页面继承父页面的&#123;% block.super %&#125;# 子页面就可以声明想要修改哪块划定了的区域&#123;% block content %&#125;子页面内容&#123;% endblock %&#125;# 一般情况下模版页面上应该至少有三块可以被修改的区域1.css区域  2.html区域  3.js区域  &#123;% block css %&#125;&#123;% endblock %&#125;    &#123;% block content %&#125;&#123;% endblock %&#125;    &#123;% block js %&#125;&#123;% endblock %&#125;  # 每一个子页面就都可以有自己独有的css代码 html代码 js代码  &quot;&quot;&quot;一般情况下 模版的页面上划定的区域越多 那么该模版的扩展性就越高但是如果太多 那还不如自己直接写&quot;&quot;&quot;</code></pre></div></figure><h2 id="1-6-模板的导入"><a href="#1-6-模板的导入" class="headerlink" title="1.6 模板的导入"></a>1.6 模板的导入</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&quot;&quot;&quot;将页面的某一个局部当成模块的形式哪个地方需要就可以直接导入使用即可&quot;&quot;&quot;&#123;% include &#39;wasai.html&#39; %&#125;</code></pre></div></figure><h1 id="二、CBV源码分析"><a href="#二、CBV源码分析" class="headerlink" title="二、CBV源码分析"></a>二、CBV源码分析</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 你自己不要修改源码 除了bug很难找# 突破口在urls.pyurl(r&#39;^login&#x2F;&#39;,views.MyLogin.as_view())# url(r&#39;^login&#x2F;&#39;,views.view)  FBV一模一样# CBV与FBV在路由匹配上本质是一样的 都是路由 对应 函数内存地址&quot;&quot;&quot;函数名&#x2F;方法名 加括号执行优先级最高猜测    as_view()        要么是被@staicmethod修饰的静态方法        要么是被@classmethod修饰的类方法  正确            @classonlymethod    def as_view(cls, **initkwargs):        pass&quot;&quot;&quot;    @classonlymethod    def as_view(cls, **initkwargs):        &quot;&quot;&quot;        cls就是我们自己写的类   MyCBV        Main entry point for a request-response process.        &quot;&quot;&quot;        def view(request, *args, **kwargs):            self &#x3D; cls(**initkwargs)  # cls是我们自己写的类            # self &#x3D; MyLogin(**initkwargs)  产生一个我们自己写的类的对象            return self.dispatch(request, *args, **kwargs)            &quot;&quot;&quot;            以后你们会经常需要看源码 但是在看python源码的时候 一定要时刻提醒自己面向对象属性方法查找顺序                先从对象自己找                再去产生对象的类里面找                之后再去父类找                ...            总结:看源码只要看到了self点一个东西 一定要问你自己当前这个self到底是谁            &quot;&quot;&quot;        return view      # CBV的精髓    def dispatch(self, request, *args, **kwargs):        # 获取当前请求的小写格式 然后比对当前请求方式是否合法        # get请求为例        # post请求        if request.method.lower() in self.http_method_names:            handler &#x3D; getattr(self, request.method.lower(), self.http_method_not_allowed)            &quot;&quot;&quot;            反射:通过字符串来操作对象的属性或者方法                handler &#x3D; getattr(自己写的类产生的对象,&#39;get&#39;,当找不到get属性或者方法的时候就会用第三个参数)                handler &#x3D; 我们自己写的类里面的get方法            &quot;&quot;&quot;        else:            handler &#x3D; self.http_method_not_allowed        return handler(request, *args, **kwargs)        &quot;&quot;&quot;        自动调用get方法        &quot;&quot;&quot;# 要求掌握到不看源码也能够描述出CBV的内部执行流程(******)</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day62-Django-03</title>
    <link href="/2022/09/12/03_Python/05_Django/day62%E7%AC%94%E8%AE%B0-Django-03/"/>
    <url>/2022/09/12/03_Python/05_Django/day62%E7%AC%94%E8%AE%B0-Django-03/</url>
    
    <content type="html"><![CDATA[<p>“Day62 Diango 03 学习笔记”</p><h1 id="一、路由层（接day61）"><a href="#一、路由层（接day61）" class="headerlink" title="一、路由层（接day61）"></a>一、路由层（接day61）</h1><h2 id="1-2-路由分发"><a href="#1-2-路由分发" class="headerlink" title="1.2 路由分发"></a>1.2 路由分发</h2><h3 id="1-2-1-什么是路由分发？"><a href="#1-2-1-什么是路由分发？" class="headerlink" title="1.2.1 什么是路由分发？"></a>1.2.1 什么是路由分发？</h3><p>​将所有的url都写在Django项目总的<code>urls.py</code>中，写多了杂乱，不好维护</p><p>​但是Django有个特点：每一个应用都可以有自己的templates文件夹、urls.py、static文件夹</p><p>​基于上述的特点 django能够非常好的做到分组开发(每个人只写自己的app)</p><p>利用路由分发来减轻总路由的压力，总路由统领各app里面的路由</p><h3 id="1-2-2-路由分发案例"><a href="#1-2-2-路由分发案例" class="headerlink" title="1.2.2 路由分发案例"></a>1.2.2 路由分发案例</h3><p>1）新项目，创建两个app</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python .\manage.py startapp app01python .\manage.py startapp app02</code></pre></div></figure><p>2）两个app配置子路由<code>urls.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01from django.urls import pathfrom app01 import viewsurlpatterns &#x3D; [    path(&#39;reg&#x2F;&#39;, views.reg),]# app02from django.urls import pathfrom app02 import viewsurlpatterns &#x3D; [    path(&#39;reg&#x2F;&#39;, views.reg),]</code></pre></div></figure><p>3）两个app的views文件修改</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01from django.shortcuts import render, HttpResponse# Create your views here.def reg(request):    return HttpResponse(&quot;app01:reg&quot;)# app02from django.shortcuts import render, HttpResponse# Create your views here.def reg(request):    return HttpResponse(&quot;app01:reg&quot;)</code></pre></div></figure><p>4）总路由<code>urls.py</code>配置路由分发</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.conf.urls import url, include# 需要导入模块from django.urls import path, re_pathfrom app01 import urls as app01_urlsfrom app02 import urls as app02_urlsurlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    # 凡是app01开头的，都交给app01子路由处理    re_path(r&#39;^app01&#x2F;&#39;, include(app01_urls)),    # 凡是app02开头的，都交给app02子路由处理    re_path(r&#39;^app02&#x2F;&#39;, include(app02_urls)),]</code></pre></div></figure><p>更推荐的写发，不需要重命名：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.conf.urls import url, include# 需要导入模块from django.urls import path, re_pathurlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    # 凡是app01开头的，都交给app01子路由处理    re_path(r&#39;^app01&#x2F;&#39;, include(&#39;app01.urls&#39;)),    # 凡是app02开头的，都交给app02子路由处理    re_path(r&#39;^app02&#x2F;&#39;, include(&#39;app02.urls&#39;)),]</code></pre></div></figure><p>测试访问成功：</p><p><img src="/../../../img/image-20220913193027730.png" alt="image-20220913193027730"></p><h2 id="1-3-名称空间-了解"><a href="#1-3-名称空间-了解" class="headerlink" title="1.3 名称空间(了解)"></a>1.3 名称空间(了解)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 当多个应用出现了相同的别名 我们研究反向解析会不会自动识别应用前缀&quot;&quot;&quot;正常情况下的反向解析是没有办法自动识别前缀的&quot;&quot;&quot;# 名称空间# 总路由    url(r&#39;^app01&#x2F;&#39;,include(&#39;app01.urls&#39;,namespace&#x3D;&#39;app01&#39;)),    url(r&#39;^app02&#x2F;&#39;,include(&#39;app02.urls&#39;,namespace&#x3D;&#39;app02&#39;))  # 解析的时候  # app01  urlpatterns &#x3D; [    url(r&#39;^reg&#x2F;&#39;,views.reg,name&#x3D;&#39;reg&#39;)]    # app02    urlpatterns &#x3D; [    url(r&#39;^reg&#x2F;&#39;,views.reg,name&#x3D;&#39;reg&#39;)]      reverse(&#39;app01:reg&#39;)    reverse(&#39;app02:reg&#39;)        &#123;% url &#39;app01:reg&#39; %&#125;    &#123;% url &#39;app02:reg&#39; %&#125;# 其实只要保证名字不冲突 就没有必要使用名称空间&quot;&quot;&quot;一般情况下 有多个app的时候我们在起别名的时候会加上app的前缀这样的话就能够确保多个app之间名字不冲突的问题&quot;&quot;&quot;urlpatterns &#x3D; [    url(r&#39;^reg&#x2F;&#39;,views.reg,name&#x3D;&#39;app01_reg&#39;)]urlpatterns &#x3D; [    url(r&#39;^reg&#x2F;&#39;,views.reg,name&#x3D;&#39;app02_reg&#39;)]</code></pre></div></figure><h2 id="1-4-伪静态-了解"><a href="#1-4-伪静态-了解" class="headerlink" title="1.4 伪静态(了解)"></a>1.4 伪静态(了解)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;静态网页数据是写死的 万年不变伪静态将一个动态网页伪装成静态网页为什么要伪装呢？https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Dominic-Ji&#x2F;p&#x2F;9234099.html伪装的目的在于增大本网站的seo查询力度并且增加搜索引擎收藏本网上的概率搜索引擎本质上就是一个巨大的爬虫程序总结:无论你怎么优化 怎么处理始终还是干不过RMB玩家&quot;&quot;&quot;urlpatterns &#x3D; [    url(r&#39;^reg.html&#39;,views.reg,name&#x3D;&#39;app02_reg&#39;)]</code></pre></div></figure><h2 id="1-5-虚拟环境-了解"><a href="#1-5-虚拟环境-了解" class="headerlink" title="1.5 虚拟环境(了解)"></a>1.5 虚拟环境(了解)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;在正常开发中 我们会给每一个项目配备一个该项目独有的解释器环境该环境内只有该项目用到的模块 用不到一概不装linux:缺什么才装什么虚拟环境你每创建一个虚拟环境就类似于重新下载了一个纯净的python解释器但是虚拟环境不要创建太多，是需要消耗硬盘空间的扩展:每一个项目都需要用到很多模块 并且每个模块版本可能还不一样那我该如何安装呢？ 一个个看一个个装？？？开发当中我们会给每一个项目配备一个requirements.txt文件里面书写了该项目所有的模块即版本你只需要直接输入一条命令即可一键安装所有模块即版本&quot;&quot;&quot;</code></pre></div></figure><h2 id="1-6-django版本区别"><a href="#1-6-django版本区别" class="headerlink" title="1.6 django版本区别"></a>1.6 django版本区别</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1.django1.X路由层使用的是url方法而在django2.Xhe3.X版本中路由层使用的是path方法url()第一个参数支持正则path()第一个参数是不支持正则的 写什么就匹配什么如果你习惯使用path那么也给你提供了另外一个方法from django.urls import path, re_pathfrom django.conf.urls import urlre_path(r&#39;^index&#x2F;&#39;,index),    url(r&#39;^login&#x2F;&#39;,login)  2.X和3.X里面的re_path就等价于1.X里面的url  2.虽然path不支持正则 但是它的内部支持五种转换器path(&#39;index&#x2F;&lt;int:id&gt;&#x2F;&#39;,index)# 将第二个路由里面的内容先转成整型然后以关键字的形式传递给后面的视图函数def index(request,id):    print(id,type(id))    return HttpResponse(&#39;index&#39;)          str,匹配除了路径分隔符（&#x2F;）之外的非空字符串，这是默认的形式int,匹配正整数，包含0。slug,匹配字母、数字以及横杠、下划线组成的字符串。uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。path,匹配任何非空字符串，包含了路径分隔符（&#x2F;）（不能用？）3.除了有默认的五个转换器之外 还支持自定义转换器(了解)class MonthConverter:    regex&#x3D;&#39;\d&#123;2&#125;&#39; # 属性名必须为regex    def to_python(self, value):        return int(value)    def to_url(self, value):        return value # 匹配的regex是两个数字，返回的结果也必须是两个数字from django.urls import path,register_converterfrom app01.path_converts import MonthConverter# 先注册转换器register_converter(MonthConverter,&#39;mon&#39;)from app01 import viewsurlpatterns &#x3D; [    path(&#39;articles&#x2F;&lt;int:year&gt;&#x2F;&lt;mon:month&gt;&#x2F;&lt;slug:other&gt;&#x2F;&#39;, views.article_detail, name&#x3D;&#39;aaa&#39;),]4.模型层里面1.X外键默认都是级联更新删除的但是到了2.X和3.X中需要你自己手动配置参数models.ForeignKey(to&#x3D;&#39;Publish&#39;)models.ForeignKey(to&#x3D;&#39;Publish&#39;,on_delete&#x3D;models.CASCADE...)&quot;&quot;&quot;</code></pre></div></figure><h1 id="二、视图层"><a href="#二、视图层" class="headerlink" title="二、视图层"></a>二、视图层</h1><h2 id="2-1-三板斧"><a href="#2-1-三板斧" class="headerlink" title="2.1 三板斧"></a>2.1 三板斧</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;HttpResponse返回字符串类型render返回html页面 并且在返回给浏览器之前还可以给html文件传值redirect重定向&quot;&quot;&quot;# 视图函数必须要返回一个HttpResponse对象  正确   研究三者的源码即可得处结论The view app01.views.index didn&#39;t return an HttpResponse object. It returned None instead.# render简单内部原理from django.template import Template,Context    res &#x3D; Template(&#39;&lt;h1&gt;&#123;&#123; user &#125;&#125;&lt;&#x2F;h1&gt;&#39;)    con &#x3D; Context(&#123;&#39;user&#39;:&#123;&#39;username&#39;:&#39;jason&#39;,&#39;password&#39;:123&#125;&#125;)    ret &#x3D; res.render(con)    print(ret)    return HttpResponse(ret)</code></pre></div></figure><h2 id="2-2-JsonResponse对象"><a href="#2-2-JsonResponse对象" class="headerlink" title="2.2 JsonResponse对象"></a>2.2 JsonResponse对象</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;json格式的数据有什么用？前后端数据交互需要使用到json作为过渡 实现跨语言传输数据前端序列化JSON.stringify()json.dumps()JSON.parse()json.loads()&quot;&quot;&quot;import jsonfrom django.http import JsonResponsedef ab_json(request):    user_dict &#x3D; &#123;&#39;username&#39;:&#39;jason好帅哦,我好喜欢!&#39;,&#39;password&#39;:&#39;123&#39;,&#39;hobby&#39;:&#39;girl&#39;&#125;    l &#x3D; [111,222,333,444,555]    # 先转成json格式字符串    # json_str &#x3D; json.dumps(user_dict,ensure_ascii&#x3D;False)    # 将该字符串返回    # return HttpResponse(json_str)    # 读源码掌握用法    # return JsonResponse(user_dict,json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;:False&#125;)    # In order to allow non-dict objects to be serialized set the safe parameter to False.    # return JsonResponse(l,safe&#x3D;False)      # 默认只能序列化字典 序列化其他需要加safe参数</code></pre></div></figure><h2 id="2-3-form表单上传文件及后端如何操作"><a href="#2-3-form表单上传文件及后端如何操作" class="headerlink" title="2.3 form表单上传文件及后端如何操作"></a>2.3 form表单上传文件及后端如何操作</h2><p>form表单上传文件类型的数据</p><ol><li>method必须指定成post</li><li>enctype必须换成formdata</li></ol><h3 id="2-3-1-案例："><a href="#2-3-1-案例：" class="headerlink" title="2.3.1 案例："></a>2.3.1 案例：</h3><p>HTML页面代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;# 必须设置    &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;        &lt;p&gt;选择文件：&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&gt;&lt;&#x2F;p&gt;        &lt;input type&#x3D;&quot;submit&quot;&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>views.py代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse# Create your views here.def reg(request):    if request.method &#x3D;&#x3D; &quot;POST&quot;:        # print(request.POST)  # 只能获取普通的简直对数据 文件不行        print(request.FILES)        file_obj &#x3D; request.FILES.get(&#39;file&#39;)  # 文件对象        print(file_obj.name)        with open(file_obj.name, &#39;wb&#39;) as f:            for line in file_obj.chunks():  # 推荐加上chunks方法 其实跟不加是一样的都是一行行的读取                f.write(line)    return render(request, &#39;index.html&#39;)</code></pre></div></figure><p>测试：页面上传文件后，会保存到项目文件夹中</p><h2 id="2-4-request对象方法"><a href="#2-4-request对象方法" class="headerlink" title="2.4 request对象方法"></a>2.4 request对象方法</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;request.methodrequest.POSTrequest.GETrequest.FILESrequest.body  # 原生的浏览器发过来的二进制数据  后面详细的讲request.path request.path_inforequest.get_full_path()  能过获取完整的url及问号后面的参数 &quot;&quot;&quot;print(request.path)  # &#x2F;app01&#x2F;ab_file&#x2F;print(request.path_info)  # &#x2F;app01&#x2F;ab_file&#x2F;print(request.get_full_path())  # &#x2F;app01&#x2F;ab_file&#x2F;?username&#x3D;jason</code></pre></div></figure><h2 id="2-5-FBV与CBV"><a href="#2-5-FBV与CBV" class="headerlink" title="2.5 FBV与CBV"></a>2.5 FBV与CBV</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 视图函数既可以是函数也可以是类def index(request):  return HttpResponse(&#39;index&#39;)# CBV    # CBV路由    url(r&#39;^login&#x2F;&#39;,views.MyLogin.as_view())    from django.views import View    class MyLogin(View):        def get(self,request):            return render(request,&#39;form.html&#39;)        def post(self,request):            return HttpResponse(&#39;post方法&#39;)      &quot;&quot;&quot;FBV和CBV各有千秋CBV特点能够直接根据请求方式的不同直接匹配到对应的方法执行内部到底是怎么实现的？CBV内部源码(******)&quot;&quot;&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day61-Django-02</title>
    <link href="/2022/09/09/03_Python/05_Django/day61%E7%AC%94%E8%AE%B0-Django-02/"/>
    <url>/2022/09/09/03_Python/05_Django/day61%E7%AC%94%E8%AE%B0-Django-02/</url>
    
    <content type="html"><![CDATA[<p>“第61天Django-02学习笔记”</p><h1 id="一、Django-ORM创建表关系"><a href="#一、Django-ORM创建表关系" class="headerlink" title="一、Django ORM创建表关系"></a>一、Django ORM创建表关系</h1><h2 id="（TODO补完数据库回来看）"><a href="#（TODO补完数据库回来看）" class="headerlink" title="（TODO补完数据库回来看）"></a>（TODO补完数据库回来看）</h2><p>表与表之间的关系分为：</p><p>一对多、多对多、一对一、没有关系</p><p>这里用一个案例来讲解：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 案例图书表出版社表作者表作者详情表# 相互的关系图书和出版社是一对多的关系 外键字段建在多的那一方 book图书和作者是多对多的关系 需要创建第三张表来专门存储作者与作者详情表是一对一from django.db import models# Create your models here.# 创建表关系  先将基表创建出来 然后再添加外键字段class Book(models.Model):    title &#x3D; models.CharField(max_length&#x3D;32)    price &#x3D; models.DecimalField(max_digits&#x3D;8,decimal_places&#x3D;2)    # 总共八位 小数点后面占两位    &quot;&quot;&quot;    图书和出版社是一对多 并且书是多的一方 所以外键字段放在书表里面    &quot;&quot;&quot;    publish &#x3D; models.ForeignKey(to&#x3D;&#39;Publish&#39;)  # 默认就是与出版社表的主键字段做外键关联    &quot;&quot;&quot;    如果字段对应的是ForeignKey 那么会orm会自动在字段的后面加_id    如果你自作聪明的加了_id那么orm还是会在后面继续加_id        后面在定义ForeignKey的时候就不要自己加_id    &quot;&quot;&quot;    &quot;&quot;&quot;    图书和作者是多对多的关系 外键字段建在任意一方均可 但是推荐你建在查询频率较高的一方    &quot;&quot;&quot;    authors &#x3D; models.ManyToManyField(to&#x3D;&#39;Author&#39;)    &quot;&quot;&quot;    authors是一个虚拟字段 主要是用来告诉orm 书籍表和作者表是多对多关系    让orm自动帮你创建第三张关系表    &quot;&quot;&quot;class Publish(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    addr &#x3D; models.CharField(max_length&#x3D;32)class Author(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.IntegerField()    &quot;&quot;&quot;    作者与作者详情是一对一的关系 外键字段建在任意一方都可以 但是推荐你建在查询频率较高的表中    &quot;&quot;&quot;    author_detail &#x3D; models.OneToOneField(to&#x3D;&#39;AuthorDetail&#39;)    &quot;&quot;&quot;    OneToOneField也会自动给字段加_id后缀    所以你也不要自作聪明的自己加_id    &quot;&quot;&quot;class AuthorDetail(models.Model):    phone &#x3D; models.BigIntegerField()  # 或者直接字符类型    addr &#x3D; models.CharField(max_length&#x3D;32)&quot;&quot;&quot;orm中如何定义三种关系publish &#x3D; models.ForeignKey(to&#x3D;&#39;Publish&#39;)  # 默认就是与出版社表的主键字段做外键关联authors &#x3D; models.ManyToManyField(to&#x3D;&#39;Author&#39;)author_detail &#x3D; models.OneToOneField(to&#x3D;&#39;AuthorDetail&#39;)ForeignKeyOneToOneField会自动在字段后面加_id后缀&quot;&quot;&quot;# 在django1.X版本中外键默认都是级联更新删除的# 多对多的表关系可以有好几种创建方式 这里暂且先介绍一种# 针对外键字段里面的其他参数 暂时不要考虑 如果感兴趣自己可以百度试试看</code></pre></div></figure><h1 id="二、Django请求周期图"><a href="#二、Django请求周期图" class="headerlink" title="二、Django请求周期图"></a>二、Django请求周期图</h1><p><img src="/../../../img/Django%E8%AF%B7%E6%B1%82%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt="Django请求周期图"></p><h1 id="三、路由层"><a href="#三、路由层" class="headerlink" title="三、路由层"></a>三、路由层</h1><h2 id="3-1-路由匹配"><a href="#3-1-路由匹配" class="headerlink" title="3.1 路由匹配"></a>3.1 路由匹配</h2><p>我们已经在<code>urls.py</code>文件中配置过路由匹配，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">path(&#39;login&#x2F;&#39;, views.login),path(&#39;register&#x2F;&#39;, views.register),</code></pre></div></figure><p>或者是老版本Django中的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">url(r&#39;test&#39;,views.test),url(r&#39;testadd&#39;,views.testadd)</code></pre></div></figure><p>那么，思考一个问题，<code>path/url方法</code>到底是什么？</p><ul><li><p><code>url</code>是<code>Django 1.x</code>中的写法，在Django2.1中，开始舍弃Django1.x中的url写法。</p></li><li><p>在<code>Django2.x</code>中，描写url配置的有两个函数：<code>path</code>和<code>re_path</code></p></li></ul><p>re_path()函数可以看做是django 1.x中得url函数，即可以在路径中使用正则。</p><h3 id="3-1-1-案例验证路由匹配"><a href="#3-1-1-案例验证路由匹配" class="headerlink" title="3.1.1 案例验证路由匹配"></a>3.1.1 案例验证路由匹配</h3><p>我们通过一个案例来验证<code>re_path</code>的正则匹配</p><p>view.py文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse# Create your views here.def login(request):    return HttpResponse(&quot;Login&quot;)def register(request):    return HttpResponse(&quot;Register&quot;)def logins(request):    return HttpResponse(&quot;Logins&quot;)</code></pre></div></figure><p>url.py文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns &#x3D; [    re_path(r&#39;login&#39;, views.login),    re_path(r&#39;register&#x2F;&#39;, views.register),    re_path(r&#39;logins&#x2F;&#39;, views.logins)]</code></pre></div></figure><p>尝试访问<a href="http://127.0.0.1:8000/logins/%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%8D%B4%E6%98%BE%E7%A4%BA%22Login%22%E7%9A%84%E7%95%8C%E9%9D%A2">http://127.0.0.1:8000/logins/，结果却显示&quot;Login&quot;的界面</a></p><p><img src="/../../../img/image-20220913091608562.png" alt="image-20220913091608562"></p><p>说明路由匹配是有效的，只是<code>被截胡了</code>，匹配到第一条re_path，发现<code>&#39;logins&#39;</code>里面正好包含<code>‘login’</code>，所以匹配上了，不继续往下匹配。</p><p>如果需要刚好匹配上，修改正则即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urlpatterns &#x3D; [    re_path(&#39;login&#x2F;&#39;, views.login),# 可以匹配到Login    re_path(&#39;register&#x2F;&#39;, views.register),    re_path(&#39;logins&#x2F;&#39;, views.logins)# 可以匹配到Logins]</code></pre></div></figure><h3 id="3-1-2-路由匹配的"><a href="#3-1-2-路由匹配的" class="headerlink" title="3.1.2 路由匹配的&#39;/&#39;"></a>3.1.2 路由匹配的<code>&#39;/&#39;</code></h3><p>在输入url的时候，默认会加上斜杠，django内部会帮你做到重定向：</p><ul><li>第一次匹配不到</li><li>url后面加斜杠再来一次</li></ul><p>如图：</p><p><img src="/../../../img/image-20220913092547460.png" alt="image-20220913092547460"></p><p>这个是通过参数控制的，<font color=red>默认为True</font>，可以取消自动加斜杠，修改<code>setting.py</code>添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">APPEND_SLASH &#x3D; False# 默认是True，自动加斜杠的，改为False可以取消</code></pre></div></figure><p>取消后，再次访问<a href="http://127.0.0.1:8000/login%EF%BC%8C%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%A6%82%E5%9B%BE%EF%BC%9A">http://127.0.0.1:8000/login，访问失败，如图：</a></p><p><img src="/../../../img/image-20220913092804781.png" alt="image-20220913092804781"></p><h3 id="3-1-3-路由匹配的妙用"><a href="#3-1-3-路由匹配的妙用" class="headerlink" title="3.1.3 路由匹配的妙用"></a>3.1.3 路由匹配的妙用</h3><p>我们可以用正则路由匹配实现<code>首页/尾页(404页面)</code>的匹配</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Django 2.Xurlpatterns &#x3D; [    re_path(r&#39;^$&#39;, views.home),    re_path(r&#39;login&#x2F;&#39;, views.login),    re_path(r&#39;register&#x2F;&#39;, views.register),    re_path(r&#39;logins&#x2F;&#39;, views.logins),    re_path(r&#39;&#39;, views.error),]# Django 1.Xurlpatterns &#x3D; [    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),    # 首页    url(r&#39;^$&#39;,views.home),    # 路由匹配    url(r&#39;^test&#x2F;$&#39;,views.test),    url(r&#39;^testadd&#x2F;$&#39;,views.testadd),    # 尾页(了解)    url(r&#39;&#39;,views.error),]</code></pre></div></figure><p>访问首页：</p><p><img src="/../../../img/image-20220913095628939.png" alt="image-20220913095628939"></p><p>访问不存在的页面（尾页）:</p><p><img src="/../../../img/image-20220913095615244.png" alt="image-20220913095615244"></p><h2 id="3-2-无名分组-位置参数"><a href="#3-2-无名分组-位置参数" class="headerlink" title="3.2 无名分组(位置参数)"></a>3.2 无名分组(位置参数)</h2><p>什么是分组？</p><p>​就是给某一段正则表达式用小括号扩起来</p><p>什么是无名分组？</p><p>​无名分组就是将<code>括号内</code>正则表达式<code>匹配到的内容</code>当作位置<code>参数</code>传递给后面的视图函数</p><p>例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">url(r&#39;^test&#x2F;(\d+)&#x2F;&#39;,views.test)</code></pre></div></figure><p>作用是什么？—  将(\d+)正则配到的内容，当参数传给test视图函数，案例如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># urls.pyurlpatterns &#x3D; [    re_path(r&#39;^$&#39;, views.home),    re_path(r&#39;login&#x2F;(\d+)&#39;, views.login), # &quot;\d+&quot;正则表达式，匹配一个或多个数字....]# views.pydef login(request, my_num):    print(my_num)    return HttpResponse(&quot;Login&quot;)</code></pre></div></figure><p>测试：</p><p>访问<a href="http://127.0.0.1:8000/login/336688">http://127.0.0.1:8000/login/336688</a></p><p>后端输出，成功拿到参数</p><p><img src="/../../../img/image-20220913100611098.png" alt="image-20220913100611098"></p><h2 id="3-3-有名分组-关键字参数"><a href="#3-3-有名分组-关键字参数" class="headerlink" title="3.3 有名分组(关键字参数)"></a>3.3 有名分组(关键字参数)</h2><p>什么是有名分组？</p><p>​将无名分组起个名，就叫有名分组，怎么起名?</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">(?P&lt;名称&gt;正则)</code></pre></div></figure><p>案例如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># urls.pyurlpatterns &#x3D; [    re_path(r&#39;^$&#39;, views.home),    re_path(r&#39;login&#x2F;(?P&lt;good_name&gt;\d+)&#39;, views.login),]# views.pydef login(request, good_name):    print(good_name)    return HttpResponse(&quot;Login&quot;)</code></pre></div></figure><p>测试：</p><p><img src="/../../../img/image-20220913102009534.png" alt="image-20220913102009534"></p><p>后台输出，成功拿到参数：</p><p><img src="/../../../img/image-20220913102027954.png" alt="image-20220913102027954"></p><h2 id="3-4-无名有名是否可以混合使用"><a href="#3-4-无名有名是否可以混合使用" class="headerlink" title="3.4 无名有名是否可以混合使用"></a>3.4 无名有名是否可以混合使用</h2><p><strong><font color=red size=100px>不能！</font></strong></p><h2 id="3-5-反向解析（重要）"><a href="#3-5-反向解析（重要）" class="headerlink" title="3.5 反向解析（重要）"></a>3.5 反向解析（重要）</h2><p>什么是反向解析？</p><p>​通过<code>url标签</code>或是reverse()方法获取到真实的<code>url地址</code></p><p>反向解析的作用是什么（重点理解）？</p><p>对于前端而言：</p><p>​需要定义一个a标签跳转到首页，此是首页在后端的urls.py的地址为<code>index/</code></p><p>​按正常逻辑，将a标签写为<code>&lt;a href=&quot;index/&quot;&gt;点我跳转&lt;/a&gt;</code>即可</p><p>​但是，假如urls.py中对于首页的地址修改了，改成了<code>index2/</code></p><p>​那么，所有的a标签都得修改，不然，无法正常访问到页面</p><p>​此时需要反向代理，通过类似于<code>&lt;a href=&#123;% url xxx %&#125;&gt;点我跳转&lt;/a&gt;</code>的标签</p><p>​可以实现后台地址的<code>动态解析</code>, 即<code>&#123;% url xxx %&#125;</code>可以动态解析成<code>index/</code>或是<code>index2/</code></p><p>对于后端而言：</p><p>​需要render或是redirect重定向到一个页面，此时也需要写一个url地址，</p><p>​通过使用反向解析，也能动态获取url地址</p><h3 id="3-5-1-后端反向解析"><a href="#3-5-1-后端反向解析" class="headerlink" title="3.5.1 后端反向解析"></a>3.5.1 后端反向解析</h3><p>案例：访问<a href="http://127.0.0.1:8000/gogo/%E8%B7%B3%E8%BD%AC%E5%88%B0http://127.0.0.1:8000/reverse_page/">http://127.0.0.1:8000/gogo/跳转到http://127.0.0.1:8000/reverse_page/</a></p><p>先正常定义，是能正常跳转的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># urls.pyfrom django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns &#x3D; [    re_path(r&#39;reverse_page&#x2F;&#39;, views.reverse_page), # 这里的路径改了怎么办？    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),]# views.pyfrom django.shortcuts import render, HttpResponse, reverse, redirect# Create your views here.def reverse_page(request):    return HttpResponse(&quot;欢迎来到Reverse Page!&quot;)def gogo(request):    return redirect(&#39;&#x2F;reverse_page&#x2F;&#39;)</code></pre></div></figure><p>但是假如<code>url.py</code>中的路径改了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">re_path(r&#39;reverse_page&#x2F;&#39;, views.reverse_page),# 改为re_path(r&#39;reverse_page2&#x2F;&#39;, views.reverse_page),</code></pre></div></figure><p>再次访问会跳转失败，返回404找不到页面，除非把<code>views.py</code>中的路径改过来</p><p>此时就需要使用<code>反向解析</code>来处理这个问题。</p><h4 id="3-5-1-1-无参数反向解析"><a href="#3-5-1-1-无参数反向解析" class="headerlink" title="3.5.1.1 无参数反向解析"></a>3.5.1.1 无参数反向解析</h4><p>修改配置项：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># urls.pyfrom django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns &#x3D; [    # 添加反向解析名name    re_path(r&#39;reverse_page2&#x2F;&#39;, views.reverse_page, name&#x3D;&quot;reverse_name&quot;),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),]# views.pyfrom django.shortcuts import render, HttpResponse, reverse, redirect# Create your views here.def reverse_page(request):    return HttpResponse(&quot;欢迎来到Reverse Page!&quot;)# 使用reverse()方法反向解析，传入在urls.py定义的namedef gogo(request):    url &#x3D; reverse(&#39;reverse_name&#39;)    return redirect(url)</code></pre></div></figure><p>此时再去测试访问<a href="http://127.0.0.1:8000/gogo/">http://127.0.0.1:8000/gogo/</a></p><p>无论<code>urls.py</code>中的路径怎么变，都能正常跳转</p><p>测试改成<code>reverse_page3/</code></p><p><img src="/../../../img/image-20220913173352149.png" alt="image-20220913173352149"></p><p>再测试改成<code>xxxx/</code></p><p><img src="/../../../img/image-20220913173442275.png" alt="image-20220913173442275"></p><h4 id="3-5-1-2-带参数（有分组）的反向解析"><a href="#3-5-1-2-带参数（有分组）的反向解析" class="headerlink" title="3.5.1.2 带参数（有分组）的反向解析"></a>3.5.1.2 带参数（有分组）的反向解析</h4><p>如果我们需要跳转的页面是带参数的怎么办？</p><p>比如<a href="http://127.0.0.1:8000/gogo/%E8%A6%81%E8%B7%B3%E8%BD%AC%E5%88%B0http://127.0.0.1:8000/reverse_page/33/44">http://127.0.0.1:8000/gogo/要跳转到http://127.0.0.1:8000/reverse_page/33/44</a></p><h5 id="对于位置参数（无名分组）："><a href="#对于位置参数（无名分组）：" class="headerlink" title="对于位置参数（无名分组）："></a>对于位置参数（无名分组）：</h5><p><code>urls.py</code>配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns &#x3D; [    # 添加【位置参数】和【反向解析名】    re_path(r&#39;xxxx&#x2F;(\d+)&#x2F;(\d+)&#39;, views.reverse_page, name&#x3D;&quot;reverse_name&quot;),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),]</code></pre></div></figure><p><code>views.py</code>配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse, reverse, redirect# Create your views here.def reverse_page(request, arg1, arg2):    return HttpResponse(&quot;&lt;p&gt;欢迎来到Reverse Page!&lt;&#x2F;p&gt;传来的参数是&quot; + &quot;: &quot; + arg1 + &quot; 和 &quot; + arg2)def gogo(request):    # 反向解析处理    url &#x3D; reverse(&#39;reverse_name&#39;, args&#x3D;(11, 22))    return redirect(url)</code></pre></div></figure><p>测试访问<a href="http://127.0.0.1:8000/gogo/%EF%BC%9A">http://127.0.0.1:8000/gogo/：</a></p><p><img src="/../../../img/image-20220913174704450.png" alt="image-20220913174704450"></p><h5 id="对于关键字参数（有名分组）："><a href="#对于关键字参数（有名分组）：" class="headerlink" title="对于关键字参数（有名分组）："></a>对于关键字参数（有名分组）：</h5><p><code>urls.py</code>配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns &#x3D; [    # 添加【关键字参数】和【反向解析名】    re_path(r&#39;xxxx&#x2F;(?P&lt;arg1&gt;\d+)&#x2F;(?P&lt;arg2&gt;\d+)&#39;, views.reverse_page, name&#x3D;&quot;reverse_name&quot;),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),]</code></pre></div></figure><p><code>views.py</code>的配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse, reverse, redirect# Create your views here.def reverse_page(request, arg1, arg2):    return HttpResponse(&quot;&lt;p&gt;欢迎来到Reverse Page!&lt;&#x2F;p&gt;传来的参数是&quot; + &quot;: &quot; + arg1 + &quot; 和 &quot; + arg2)def gogo(request):    # 反向解析处理    url &#x3D; reverse(&#39;reverse_name&#39;, kwargs&#x3D;&#123;&#39;arg1&#39;: 33, &#39;arg2&#39;: 44&#125;)    return redirect(url)</code></pre></div></figure><p>测试访问<a href="http://127.0.0.1:8000/gogo/%EF%BC%9A">http://127.0.0.1:8000/gogo/：</a></p><p><img src="/../../../img/image-20220913175015732.png" alt="image-20220913175015732"></p><h3 id="3-6-1-前端反向解析"><a href="#3-6-1-前端反向解析" class="headerlink" title="3.6.1 前端反向解析"></a>3.6.1 前端反向解析</h3><p>案例：前端点击login页面中的<code>a标签</code>，要跳转到<a href="http://127.0.0.1:8000/reverse_page/">http://127.0.0.1:8000/reverse_page/</a></p><p>按普通的写法：</p><p>url.py定义路由</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urlpatterns &#x3D; [    re_path(r&#39;reverse_page&#x2F;&#39;, views.reverse_page),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),    re_path(r&#39;login&#x2F;&#39;, views.login),]</code></pre></div></figure><p>views.py定义视图</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Create your views here.def reverse_page(request):    return HttpResponse(&quot;&lt;p&gt;欢迎来到Reverse Page!&quot;)# 定义Login页面标签a标签def login(request):    return render(request, &#39;login.html&#39;)</code></pre></div></figure><p>login.html 页面代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;Login页面&lt;&#x2F;h1&gt;&lt;a href&#x3D;&quot;&#x2F;reverse_page&quot;&gt;不要点我&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>测试，访问Login页面，点击a标签</p><p><img src="/../../../img/image-20220913181151310.png" alt="image-20220913181151310"></p><p>成功跳转</p><p><img src="/../../../img/image-20220913181209249.png" alt="image-20220913181209249"></p><p>修改<code>urls.py</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urlpatterns &#x3D; [    # re_path(r&#39;reverse_page&#x2F;&#39;, views.reverse_page), 修改为    re_path(r&#39;reverse_page2&#x2F;&#39;, views.reverse_page),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),    re_path(r&#39;login&#x2F;&#39;, views.login),]</code></pre></div></figure><p>再次操作，访问失败，404页面</p><p><img src="/../../../img/image-20220913181339813.png" alt="image-20220913181339813"></p><p>那么，也要通过反向解析来解决问题。</p><h4 id="3-6-1-1-无参数反向解析"><a href="#3-6-1-1-无参数反向解析" class="headerlink" title="3.6.1.1 无参数反向解析"></a>3.6.1.1 无参数反向解析</h4><p>修改<code>urls.py</code>添加反向解析名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urlpatterns &#x3D; [    # 加个反向解析name    re_path(r&#39;reverse_page2&#x2F;&#39;, views.reverse_page, name&#x3D;&quot;reverse_name&quot;),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),    re_path(r&#39;login&#x2F;&#39;, views.login),]</code></pre></div></figure><p>修改<code>login.html</code>代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;Login页面&lt;&#x2F;h1&gt;# 使用反向解析&lt;a href&#x3D;&#123;% url &#39;reverse_name&#39; %&#125;&gt;不要点我&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>将<code>url改为reverse2/</code>测试访问：</p><p><img src="/../../../img/image-20220913182018078.png" alt="image-20220913182018078"></p><p>将<code>url改为xxxxx/</code>测试访问：</p><p><img src="/../../../img/image-20220913182117945.png" alt="image-20220913182117945"></p><h4 id="3-6-1-2-带参数（有分组）的反向解析"><a href="#3-6-1-2-带参数（有分组）的反向解析" class="headerlink" title="3.6.1.2 带参数（有分组）的反向解析"></a>3.6.1.2 带参数（有分组）的反向解析</h4><p>案例：前端点击login页面中的<code>a标签</code>，要跳转到<a href="http://127.0.0.1:8000/reverse_page/111/222">http://127.0.0.1:8000/reverse_page/111/222</a></p><h5 id="对于位置参数（无名分组）"><a href="#对于位置参数（无名分组）" class="headerlink" title="对于位置参数（无名分组）"></a>对于位置参数（无名分组）</h5><p><code>urls.py</code>修改：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urlpatterns &#x3D; [    re_path(r&#39;xxxx&#x2F;(\d+)&#x2F;(\d+)&#39;, views.reverse_page, name&#x3D;&quot;reverse_name&quot;),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),    re_path(r&#39;login&#x2F;&#39;, views.login),]</code></pre></div></figure><p><code>login.html</code>修改:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;Login页面&lt;&#x2F;h1&gt;&lt;a href&#x3D;&#123;% url &#39;reverse_name&#39; 111 222 %&#125;&gt;不要点我&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p><code>views.py</code>修改：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def reverse_page(request, arg1, arg2):    return HttpResponse(&quot;&lt;p&gt;欢迎来到Reverse Page!&lt;&#x2F;p&gt;传来的参数是&quot; + &quot;: &quot; + arg1 + &quot; 和 &quot; + arg2)</code></pre></div></figure><p>测试显示解析成功：</p><p><img src="/../../../img/image-20220913182556935.png" alt="image-20220913182556935"></p><h5 id="对于关键字参数（有名分组）"><a href="#对于关键字参数（有名分组）" class="headerlink" title="对于关键字参数（有名分组）"></a>对于关键字参数（有名分组）</h5><p><code>urls.py</code>修改：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urlpatterns &#x3D; [    # 定义关键字参数    re_path(r&#39;reverse_page&#x2F;(?P&lt;arg1&gt;\d+)&#x2F;(?P&lt;arg2&gt;\d+)&#39;, views.reverse_page, name&#x3D;&quot;reverse_name&quot;),    re_path(r&#39;gogo&#x2F;&#39;, views.gogo),    re_path(r&#39;login&#x2F;&#39;, views.login),]</code></pre></div></figure><p><code>login.html</code>修改:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;Login页面&lt;&#x2F;h1&gt;# 传入参数&lt;a href&#x3D;&#123;% url &#39;reverse_name&#39; arg1&#x3D;111 arg2&#x3D;222 %&#125;&gt;不要点我&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>测试显示解析成功：</p><p><img src="/../../../img/image-20220913182934560.png" alt="image-20220913182934560"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day60-Django-01</title>
    <link href="/2022/09/02/03_Python/05_Django/day60%E7%AC%94%E8%AE%B0-Django-01/"/>
    <url>/2022/09/02/03_Python/05_Django/day60%E7%AC%94%E8%AE%B0-Django-01/</url>
    
    <content type="html"><![CDATA[<p>“第60天Django-01学习笔记”</p><h1 id="1-静态文件配置"><a href="#1-静态文件配置" class="headerlink" title="1 静态文件配置"></a>1 静态文件配置</h1><h2 id="1-1-静态文件介绍"><a href="#1-1-静态文件介绍" class="headerlink" title="1.1 静态文件介绍"></a>1.1 静态文件介绍</h2><p>什么是静态文件？</p><p>​前端已经写好了的 能够直接调用使用的文件，如</p><ul><li>网站写好的js文件</li><li>网站写好的css文件</li><li>网站用到的图片文件</li><li>第三方前端框架</li></ul><p>我们将网站使用的所有<code>静态文件</code>默认都放在<code>static</code>文件夹中</p><p><font color=red><strong>static文件夹默认没有，需要手动创建</strong></font></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">一般情况下我们在static文件夹内还会做进一步的划分处理-static  --js    --css    --img    其他第三方文件    &quot;&quot;&quot;在浏览器中输入url能够看到对应的资源是因为后端提前开设了该资源的接口如果访问不到资源 说明后端没有开设该资源的接口http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;static&#x2F;bootstrap-3.3.7-dist&#x2F;css&#x2F;bootstrap.min.css&quot;&quot;&quot;</code></pre></div></figure><h2 id="1-2-静态文件配置"><a href="#1-2-静态文件配置" class="headerlink" title="1.2 静态文件配置"></a>1.2 静态文件配置</h2><h3 id="1-2-1-回顾创建一个普通Django项目"><a href="#1-2-1-回顾创建一个普通Django项目" class="headerlink" title="1.2.1 回顾创建一个普通Django项目"></a>1.2.1 回顾创建一个普通Django项目</h3><p>如何在Django项目中设置静态文件？</p><p>我们先创建一个普通的Django项目</p><p>1、先在Pycharm创建Django项目-<code>day60_Django02</code></p><p>2、打开terminal窗口，创建app01</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python manage.py startapp app01</code></pre></div></figure><p>3、注册app01应用</p><p>编辑setting.py文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">INSTALLED_APPS &#x3D; [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    # 注册应用    &#39;app01&#39;,]</code></pre></div></figure><p>4、配置<code>urls.py</code>文件和<code>app01/views.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import pathfrom app01 import viewsurlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    path(&#39;login&#x2F;&#39;, views.login),]</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01&#x2F;views.py内容from django.shortcuts import render# Create your views here.def login(request):    return render(request, &#39;test.html&#39;)</code></pre></div></figure><p>5、创建HTML文件<code>templates/test.html</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;这是测试文件&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>6、运行项目</p><p>访问<code>http://127.0.0.1:8000/login</code>可见到<code>test.html</code>页面的内容</p><h3 id="1-2-2-静态文件配置与动态解析"><a href="#1-2-2-静态文件配置与动态解析" class="headerlink" title="1.2.2 静态文件配置与动态解析"></a>1.2.2 静态文件配置与动态解析</h3><p>使用静态文件需要先创建<code>static</code>文件夹，并将静态文件都放到里面</p><p>1、创建<code>src01</code>文件夹，把下载并解压的<code>bootstrap-5.2.0-dist</code>文件夹放进去</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls static&#x2F;src01&#x2F;bootstrap-5.2.0-dist</code></pre></div></figure><p>2、设置静态文件的<code>访问路径</code>和<code>存储路径</code></p><p>编辑settings.py文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置静态文件的访问路径STATIC_URL &#x3D; &#39;&#x2F;bbc&#x2F;&#39;# 配置静态文件的存储路径，会在三个文件夹依次寻找STATICFILES_DIRS &#x3D; [    os.path.join(BASE_DIR, &#39;src01&#39;),    os.path.join(BASE_DIR, &#39;src02&#39;),    os.path.join(BASE_DIR, &#39;src03&#39;),]</code></pre></div></figure><p>3、静态文件动态解析</p><p>给html文件添加动态解析代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;这是测试文件&lt;&#x2F;h1&gt;    &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;Primary&lt;&#x2F;button&gt;    &#123;% load static %&#125;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#123;% static &#39;bootstrap-5.2.0-dist&#x2F;css&#x2F;bootstrap.min.css&#39; %&#125;&quot;&gt;    &lt;script src&#x3D;&quot;&#123;% static &#39;bootstrap-5.2.0-dist&#x2F;js&#x2F;bootstrap.min.js&#39; %&#125;&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><blockquote><p>PS: 为什么需要动态解析？</p><p>如果我们直接写路径，例如</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&gt;&lt;link href&#x3D;&quot;&#x2F;static&#x2F;a.txt&quot;&gt;</code></pre></div></figure><p>一旦<code>令牌名称改了</code>，那么这个<code>资源将访问不到</code>，尤其是link很多的时候，改起来比较麻烦</p></blockquote><p>4、查看效果</p><p>可见Bootstrap已生效</p><p><img src="/../../../img/image-20220905185920419.png" alt="image-20220905185920419"></p><h3 id="1-3-访问路径和存储路径"><a href="#1-3-访问路径和存储路径" class="headerlink" title="1.3 访问路径和存储路径"></a>1.3 访问路径和存储路径</h3><p>有个容易迷惑的问题，什么是访问路径？什么又是存储路径？</p><p><strong>访问路径（令牌）</strong>：</p><p>​通过浏览器访问静态文件的路径，如图：</p><p><img src="/../../../img/image-20220905190223177.png" alt="image-20220905190223177"></p><p><strong>存储路径（实际存储）：</strong></p><p>​静态文件实际存放的路径，如图：</p><p><img src="/../../../img/image-20220905190333652.png" alt="image-20220905190333652"></p><h1 id="2-request对象方法认识"><a href="#2-request对象方法认识" class="headerlink" title="2 request对象方法认识"></a>2 request对象方法认识</h1><p>将第一章中的<code>test.html</code>修改为一个form表单页面</p><blockquote><p>如需获取数据，需要<code>name</code>属性</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1 class&#x3D;&quot;text-center&quot;&gt;欢迎来到的德莱联盟，请注册！&lt;&#x2F;h1&gt;    &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt;        &lt;div class&#x3D;&quot;container&quot;&gt;            &lt;div class&#x3D;&quot;row&quot;&gt;                &lt;div class&#x3D;&quot;col-md-8 offset-md-2&quot;&gt;                    &lt;div&gt;用户名                        &lt;input  class&#x3D;&quot;form-control&quot; name&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot;&gt;                    &lt;&#x2F;div&gt;                    &lt;div&gt;密码                        &lt;input  class&#x3D;&quot;form-control&quot; name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot;&gt;                    &lt;&#x2F;div&gt;                    &lt;div&gt;性别                        &lt;select name&#x3D;&quot;gender&quot;&gt;                            &lt;option value&#x3D;&quot;1&quot;&gt;男&lt;&#x2F;option&gt;                            &lt;option value&#x3D;&quot;0&quot;&gt;女&lt;&#x2F;option&gt;                        &lt;&#x2F;select&gt;                    &lt;&#x2F;div&gt;                    &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary form-control&quot; value&#x3D;&quot;注册&quot;&gt;                 &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;form&gt;    &#123;% load static %&#125;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#123;% static &#39;bootstrap-5.2.0-dist&#x2F;css&#x2F;bootstrap.min.css&#39; %&#125;&quot;&gt;    &lt;script src&#x3D;&quot;&#123;% static &#39;bootstrap-5.2.0-dist&#x2F;js&#x2F;bootstrap.min.js&#39; %&#125;&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>界面效果如下：</p><p><img src="/../../../img/image-20220905200230475.png" alt="image-20220905200230475"></p><h2 id="2-1-GET和POST的区别"><a href="#2-1-GET和POST的区别" class="headerlink" title="2.1 GET和POST的区别"></a>2.1 GET和POST的区别</h2><p>Form表单主要有两个参数，<code>action</code>和<code>method</code></p><p>action参数：</p><p>​1.不写 默认朝当前所在的url提交数据</p><p>​2.全写 指名道姓</p><p>​3.只写后缀 &#x2F;login&#x2F;</p><p>method参数：</p><p>​1、get</p><p>​2、post</p><p>本节主要介绍<code>GET</code>和<code>POST</code>的区别：</p><p>设置GET跟POST是通过html代码中的<code>method</code>指定，如:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;GET&quot;&gt;...&lt;&#x2F;form&gt;</code></pre></div></figure><h3 id="2-1-1-GET"><a href="#2-1-1-GET" class="headerlink" title="2.1.1 GET"></a>2.1.1 GET</h3><p>GET请求会在submit时，明文传递数据，浏览器上会显示，如图</p><p><img src="/../../../img/image-20220905222449310.png" alt="image-20220905222449310"></p><h3 id="2-1-2-POST"><a href="#2-1-2-POST" class="headerlink" title="2.1.2 POST"></a>2.1.2 POST</h3><p>而POST请求在submit的时候，传递的是密文数据，浏览器上不会显示，如图</p><p><img src="/../../../img/image-20220905223427713.png" alt="image-20220905223427713"></p><p><font color=red>注意：</font></p><p>在前期我们使用django提交post请求的时候 需要取配置文件中注释掉一行代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">MIDDLEWARE &#x3D; [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre></div></figure><p>否则，submit提交后会出现<code>403</code>界面</p><p><img src="/../../../img/image-20220905203914884.png" alt="image-20220905203914884"></p><p>具体报错信息是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Quit the server with CTRL-BREAK.[05&#x2F;Sep&#x2F;2022 20:37:32] &quot;GET &#x2F;login&#x2F;? HTTP&#x2F;1.1&quot; 200 1175Forbidden (CSRF cookie not set.): &#x2F;login&#x2F;[05&#x2F;Sep&#x2F;2022 20:37:35] &quot;POST &#x2F;login&#x2F;? HTTP&#x2F;1.1&quot; 403 2870</code></pre></div></figure><h3 id="2-1-3-通过request获取请求信息"><a href="#2-1-3-通过request获取请求信息" class="headerlink" title="2.1.3 通过request获取请求信息"></a>2.1.3 通过request获取请求信息</h3><p>可以获取如下信息:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">request.method # 返回请求方式 并且是全大写的字符串形式  &lt;class &#39;str&#39;&gt;request.POST  # 获取用户post请求提交的普通数据不包含文件request.POST.get()  # 只获取列表最后一个元素  request.POST.getlist()  # 直接将列表取出request.GET  # 获取用户提交的get请求数据request.GET.get()  # 只获取列表最后一个元素  request.GET.getlist()  # 直接将列表取出&quot;&quot;&quot;get请求携带的数据是有大小限制的 大概好像只有4KB左右而post请求则没有限制&quot;&quot;&quot;</code></pre></div></figure><p>使用方法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01&#x2F;views.py文件from django.shortcuts import render# Create your views here.def login(request):    print(request.POST)    return render(request, &#39;test.html&#39;)# 显示&lt;QueryDict: &#123;&#39;username&#39;: [&#39;test&#39;], &#39;password&#39;: [&#39;qwer123&#39;], &#39;gender&#39;: [&#39;1&#39;]&#125;&gt;</code></pre></div></figure><p>也可以用于GET和POST的判断：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def login(request):    # 返回一个登陆界面    &quot;&quot;&quot;    get请求和post请求应该有不同的处理机制    :param request: 请求相关的数据对象 里面有很多简易的方法    :return:    &quot;&quot;&quot;    # print(type(request.method))  # 返回请求方式 并且是全大写的字符串形式  &lt;class &#39;str&#39;&gt;    # if request.method &#x3D;&#x3D; &#39;GET&#39;:    #     print(&#39;来了 老弟&#39;)    #     return render(request,&#39;login.html&#39;)    # elif request.method &#x3D;&#x3D; &#39;POST&#39;:    #     return HttpResponse(&quot;收到了 宝贝&quot;)        if request.method &#x3D;&#x3D; &#39;POST&#39;:        return HttpResponse(&quot;收到了 宝贝&quot;)    return render(request, &#39;login.html&#39;)</code></pre></div></figure><h1 id="3-Pycharm和Django连接MySQL的方法"><a href="#3-Pycharm和Django连接MySQL的方法" class="headerlink" title="3 Pycharm和Django连接MySQL的方法"></a>3 Pycharm和Django连接MySQL的方法</h1><h2 id="3-1-Pycharm连接MySQL"><a href="#3-1-Pycharm连接MySQL" class="headerlink" title="3.1 Pycharm连接MySQL"></a>3.1 Pycharm连接MySQL</h2><p>有三个地方可以找到设置入口：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1、右侧上方database2、左下方database3、配置里面的plugins插件搜索安装</code></pre></div></figure><p>右上角的设置方式，如图</p><p><img src="/../../../img/image-20220906084608205.png" alt="image-20220906084608205"></p><p>设置完用户名、密码等信息，连接上之后需要<code>安装驱动</code>，之后可以使用语句操作数据库。</p><p><img src="/../../../img/image-20220906090938359.png" alt="image-20220906090938359"></p><h2 id="3-2-Django连接MySQL"><a href="#3-2-Django连接MySQL" class="headerlink" title="3.2 Django连接MySQL"></a>3.2 Django连接MySQL</h2><p>1、Django默认用的是sqlite3数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">DATABASES &#x3D; &#123;    &#39;default&#39;: &#123;        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;NAME&#39;: BASE_DIR &#x2F; &#39;db.sqlite3&#39;,    &#125;&#125;</code></pre></div></figure><p>2、需要在<code>settings.py</code>文件中修改为mysql，比如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">DATABASES &#x3D; &#123;    &#39;default&#39;: &#123;        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;NAME&#39;: &#39;test&#39;, # 数据库的名称        &#39;USER&#39;: &#39;root&#39;,        &#39;PASSWORD&#39;: &#39;&#39;,        &#39;HOST&#39;: &#39;127.0.0.1&#39;,        &#39;PORT&#39;: 3306,        &#39;CHARSET&#39;: &#39;utf8&#39;    &#125;&#125;</code></pre></div></figure><p>3、使用pymysql连接数据库</p><p>django默认用的是mysqldb模块链接MySQL，但是该模块的兼容性不好，</p><p>需要手动改为用pymysql链接</p><p>修改<code>init.py</code>文件（在项目名下的init或者任意的应用名下的init文件中书写以下代码都可以）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymysqlpymysql.install_as_MySQLdb()</code></pre></div></figure><h1 id="4-Django-ORM"><a href="#4-Django-ORM" class="headerlink" title="4 Django ORM"></a>4 Django ORM</h1><h2 id="4-1-什么是ORM？"><a href="#4-1-什么是ORM？" class="headerlink" title="4.1 什么是ORM？"></a>4.1 什么是ORM？</h2><p>ORM称为”关系对象映射”</p><p><strong>作用：</strong></p><p>能够让一个不用sql语句的小白也能够通过python 面向对象的代码简单快捷的操作数据库</p><p><strong>不足之处：</strong></p><p>封装程度太高 有时候sql语句的效率偏低 需要你自己写SQL语句</p><h2 id="4-2-创建表"><a href="#4-2-创建表" class="headerlink" title="4.2 创建表"></a>4.2 创建表</h2><p>1、编辑<code>models.py</code>文件，创建一个表(table)</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models# Create your models here.class User(models.Model):    # id int primary_key auto_increment    id &#x3D; models.AutoField(primary_key&#x3D;True)    # username vachar(32)    username &#x3D; models.CharField(max_length&#x3D;32)    # password int    password &#x3D; models.IntegerField()</code></pre></div></figure><p>2、同步数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将操作记录记录到小本本上(migrations文件夹)python3 manage.py makemigrations # 将操作真正的同步到数据库中python3 manage.py migrate  ******************************************************************# 只要你修改了models.py中跟数据库相关的代码 就必须重新执行上述的两条命令 #******************************************************************</code></pre></div></figure><p>3、后续新建表也是一样的，继续往下写class即可</p><h2 id="4-3-字段的增删改"><a href="#4-3-字段的增删改" class="headerlink" title="4.3 字段的增删改"></a>4.3 字段的增删改</h2><p><strong>1、增：</strong></p><p>修改<code>models.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models# Create your models here.class User(models.Model):    # id int primary_key auto_increment    id &#x3D; models.AutoField(primary_key&#x3D;True)    # username vachar(32)    username &#x3D; models.CharField(max_length&#x3D;32)    # password int    password &#x3D; models.IntegerField()    # info    info &#x3D; models.CharField(max_length&#x3D;100, verbose_name&#x3D;&#39;个人简介&#39;, null&#x3D;True)    # hobby    hobby &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&#39;兴趣爱好&#39;, default&#x3D;&#39;study&#39;)</code></pre></div></figure><p>添加info、hobby两个字段，然后同步数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 manage.py makemigrationspython3 manage.py migrate </code></pre></div></figure><p>同步之后查看，（增）成功</p><p><img src="/../../../img/image-20220906094750474.png" alt="image-20220906094750474"></p><p><strong>2、删</strong></p><p>删除对应的字段，再保存同步即可，如删除password字段</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models# Create your models here.class User(models.Model):    # id int primary_key auto_increment    id &#x3D; models.AutoField(primary_key&#x3D;True)    # username vachar(32)    username &#x3D; models.CharField(max_length&#x3D;32)    # info    info &#x3D; models.CharField(max_length&#x3D;100, verbose_name&#x3D;&#39;个人简介&#39;, null&#x3D;True)    # hobby    hobby &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&#39;兴趣爱好&#39;, default&#x3D;&#39;study&#39;)</code></pre></div></figure><p>同步后，（删）成功</p><p><img src="/../../../img/image-20220906095025980.png" alt="image-20220906095025980"></p><p><strong>3、改</strong></p><p>修改字段信息，再保存同步数据库即可</p><blockquote><p><font color=red><strong>注意</strong></font></p><p>执行完毕之后字段对应的数据也都没有了</p></blockquote><h2 id="4-4-数据的增查-案例"><a href="#4-4-数据的增查-案例" class="headerlink" title="4.4 数据的增查-案例"></a>4.4 数据的增查-案例</h2><p>我们通过注册&#x2F;登录页面的案例，来学习<code>Django ORM</code>数据的增删改查</p><blockquote><p>案例前提：</p><p>先完成3.2连接MYSQL数据库的操作</p></blockquote><h3 id="4-4-1-案例思路"><a href="#4-4-1-案例思路" class="headerlink" title="4.4.1 案例思路"></a>4.4.1 案例思路</h3><p>基本思路：</p><p>​注册页面：</p><p>​提交注册信息，写入到数据库（增数据）</p><p>​登录页面：</p><p>​提交用户名和密码</p><p>​查询数据库，验证用户名密码是否匹配（查数据）</p><p>​匹配成功返回“登录成功”，否则返回“登录失败”</p><h3 id="4-4-2-页面编写"><a href="#4-4-2-页面编写" class="headerlink" title="4.4.2 页面编写"></a>4.4.2 页面编写</h3><p>创建登录页面<code>template/login.html</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;登录页面&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;登录页面&lt;&#x2F;h1&gt;    &lt;div&gt;        &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt;            &lt;div&gt;username：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;&lt;&#x2F;div&gt;            &lt;div&gt;password：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt;&lt;&#x2F;div&gt;            &lt;div&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;div&gt;        &lt;&#x2F;form&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>创建注册页面<code>template/register.html</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;注册页面&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;注册页面&lt;&#x2F;h1&gt;    &lt;div&gt;        &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt;            &lt;div&gt;username：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;&lt;&#x2F;div&gt;            &lt;div&gt;password：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt;&lt;&#x2F;div&gt;            &lt;div&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;div&gt;        &lt;&#x2F;form&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>4.4.2 </p><h3 id="4-4-3-创建数据表"><a href="#4-4-3-创建数据表" class="headerlink" title="4.4.3 创建数据表"></a>4.4.3 创建数据表</h3><p>编辑<code>models.py</code>文件，并同步数据库</p><blockquote><p>这一步要谨慎</p><p>记住：<strong>迁移文件、数据库中的表以及迁移信息的记录</strong>这三方删除的时候缺一不可，缺少任何一方都会报错。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models# Create your models here.class MyUser(models.Model):    id &#x3D; models.AutoField(primary_key&#x3D;True, verbose_name&#x3D;&#39;主键&#39;)    username &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&#39;用户名&#39;)    password &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&#39;密码&#39;)</code></pre></div></figure><h3 id="4-4-5-设置urls"><a href="#4-4-5-设置urls" class="headerlink" title="4.4.5 设置urls"></a>4.4.5 设置urls</h3><p><code>urls.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import pathfrom app01 import viewsurlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    path(&#39;login&#x2F;&#39;, views.login),    path(&#39;register&#x2F;&#39;, views.register),]</code></pre></div></figure><h3 id="4-4-6-设置app的views"><a href="#4-4-6-设置app的views" class="headerlink" title="4.4.6 设置app的views"></a>4.4.6 设置app的views</h3><p>编辑<code>app01/views.py</code>，完成注册登录的逻辑判断</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse# Create your views here.def login(request):    if request.method &#x3D;&#x3D; &quot;POST&quot;:        # 获取网页submit的数据        username &#x3D; request.POST.get(&#39;username&#39;)        password &#x3D; request.POST.get(&#39;password&#39;)        # 去数据库查询数据        from app01 import models        user_obj &#x3D; models.MyUser.objects.filter(username&#x3D;username).first()        # 如果获取成功        if user_obj:            # 对比密码            if password &#x3D;&#x3D; user_obj.password:                return HttpResponse(&quot;登录成功&quot;)            else:                return HttpResponse(&quot;登录失败&quot;)        else:            return HttpResponse(&quot;用户不存在&quot;)    # 给用户返回一个登录页面    return render(request, &#39;login.html&#39;)def register(request):    if request.method &#x3D;&#x3D; &quot;POST&quot;:        # 获取网页submit的数据        username &#x3D; request.POST.get(&#39;username&#39;)        password &#x3D; request.POST.get(&#39;password&#39;)        # 第一种增加方式        from app01 import models        res &#x3D; models.MyUser.objects.create(username&#x3D;username, password&#x3D;password)        # 返回值就是创建的对象本身        print(res, res.username, res.password)        # 第二种增加方式        # user_obj &#x3D; models.MyUser(username&#x3D;username, password&#x3D;password)        # user_obj.save()    # 给用户返回一个注册页面    return render(request, &quot;register.html&quot;)</code></pre></div></figure><h3 id="4-4-7-测试"><a href="#4-4-7-测试" class="headerlink" title="4.4.7 测试"></a>4.4.7 测试</h3><p>注册：</p><p><img src="/../../../img/image-20220906112347490.png" alt="image-20220906112347490"></p><p>注册成功：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_myuser;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | test     | test123  ||  2 | goosh    | admin123 |+----+----------+----------+2 rows in set (0.00 sec)</code></pre></div></figure><p>登录：</p><p><img src="/../../../img/image-20220906112452782.png" alt="image-20220906112452782"></p><p>输错密码：</p><p><img src="/../../../img/image-20220906112506512.png" alt="image-20220906112506512"></p><p>案例完成。</p><h2 id="4-5-数据的删改查-案例"><a href="#4-5-数据的删改查-案例" class="headerlink" title="4.5 数据的删改查-案例"></a>4.5 数据的删改查-案例</h2><p>本案例流程：</p><ul><li>将数据库中的数据展示到前端【查】</li><li>每个数据有两个按钮（编辑、删除）</li><li>编辑可以【改】数据</li><li>删除可以【删】数据</li></ul><h3 id="4-5-1-项目创建"><a href="#4-5-1-项目创建" class="headerlink" title="4.5.1 项目创建"></a>4.5.1 项目创建</h3><p>1、PyCharm创建Django项目</p><p>2、输入命令创建app01</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python.exe .\manage.py startapp app01</code></pre></div></figure><h3 id="4-5-2-数据库配置"><a href="#4-5-2-数据库配置" class="headerlink" title="4.5.2 数据库配置"></a>4.5.2 数据库配置</h3><p>1、配置app01项目、连接数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># setting.py文件INSTALLED_APPS &#x3D; [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;app01&#39;,]DATABASES &#x3D; &#123;    &#39;default&#39;: &#123;        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;NAME&#39;: &#39;day61&#39;,        &#39;USER&#39;: &#39;root&#39;,        &#39;PASSWORD&#39;: &#39;&#39;,        &#39;HOST&#39;: &#39;127.0.0.1&#39;,        &#39;PORT&#39;: 3306,        &#39;CHARSET&#39;: &#39;utf8&#39;,    &#125;&#125;# 注释CSRF(post提交需要)MIDDLEWARE &#x3D; [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    #&#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre></div></figure><p>2、编辑<code>init.py</code>使用上pymysql</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymysqlpymysql.install_as_MySQLdb()</code></pre></div></figure><p>3、ORM创建数据库</p><p>编辑<code>models.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models# Create your models here.class User(models.Model):    id &#x3D; models.AutoField(primary_key&#x3D;True, verbose_name&#x3D;&quot;主键&quot;)    name &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;姓名&quot;)    age &#x3D; models.IntegerField(verbose_name&#x3D;&quot;年龄&quot;)    sex &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;性别&quot;)</code></pre></div></figure><p>同步到数据库，完成创建数据库的操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python.exe .\manage.py makemigrationspython.exe .\manage.py migrate </code></pre></div></figure><p>可见数据库中增加了app01_user表</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; use day61;Database changedmysql&gt; show tables;+----------------------------+| Tables_in_day61            |+----------------------------+| app01_user                 || auth_group                 |....</code></pre></div></figure><p>4、往数据库中添加数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; insert into app01_user values (1, &#39;小姐姐&#39;, 20, &#39;女&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into app01_user values (2, &#39;大哥哥&#39;, 30, &#39;男&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into app01_user values (3, &#39;老爷爷&#39;, 80, &#39;男&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into app01_user values (4, &#39;老奶奶&#39;, 90, &#39;女&#39;);Query OK, 1 row affected (0.00 sec)</code></pre></div></figure><p>查询数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from app01_user;+----+--------+-----+-----+| id | name   | age | sex |+----+--------+-----+-----+|  1 | 小姐姐 |  20 | 女  ||  2 | 大哥哥 |  30 | 男  ||  3 | 老爷爷 |  80 | 男  ||  4 | 老奶奶 |  90 | 女  |+----+--------+-----+-----+4 rows in set (0.00 sec)</code></pre></div></figure><h3 id="4-5-3-配置路由匹配（Urls）"><a href="#4-5-3-配置路由匹配（Urls）" class="headerlink" title="4.5.3 配置路由匹配（Urls）"></a>4.5.3 配置路由匹配（Urls）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import pathfrom app01 import viewsurlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    path(&#39;index&#x2F;&#39;, views.index),    path(&#39;edit_user&#x2F;&#39;, views.edit_user),    path(&#39;delete_user&#x2F;&#39;, views.delete_user),]</code></pre></div></figure><h3 id="4-5-4-创建HTML页面"><a href="#4-5-4-创建HTML页面" class="headerlink" title="4.5.4 创建HTML页面"></a>4.5.4 创建HTML页面</h3><p>创建<code>edit_user.html</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1 class&#x3D;&quot;text-center&quot;&gt;编辑&lt;&#x2F;h1&gt;&lt;div class&#x3D;&quot;container&quot;&gt;    &lt;div class&#x3D;&quot;row&quot;&gt;        &lt;div class&#x3D;&quot;col-md-8 col-md-offset-2&quot;&gt;            &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt;                &lt;p&gt;姓名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;&#123;&#123; edit_obj.name &#125;&#125;&quot;&gt;&lt;&#x2F;p&gt;                &lt;p&gt;年龄:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;&#123;&#123; edit_obj.age &#125;&#125;&quot;&gt;&lt;&#x2F;p&gt;                &lt;p&gt;性别:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;sex&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;&#123;&#123; edit_obj.sex &#125;&#125;&quot;&gt;&lt;&#x2F;p&gt;                &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-info btn-block&quot; value&#x3D;&quot;编辑&quot;&gt;            &lt;&#x2F;form&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>创建<code>index.html</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1 class&#x3D;&quot;text-center&quot;&gt;数据展示&lt;&#x2F;h1&gt;    &lt;div class&#x3D;&quot;container&quot;&gt;        &lt;div class&#x3D;&quot;row&quot;&gt;            &lt;div class&#x3D;&quot;col-mid-8 col-mid-offset-2&quot;&gt;                &lt;table class&#x3D;&quot;table table-striped table-hover&quot;&gt;                    &lt;thead&gt;                        &lt;tr&gt;                            &lt;th&gt;ID&lt;&#x2F;th&gt;                            &lt;th&gt;姓名&lt;&#x2F;th&gt;                            &lt;th&gt;年龄&lt;&#x2F;th&gt;                            &lt;th&gt;性别&lt;&#x2F;th&gt;                            &lt;th&gt;操作&lt;&#x2F;th&gt;                        &lt;&#x2F;tr&gt;                    &lt;&#x2F;thead&gt;                    &lt;tbody&gt;                        &#123;% for user_obj in userquery_set %&#125;                            &lt;tr&gt;                                &lt;td&gt;&#123;&#123; user_obj.id &#125;&#125;&lt;&#x2F;td&gt;                                &lt;td&gt;&#123;&#123; user_obj.name &#125;&#125;&lt;&#x2F;td&gt;                                &lt;td&gt;&#123;&#123; user_obj.age &#125;&#125;&lt;&#x2F;td&gt;                                &lt;td&gt;&#123;&#123; user_obj.sex &#125;&#125;&lt;&#x2F;td&gt;                                &lt;td&gt;                                    &lt;a href&#x3D;&quot;&#x2F;edit_user&#x2F;?user_id&#x3D;&#123;&#123; user_obj.id &#125;&#125;&quot; class&#x3D;&quot;btn btn-primary btn-xs&quot;&gt;编辑&lt;&#x2F;a&gt;                                    &lt;a href&#x3D;&quot;&#x2F;delete_user&#x2F;?user_id&#x3D;&#123;&#123; user_obj.id &#125;&#125;&quot; class&#x3D;&quot;btn btn-danger btn-xs&quot;&gt;删除&lt;&#x2F;a&gt;                                &lt;&#x2F;td&gt;                            &lt;&#x2F;tr&gt;                        &#123;% endfor %&#125;                    &lt;&#x2F;tbody&gt;                &lt;&#x2F;table&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h3 id="4-5-5-页面逻辑（View）"><a href="#4-5-5-页面逻辑（View）" class="headerlink" title="4.5.5 页面逻辑（View）"></a>4.5.5 页面逻辑（View）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse, redirectfrom app01 import models# Create your views here.def index(request):    # 1、通过ORM获取数据（可以用，但是语义不太明确）    # 方式一    # data &#x3D; models.User.objects.filter()    # print(data)    # 方式二    userquery_set &#x3D; models.User.objects.all()    print(userquery_set)    # 2、返回前端页面    # 方式一    # return render(request,&#39;userlist.html&#39;,&#123;&#39;user_queryset&#39;:user_queryset&#125;)    # 方式二    return render(request, &#39;index.html&#39;, locals())def edit_user(request):    # 1、获取url后面的参数    edit_id &#x3D; request.GET.get(&#39;user_id&#39;)    # 2、查询当前用户想要编辑的数据对象    edit_obj &#x3D; models.User.objects.filter(id&#x3D;edit_id).first()    # 3、获取数据    if request.method &#x3D;&#x3D; &quot;POST&quot;:        name &#x3D; request.POST.get(&#39;name&#39;)        age &#x3D; request.POST.get(&#39;age&#39;)        sex &#x3D; request.POST.get(&#39;sex&#39;)        # 4、修改数据库数据        # 方式一        # models.User.objects.filter(id&#x3D;edit_id).update(name&#x3D;name, age&#x3D;age, sex&#x3D;sex)        # 方式二        edit_obj.name &#x3D; name        edit_obj.age &#x3D; age        edit_obj.sex &#x3D; sex        edit_obj.save()        &quot;&quot;&quot;            上述方法当字段特别多的时候效率会非常的低            从头到尾将数据的所有字段全部更新一边 无论该字段是否被修改        &quot;&quot;&quot;        # 5、跳转到数据的展示页面        return redirect(&#39;&#x2F;index&#x2F;&#39;)    # 将数据对象展示到页面上    return render(request, &#39;edit_user.html&#39;, locals())def delete_user(request):    # 获取想要删除的用户的ID    delete_id &#x3D; request.GET.get(&#39;user_id&#39;)    # 从数据库中删除数据    models.User.objects.filter(id&#x3D;delete_id).delete()    &quot;&quot;&quot;    考虑如何批量删除？    &quot;&quot;&quot;    # 跳转到展示页面    return redirect(&#39;&#x2F;index&#x2F;&#39;)</code></pre></div></figure><h3 id="4-5-6-测试"><a href="#4-5-6-测试" class="headerlink" title="4.5.6 测试"></a>4.5.6 测试</h3><p>运行项目，测试编辑、删除功能</p><p><img src="/../../../img/image-20220910112832835.png" alt="image-20220910112832835"></p><p>编辑界面</p><p><img src="/../../../img/image-20220910112858542.png" alt="image-20220910112858542"></p><p>确认写到数据库</p><p><img src="/../../../img/image-20220910112949632.png" alt="image-20220910112949632"></p><h3 id="4-5-7-补充说明"><a href="#4-5-7-补充说明" class="headerlink" title="4.5.7 补充说明"></a>4.5.7 补充说明</h3><p>真正的删除功能应该需要二次确认 我们这里先不做后面会讲</p><p>删除数据内部其实<code>并不是真正的删除</code> 我们会给数据<code>添加</code>一个<code>标识字段</code>用来表示当前数</p><p>据<code>是否被删除</code>了，如果数据被删了仅仅只是讲<code>字段修改一个状态</code></p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">username  passwordis_deletejason    1230egon1231</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day59-Web框架介绍</title>
    <link href="/2022/09/01/03_Python/05_Django/day59%E7%AC%94%E8%AE%B0-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/09/01/03_Python/05_Django/day59%E7%AC%94%E8%AE%B0-Web%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>“第59天Web框架介绍学习笔记”</p><h1 id="1-手写Web框架"><a href="#1-手写Web框架" class="headerlink" title="1 手写Web框架"></a>1 手写Web框架</h1><p>在学Web框架之前，复习下HTTP协议</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># HTTP协议&quot;&quot;&quot;网络协议HTTP协议数据传输是明文HTTPS协议数据传输是密文websocket协议数据传输是密文四大特性1.基于请求响应2.基于TCP、IP作用于应用层之上的协议3.无状态4.短&#x2F;无链接数据格式请求首行请求头请求体响应状态码1XX2XX2003XX4XX403 4045XX500&quot;&quot;&quot;</code></pre></div></figure><h2 id="1-1-纯手写的Web框架"><a href="#1-1-纯手写的Web框架" class="headerlink" title="1.1 纯手写的Web框架"></a>1.1 纯手写的Web框架</h2><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 案例：纯手写的python Web框架import socket# 创建套接字server &#x3D; socket.socket()# 绑定IP和端口server.bind((&#39;127.0.0.1&#39;, 8080))# 设置监听池大小server.listen(5)while True:    # 开始接收客户端连接    conn, addr &#x3D; server.accept()    # 接收客户端传来的数据(二进制)    data &#x3D; conn.recv(1024)    # 输出data看看是什么东西    print(data)    # 将二进制数据转换成字符串    data &#x3D; data.decode(&#39;utf-8&#39;)    # 向客户端发送数据    conn.send(b&#39;HTTP&#x2F;1.1 200 OK\r\n\r\n&#39;)    current_path &#x3D; data.split(&#39; &#39;)[1]    # 输出路径看看    print(current_path)    # 路径判断    if current_path &#x3D;&#x3D; &quot;&#x2F;index&quot;:        with open(r&#39;templates&#x2F;index.html&#39;, &#39;rb&#39;) as f:            conn.send(f.read())    elif current_path &#x3D;&#x3D; &#39;&#x2F;login&#39;:        conn.send(b&#39;login page&#39;)    else:        conn.send(b&#39;Hello World&#39;)    # 关闭套接字    conn.close()</code></pre></div></figure><p>其中<code>print(data)</code>输出的内容，<code>/favicon.ico</code>可以忽略，通过<code>data.split(&#39; &#39;)[1]</code>可以获取访问的路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 当访问http:&#x2F;&#x2F;127.0.0.1:8080b&#39;GET &#x2F; HTTP&#x2F;1.1\r\nHost: 127.0.0.1:8080\r\nConnection: keep-alive\r\nCache-Control: max-age&#x3D;0\r\nsec-ch-ua: &quot;Chromium&quot;;v&#x3D;&quot;104&quot;, &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;104&quot;\r\nsec-ch-ua-mobile: ?0\r\nsec-ch-ua-platform: &quot;Windows&quot;\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.0.0 Safari&#x2F;537.36\r\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\r\nSec-Fetch-Site: none\r\nSec-Fetch-Mode: navigate\r\nSec-Fetch-User: ?1\r\nSec-Fetch-Dest: document\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q&#x3D;0.9,zh-TW;q&#x3D;0.8,en-US;q&#x3D;0.7,en;q&#x3D;0.6\r\n\r\n&#39;&#x2F;b&#39;GET &#x2F;favicon.ico HTTP&#x2F;1.1\r\nHost: 127.0.0.1:8080\r\nConnection: keep-alive\r\nsec-ch-ua: &quot;Chromium&quot;;v&#x3D;&quot;104&quot;, &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;104&quot;\r\nsec-ch-ua-mobile: ?0\r\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.0.0 Safari&#x2F;537.36\r\nsec-ch-ua-platform: &quot;Windows&quot;\r\nAccept: image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;svg+xml,image&#x2F;*,*&#x2F;*;q&#x3D;0.8\r\nSec-Fetch-Site: same-origin\r\nSec-Fetch-Mode: no-cors\r\nSec-Fetch-Dest: image\r\nReferer: http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q&#x3D;0.9,zh-TW;q&#x3D;0.8,en-US;q&#x3D;0.7,en;q&#x3D;0.6\r\n\r\n&#39;&#x2F;favicon.ico# 当访问http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;indexb&#39;GET &#x2F;index HTTP&#x2F;1.1\r\nHost: 127.0.0.1:8080\r\nConnection: keep-alive\r\nsec-ch-ua: &quot;Chromium&quot;;v&#x3D;&quot;104&quot;, &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;104&quot;\r\nsec-ch-ua-mobile: ?0\r\nsec-ch-ua-platform: &quot;Windows&quot;\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.0.0 Safari&#x2F;537.36\r\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\r\nPurpose: prefetch\r\nSec-Fetch-Site: none\r\nSec-Fetch-Mode: navigate\r\nSec-Fetch-User: ?1\r\nSec-Fetch-Dest: document\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q&#x3D;0.9,zh-TW;q&#x3D;0.8,en-US;q&#x3D;0.7,en;q&#x3D;0.6\r\n\r\n&#39;&#x2F;indexb&#39;GET &#x2F;favicon.ico HTTP&#x2F;1.1\r\nHost: 127.0.0.1:8080\r\nConnection: keep-alive\r\nsec-ch-ua: &quot;Chromium&quot;;v&#x3D;&quot;104&quot;, &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;104&quot;\r\nsec-ch-ua-mobile: ?0\r\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.0.0 Safari&#x2F;537.36\r\nsec-ch-ua-platform: &quot;Windows&quot;\r\nAccept: image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;svg+xml,image&#x2F;*,*&#x2F;*;q&#x3D;0.8\r\nSec-Fetch-Site: same-origin\r\nSec-Fetch-Mode: no-cors\r\nSec-Fetch-Dest: image\r\nReferer: http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q&#x3D;0.9,zh-TW;q&#x3D;0.8,en-US;q&#x3D;0.7,en;q&#x3D;0.6\r\n\r\n&#39;&#x2F;favicon.ico</code></pre></div></figure><p>实现的效果：</p><p>​通过不同的路径可以访问到不同的html页面</p><h3 id="1-1-1-纯手撸的web框架有以下不足："><a href="#1-1-1-纯手撸的web框架有以下不足：" class="headerlink" title="1.1.1 纯手撸的web框架有以下不足："></a>1.1.1 纯手撸的web框架有以下不足：</h3><ul><li>代码重复(服务端代码所有人都要重复写)</li><li>手动处理http格式的数据 并且只能拿到url后缀 其他数据获取繁琐(数据格式一样处理的代码其实也大致一样 重复写)</li><li>并发的问题</li></ul><h2 id="1-2-使用wsgiref模块写Web框架"><a href="#1-2-使用wsgiref模块写Web框架" class="headerlink" title="1.2 使用wsgiref模块写Web框架"></a>1.2 使用wsgiref模块写Web框架</h2><p>wsgiref整合了socket框架，不用重新写socket，比纯手写要好点</p><h3 id="1-2-1-server代码"><a href="#1-2-1-server代码" class="headerlink" title="1.2.1 server代码"></a>1.2.1 server代码</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from wsgiref.simple_server import make_serverfrom urls import urlsfrom views import *def run(env, response):    &quot;&quot;&quot;    :param env: 请求相关的所有数据    :param response: 响应相关的所有数据    :return: 返回给浏览器的数据    &quot;&quot;&quot;    # env 大字典 wsgiref模块帮你你处理好Http格式的数据，封装成了字典让你更加方便操作    # print(env)    # 响应首行，响应头    response(&#39;200 OK&#39;, [])    # 从env中获取当前访问的路径    current_path &#x3D; env.get(&#39;PATH_INFO&#39;)    # 定义func变量，存储函数名    func &#x3D; None    for url in urls:        if current_path &#x3D;&#x3D; url[0]:            func &#x3D; url[1]            break    # 判断func是否有值    if func:        res &#x3D; func(env)    else:        res &#x3D; error(env)    # 返回得到的数据，在此统一编码    return [res.encode(&#39;utf-8&#39;)]if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    server &#x3D; make_server(&#39;127.0.0.1&#39;, 8080, run)    # 启动服务    server.serve_forever()</code></pre></div></figure><blockquote><p>PS：补充，关于<code>print(env)</code>的输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&#123;&#39;ALLUSERSPROFILE&#39;: &#39;C:\\ProgramData&#39;, &#39;APPDATA&#39;: &#39;C:\\Users\\fr724\\AppData\\Roaming&#39;, &#39;APR_ICONV_PATH&#39;: &#39;D:\\software\\subversion\\iconv&#39;, &#39;COMMONPROGRAMFILES&#39;: &#39;C:\\Program&#39;.....&#39;HTTP_UPGRADE_INSECURE_REQUESTS&#39;: &#39;1&#39;, &#39;HTTP_USER_AGENT&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) </code></pre></div></figure><p>可以看出，其中是大量的<font color=red>环境变量</font>的键值对，主要取其中有用的段<code>PATH_INFO</code>来获取访问路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&#39;PATH_INFO&#39;: &#39;&#x2F;index&#39;</code></pre></div></figure></blockquote><h3 id="1-2-2-特定文件夹格式"><a href="#1-2-2-特定文件夹格式" class="headerlink" title="1.2.2 特定文件夹格式"></a>1.2.2 特定文件夹格式</h3><p>使用wsgi需要特定的文件夹格式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;urls.py路由与视图函数对应关系views.py视图函数(后端业务逻辑)templates文件夹专门用来存储html文件&quot;&quot;&quot;# 按照功能的不同拆分之后 后续添加功能只需要在urls.py书写对应关系然后取views.py书写业务逻辑即可</code></pre></div></figure><p>urls.py的内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from views import *# url与函数的对应关系urls &#x3D; [    (&#39;&#x2F;index&#39;,index),    (&#39;&#x2F;login&#39;,login),    (&#39;&#x2F;xxx&#39;,xxx),    (&#39;&#x2F;get_time&#39;,get_time),    (&#39;&#x2F;get_dict&#39;,get_dict),    (&#39;&#x2F;get_user&#39;,get_user)]</code></pre></div></figure><p>views.py的内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import datetimedef index(env):    return &#39;index&#39;def login(env):    return &#39;login&#39;def error(env):    return &#39;404 error&#39;# 读取html文件的案例def xxx(env):    with open(r&#39;templates&#x2F;myxxx.html&#39;, rb) as f:        return f.read()# 动态修改html内容的案例 -- 通过文字替换实现def get_time(env):    # 获取当前时间    current_time &#x3D; datetime.datetime.now().strftime(&#39;%Y-%m-%d %X&#39;)    # 通过文字替换将后端获取到的数据&#39;传递到&#39;html文件    with open(r&#39;templates&#x2F;mytime.html&#39;, &#39;r&#39;, encoding&#x3D;(&#39;utf-8&#39;)) as f:        data &#x3D; f.read()        # 处理数据        data &#x3D; data.replace(&#39;dsadsa&#39;, current_time)        # 返回处理好的数据        return data# 动态修改html内容的案例 -- 通过jinja2实现# 导入jinja2模块from jinja2 import Templatedef get_dict(env):    # 创建数据变量    user_dic &#x3D; &#123;&#39;username&#39;:&#39;Goosh&#39;, &#39;age&#39;:18, &#39;hobby&#39;:&#39;cook&#39;&#125;    # 读取html文件    with open(r&#39;templates&#x2F;get_dict.html&#39;, &#39;r&#39;, encoding&#x3D;(&#39;utf-8&#39;)) as f:        data &#x3D; f.read()    # 处理数据变量，渲染成jinja2变量    tmp &#x3D; Template(data)    res &#x3D; tmp.render(user&#x3D;user_dic)    # 返回处理后的结果    return res# 动态获取数据库中的数据，传递到html中import pymysqldef get_user(env):    # 连接数据库    conn &#x3D; pymysql.connect(        host &#x3D; &#39;127.0.0.1&#39;,        port &#x3D; 3306,        user &#x3D; &#39;root&#39;,        password&#x3D; &#39;&#39;,        db &#x3D; &#39;test&#39;,        charset&#x3D; &#39;utf8&#39;,        autocommit &#x3D; True    )    # 创建游标    cursor &#x3D; conn.cursor(cursor&#x3D;pymysql.cursors.DictCursor)    # 要查询的语句    sql &#x3D; &#39;select * from students&#39;    # 执行语句    affect_rows &#x3D; cursor.execute(sql)    # 将获取的数据保存到变量中    data_list &#x3D; cursor.fetchall()    # 将数据床底给html    with open(r&#39;templates&#x2F;get_data.html&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:        data &#x3D; f.read()    # jinja2渲染数据    tmp &#x3D; Template(data)    res &#x3D; tmp.render(user_list&#x3D;data_list)    # 返回数据    return  resif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    get_user(111)</code></pre></div></figure><h3 id="1-2-3-html页面创建"><a href="#1-2-3-html页面创建" class="headerlink" title="1.2.3 html页面创建"></a>1.2.3 html页面创建</h3><p>创建html页面，放到<code>templates</code>文件夹中</p><p>mytime.html</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div&gt;当前时间是: dsadsa&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>myxxx.html</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &lt;div&gt;这是xxx的页面&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>get_dict.html</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;我是一个页面&lt;&#x2F;h1&gt;&#123;&#123; user &#125;&#125;&#123;&#123; user.get(&#39;username&#39;)&#125;&#125;&#123;&#123; user.age &#125;&#125;&#123;&#123; user[&#39;hobby&#39;] &#125;&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>get_data.html</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &#123;&#123; user_list &#125;&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h1 id="2-动态网页和静态网页"><a href="#2-动态网页和静态网页" class="headerlink" title="2 动态网页和静态网页"></a>2 动态网页和静态网页</h1><p>什么是动态网页？什么又是静态网页？它们的区别是什么？</p><ul><li>静态网页<ul><li>页面上的数据是直接写死的(万年不变)</li></ul></li><li>动态网页<ul><li>数据是实时获取的</li><li>例如：<ul><li>后端获取当前时间展示到html页面上</li><li>数据是从数据库中获取的展示到html页面上</li></ul></li></ul></li></ul><p>动态网页的案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 动态网页制作import datetimedef get_time(env):    current_time &#x3D; datetime.datetime.now().strftime(&#39;%Y-%m-%d %X&#39;)    # 如何将后端获取到的数据&quot;传递&quot;给html文件？    with open(r&#39;templates&#x2F;03 mytime.html&#39;,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:        data &#x3D; f.read()        # data就是一堆字符串    data &#x3D; data.replace(&#39;dwadasdsadsadasdas&#39;,current_time)   # 在后端将html页面处理好之后再返回给前端    return data# 将一个字典传递给html文件 并且可以在文件上方便快捷的操作字典数据from jinja2 import Templatedef get_dict(env):    user_dic &#x3D; &#123;&#39;username&#39;:&#39;jason&#39;,&#39;age&#39;:18,&#39;hobby&#39;:&#39;read&#39;&#125;    with open(r&#39;templates&#x2F;04 get_dict.html&#39;,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:        data &#x3D; f.read()    tmp &#x3D; Template(data)    res &#x3D; tmp.render(user&#x3D;user_dic)    # 给get_dict.html传递了一个值 页面上通过变量名user就能够拿到user_dict    return res# 后端获取数据库中数据展示到前端页面</code></pre></div></figure><h1 id="3-自定义简易版本web框架请求流程图"><a href="#3-自定义简易版本web框架请求流程图" class="headerlink" title="3 自定义简易版本web框架请求流程图"></a>3 自定义简易版本web框架请求流程图</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;wsgiref模块1.请求来的时候解析http格式的数据 封装成大字典2.响应走的时候给数据打包成符合http格式 再返回给浏览器&quot;&quot;&quot;</code></pre></div></figure><h1 id="4-python三大主流web框架"><a href="#4-python三大主流web框架" class="headerlink" title="4 python三大主流web框架"></a>4 python三大主流web框架</h1><h2 id="4-1-三大主流框架"><a href="#4-1-三大主流框架" class="headerlink" title="4.1 三大主流框架"></a>4.1 三大主流框架</h2><p><strong>django</strong></p><p>​特点:大而全 自带的功能特别特别特别的多 类似于航空母舰</p><p>​不足之处:</p><p>​有时候过于笨重</p><p><strong>flask</strong></p><p>​特点:小而精  自带的功能特别特别特别的少 类似于游骑兵</p><p>​第三方的模块特别特别特别的多，如果将flask第三方的模块加起来完全可以盖过django</p><p>​并且也越来越像django</p><p>​不足之处:</p><p>​比较依赖于第三方的开发者<br>​<br><strong>tornado</strong></p><p>​特点:异步非阻塞 支持高并发</p><p>​牛逼到甚至可以开发游戏服务器</p><p>​不足之处:</p><p>​暂时你不会</p><h2 id="4-2-三大框架的对比"><a href="#4-2-三大框架的对比" class="headerlink" title="4.2 三大框架的对比"></a>4.2 三大框架的对比</h2><p>如果将框架分为三部分</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">A:socket部分B:路由与视图函数对应关系(路由匹配)C:模版语法</code></pre></div></figure><p>三个框架之间的对比如下：</p><p><strong>django</strong></p><ul><li>A用的是别人的wsgiref模块</li><li>B用的是自己的</li><li>C用的是自己的(没有jinja2好用 但是也很方便)</li></ul><p><strong>flask</strong></p><ul><li>A用的是别人的werkzeug(内部还是wsgiref模块)</li><li>B自己写的</li><li>C用的别人的(jinja2)</li></ul><p><strong>tornado</strong></p><ul><li>A，B，C都是自己写的</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 如何让你的计算机能够正常的启动django项目1.计算机的名称不能有中文2.一个pycharm窗口只开一个项目3.项目里面所有的文件也尽量不要出现中文4.python解释器尽量使用3.4~3.6之间的版本(如果你的项目报错 你点击最后一个报错信息去源码中把逗号删掉)</code></pre></div></figure><h1 id="5-Django"><a href="#5-Django" class="headerlink" title="5 Django"></a>5 Django</h1><h2 id="5-1-安装Django"><a href="#5-1-安装Django" class="headerlink" title="5.1 安装Django"></a>5.1 安装Django</h2><p>使用<code>pip</code>安装Django</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$pip3 install django&#x3D;&#x3D;3.2</code></pre></div></figure><p>验证是否安装成功的方式:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ django-admin --version3.2</code></pre></div></figure><p><strong>Django版本选择</strong></p><p>目前版本主要分为：</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">1.X 2.X 3.X 4.X</code></pre></div></figure><p>最新的为4.1，最新的LTS版本是3.2，因此选择3.2版本</p><h2 id="5-1-创建Django项目"><a href="#5-1-创建Django项目" class="headerlink" title="5.1 创建Django项目"></a>5.1 创建Django项目</h2><h3 id="5-1-1-方式一：通过命令行创建"><a href="#5-1-1-方式一：通过命令行创建" class="headerlink" title="5.1.1 方式一：通过命令行创建"></a>5.1.1 方式一：通过命令行创建</h3><p>1、进入到工作目录，使用命令创建Django项目</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">django-admin startproject mysite</code></pre></div></figure><p>2、查看创建好的项目目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls mysitemanage.py*  mysite&#x2F;$ ls mysite&#x2F;mysite&#x2F;__init__.py  asgi.py  settings.py  urls.py  wsgi.py</code></pre></div></figure><p>好像是一群看不懂得文件，他们的作用是什么？</p><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>manage.py</td><td>一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互</td></tr><tr><td><strong>init</strong>.py</td><td>一个空文件，告诉 Python 该目录是一个 Python 包</td></tr><tr><td>asgi.py</td><td>一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目。</td></tr><tr><td>settings.py</td><td>该 Django 项目的设置&#x2F;配置。包括app路径，数据库配置，sql语句，静态文件目录，中间件，session存储的相关配置</td></tr><tr><td>urls.py</td><td>该 Django 项目的 URL 声明，是所有网址的入口，会关联到views中的函数。</td></tr><tr><td>wsgi.py</td><td>一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。</td></tr></tbody></table><p>3、启动项目</p><p>进入项目目录，并启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python manage.py runserver</code></pre></div></figure><p> 以下是输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Watching for file changes with StatReloaderPerforming system checks...System check identified no issues (0 silenced).You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.Run &#39;python manage.py migrate&#39; to apply them.September 02, 2022 - 14:14:29Django version 3.2, using settings &#39;mysite.settings&#39;Starting development server at http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;Quit the server with CTRL-BREAK.</code></pre></div></figure><p>访问页面成功即可</p><p><img src="/../../../img/image-20220902141628470.png" alt="image-20220902141628470"></p><p>4、 创建应用</p><p>通过命令行创建应用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python manage.py startapp app01</code></pre></div></figure><blockquote><p>关于应用的名称:</p><p>​app起名应做到见名知意，如:</p><p>​user、order、web等等</p><p>​这里练习因此使用app01, app02这些名称</p></blockquote><p>查看创建完的文件夹里有些什么？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls app01&#x2F;__init__.py  admin.py  apps.py  migrations&#x2F;  models.py  tests.py  views.py</code></pre></div></figure><h3 id="5-1-2-方式二：通过Pycharm创建"><a href="#5-1-2-方式二：通过Pycharm创建" class="headerlink" title="5.1.2 方式二：通过Pycharm创建"></a>5.1.2 方式二：通过Pycharm创建</h3><p>1、创建Django项目</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># pycharm界面操作File -- New Project -- Django</code></pre></div></figure><p>2、启动项目</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 方式一pycharm终端，使用命令行启动# 方式二点击Run -- Run(绿色小箭头)即可</code></pre></div></figure><p>3、创建应用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 方式一（建议，练习记忆命令）pycharm提供的终端直接输入完整命令$ python manage.py startapp app01# 方式二（不建议。Pycharm界面打开manange.py终端窗口）tools -- run manage.py task# 使用起来是一样的manage.py@mysite &gt; startapp app01C:\Users\fr724\Desktop\python-learning\01-老男孩Python29期学习\03-Python进阶之前端Web方向\mysite\Scripts\python.exe &quot;D:\software\PyCharm 2021.3.1\plugins\python\helpers\pycharm\django_manage.py&quot; startapp app01 C:&#x2F;Users&#x2F;fr724&#x2F;Desktop&#x2F;python-learning&#x2F;01-老男孩Python29期学习&#x2F;02-Python高级阶段&#x2F;mysiteTracking file by folder pattern:  migrationsFollowing files were affected  C:\Users\fr724\Desktop\python-learning\01-老男孩Python29期学习\02-Python高级阶段\mysite\app01\migrations\__init__.pyProcess finished with exit code 0</code></pre></div></figure><p>4、修改端口号以及创建server（Pycharm操作的优势，这点比命令行方面）</p><p>界面操作</p><p><img src="/../../../img/image-20220902144040797.png" alt="image-20220902144040797"></p><p>里面可以修改</p><p><img src="/../../../img/image-20220902144103426.png" alt="image-20220902144103426"></p><h3 id="5-1-3-命令行与pycharm创建项目的区别"><a href="#5-1-3-命令行与pycharm创建项目的区别" class="headerlink" title="5.1.3 命令行与pycharm创建项目的区别"></a>5.1.3 命令行与pycharm创建项目的区别</h3><p>命令行创建:</p><p>​不会自动有template文件夹,需要你自己手动创建</p><p>pycharm创建：</p><p>​会自动帮你创建template文件夹且还会自动在配置文件中配置对应的路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># pycharm创建TEMPLATES &#x3D; [    &#123;        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)]        ....]# 命令行创建TEMPLATES &#x3D; [    &#123;        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,        &#39;DIRS&#39;: [],        ...]</code></pre></div></figure><blockquote><p>也就意味着你在用命令创建django项目的时候不单单需要创建templates文件夹还需要去</p><p>配置文件中配置路径</p><p>‘DIRS’: [os.path.join(BASE_DIR, ‘templates’)]</p></blockquote><h2 id="5-2-应用的配置和使用"><a href="#5-2-应用的配置和使用" class="headerlink" title="5.2 应用的配置和使用"></a>5.2 应用的配置和使用</h2><h3 id="5-2-1-什么是应用（APP）"><a href="#5-2-1-什么是应用（APP）" class="headerlink" title="5.2.1 什么是应用（APP）"></a>5.2.1 什么是应用（APP）</h3><p>APP的介绍：</p><ul><li><p>django是一款专门用来开发app的web框架</p></li><li><p>django框架就类似于是一所大学(空壳子)</p></li><li><p>app就类似于大学里面各个学院(具体功能的app)</p></li><li><p>一个app就是一个独立的功能模块</p></li></ul><p>app内的文件介绍：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">app01文件夹    ---admin.pydjango后台管理    ---apps.py注册使用    ---migrations文件夹数据库迁移记录    ---models.py数据库相关的 模型类(orm)    ---tests.py测试文件    ---views.py视图函数(视图层)</code></pre></div></figure><h3 id="5-2-2-如何使用应用？"><a href="#5-2-2-如何使用应用？" class="headerlink" title="5.2.2 如何使用应用？"></a>5.2.2 如何使用应用？</h3><p>在开始前，先梳理下文件夹路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">$ ls mysite&#x2F;app01&#x2F;  db.sqlite3  manage.py*  mysite&#x2F;  templates&#x2F;# 查看项目文件$ ls mysite&#x2F;mysite&#x2F;__init__.py  __pycache__&#x2F;  asgi.py  settings.py  urls.py  wsgi.py# 查看app文件$ ls mysite&#x2F;app01&#x2F;__init__.py  __pycache__&#x2F;  admin.py  apps.py  migrations&#x2F;  models.py  tests.py  views.py</code></pre></div></figure><h4 id="1、注册应用"><a href="#1、注册应用" class="headerlink" title="1、注册应用"></a>1、注册应用</h4><p>编辑<code>mysite/mysite/settings.py</code>文件，添加<code>app01</code>应用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">***********************创建的应用一定要去配置文件中注册**********************INSTALLED_APPS &#x3D; [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;app01.apps.App01Config&#39;,  # 全写  &#39;app01&#39;, # 简写]# 创建出来的的应用第一步先去配置文件中注册 其他的先不要给我干ps:你在用pycharm创建项目的时候 pycharm可以帮你创建一个app并且自动注册***********************************************************************</code></pre></div></figure><h4 id="2、添加url路由"><a href="#2、添加url路由" class="headerlink" title="2、添加url路由"></a>2、添加url路由</h4><p>编辑<code>mysite/mysite/urls.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.contrib import adminfrom django.urls import path# 导入app01的viewsfrom app01 import viewsurlpatterns &#x3D; [    path(&#39;admin&#x2F;&#39;, admin.site.urls),    # 写我们自己的路由与视图关系    path(&#39;index&#x2F;&#39;, views.index),    path(&#39;home&#x2F;&#39;, views.home),]</code></pre></div></figure><h4 id="3、添加views"><a href="#3、添加views" class="headerlink" title="3、添加views"></a>3、添加views</h4><p>编辑<code>mysite/mysite/app01/views.py</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse, redirect# Create your views here.def index(request):    &quot;&quot;&quot;    :param request: 请求相关的所有数据对象 比你之前的env更加牛逼    :return:    &quot;&quot;&quot;    return HttpResponse(&quot;哎呀！ 被你发现了&quot;)def home(request):    return HttpResponse(&quot;欢迎回家！&quot;)</code></pre></div></figure><h4 id="4、访问网站"><a href="#4、访问网站" class="headerlink" title="4、访问网站"></a>4、访问网站</h4><p>访问<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p><p><img src="/../../../img/image-20220902153251103.png" alt="image-20220902153251103"></p><p>访问<a href="http://127.0.0.1:8080/index">http://127.0.0.1:8080/index</a></p><p><img src="/../../../img/image-20220902153315217.png" alt="image-20220902153315217"></p><p>访问<a href="http://127.0.0.1:8080/home">http://127.0.0.1:8080/home</a></p><p><img src="/../../../img/image-20220902153327321.png" alt="image-20220902153327321"></p><h2 id="5-5-django小白必会三板斧"><a href="#5-5-django小白必会三板斧" class="headerlink" title="5.5 django小白必会三板斧"></a>5.5 django小白必会三板斧</h2><p>在编辑<code>app01/views.py</code>文件时，有三种方式可以返回页面内容，称为三板斧：</p><p>使用前需要导入：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render,HttpResponse,redirect</code></pre></div></figure><h3 id="1、HttpResponse"><a href="#1、HttpResponse" class="headerlink" title="1、HttpResponse"></a>1、HttpResponse</h3><p>作用：返回字符串类型的数据</p><p>使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">return HttpResponse(&quot;欢迎回家！&quot;)</code></pre></div></figure><h3 id="2、render"><a href="#2、render" class="headerlink" title="2、render"></a>2、render</h3><p>作用：返回html文件</p><p>使用：</p><p>创建<code>Template/test.html</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;哥只是个传说&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>返回html页面</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, HttpResponse, redirect# Create your views here.def index(request):    &quot;&quot;&quot;    :param request: 请求相关的所有数据对象 比你之前的env更加牛逼    :return:    &quot;&quot;&quot;    return render(request, &#39;test.html&#39;)def home(request):    return HttpResponse(&quot;欢迎回家！&quot;)</code></pre></div></figure><h3 id="3、redirect"><a href="#3、redirect" class="headerlink" title="3、redirect"></a>3、redirect</h3><p>作用：重定向页面</p><p>使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">return redirect(&#39;https:&#x2F;&#x2F;www.mzitu.com&#x2F;&#39;)# 或者return redirect(&#39;&#x2F;home&#x2F;&#39;)</code></pre></div></figure><h1 id="6-作业"><a href="#6-作业" class="headerlink" title="6 作业"></a>6 作业</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1.整理web框架推导思路2.安装django并正常启动访问，测试三板斧3.整理今日日考题，django内容选做题1.结合前端，django，MySQL，pymysql模块实现数据库数据动态展示到前端2.尝试着摸索django模版语法&quot;&quot;&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>09_Django</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day57-JQuery-02</title>
    <link href="/2022/08/25/03_Python/04_%E5%89%8D%E7%AB%AF/day57%E7%AC%94%E8%AE%B0-JQuery-02/"/>
    <url>/2022/08/25/03_Python/04_%E5%89%8D%E7%AB%AF/day57%E7%AC%94%E8%AE%B0-JQuery-02/</url>
    
    <content type="html"><![CDATA[<p>“第57天JQuery（02）学习笔记”</p><p>今天主要内容</p><ul><li>jQuery操作标签</li><li>jQuery绑定事件</li><li>jQuery补充知识点</li><li>jQuery动画效果(了解)</li><li>Bootstrap(前端框架)开头</li></ul><h1 id="1-JQuery练习题"><a href="#1-JQuery练习题" class="headerlink" title="1 JQuery练习题"></a>1 JQuery练习题</h1><p><a href="https://github.com/gsproj/gsproj.github.io/blob/source/source/_posts/03_Python/02_%E5%89%8D%E7%AB%AF/sources/day57/jQuery%E7%BB%83%E4%B9%A0%E9%A2%98.html">练习题页面的源码</a></p><p>找到本页面中id是<code>i1</code>的标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#i1&#39;)S.fn.init [div#i1.container]$(&#39;#i1&#39;)[0]&lt;div id&#x3D;​&quot;i1&quot; class&#x3D;​&quot;container&quot;&gt;​…​&lt;&#x2F;div&gt;​</code></pre></div></figure><p>找到本页面中所有的<code>h2</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;h2&#39;)S.fn.init [h2, prevObject: S.fn.init(1)]$(&#39;h2&#39;)[0]&lt;h2&gt;​练习题：​&lt;&#x2F;h2&gt;​</code></pre></div></figure><p>找到本页面中所有的<code>input</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;input&#39;)S.fn.init(9) [input#exampleInputEmail1.form-control, input#exampleInputPassword1.form-control, input#exampleInputFile, input, input, input, input, input#optionsRadios1, input#optionsRadios2, prevObject: S.fn.init(1)]$(&#39;input&#39;)[0]&lt;input type&#x3D;​&quot;email&quot; class&#x3D;​&quot;form-control&quot; id&#x3D;​&quot;exampleInputEmail1&quot; placeholder&#x3D;​&quot;Email&quot;&gt;​$(&#39;input&#39;)[1]&lt;input type&#x3D;​&quot;password&quot; class&#x3D;​&quot;form-control&quot; id&#x3D;​&quot;exampleInputPassword1&quot; placeholder&#x3D;​&quot;Password&quot;&gt;​</code></pre></div></figure><p>找到本页面所有样式类中有<code>c1</code>的标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;.c1&#39;)S.fn.init(2) [h1.c1, h1.c1, prevObject: S.fn.init(1)]$(&#39;.c1&#39;)[0]&lt;h1 class&#x3D;​&quot;c1&quot;&gt;​Jason​&lt;&#x2F;h1&gt;​</code></pre></div></figure><p>找到本页面所有样式类中有<code>btn-default</code>的标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;.btn-default&#39;)S.fn.init [button#btnSubmit.btn.btn-default, prevObject: S.fn.init(1)]$(&#39;.btn-default&#39;)[0]&lt;button id&#x3D;​&quot;btnSubmit&quot; type&#x3D;​&quot;submit&quot; class&#x3D;​&quot;btn btn-default&quot;&gt;​提交​&lt;&#x2F;button&gt;​</code></pre></div></figure><p>找到本页面所有样式类中有<code>c1</code>的标签和所有<code>h2</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;.c1, h2&#39;)S.fn.init(3) [h1.c1, h1.c1, h2, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到本页面所有样式类中有<code>c1</code>的标签和id是<code>p3</code>的标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;.c1, #p3&#39;)S.fn.init(3) [h1.c1, h1.c1, p#p3.divider, prevObject: S.fn.init(1)]$(&#39;.c1, #p3&#39;)[2]&lt;p id&#x3D;​&quot;p3&quot; class&#x3D;​&quot;divider&quot;&gt;​&lt;&#x2F;p&gt;​</code></pre></div></figure><p>找到本页面所有样式类中有<code>c1</code>的标签和所有样式类中有<code>btn</code>的标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;.c1, .btn&#39;)S.fn.init(11) [h1.c1, h1.c1, a.btn.btn-primary.btn-lg, button.btn.btn-warning, button.btn.btn-danger, button.btn.btn-warning, button.btn.btn-danger, button.btn.btn-warning, button.btn.btn-danger, button#btnSubmit.btn.btn-default, a.btn.btn-success, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到本页面中<code>form</code>标签中的所有<code>input</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;form&#39;).find(&#39;input&#39;)S.fn.init(3) [input#exampleInputEmail1.form-control, input#exampleInputPassword1.form-control, input#exampleInputFile, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到本页面中被包裹在<code>label</code>标签内的<code>input</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;label input&#39;)S.fn.init(6) [input, input, input, input, input#optionsRadios1, input#optionsRadios2, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到本页面中紧挨在<code>label</code>标签后面的<code>input</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;label+input&#39;)S.fn.init(3) [input#exampleInputEmail1.form-control, input#exampleInputPassword1.form-control, input#exampleInputFile, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到本页面中id为<code>p2</code>的标签后面所有和它同级的<code>li</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#p2~li&#39;)S.fn.init(8) [li, li, li, li, li, li, li, li, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到id值为<code>f1</code>的标签内部的第一个input标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#f1 input:first&#39;)S.fn.init [input#exampleInputEmail1.form-control, prevObject: S.fn.init(1)]$(&#39;#f1 input:first&#39;)[0]&lt;input type&#x3D;​&quot;email&quot; class&#x3D;​&quot;form-control&quot; id&#x3D;​&quot;exampleInputEmail1&quot; placeholder&#x3D;​&quot;Email&quot;&gt;​</code></pre></div></figure><p>找到id值为<code>my-checkbox</code>的标签内部最后一个input标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#my-checkbox input:last&#39;)S.fn.init [input, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到id值为<code>my-checkbox</code>的标签内部没有被选中的那个input标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#my-checkbox input[checked!&#x3D;&quot;checked&quot;]&#39;)S.fn.init(3) [input, input, input, prevObject: S.fn.init(1)]</code></pre></div></figure><p>找到所有含有<code>input</code>标签的<code>label</code>标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;label:has(&quot;input&quot;)&#39;)S.fn.init(6) [label, label, label, label, label, label, prevObject: S.fn.init(1)]</code></pre></div></figure><h1 id="2-JQuery操作标签"><a href="#2-JQuery操作标签" class="headerlink" title="2 JQuery操作标签"></a>2 JQuery操作标签</h1><h2 id="2-1-操作Class"><a href="#2-1-操作Class" class="headerlink" title="2.1 操作Class"></a>2.1 操作Class</h2><p>JQuery操作类主要有四个方法：</p><table><thead><tr><th>JQuery方法</th><th>JS方法</th><th>作用</th></tr></thead><tbody><tr><td>addClass()</td><td>classList.add()</td><td>添加类</td></tr><tr><td>removeClass()</td><td>classList.remove()</td><td>移除类</td></tr><tr><td>hasClass()</td><td>classList.contains()</td><td>查询是否包含某个类</td></tr><tr><td>toggleClass()</td><td>classList.toggle()</td><td>有则移除，无则添加</td></tr></tbody></table><p>操作案例如下：</p><p>页面代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;style&gt;        .c1 &#123;            background-color: coral;            height: 200px;            width: 300px;        &#125;        .c2 &#123;            border: 20px solid red;        &#125;        .c3 &#123;            margin-top: 20%;            margin-left: 50%;        &#125;    &lt;&#x2F;style&gt;    &lt;script src&#x3D;&quot;jquery-3.6.0.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;c1 c2 c3&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>操作类：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 移除类$(&#39;div&#39;).removeClass(&#39;c2&#39;)S.fn.init [div.c1.c3, prevObject: S.fn.init(1)]&#x2F;&#x2F; 添加类$(&#39;div&#39;).addClass(&#39;c2&#39;)S.fn.init [div.c1.c3.c2, prevObject: S.fn.init(1)]&#x2F;&#x2F; 查询是否包含类$(&#39;div&#39;).hasClass(&#39;c1&#39;)true&#x2F;&#x2F; 有则移除，无则添加$(&#39;div&#39;).toggleClass(&#39;c1&#39;)S.fn.init [div.c2.c3, prevObject: S.fn.init(1)]$(&#39;div&#39;).toggleClass(&#39;c1&#39;)S.fn.init [div.c2.c3.c1, prevObject: S.fn.init(1)]$(&#39;div&#39;).toggleClass(&#39;c1&#39;)S.fn.init [div.c2.c3, prevObject: S.fn.init(1)]</code></pre></div></figure><h2 id="2-2-操作CSS"><a href="#2-2-操作CSS" class="headerlink" title="2.2 操作CSS"></a>2.2 操作CSS</h2><p>JQuery操作CSS的方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 选择的标签.css(&#39;属性&#39;,&#39;值&#39;)&#x2F;&#x2F; 即：$(&#39;div&#39;).css(&#39;color&#39;,&#39;red&#39;)</code></pre></div></figure><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt;111&lt;&#x2F;p&gt;&lt;p&gt;222&lt;&#x2F;p&gt;&lt;p&gt;333&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>操作CSS：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 使第一个p标签，变为红色$(&#39;p&#39;).first().css(&#39;color&#39;,&#39;red&#39;)w.fn.init [p, prevObject: w.fn.init(3)]</code></pre></div></figure><p>也可以连起来操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 让第2个p标签变为绿色，让最后一个p标签变为黄色$(&#39;p&#39;).last().css(&#39;color&#39;,&#39;green&#39;).prev().css(&#39;color&#39;,&#39;yellow&#39;)w.fn.init [p, prevObject: w.fn.init(1)]</code></pre></div></figure><blockquote><p>补充：</p><p>为什么JQuery可以连起来操作？</p><p>因为操作完之后返回的还是JQuery对象</p><p>实际上是一种链式操作，用Python的方式还原，如下代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;class MyClass(object):   def func1(self):       print(&#39;func1&#39;)       return self   def func2(self):       print(&#39;func2&#39;)       return self&gt;obj &#x3D; MyClass()&gt;obj.func1().func2()</code></pre></div></figure></blockquote><h2 id="2-3-操作位置"><a href="#2-3-操作位置" class="headerlink" title="2.3 操作位置"></a>2.3 操作位置</h2><p>操作位置需要了解</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>offset()</td><td>相较于浏览器窗口，移动位置</td></tr><tr><td>position()</td><td>相对于父标签，移动位置</td></tr><tr><td>scrollTop()</td><td>获取&#x2F;设置滚动条的位置（左右）</td></tr><tr><td>scrollLeft()</td><td>获取&#x2F;设置滚动条的位置（上下）</td></tr></tbody></table><h3 id="2-3-1-offset-和position-案例"><a href="#2-3-1-offset-和position-案例" class="headerlink" title="2.3.1 offset()和position()案例"></a>2.3.1 offset()和position()案例</h3><p>页面代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;style&gt;        body &#123;            margin: 0;        &#125;        p &#123;            position: relative;            top: 100px;            left: 100px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt;ppp&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>操作代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; offset移动p标签$(&#39;p&#39;).offset(&#123;top:10,left:10&#125;)w.fn.init [p, prevObject: w.fn.init(1)]&#x2F;&#x2F; position获取标签的位置$(&#39;p&#39;).position()&#123;top: -6, left: 10&#125;</code></pre></div></figure><h3 id="2-3-2-scrollTop-案例"><a href="#2-3-2-scrollTop-案例" class="headerlink" title="2.3.2 scrollTop()案例"></a>2.3.2 scrollTop()案例</h3><p>页面代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;style&gt;        .c1 &#123;            width: 100%;            height: 500px;            background-color: red;        &#125;        .c2 &#123;            width: 100%;            height: 500px;            background-color: blue;        &#125;        .c3 &#123;            width: 100%;            height: 500px;            background-color: pink;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div class&#x3D;&quot;c1&quot;&gt;&lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;c2&quot;&gt;&lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;c3&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>获取当前窗口下拉框的位置</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(window).scrollTop()400</code></pre></div></figure><p>设置当前窗口下拉框的位置</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(window).scrollTop(20)w.fn.init [Window]</code></pre></div></figure><h2 id="2-4-操作尺寸"><a href="#2-4-操作尺寸" class="headerlink" title="2.4 操作尺寸"></a>2.4 操作尺寸</h2><p>操作标签尺寸的方法有如下：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>height()</td><td>设置标签内容的宽度</td></tr><tr><td>width()</td><td>设置标签内容的高度</td></tr><tr><td>innerHeight()</td><td>设置标签内高</td></tr><tr><td>innerWidth()</td><td>设置标签内宽</td></tr><tr><td>outerHeight()</td><td>设置标签外高</td></tr><tr><td>outerWidth()</td><td>设置标签外宽</td></tr></tbody></table><p>关于这些方法控制的位置，图示图下：</p><p><img src="/../../../img/image-20220825165519019.png" alt="image-20220825165519019"></p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 不加参数，获取标签宽度&#x2F;高度$(&#39;p&#39;).last().width()942$(&#39;p&#39;).last().innerHeight()21&#x2F;&#x2F; 指定参数，设置标签宽度&#x2F;高度$(&#39;p&#39;).last().innerHeight(300)w.fn.init [p, prevObject: w.fn.init(3)]</code></pre></div></figure><h2 id="2-5-文本操作"><a href="#2-5-文本操作" class="headerlink" title="2.5 文本操作"></a>2.5 文本操作</h2><p>主要方法如下</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>text()</td><td>获取标签内的文本</td></tr><tr><td>html()</td><td>获取标签内的HTML代码</td></tr></tbody></table><p>案例代码：</p><p>HTML:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;d1&quot;&gt;童稚    &lt;p class&#x3D;&quot;c1&quot;&gt;余忆童稚时&lt;&#x2F;p&gt;    &lt;p class&#x3D;&quot;c1&quot;&gt;能张目对日&lt;&#x2F;p&gt;    &lt;p class&#x3D;&quot;c1&quot;&gt;明察秋毫&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;p id&#x3D;&quot;d2&quot;&gt;222&lt;&#x2F;p&gt;&lt;p id&#x3D;&quot;d3&quot;&gt;333&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>JS:</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取标签内部文本$(&#39;#d1&#39;).text()&#39;童稚\n    余忆童稚时\n    能张目对日\n    明察秋毫\n&#39;&#x2F;&#x2F; 获取标签内部HTML代码$(&#39;#d1&#39;).html()&#39;童稚\n    &lt;p class&#x3D;&quot;c1&quot;&gt;余忆童稚时&lt;&#x2F;p&gt;\n    &lt;p class&#x3D;&quot;c1&quot;&gt;能张目对日&lt;&#x2F;p&gt;\n    &lt;p class&#x3D;&quot;c1&quot;&gt;明察秋毫&lt;&#x2F;p&gt;\n&#39;</code></pre></div></figure><h2 id="2-6-操作Value"><a href="#2-6-操作Value" class="headerlink" title="2.6 操作Value"></a>2.6 操作Value</h2><p>JQuery中使用<code>val()</code>方法获取<code>input</code>标签的<code>value</code>属性值</p><p>案例HTML代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div&gt;&lt;input id&#x3D;&quot;d1&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;测试&quot;&gt;&lt;&#x2F;div&gt;    &lt;div&gt;&lt;input id&#x3D;&quot;d2&quot; type&#x3D;&quot;file&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>普通输入框-值操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取标签d1的value值$(&#39;#d1&#39;).val()&#39;测试&#39;&#x2F;&#x2F; 设置标签d1的value值$(&#39;#d1&#39;).val(&#39;我换值了&#39;)w.fn.init [input#d1]</code></pre></div></figure><p>文件选择框的值操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取值$(&#39;#d2&#39;).val()&#39;C:\\fakepath\\TFile.txt&#39;&#x2F;&#x2F; 转换为文件对象$(&#39;#d2&#39;)[0].files[0]File &#123;name: &#39;TFile.txt&#39;, lastModified: 1661233436430, lastModifiedDate: Tue Aug 23 2022 13:43:56 GMT+0800 (中国标准时间), webkitRelativePath: &#39;&#39;, size: 797, …&#125;</code></pre></div></figure><h2 id="2-7-操作属性"><a href="#2-7-操作属性" class="headerlink" title="2.7 操作属性"></a>2.7 操作属性</h2><p>有如下方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>attr(name, value)</td><td>设置属性name的value</td></tr><tr><td>attr(name)</td><td>获取属性name的值</td></tr><tr><td>removeAttr(name)</td><td>移除name属性</td></tr></tbody></table><p>仍用2.6的HTML代码，操作案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取d1标签的id值$(&#39;#d1&#39;).attr(&#39;id&#39;)&#39;d1&#39;&#x2F;&#x2F; 将id值改为d3$(&#39;#d1&#39;).attr(&#39;id&#39;, &#39;d3&#39;)w.fn.init [input#d3]&#x2F;&#x2F; 再次获取标签d1的id值，获取失败，说明修改成功$(&#39;#d1&#39;).attr(&#39;id&#39;)undefined&#x2F;&#x2F; 获取标签d3的值，获取成功$(&#39;#d3&#39;).attr(&#39;id&#39;)&#39;d3&#39;&#x2F;&#x2F; 移除d3属性$(&#39;#d3&#39;).removeAttr(&#39;d3&#39;)w.fn.init [input#d3]&#x2F;&#x2F; 获取不到，说明移除成功           $(&#39;#d3&#39;).attr(&#39;d3&#39;)undefined</code></pre></div></figure><p>**<font color=red>特殊情况说明</font>**：</p><ul><li>对于标签上有的能够看到的属性和自定义属性用attr</li><li>对于返回布尔值比如checkbox radio option是否被选中用prop</li></ul><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div&gt;&lt;input id&#x3D;&quot;d1&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;测试&quot;&gt;&lt;&#x2F;div&gt;    &lt;div&gt;&lt;input id&#x3D;&quot;d2&quot; type&#x3D;&quot;file&quot;&gt;&lt;&#x2F;div&gt;    &lt;div&gt;        &lt;input type&#x3D;&quot;checkbox&quot;&gt;sel01        &lt;input id&#x3D;&quot;d3&quot; type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot;&gt;sel02        &lt;input id&#x3D;&quot;d4&quot; type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot;&gt;sel03    &lt;&#x2F;div&gt;    &lt;div&gt;        &lt;input id&#x3D;&quot;d5&quot; type&#x3D;&quot;radio&quot; &gt;Rad01        &lt;input id&#x3D;&quot;d6&quot; type&#x3D;&quot;radio&quot; checked&#x3D;&quot;checked&quot;&gt;Rad02        &lt;input type&#x3D;&quot;radio&quot; &gt;Rad03    &lt;&#x2F;div&gt;    &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;        &lt;option id&#x3D;&quot;d7&quot; value&#x3D;&quot;&quot;&gt;选择一&lt;&#x2F;option&gt;        &lt;option id&#x3D;&quot;d8&quot; value&#x3D;&quot;&quot; selected&#x3D;&quot;selected&quot;&gt;选择二&lt;&#x2F;option&gt;    &lt;&#x2F;select&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>什么问题？</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 用attr获取checkbox得值，能获取$(&quot;#d3&quot;).attr(&#39;checked&#39;)&#39;checked&#39;&#x2F;&#x2F; 设置值$(&quot;#d3&quot;).attr(&#39;checked&#39;, &#39;unchecked&#39;)w.fn.init [input#d3]&#x2F;&#x2F; 再次获取，设置是失败的，这就是问题$(&quot;#d3&quot;).attr(&#39;checked&#39;)&#39;checked&#39;</code></pre></div></figure><p>使用<code>prop()</code>尝试</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1、设置checkbox&#x2F;&#x2F; 获取值$(&quot;#d3&quot;).prop(&#39;checked&#39;)true&#x2F;&#x2F; 设置值$(&quot;#d3&quot;).prop(&#39;checked&#39;, false)w.fn.init [input#d3]$(&quot;#d3&quot;).prop(&#39;checked&#39;)false&#x2F;&#x2F; 2、设置radio$(&quot;#d5&quot;).prop(&#39;checked&#39;)false$(&quot;#d5&quot;).prop(&#39;checked&#39;, true)w.fn.init [input#d5]$(&quot;#d5&quot;).prop(&#39;checked&#39;)true&#x2F;&#x2F; 3、设置select的option$(&quot;#d8&quot;).prop(&#39;selected&#39;)true$(&quot;#d8&quot;).prop(&#39;selected&#39;, false)w.fn.init [option#d8]$(&quot;#d8&quot;).prop(&#39;selected&#39;)false</code></pre></div></figure><h2 id="2-8-文档处理"><a href="#2-8-文档处理" class="headerlink" title="2.8 文档处理"></a>2.8 文档处理</h2><p>文档处理常用操作</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>$(‘<p>‘)</td><td>创建标签，相当于JS的createElement(‘p’)</td></tr><tr><td>append($pEle)</td><td>内部尾部追加元素，相当于appendChild()</td></tr><tr><td>prepend($pEle)</td><td>内部头部追加元素</td></tr><tr><td>after($pEle)</td><td>放在某个标签后面</td></tr><tr><td>insertAfter($(‘#d1’))</td><td></td></tr><tr><td>before($pEle)</td><td>放在某个标签前面</td></tr><tr><td>$(‘#d1’).remove()</td><td>将标签从DOM树中删除</td></tr><tr><td>$(‘#d1’).empty()</td><td>清空标签内部所有的内容</td></tr></tbody></table><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let $pEle &#x3D; $(&#39;&lt;p&gt;&#39;)$pEle.text(&#39;你好啊 草莓要不要来几个?&#39;)$pEle.attr(&#39;id&#39;,&#39;d1&#39;)          $(&#39;#d1&#39;).append($pEle)  # 内部尾部追加$pEle.appendTo($(&#39;#d1&#39;))            $(&#39;#d1&#39;).prepend($pEle)  # 内部头部追加w.fn.init [div#d1]$pEle.prependTo($(&#39;#d1&#39;))w.fn.init [p#d1, prevObject: w.fn.init(1)]         $(&#39;#d2&#39;).after($pEle)  # 放在某个标签后面w.fn.init [p#d2]$pEle.insertAfter($(&#39;#d1&#39;))        $(&#39;#d1&#39;).before($pEle)w.fn.init [div#d1]$pEle.insertBefore($(&#39;#d2&#39;))$(&#39;#d1&#39;).remove()  # 将标签从DOM树中删除w.fn.init [div#d1]           $(&#39;#d1&#39;).empty()  # 清空标签内部所有的内容w.fn.init [div#d1]</code></pre></div></figure><h1 id="3-JQuery事件"><a href="#3-JQuery事件" class="headerlink" title="3 JQuery事件"></a>3 JQuery事件</h1><h2 id="3-1-事件触发"><a href="#3-1-事件触发" class="headerlink" title="3.1 事件触发"></a>3.1 事件触发</h2><p>触发事件有两种方式</p><p>第一种</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#d1&#39;).click(function () &#123;    alert(&#39;别说话 吻我&#39;)&#125;);</code></pre></div></figure><p>第二种(功能更加强大 还支持事件委托)</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">$(&#39;#d2&#39;).on(&#39;click&#39;,function () &#123;    alert(&#39;借我钱买草莓 后面还你&#39;)&#125;)</code></pre></div></figure><h2 id="3-2-克隆事件"><a href="#3-2-克隆事件" class="headerlink" title="3.2 克隆事件"></a>3.2 克隆事件</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;button id&#x3D;&quot;d1&quot;&gt;屠龙宝刀，点击就送&lt;&#x2F;button&gt;&lt;script&gt;    $(&#39;#d1&#39;).on(&#39;click&#39;,function () &#123;        &#x2F;&#x2F; console.log(this)  &#x2F;&#x2F; this指代是当前被操作的标签对象        &#x2F;&#x2F; $(this).clone().insertAfter($(&#39;body&#39;))  &#x2F;&#x2F; clone默认情况下只克隆html和css 不克隆事件        $(this).clone(true).insertAfter($(&#39;body&#39;))  &#x2F;&#x2F; 括号内加true即可克隆事件    &#125;)&lt;&#x2F;script&gt;</code></pre></div></figure><h2 id="3-3-自定义模态框"><a href="#3-3-自定义模态框" class="headerlink" title="3.3 自定义模态框"></a>3.3 自定义模态框</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;模态框内部本质就是给标签移除或者添加上hide属性&quot;&quot;&quot;</code></pre></div></figure><ul><li><p>左侧菜单</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script&gt;    $(&#39;.title&#39;).click(function () &#123;        &#x2F;&#x2F; 先给所有的items加hide        $(&#39;.items&#39;).addClass(&#39;hide&#39;)        &#x2F;&#x2F; 然后将被点击标签内部的hide移除        $(this).children().removeClass(&#39;hide&#39;)    &#125;)&lt;&#x2F;script&gt;&lt;!--尝试用一行代码搞定上面的操作--&gt;</code></pre></div></figure></li><li><p>返回顶部</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;script&gt;    $(window).scroll(function () &#123;        if($(window).scrollTop() &gt; 300)&#123;            $(&#39;#d1&#39;).removeClass(&#39;hide&#39;)        &#125;else&#123;            $(&#39;#d1&#39;).addClass(&#39;hide&#39;)        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre></div></figure></li><li><p>自定义登陆校验</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在获取用户的用户名和密码的时候 用户如果没有填写 应该给用户展示提示信息&lt;p&gt;username:    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot;&gt;    &lt;span style&#x3D;&quot;color: red&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;p&gt;password:    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;password&quot;&gt;    &lt;span style&#x3D;&quot;color: red&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;button id&#x3D;&quot;d1&quot;&gt;提交&lt;&#x2F;button&gt;&lt;script&gt;    let $userName &#x3D; $(&#39;#username&#39;)    let $passWord &#x3D; $(&#39;#password&#39;)    $(&#39;#d1&#39;).click(function () &#123;        &#x2F;&#x2F; 获取用户输入的用户名和密码 做校验        let userName &#x3D; $userName.val()        let passWord &#x3D; $passWord.val()        if (!userName)&#123;            $userName.next().text(&quot;用户名不能为空&quot;)        &#125;        if (!passWord)&#123;            $passWord.next().text(&#39;密码不能为空&#39;)        &#125;    &#125;)    $(&#39;input&#39;).focus(function () &#123;        $(this).next().text(&#39;&#39;)    &#125;)&lt;&#x2F;script&gt;</code></pre></div></figure></li><li><p>input实时监控</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;d1&quot;&gt;&lt;script&gt;    $(&#39;#d1&#39;).on(&#39;input&#39;,function () &#123;        console.log(this.value)      &#125;)&lt;&#x2F;script&gt;</code></pre></div></figure></li><li><p>hover事件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;script&gt;    &#x2F;&#x2F; $(&quot;#d1&quot;).hover(function () &#123;  &#x2F;&#x2F; 鼠标悬浮 + 鼠标移开    &#x2F;&#x2F;     alert(123)    &#x2F;&#x2F; &#125;)    $(&#39;#d1&#39;).hover(        function () &#123;            alert(&#39;我来了&#39;)  &#x2F;&#x2F; 悬浮    &#125;,        function () &#123;            alert(&#39;我溜了&#39;)  &#x2F;&#x2F; 移开        &#125;    )&lt;&#x2F;script&gt;</code></pre></div></figure></li><li><p>键盘按键按下事件</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script&gt;    $(window).keydown(function (event) &#123;        console.log(event.keyCode)        if (event.keyCode &#x3D;&#x3D;&#x3D; 16)&#123;            alert(&#39;你按了shift键&#39;)        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre></div></figure></li></ul><h2 id="3-4-阻止后续事件执行"><a href="#3-4-阻止后续事件执行" class="headerlink" title="3.4 阻止后续事件执行"></a>3.4 阻止后续事件执行</h2><p>以案例说明，点击按钮后，本应将span(d1)的文本设置成’宝贝 你能看到我吗?’，但由于后续submit的提交事件执行，页面将刷新，导致设置的文本消失：</p><p>提交前：</p><p><img src="/../../../img/image-20220831151405792.png" alt="image-20220831151405792"></p><p>提交后：</p><p><img src="/../../../img/image-20220831151419650.png" alt="image-20220831151419650"></p><p>半秒后：</p><p><img src="/../../../img/image-20220831151405792.png" alt="image-20220831151405792"></p><p>如何解决这个问题，停止后续的submit操作？</p><ul><li>return false</li><li>e.preventDefault()</li></ul><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action&#x3D;&quot;&quot;&gt;    &lt;span id&#x3D;&quot;d1&quot; style&#x3D;&quot;color: red&quot;&gt;&lt;&#x2F;span&gt;    &lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;d2&quot;&gt;&lt;&#x2F;form&gt;&lt;script&gt;    $(&#39;#d2&#39;).click(function (e) &#123;        $(&#39;#d1&#39;).text(&#39;宝贝 你能看到我吗?&#39;)        &#x2F;&#x2F; 阻止标签后续事件的执行 方式1        &#x2F;&#x2F; return false        &#x2F;&#x2F; 阻止标签后续事件的执行 方式2        &#x2F;&#x2F; e.preventDefault()    &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h2 id="3-5-阻止事件冒泡"><a href="#3-5-阻止事件冒泡" class="headerlink" title="3.5 阻止事件冒泡"></a>3.5 阻止事件冒泡</h2><p>以案例说明，由于d1、d2、 d3是嵌套关系，当点击d3触发click事件后，页面显示alert(‘span’)，然后alert(‘p’)，最后alert(‘div’)，将alert三次。</p><p>怎么解决这个问题，实现只触发#d3的alert？</p><ul><li>return false</li><li>e.stopPropagation()</li></ul><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;d1&quot;&gt;div        &lt;p id&#x3D;&quot;d2&quot;&gt;div&gt;p            &lt;span id&#x3D;&quot;d3&quot;&gt;span&lt;&#x2F;span&gt;        &lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;    &lt;script&gt;        $(&#39;#d1&#39;).click(function () &#123;            alert(&#39;div&#39;)        &#125;)        $(&#39;#d2&#39;).click(function () &#123;            alert(&#39;p&#39;)        &#125;)        $(&#39;#d3&#39;).click(function (e) &#123;            alert(&#39;span&#39;)            &#x2F;&#x2F; 阻止事件冒泡的方式1            &#x2F;&#x2F; return false            &#x2F;&#x2F; 阻止事件冒泡的方式2            &#x2F;&#x2F; e.stopPropagation()        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h2 id="3-6-事件委托"><a href="#3-6-事件委托" class="headerlink" title="3.6 事件委托"></a>3.6 事件委托</h2><p>正常情况下，我们帮一个按钮添加点击事件，只需给按钮绑定事件即可，即：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;button&#39;).click(function () &#123;  &#x2F;&#x2F; 无法影响到动态创建的标签     alert(123)&#125;)</code></pre></div></figure><p>但是，假如我们动态创建了button按钮，这种绑定方式对<code>后续动态生成的button</code>是<code>无效的</code></p><p>需要使用事件委托:</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 事件委托$(&#39;body&#39;).on(&#39;click&#39;,&#39;button&#39;,function () &#123;    alert(123)  &#x2F;&#x2F; 在指定的范围内 将事件委托给某个标签 无论该标签是事先写好的还是后面动态创建的&#125;)</code></pre></div></figure><h1 id="4-补充"><a href="#4-补充" class="headerlink" title="4 补充"></a>4 补充</h1><h2 id="4-1-页面加载"><a href="#4-1-页面加载" class="headerlink" title="4.1 页面加载"></a>4.1 页面加载</h2><p>等页面元素加载完毕后，再调用JS代码。</p><p>在原生JS中，我们使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 方法一window.onload &#x3D; function()&#123;  &#x2F;&#x2F; js代码&#125;&#x2F;&#x2F; 方法二直接写在body最下方</code></pre></div></figure><p>在JQuery中有三种方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 第一种$(document).ready(function()&#123;  &#x2F;&#x2F; js代码&#125;)&#x2F;&#x2F; 第二种$(function()&#123;  &#x2F;&#x2F; js代码&#125;)&#x2F;&#x2F; 第三种直接写在body内部最下方</code></pre></div></figure><h2 id="4-2-动画效果"><a href="#4-2-动画效果" class="headerlink" title="4.2 动画效果"></a>4.2 动画效果</h2><p>给元素添加<code>淡入淡出</code>、<code>隐藏/出现</code>等效果</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#d1&#39;).hide(5000)w.fn.init [div#d1]$(&#39;#d1&#39;).show(5000)w.fn.init [div#d1]$(&#39;#d1&#39;).slideUp(5000)w.fn.init [div#d1]$(&#39;#d1&#39;).slideDown(5000)w.fn.init [div#d1]$(&#39;#d1&#39;).fadeOut(5000)w.fn.init [div#d1]$(&#39;#d1&#39;).fadeIn(5000)w.fn.init [div#d1]$(&#39;#d1&#39;).fadeTo(5000,0.4)w.fn.init [div#d1]   </code></pre></div></figure><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;3.4.1&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;style&gt;        #d1 &#123;            height: 1000px;            width: 400px;            background-color: red;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;d1&quot;&gt;&lt;&#x2F;div&gt;    &lt;div&gt;&lt;button id&#x3D;&quot;d2&quot;&gt;别按我！&lt;&#x2F;button&gt;&lt;button id&#x3D;&quot;d3&quot;&gt;再按就生气了~！&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;    &lt;script&gt;        $(&quot;#d2&quot;).click(            function() &#123;                $(&quot;#d1&quot;).hide(5000)&#x2F;&#x2F; 5秒动画-消失            &#125;        )        $(&quot;#d3&quot;).click(            function() &#123;                $(&quot;#d1&quot;).show(5000) &#x2F;&#x2F; 5秒动画-出现                            &#125;        )    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h2 id="4-3-遍历元素"><a href="#4-3-遍历元素" class="headerlink" title="4.3 遍历元素"></a>4.3 遍历元素</h2><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"># each()# 第一种方式$(&#39;div&#39;)w.fn.init(10) [div, div, div, div, div, div, div, div, div, div, prevObject: w.fn.init(1)]$(&#39;div&#39;).each(function(index)&#123;console.log(index)&#125;)VM181:1 0VM181:1 1VM181:1 2VM181:1 3VM181:1 4VM181:1 5VM181:1 6VM181:1 7VM181:1 8VM181:1 9$(&#39;div&#39;).each(function(index,obj)&#123;console.log(index,obj)&#125;)VM243:1 0 &lt;div&gt;​1​&lt;&#x2F;div&gt;​VM243:1 1 &lt;div&gt;​2​&lt;&#x2F;div&gt;​VM243:1 2 &lt;div&gt;​3​&lt;&#x2F;div&gt;​VM243:1 3 &lt;div&gt;​4​&lt;&#x2F;div&gt;​VM243:1 4 &lt;div&gt;​5​&lt;&#x2F;div&gt;​VM243:1 5 &lt;div&gt;​6​&lt;&#x2F;div&gt;​VM243:1 6 &lt;div&gt;​7​&lt;&#x2F;div&gt;​VM243:1 7 &lt;div&gt;​8​&lt;&#x2F;div&gt;​VM243:1 8 &lt;div&gt;​9​&lt;&#x2F;div&gt;​VM243:1 9 &lt;div&gt;​10​&lt;&#x2F;div&gt;​# 第二种方式$.each([111,222,333],function(index,obj)&#123;console.log(index,obj)&#125;)VM484:1 0 111VM484:1 1 222VM484:1 2 333(3) [111, 222, 333]&quot;&quot;&quot;有了each之后 就无需自己写for循环了 用它更加的方便&quot;&quot;&quot;# data()&quot;&quot;&quot;能够让标签帮我们存储数据 并且用户肉眼看不见&quot;&quot;&quot;$(&#39;div&#39;).data(&#39;info&#39;,&#39;回来吧，我原谅你了!&#39;)w.fn.init(10) [div#d1, div, div, div, div, div, div, div, div, div, prevObject: w.fn.init(1)]               $(&#39;div&#39;).first().data(&#39;info&#39;)&quot;回来吧，我原谅你了!&quot;$(&#39;div&#39;).last().data(&#39;info&#39;)&quot;回来吧，我原谅你了!&quot;               $(&#39;div&#39;).first().data(&#39;xxx&#39;)undefined$(&#39;div&#39;).first().removeData(&#39;info&#39;)w.fn.init [div#d1, prevObject: w.fn.init(10)]           $(&#39;div&#39;).first().data(&#39;info&#39;)undefined$(&#39;div&#39;).last().data(&#39;info&#39;)&quot;回来吧，我原谅你了!&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>07_JQuery</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day58-Bootstrap</title>
    <link href="/2022/08/25/03_Python/04_%E5%89%8D%E7%AB%AF/day58%E7%AC%94%E8%AE%B0-Bootstrap/"/>
    <url>/2022/08/25/03_Python/04_%E5%89%8D%E7%AB%AF/day58%E7%AC%94%E8%AE%B0-Bootstrap/</url>
    
    <content type="html"><![CDATA[<p>“第58天Bootstrap学习笔记”</p><h1 id="1-什么是Bootstrap"><a href="#1-什么是Bootstrap" class="headerlink" title="1 什么是Bootstrap"></a>1 什么是Bootstrap</h1><p>&lt;部分没有练习，但已知道用途，后续可按实际需要使用&gt;</p><p>该框架已经帮你写好了很多页面样式，你如果需要使用，只需要下载它对应文件，之后直接cv拷贝即可</p><p>在使用Bootstrap的时候所有的页面样式都只需要你通过class来调节即可</p><p>版本选择建议使用v3版本：<a href="https://v3.bootcss.com/">https://v3.bootcss.com/</a></p><blockquote><p><font color=red>–注意–</font></p><p><strong>bootstrap的js代码是依赖于jQuery的，也就意味着你在使用Bootstrap动态效果的时候，一定要导入jQuery</strong></p></blockquote><h1 id="2-使用Bootstrap"><a href="#2-使用Bootstrap" class="headerlink" title="2 使用Bootstrap"></a>2 使用Bootstrap</h1><h2 id="2-1-布局容器"><a href="#2-1-布局容器" class="headerlink" title="2.1 布局容器"></a>2.1 布局容器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;div class&#x3D;&quot;container&quot;&gt;    左右两侧有留白&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;container-fluid&quot;&gt;左右两侧没有留白&lt;&#x2F;div&gt;# 后续在使用bootstrap做页面的时候 上来先写一个div class&#x3D;container,之后在div内部书写页面</code></pre></div></figure><h2 id="2-2-栅格系统"><a href="#2-2-栅格系统" class="headerlink" title="2.2 栅格系统"></a>2.2 栅格系统</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;div class&#x3D;&quot;row&quot;&gt;&lt;&#x2F;div&gt;写一个row就是将所在的区域划分成12份&lt;div class&#x3D;&quot;col-md-6 &quot;&gt;  获取你所要的份数# 在使用bootstrap的时候 脑子里面一定要做12的加减法</code></pre></div></figure><h2 id="2-3-栅格参数"><a href="#2-3-栅格参数" class="headerlink" title="2.3 栅格参数"></a>2.3 栅格参数</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">.col-xs-.col-sm-.col-md-.col-lg-# 针对不同的显示器 bootstrap会自动选择对应的参数# 如果你想要兼容所有的显示器 你就全部加上即可# 在一行如何移动位置&lt;div class&#x3D;&quot;col-md-8 c1 col-md-offset-2&quot;&gt;&lt;&#x2F;div&gt;</code></pre></div></figure><h2 id="2-4-排版"><a href="#2-4-排版" class="headerlink" title="2.4 排版"></a>2.4 排版</h2><p>bootstrap将所有原生的HTML标签的文本字体统一设置成了肉眼可以接受的样式</p><p>效果一样，但是标签表达的意思不一样（语义）</p><h2 id="2-5-表格"><a href="#2-5-表格" class="headerlink" title="2.5 表格"></a>2.5 表格</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;table class&#x3D;&quot;table table-hover table-striped table-bordered&quot;&gt;&lt;tr class&#x3D;&quot;success&quot;&gt;            &lt;td&gt;1&lt;&#x2F;td&gt;            &lt;td&gt;jason&lt;&#x2F;td&gt;            &lt;td&gt;123&lt;&#x2F;td&gt;            &lt;td&gt;study&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr class&#x3D;&quot;active&quot;&gt;...&lt;&#x2F;tr&gt;&lt;tr class&#x3D;&quot;success&quot;&gt;...&lt;&#x2F;tr&gt;&lt;tr class&#x3D;&quot;warning&quot;&gt;...&lt;&#x2F;tr&gt;&lt;tr class&#x3D;&quot;danger&quot;&gt;...&lt;&#x2F;tr&gt;&lt;tr class&#x3D;&quot;info&quot;&gt;...&lt;&#x2F;tr&gt;</code></pre></div></figure><h2 id="2-6-表单"><a href="#2-6-表单" class="headerlink" title="2.6 表单"></a>2.6 表单</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;div class&#x3D;&quot;container&quot;&gt;    &lt;div class&#x3D;&quot;col-md-8 col-md-offset-2&quot;&gt;        &lt;h2 class&#x3D;&quot;text-center&quot;&gt;登陆页面&lt;&#x2F;h2&gt;        &lt;form action&#x3D;&quot;&quot;&gt;            &lt;p&gt;username:&lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot;&gt;&lt;&#x2F;p&gt;            &lt;p&gt;password:&lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot;&gt;&lt;&#x2F;p&gt;            &lt;p&gt;                &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; class&#x3D;&quot;form-control&quot;&gt;                    &lt;option value&#x3D;&quot;&quot;&gt;111&lt;&#x2F;option&gt;                    &lt;option value&#x3D;&quot;&quot;&gt;222&lt;&#x2F;option&gt;                    &lt;option value&#x3D;&quot;&quot;&gt;333&lt;&#x2F;option&gt;                &lt;&#x2F;select&gt;            &lt;&#x2F;p&gt;            &lt;textarea name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; cols&#x3D;&quot;30&quot; rows&#x3D;&quot;10&quot; class&#x3D;&quot;form-control&quot;&gt;&lt;&#x2F;textarea&gt;            &lt;input type&#x3D;&quot;submit&quot;&gt;        &lt;&#x2F;form&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;# 针对表单标签 加样式就用form-controlclass&#x3D;&quot;form-control&quot;&quot;&quot;&quot;&lt;input type&#x3D;&quot;checkbox&quot;&gt;222&lt;input type&#x3D;&quot;radio&quot;&gt;333checkbox和radio我们一般不会给它加form-control，直接使用原生的即可&quot;&quot;&quot;# 针对报错信息 可以加has-error（input的父标签加）&lt;p class&#x3D;&quot;has-error&quot;&gt;username:  &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot;&gt;&lt;&#x2F;p&gt;</code></pre></div></figure><h2 id="2-7-按钮"><a href="#2-7-按钮" class="headerlink" title="2.7 按钮"></a>2.7 按钮</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.mzitu.com&#x2F;&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;点我&lt;&#x2F;a&gt;&lt;button class&#x3D;&quot;btn btn-danger&quot;&gt;按我&lt;&#x2F;button&gt;&lt;button class&#x3D;&quot;btn btn-default&quot;&gt;按我&lt;&#x2F;button&gt;&lt;button class&#x3D;&quot;btn btn-success&quot;&gt;按我&lt;&#x2F;button&gt;&lt;button class&#x3D;&quot;btn btn-info&quot;&gt;按我&lt;&#x2F;button&gt;&lt;button class&#x3D;&quot;btn btn-warning&quot;&gt;按我&lt;&#x2F;button&gt;&lt;button class&#x3D;&quot;btn btn-warning btn-lg&quot;&gt;按我&lt;&#x2F;button&gt;&lt;button class&#x3D;&quot;btn btn-warning btn-sm&quot;&gt;按我&lt;&#x2F;button&gt;&lt;button class&#x3D;&quot;btn btn-warning btn-xs&quot;&gt;按我&lt;&#x2F;button&gt;&lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary btn-block&quot;&gt;  通过给按钮添加 .btn-block 类可以将其拉伸至父元素100%的宽度，而且按钮也变为了块级（block）元素。</code></pre></div></figure><h2 id="2-8-图表"><a href="#2-8-图表" class="headerlink" title="2.8 图表"></a>2.8 图表</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;h2 class&#x3D;&quot;text-center&quot;&gt;登陆页面 &lt;span class&#x3D;&quot;glyphicon glyphicon-user&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;h2&gt;    &lt;style&gt;        span &#123;            color: greenyellow;        &#125;    &lt;&#x2F;style&gt;# 扩展</code></pre></div></figure><h2 id="2-9-导航条"><a href="#2-9-导航条" class="headerlink" title="2.9 导航条"></a>2.9 导航条</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;nav class&#x3D;&quot;navbar navbar-inverse&quot;&gt;&lt;nav class&#x3D;&quot;navbar navbar-default&quot;&gt;</code></pre></div></figure><h2 id="2-10-分页器"><a href="#2-10-分页器" class="headerlink" title="2.10 分页器"></a>2.10 分页器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;nav aria-label&#x3D;&quot;Page navigation&quot;&gt;  &lt;ul class&#x3D;&quot;pagination&quot;&gt;    &lt;li&gt;      &lt;a href&#x3D;&quot;#&quot; aria-label&#x3D;&quot;Previous&quot;&gt;        &lt;span aria-hidden&#x3D;&quot;true&quot;&gt;&laquo;&lt;&#x2F;span&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;li&gt;    &lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    &lt;li&gt;      &lt;a href&#x3D;&quot;#&quot; aria-label&#x3D;&quot;Next&quot;&gt;        &lt;span aria-hidden&#x3D;&quot;true&quot;&gt;&raquo;&lt;&#x2F;span&gt;      &lt;&#x2F;a&gt;    &lt;&#x2F;li&gt;  &lt;&#x2F;ul&gt;&lt;&#x2F;nav&gt;</code></pre></div></figure><h2 id="2-11-弹框"><a href="#2-11-弹框" class="headerlink" title="2.11 弹框"></a>2.11 弹框</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">https:&#x2F;&#x2F;lipis.github.io&#x2F;bootstrap-sweetalert&#x2F;    swal(&#39;你还好吗?&#39;)undefinedswal(&#39;你还好吗?&#39;)undefinedswal(&#39;你还好吗?&#39;,&#39;我不好，想你了!&#39;)undefinedswal(&#39;你还好吗?&#39;,&#39;我不好，想你了!&#39;,&#39;success&#39;)undefinedswal(&#39;你还好吗?&#39;,&#39;我不好，想你了!&#39;,&#39;warning&#39;)undefinedswal(&#39;你还好吗?&#39;,&#39;我不好，想你了!&#39;,&#39;error&#39;)undefinedswal(&#39;你还好吗?&#39;,&#39;我不好，想你了!&#39;,&#39;info&#39;)undefined# 我们在后面的课程中 还会涉及到该部分内容</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>08_BootStrap</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day56-JQuery-01</title>
    <link href="/2022/08/22/03_Python/04_%E5%89%8D%E7%AB%AF/day56%E7%AC%94%E8%AE%B0-JQuery-01/"/>
    <url>/2022/08/22/03_Python/04_%E5%89%8D%E7%AB%AF/day56%E7%AC%94%E8%AE%B0-JQuery-01/</url>
    
    <content type="html"><![CDATA[<p>“第56天JQuery（01）学习笔记”</p><h1 id="1-JQuery介绍"><a href="#1-JQuery介绍" class="headerlink" title="1 JQuery介绍"></a>1 JQuery介绍</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>什么是JQuery？</p><ul><li>jQuery内部封装了原生的js代码(还额外添加了很多的功能)</li><li>能够让你通过书写更少的代码 完成js操作 </li><li>类似于python里面的模块  在前端模块不叫模块  叫 “类库”</li></ul><p>JQuery的宗旨：</p><p>​write less do more</p><p>JQuery选择：</p><p>​jquery.js未压缩的版本</p><p>​jquery.min.js压缩后的版本（推荐）</p><h2 id="1-2-导入JQuery"><a href="#1-2-导入JQuery" class="headerlink" title="1.2 导入JQuery"></a>1.2 导入JQuery</h2><p>导入JQuery有两种方式</p><h3 id="1-2-1-本地方式导入："><a href="#1-2-1-本地方式导入：" class="headerlink" title="1.2.1 本地方式导入："></a>1.2.1 本地方式导入：</h3><p>到JQuery官网获取JQuery的JS文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">https:&#x2F;&#x2F;jquery.com&#x2F;</code></pre></div></figure><p>在HTML中导入文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;script src&#x3D;&quot;js&#x2F;jquery-3.6.0.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h3 id="1-2-2-网络CDN导入-需要网络"><a href="#1-2-2-网络CDN导入-需要网络" class="headerlink" title="1.2.2 网络CDN导入(需要网络)"></a>1.2.2 网络CDN导入(需要网络)</h3><p>前端免费的cdn网站: </p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">https:&#x2F;&#x2F;www.bootcdn.cn&#x2F;</code></pre></div></figure><p>导入方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre></div></figure><h2 id="1-3-JQuery的简单使用"><a href="#1-3-JQuery的简单使用" class="headerlink" title="1.3 JQuery的简单使用"></a>1.3 JQuery的简单使用</h2><h3 id="1-3-1-基本语法"><a href="#1-3-1-基本语法" class="headerlink" title="1.3.1 基本语法"></a>1.3.1 基本语法</h3><p>使用JQuery有两种方式：</p><p>第一种</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">jQuery(选择器).action()</code></pre></div></figure><p>第二种</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(选择器).action()</code></pre></div></figure><p>两种方法是等价的，推荐<font color=red>第二种</font></p><h3 id="1-3-2-JQuery与JavaScript的语法对比"><a href="#1-3-2-JQuery与JavaScript的语法对比" class="headerlink" title="1.3.2 JQuery与JavaScript的语法对比"></a>1.3.2 JQuery与JavaScript的语法对比</h3><p>通过案例可见，实现相同的功能，使用JQuery后，代码量确实可以减少</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; JS原生代码d1Ele &#x3D; document.getElementById(&#39;d1&#39;)d1Ele.style.color &#x3D; &#39;red&#39;&#x2F;&#x2F; 使用JQuery$(&#39;#d1&#39;).css(&#39;color&#39;,&#39;red&#39;)</code></pre></div></figure><h1 id="2-JQuery的使用"><a href="#2-JQuery的使用" class="headerlink" title="2 JQuery的使用"></a>2 JQuery的使用</h1><h2 id="2-1-标签查找"><a href="#2-1-标签查找" class="headerlink" title="2.1 标签查找"></a>2.1 标签查找</h2><p>通过下面的案例，演示标签查找</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;script src&#x3D;&quot;jquery-3.6.0.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;d1&quot;&gt;d1div        &lt;span&gt;d1div-span&lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;c1&quot;&gt;c1div&lt;&#x2F;div&gt;    &lt;span&gt;span&lt;&#x2F;span&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>id选择器</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#d1&#39;)S.fn.init [div#d1]&#x2F;&#x2F; 找到一个JQuery对象</code></pre></div></figure><p>class选择器</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;.c1&#39;)S.fn.init [div.c1, prevObject: S.fn.init(1)]&#x2F;&#x2F; 找到一个JQuery对象</code></pre></div></figure><p>标签选择器</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;span&#39;)S.fn.init(2) [span, span, prevObject: S.fn.init(1)]&#x2F;&#x2F; 找到两个JQuery对象</code></pre></div></figure><p><strong><font color=blue>发现我们查找到的并不是标签，而是<code>JQuery对象</code>，那么如何才能将<code>JQuery对象</code>转换成<code>标签对象</code>呢？</font></strong></p><p>JQuery对象和标签对象的互相转换</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; JQuery对象转换成标签对象$(&#39;#d1&#39;)[0]&lt;div id&#x3D;​&quot;d1&quot;&gt;​…​&lt;&#x2F;div&gt;​&quot;d1div &quot;&lt;span&gt;​d1div-span​&lt;&#x2F;span&gt;​&lt;&#x2F;div&gt;​&#x2F;&#x2F; 标签对象转换成JQuery对象$(document.getElementById(&#39;d1&#39;))S.fn.init [div#d1]</code></pre></div></figure><h2 id="2-2-组合选择器-分组与嵌套"><a href="#2-2-组合选择器-分组与嵌套" class="headerlink" title="2.2 组合选择器&#x2F;分组与嵌套"></a>2.2 组合选择器&#x2F;分组与嵌套</h2><p>组合选择器的使用和CSS的选择器基本相同</p><p>组合选择器</p><table><thead><tr><th>选择器</th><th>作用</th></tr></thead><tbody><tr><td>$(‘div’)</td><td>基本选择器，选择div标签</td></tr><tr><td>$(‘div.c1’)</td><td>选择class名为c1的div标签</td></tr><tr><td>$(‘div#d1’)</td><td>选择id名为d1的div标签</td></tr><tr><td>$(‘*’)</td><td>通用选择器，选择所有标签</td></tr><tr><td>$(‘#d1,.c1,p’)</td><td>组合选择器，选择id名为d1的标签、class名为c1的标签、所有p标签</td></tr></tbody></table><p>分组与嵌套</p><table><thead><tr><th>选择器</th><th>作用</th></tr></thead><tbody><tr><td>$(‘div span’)</td><td>后代选择器，选择div的所有后代span</td></tr><tr><td>$(‘div&gt;span’)</td><td>儿子选择器，选择div的儿子span (孙子辈就不算了)</td></tr><tr><td>$(‘div+span’)</td><td>毗邻选择器，选择<code>紧接</code>在<code>指定元素</code>后的元素，且二者有相同父元素。</td></tr><tr><td>$(‘div~span’)</td><td>弟弟选择器，选择<code>指定元素</code>后的元素，且二者有相同父元素。</td></tr></tbody></table><p>分组与嵌套通过一个案例演示</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;script src&#x3D;&quot;jquery-3.6.0.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;span class&#x3D;&quot;c1&quot;&gt;c1-span&lt;&#x2F;span&gt;    &lt;div id&#x3D;&quot;d1&quot;&gt;d1        &lt;div id&#x3D;&quot;d2&quot;&gt;d2            &lt;div id&#x3D;&quot;d3&quot;&gt;d3&lt;span&gt;d3-span&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div id&#x3D;&quot;d4&quot;&gt;d4&lt;&#x2F;div&gt;    &lt;span class&#x3D;&quot;c2&quot;&gt;c2span&lt;&#x2F;span&gt;    &lt;span class&#x3D;&quot;c3&quot;&gt;c3span&lt;&#x2F;span&gt;    &lt;div id&#x3D;&quot;d5&quot;&gt;d5        &lt;div id&#x3D;&quot;d6&quot;&gt;d6&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div id&#x3D;&quot;d7&quot;&gt;d7        &lt;span&gt;d7-span            &lt;span&gt;                d7-span-span            &lt;&#x2F;span&gt;        &lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>查找div的后代span</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 找到3个$(&#39;div span&#39;)S.fn.init(3) [span, span, span, prevObject: S.fn.init(1)]&#x2F;&#x2F; 分别是$(&#39;div span&#39;)[0]&lt;span&gt;​d3-span​&lt;&#x2F;span&gt;​$(&#39;div span&#39;)[1]&lt;span&gt;​&quot;d7-span &quot;&lt;span&gt;​ d7-span-span ​&lt;&#x2F;span&gt;​&lt;&#x2F;span&gt;​$(&#39;div span&#39;)[2]&lt;span&gt;​ d7-span-span ​&lt;&#x2F;span&gt;​</code></pre></div></figure><p>查找div的儿子span</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 查到2个$(&#39;div&gt;span&#39;)S.fn.init(2) [span, span, prevObject: S.fn.init(1)]&#x2F;&#x2F; 分别是$(&#39;div&gt;span&#39;)[0]&lt;span&gt;​d3-span​&lt;&#x2F;span&gt;​$(&#39;div&gt;span&#39;)[1]&lt;span&gt;​&quot;d7-span &quot;&lt;span&gt;​ d7-span-span ​&lt;&#x2F;span&gt;​&lt;&#x2F;span&gt;​&#x2F;&#x2F; 为什么比后代少1个？因为d7-span-span已经是孙子辈了，不在&quot;儿子&quot;里面</code></pre></div></figure><p>查找div的毗邻span</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 只能找到1个$(&#39;div+span&#39;)S.fn.init [span.c2, prevObject: S.fn.init(1)]0: span.c2length: 1prevObject: S.fn.init [document][[Prototype]]: Object(0)&#x2F;&#x2F; d4紧接着的c2span$(&#39;div+span&#39;)[0]&lt;span class&#x3D;​&quot;c2&quot;&gt;​c2span​&lt;&#x2F;span&gt;​</code></pre></div></figure><p>查找div的弟弟span</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 可以找到2个$(&#39;div~span&#39;)S.fn.init(2) [span.c2, span.c3, prevObject: S.fn.init(1)]&#x2F;&#x2F; 分别是$(&#39;div~span&#39;)[0]&lt;span class&#x3D;​&quot;c2&quot;&gt;​c2span​&lt;&#x2F;span&gt;​$(&#39;div~span&#39;)[1]&lt;span class&#x3D;​&quot;c3&quot;&gt;​c3span​&lt;&#x2F;span&gt;​&#x2F;&#x2F; 为什么会比毗邻多一个？因为毗邻只算紧接的第一个，而弟弟可以算全部</code></pre></div></figure><h2 id="2-3-基本筛选器"><a href="#2-3-基本筛选器" class="headerlink" title="2.3 基本筛选器"></a>2.3 基本筛选器</h2><p>以ul li为例子，演示基本筛选器的使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;ul&gt;爸爸        &lt;li&gt;儿子01&lt;&#x2F;li&gt;        &lt;li id&#x3D;&#39;d1&#39;&gt;儿子02&lt;&#x2F;li&gt;        &lt;li&gt;儿子03&lt;&#x2F;li&gt;        &lt;li&gt;儿子04&lt;&#x2F;li&gt;        &lt;li&gt;儿子05&lt;&#x2F;li&gt;        &lt;li&gt;儿子06&lt;&#x2F;li&gt;        &lt;li&gt;儿子07&lt;&#x2F;li&gt;        &lt;li&gt;儿子08&lt;&#x2F;li&gt;        &lt;li&gt;儿子09&lt;&#x2F;li&gt;        &lt;li&gt;儿子10&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>使用基本筛选器</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1、获取ul下的所有li$(&#39;ul li&#39;)S.fn.init(10) [li, li, li, li, li, li, li, li, li, li, prevObject: S.fn.init(1)]&#x2F;&#x2F; 2、获取ul下的第一个li$(&#39;ul li:first&#39;)S.fn.init [li, prevObject: S.fn.init(1)]&#x2F;&#x2F; 或者$(&#39;ul li&#39;).first()S.fn.init [li, prevObject: S.fn.init(10)]&#x2F;&#x2F; 3、获取ul下的最后一个li$(&#39;ul li:last&#39;)S.fn.init [li, prevObject: S.fn.init(1)]&#x2F;&#x2F; 或者$(&#39;ul li&#39;).last()S.fn.init [li, prevObject: S.fn.init(10)]&#x2F;&#x2F; 4、获取ul的下标为2的后代$(&#39;ul li:eq(2)&#39;)S.fn.init [li, prevObject: S.fn.init(1)]&#x2F;&#x2F; 或者$(&#39;ul li&#39;).eq(2)S.fn.init [li, prevObject: S.fn.init(10)]&#x2F;&#x2F; 5、获取ul中下标为偶数的后代（0包含在内）$(&#39;ul li:even&#39;)S.fn.init(5) [li, li, li, li, li, prevObject: S.fn.init(1)]&#x2F;&#x2F; 6、获取ul中下标为奇数的后代$(&#39;ul li:odd&#39;)S.fn.init(5) [li, li, li, li, li, prevObject: S.fn.init(1)]&#x2F;&#x2F; 7、获取索引大于2的后代$(&#39;ul li:gt(2)&#39;)S.fn.init(7) [li, li, li, li, li, li, li, prevObject: S.fn.init(1)]&#x2F;&#x2F; 8、获取索引小于2的后代$(&#39;ul li:lt(2)&#39;)S.fn.init(2) [li, li#d1, prevObject: S.fn.init(1)]&#x2F;&#x2F; 9、移除满足条件的后代标签$(&#39;ul li:not(#d1)&#39;)S.fn.init(9) [li, li, li, li, li, li, li, li, li, prevObject: S.fn.init(1)]</code></pre></div></figure><h2 id="2-4-属性选择器"><a href="#2-4-属性选择器" class="headerlink" title="2.4 属性选择器"></a>2.4 属性选择器</h2><p>可以根据标签属性选择到标签</p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;form action&#x3D;&quot;&quot;&gt;        &lt;p&gt;用户名：&lt;input type&#x3D;&quot;text&quot; username&#x3D;&#39;Tom&#39;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;真实姓名：&lt;input type&#x3D;&quot;text&quot; username&#x3D;&#39;Jack&#39;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;住址：&lt;input type&#x3D;&quot;text&quot; site&#x3D;&#39;HuNan ChangSha&#39;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;密码：&lt;input type&#x3D;&quot;password&quot;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&#39;点我好康&#39;&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>属性选择器的使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1、找到所有包含username属性的标签$(&#39;[username]&#39;)S.fn.init(2) [input, input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 2、找到所有username&#x3D;&#39;Tom&#39;的标签$(&#39;[username&#x3D;&quot;Tom&quot;]&#39;)S.fn.init [input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 3、找到所有username&#x3D;&#39;Jack&#39;的标签$(&#39;[username&#x3D;&quot;Jack&quot;]&#39;)S.fn.init [input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 4、找到所有包含type属性的标签$(&#39;[type]&#39;)S.fn.init(5) [input, input, input, input, input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 5、找到所有包含type属性且type&#x3D;&#39;text&#39;的标签$(&#39;[type&#x3D;&quot;text&quot;]&#39;)S.fn.init(3) [input, input, input, prevObject: S.fn.init(1)]</code></pre></div></figure><h2 id="2-5-表单筛选器"><a href="#2-5-表单筛选器" class="headerlink" title="2.5 表单筛选器"></a>2.5 表单筛选器</h2><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.6.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;form action&#x3D;&quot;&quot;&gt;        &lt;p&gt;用户名：&lt;input type&#x3D;&quot;text&quot; username&#x3D;&#39;Tom&#39;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;真实姓名：&lt;input type&#x3D;&quot;text&quot; username&#x3D;&#39;Jack&#39;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;住址：&lt;input type&#x3D;&quot;text&quot; site&#x3D;&#39;HuNan ChangSha&#39;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;密码：&lt;input type&#x3D;&quot;password&quot;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&#39;点我好康&#39;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;性别            &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; checked&gt;男            &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; &gt;女            &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; &gt;未知        &lt;&#x2F;p&gt;        &lt;p&gt;爱好            &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; checked&gt;游泳            &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;唱歌            &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;划船        &lt;&#x2F;p&gt;        &lt;p&gt;学历            &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;                &lt;option value&#x3D;&quot;&quot; selected&gt;本科&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;&quot;&gt;研究生&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;&quot;&gt;博士&lt;&#x2F;option&gt;            &lt;&#x2F;select&gt;        &lt;&#x2F;p&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h3 id="2-5-1-通过input标签的类型选择元素"><a href="#2-5-1-通过input标签的类型选择元素" class="headerlink" title="2.5.1 通过input标签的类型选择元素"></a>2.5.1 通过input标签的类型选择元素</h3><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1、获取拥有属性type&#x3D;&#39;text&#39;的input标签$(&#39;input[type&#x3D;&quot;text&quot;]&#39;)S.fn.init(3) [input, input, input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 可以简写为$(&#39;:text&#39;)S.fn.init(3) [input, input, input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 2、获取拥有属性type&#x3D;&#39;password&#39;的input标签$(&#39;input[type&#x3D;&quot;password&quot;]&#39;)S.fn.init [input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 可以简写为$(&#39;:password&#39;)S.fn.init [input, prevObject: S.fn.init(1)]</code></pre></div></figure><p>可简写的一些方法：</p><ul><li>:text</li><li>:password</li><li>:file</li><li>:radio</li><li>:checkbox</li><li>:submit</li><li>:reset</li><li>:button</li></ul><h3 id="2-5-2-通过表单对象属性选择元素"><a href="#2-5-2-通过表单对象属性选择元素" class="headerlink" title="2.5.2 通过表单对象属性选择元素"></a>2.5.2 通过表单对象属性选择元素</h3><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1、获取所有包含checked&#x3D;“checked”的标签$(&#39;:checked&#39;)S.fn.init(3) [input, input, option, prevObject: S.fn.init(1)]&#x2F;&#x2F; 明明只有两个checked，为什么拿了3个，因为有BUG，会把selected也拿到$(&#39;:checked&#39;)[2]&lt;option value selected&gt;​本科​&lt;&#x2F;option&gt;​   slot &#x2F;&#x2F; 怎么解决这个问题？自己加限制条件$(&#39;input:checked&#39;)S.fn.init(2) [input, input, prevObject: S.fn.init(1)]&#x2F;&#x2F; 2、获取所有包含selected&#x3D;“selected”的标签$(&#39;:selected&#39;)S.fn.init [option, prevObject: S.fn.init(1)]</code></pre></div></figure><p>相同用法的还有：</p><ul><li>:enabled</li><li>:disabled</li></ul><h2 id="2-6-筛选器方法"><a href="#2-6-筛选器方法" class="headerlink" title="2.6 筛选器方法"></a>2.6 筛选器方法</h2><p>根据一个标签，获取它的<code>父亲</code>、<code>儿子</code>、<code>爷爷</code>等</p><p>往后找</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取#d1同级别下一个$(&#39;#d1&#39;).next()  w.fn.init [span, prevObject: w.fn.init(1)]0: spanlength: 1prevObject: w.fn.init [span#d1]__proto__: Object(0)           &#x2F;&#x2F; 获取#d1同级别下的所有     $(&#39;#d1&#39;).nextAll()w.fn.init(5) [span, div#d2, span, span, span.c1, prevObject: w.fn.init(1)]0: span1: div#d22: span3: span4: span.c1length: 5prevObject: w.fn.init [span#d1]__proto__: Object(0)&#x2F;&#x2F; 获取#d1同级别下的所有，直到遇到.c1停止查找$(&#39;#d1&#39;).nextUntil(&#39;.c1&#39;)  # 不包括最后一个w.fn.init(4) [span, div#d2, span, span, prevObject: w.fn.init(1)]0: span1: div#d22: span3: spanlengt: 4prevObject: w.fn.init [span#d1]__proto__: Object(0)</code></pre></div></figure><p>往前找</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取#d1同级别上一个$(&#39;.c1&#39;).prev() w.fn.init [span, prevObject: w.fn.init(1)]0: spanlength: 1prevObject: w.fn.init [span.c1, prevObject: w.fn.init(1)]__proto__: Object(0)&#x2F;&#x2F; 获取#d1同级别上的所有$(&#39;.c1&#39;).prevAll()w.fn.init(5) [span, span, div#d2, span, span#d1, prevObject: w.fn.init(1)]              &#x2F;&#x2F; 获取#d1同级别下的所有，直到遇到#d2停止查找$(&#39;.c1&#39;).prevUntil(&#39;#d2&#39;)w.fn.init(2) [span, span, prevObject: w.fn.init(1)]</code></pre></div></figure><p>找爸爸</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#d3&#39;).parent()  # 第一级父标签w.fn.init [p, prevObject: w.fn.init(1)]0: plength: 1prevObject: w.fn.init [span#d3]__proto__: Object(0)$(&#39;#d3&#39;).parent().parent()w.fn.init [div#d2, prevObject: w.fn.init(1)]$(&#39;#d3&#39;).parent().parent().parent()w.fn.init [body, prevObject: w.fn.init(1)]$(&#39;#d3&#39;).parent().parent().parent().parent()w.fn.init [html, prevObject: w.fn.init(1)]$(&#39;#d3&#39;).parent().parent().parent().parent().parent()w.fn.init [document, prevObject: w.fn.init(1)]$(&#39;#d3&#39;).parent().parent().parent().parent().parent().parent()w.fn.init [prevObject: w.fn.init(1)]$(&#39;#d3&#39;).parents()w.fn.init(4) [p, div#d2, body, html, prevObject: w.fn.init(1)]$(&#39;#d3&#39;).parentsUntil(&#39;body&#39;)w.fn.init(2) [p, div#d2, prevObject: w.fn.init(1)]</code></pre></div></figure><p>找儿子</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#d2&#39;).children()</code></pre></div></figure><p>找兄弟</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&#39;#d2&#39;).siblings()  # 同级别上下所有</code></pre></div></figure><h2 id="2-7-补充说明"><a href="#2-7-补充说明" class="headerlink" title="2.7 补充说明"></a>2.7 补充说明</h2><p>存在一些互相等价的用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 案例1$(&#39;div p&#39;)&#x2F;&#x2F; 等价于           $(&#39;div&#39;).find(&#39;p&#39;)  # find从某个区域内筛选出想要的标签               &#x2F;&#x2F; 案例2$(&#39;div span:first&#39;)w.fn.init [span, prevObject: w.fn.init(1)]&#x2F;&#x2F; 等价于$(&#39;div span&#39;).first()w.fn.init [span, prevObject: w.fn.init(3)]0: spanlength: 1prevObject: w.fn.init(3) [span, span#d3, span, prevObject: w.fn.init(1)]__proto__: Object(0)&#x2F;&#x2F; 案例3$(&#39;div span:last&#39;)w.fn.init [span, prevObject: w.fn.init(1)]$(&#39;div span&#39;).last()&#x2F;&#x2F; 案例4w.fn.init [span, prevObject: w.fn.init(3)]$(&#39;div span:not(&quot;#d3&quot;)&#39;)w.fn.init(2) [span, span, prevObject: w.fn.init(1)]&#x2F;&#x2F; 等价于$(&#39;div span&#39;).not(&#39;#d3&#39;)w.fn.init(2) [span, span, prevObject: w.fn.init(3)]</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>07_JQuery</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day55-JavaScript-02</title>
    <link href="/2022/08/17/03_Python/04_%E5%89%8D%E7%AB%AF/day55%E7%AC%94%E8%AE%B0-JS-02/"/>
    <url>/2022/08/17/03_Python/04_%E5%89%8D%E7%AB%AF/day55%E7%AC%94%E8%AE%B0-JS-02/</url>
    
    <content type="html"><![CDATA[<p>“第54天JavaScript（02）学习笔记”</p><h1 id="1-BOM操作"><a href="#1-BOM操作" class="headerlink" title="1 BOM操作"></a>1 BOM操作</h1><p>BOM全称<strong>Browser Object Model</strong>，译为<strong>浏览器对象模型</strong>，主要用于操作浏览器，比如：</p><ul><li>操作浏览器开打指定网页</li><li>浏览器跳转下一页&#x2F;返回上一页</li><li>设置浏览器窗口大小</li></ul><h2 id="1-1-window对象"><a href="#1-1-window对象" class="headerlink" title="1.1 window对象"></a>1.1 window对象</h2><p>window对象指代的就是浏览器窗口</p><p>案例 – 打开网页，并指定窗口大小</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.open(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;,&#39;&#39;,&#39;height&#x3D;400px,width&#x3D;400px,top&#x3D;400px,left&#x3D;400px&#39;)&#x2F;&#x2F; 新建窗口打开页面 第二个参数写空即可 第三个参数写新建的窗口的大小和位置&#x2F;&#x2F; 扩展父子页面通信window.opener()  了解</code></pre></div></figure><p>效果如下：</p><p><img src="/../../../img/image-20220817112220408.png" alt="image-20220817112220408"></p><p>案例 – 关闭网页</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.close()</code></pre></div></figure><h2 id="1-2-navigator对象"><a href="#1-2-navigator对象" class="headerlink" title="1.2 navigator对象"></a>1.2 navigator对象</h2><p>获取浏览器信息</p><p>案例代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.navigator.appName&#39;Netscape&#39;window.navigator.appVersion&#39;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.0.0 Safari&#x2F;5....window.navigator.userAgent&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.0.0 Safari&#x2F;537.36&#39;&#x2F;&#x2F; 如果是window的子对象，那么window可以省略不写，如navigator.platform&#39;Win32&#39;</code></pre></div></figure><h2 id="1-3-history对象"><a href="#1-3-history对象" class="headerlink" title="1.3 history对象"></a>1.3 history对象</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.history.back()  &#x2F;&#x2F; 回退到上一页window.history.forward()  &#x2F;&#x2F; 前进到下一页# 对应的就是你浏览器左上方的两个的箭头</code></pre></div></figure><h2 id="1-4-localtion对象"><a href="#1-4-localtion对象" class="headerlink" title="1.4 localtion对象"></a>1.4 localtion对象</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取当前页面的url window.location.href&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;&#x2F;&#x2F; 跳转到指定的urlwindow.location.href &#x3D; &#39;https:&#x2F;&#x2F;www.qq.com&#39;&#x2F;&#x2F; 重载刷新页面window.location.reload()</code></pre></div></figure><h2 id="1-5-弹出框"><a href="#1-5-弹出框" class="headerlink" title="1.5 弹出框"></a>1.5 弹出框</h2><p>弹出框分为：警告框、确认框、提示框</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 警告框alert(&#39;你不要过来啊！！！&#39;)undefined&#x2F;&#x2F; 确认框confirm(&#39;你确定真的要这么做吗?能不能有其他方式能够满足你...&#39;)falseconfirm(&#39;你确定真的要这么做吗?能不能有其他方式能够满足你...&#39;)true&#x2F;&#x2F; 提示框 -- 输入后点击确认，内容将返回prompt(&#39;这是输入框的名称&#39;, &#39;这是输入框的默认内容&#39;)&#39;你过来啊！&#39; </code></pre></div></figure><h2 id="1-6-计时器相关"><a href="#1-6-计时器相关" class="headerlink" title="1.6 计时器相关"></a>1.6 计时器相关</h2><p>创建定时任务–隔多久执行<code>Timeout</code></p><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建定时任务function func1() &#123;    alert(123)&#125;&#x2F;&#x2F; 毫秒为单位，3秒后自动执行let t &#x3D; setTimeout(func1, 3000) &#x2F;&#x2F; 取消定时任务clearTimeout(t) </code></pre></div></figure><p>创建循环定时任务–每隔多久执行一次<code>Interval</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建定时任务function func2() &#123;    alert(456)&#125;function show() &#123;    &#x2F;&#x2F; 每3秒执行一次    let t &#x3D; setInterval(func2, 3000)     function inner() &#123;        &#x2F;&#x2F; 清除定时器        clearInterval(t)     &#125;    &#x2F;&#x2F; 9秒之后停止循环    setTimeout(inner, 9000) &#125;&#x2F;&#x2F; 调用方法执行show()</code></pre></div></figure><h1 id="2-DOM操作"><a href="#2-DOM操作" class="headerlink" title="2 DOM操作"></a>2 DOM操作</h1><p>DOM全称<strong>Document Object Model</strong>，译为<strong>文档对象模型</strong>，主要用于操作网页内容，比如：</p><ul><li>操作HTML添加标签</li><li>操作CSS添加&#x2F;移除效果</li></ul><h2 id="2-1-查找标签"><a href="#2-1-查找标签" class="headerlink" title="2.1 查找标签"></a>2.1 查找标签</h2><h3 id="2-1-1-直接查找"><a href="#2-1-1-直接查找" class="headerlink" title="2.1.1 直接查找"></a>2.1.1 直接查找</h3><p>通过ID、Class、标签名直接查找标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div class&#x3D;&quot;c1&quot;&gt;DIV        &lt;div id&#x3D;&quot;d1&quot;&gt;DIV-DIV            &lt;div&gt;&lt;&#x2F;div&gt;DIV-DIV-DIV        &lt;&#x2F;div&gt;        &lt;div&gt;&lt;p&gt;不做大哥好多年&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;script&gt;        &#x2F;&#x2F; 通过ID获得标签        let d1Ele &#x3D; document.getElementById(&#39;d1&#39;)        console.log(d1Ele)        &#x2F;&#x2F; 通过Class获得标签        console.log(document.getElementsByClassName(&#39;c1&#39;))        &#x2F;&#x2F; 通过标签名获得标签        console.log(document.getElementsByTagName(&#39;p&#39;))        &#x2F;&#x2F; 如果有多个结果，需要指定下标        console.log(document.getElementsByTagName(&#39;div&#39;)[2])    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h3 id="2-1-2-间接查找"><a href="#2-1-2-间接查找" class="headerlink" title="2.1.2 间接查找"></a>2.1.2 间接查找</h3><p>通过已找到的标签，间接查找标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 通过直接查找先找到一个标签let d1Ele &#x3D; document.getElementById(&#39;d1&#39;)&#x2F;&#x2F; 获取标签的父标签d1Ele.parentElement&#x2F;&#x2F; 获取标签的爷爷标签d1Ele.parentElement.parentElement&#x2F;&#x2F; 获取标签的所有子标签d1Ele.children&#x2F;&#x2F; 获取指定子标签d1Ele.childern[2]&#x2F;&#x2F; 获取标签的第一个子标签d1Ele.firstChild&quot;DIV-DIV &quot;&#x2F;&#x2F; 获取标签的最后一个子标签d1Ele.lastChild&quot;DIV-DIV-DIV &quot;&#x2F;&#x2F; 获取标签同级别下面第一个d1Ele.nextElementSibling&#x2F;&#x2F; 获取标签同级别上面第一个d1Ele.previousElementSibling</code></pre></div></figure><h2 id="2-2-节点操作"><a href="#2-2-节点操作" class="headerlink" title="2.2 节点操作"></a>2.2 节点操作</h2><h3 id="2-2-1-案例一"><a href="#2-2-1-案例一" class="headerlink" title="2.2.1 案例一"></a>2.2.1 案例一</h3><p>通过DOM动态创建img标签，并且给img标签添加属性，最后将标签添加到文本中</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div class&#x3D;&quot;c1&quot;&gt;DIV        &lt;div id&#x3D;&quot;d1&quot;&gt;DIV-DIV            &lt;div&gt;&lt;&#x2F;div&gt;DIV-DIV-DIV        &lt;&#x2F;div&gt;        &lt;div id&#x3D;&quot;d2&quot;&gt;不做大哥好多年&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;script&gt;        &#x2F;&#x2F; 创建img标签        let imgEle &#x3D; document.createElement(&#39;img&#39;)        &#x2F;&#x2F; 设置img标签属性        imgEle.src &#x3D; &quot;111.png&quot;        imgEle.title &#x3D; &quot;飞跃黄河第一人&quot;        &#x2F;&#x2F; 设置自定义属性de方式一        imgEle.username &#x3D; &#39;Goosh&#39;        &#x2F;&#x2F; 设置自定义属性de方式二        imgEle.setAttribute(&#39;username&#39;, &#39;Goosh&#39;)        &#x2F;&#x2F; 将img标签添加到d2中        let d2Ele &#x3D; document.getElementById(&quot;d2&quot;)        d2Ele.appendChild(imgEle)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220817161226379.png" alt="image-20220817161226379"></p><h3 id="2-2-2-案例二"><a href="#2-2-2-案例二" class="headerlink" title="2.2.2 案例二"></a>2.2.2 案例二</h3><p>创建<code>a</code>标签，设置属性，设置文本，</p><p>添加到<font color=red><strong>指定[子标签]之前</strong></font></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;d1&quot;&gt;第一层        &lt;div id&#x3D;&quot;d2&quot;&gt;第二层&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;        &lt;script&gt;        &#x2F;&#x2F; 创建a标签        let aEle &#x3D; document.createElement(&#39;a&#39;)        aEle.href &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;        aEle.innerText &#x3D; &#39;点我有你好看，嘿嘿嘿&#39;                &#x2F;&#x2F; 插到d1的里面，d2之前        let d1Ele &#x3D; document.getElementById(&#39;d1&#39;)        let d2Ele &#x3D; document.getElementById(&#39;d2&#39;)        d1Ele.insertBefore(aEle, d2Ele)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果如下图：</p><p><img src="/../../../img/image-20220817164119646.png" alt="image-20220817164119646"></p><h3 id="2-2-3-额外补充"><a href="#2-2-3-额外补充" class="headerlink" title="2.2.3 额外补充"></a>2.2.3 额外补充</h3><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&quot;&quot;&quot;额外补充appendChild()removeChild()replaceChild()setAttribute()  设置属性getAttribute()  获取属性removeAttribute()  移除属性&quot;&quot;&quot;</code></pre></div></figure><p>InnerText和InnerHtml的区别</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">divEle.innerText  # 获取标签内部所有的文本&quot;div 点我有你好看!div&gt;pdiv&gt;span&quot;divEle.innerHTML  # 内部文本和标签都拿到&quot;div        &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.mzitu.com&#x2F;&quot;&gt;点我有你好看!&lt;&#x2F;a&gt;&lt;p id&#x3D;&quot;d2&quot;&gt;div&gt;p&lt;&#x2F;p&gt;        &lt;span&gt;div&gt;span&lt;&#x2F;span&gt;    &quot;    divEle.innerText &#x3D; &#39;heiheihei&#39;&quot;heiheihei&quot;divEle.innerHTML &#x3D; &#39;hahahaha&#39;&quot;hahahaha&quot;divEle.innerText &#x3D; &#39;&lt;h1&gt;heiheihei&lt;&#x2F;h1&gt;&#39;  # 不识别html标签&quot;&lt;h1&gt;heiheihei&lt;&#x2F;h1&gt;&quot;divEle.innerHTML &#x3D; &#39;&lt;h1&gt;hahahaha&lt;&#x2F;h1&gt;&#39;  # 识别html标签&quot;&lt;h1&gt;hahahaha&lt;&#x2F;h1&gt;&quot;</code></pre></div></figure><h1 id="3-获取值的操作"><a href="#3-获取值的操作" class="headerlink" title="3 获取值的操作"></a>3 获取值的操作</h1><p>获取标签内部属性的数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;d1&quot; value&#x3D;&quot;我是D1&quot;&gt;第一层        &lt;div id&#x3D;&quot;d2&quot; value&#x3D;&quot;我是D2&quot; desc&#x3D;&quot;今年18岁&quot;&gt;第二层&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;        &lt;script&gt;        &#x2F;&#x2F; 获取标签d1的序号1属性的值        var d1Ele &#x3D; document.getElementById(&#39;d1&#39;)        console.log(d1Ele.attributes[1].value)&#x2F;&#x2F; 输出 -- 我是01&#x2F;&#x2F; 获取标签d2的序号2属性的值        var d2Ele &#x3D; document.getElementById(&#39;d2&#39;)        console.log(d2Ele.attributes[2].value)&#x2F;&#x2F; 输出 -- 今年18岁    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>获取输入框中的数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;form action&#x3D;&quot;&quot;&gt;        &lt;div&gt;账号：&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;input01&quot;&gt;&lt;&#x2F;div&gt;        &lt;div&gt;文件：&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;input02&quot;&gt;&lt;&#x2F;div&gt;    &lt;&#x2F;form&gt;        &lt;script&gt;        let input01Ele &#x3D; document.getElementById(&#39;input01&#39;)        let input02Ele &#x3D; document.getElementById(&#39;input02&#39;)                &#x2F;&#x2F; 获取数据        input01Ele.valueinput02Ele.value    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p><img src="/../../../img/image-20220818095441409.png" alt="image-20220818095441409"></p><h1 id="4-操作Class和CSS"><a href="#4-操作Class和CSS" class="headerlink" title="4 操作Class和CSS"></a>4 操作Class和CSS</h1><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        body &#123;            margin: 0;        &#125;            #d1 &#123;            height: 200px;            width: 200px;        &#125;        #d2 &#123;            border-radius: 50px;            height: 100px;            width: 100px;        &#125;        .bg_red &#123;            background-color: red;        &#125;        .bg_green &#123;            background-color: green;        &#125;        .bg_orange &#123;            background-color: darkorange;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;d1&quot; class&#x3D;&quot;c1 bg_red bg_green&quot;&gt;        &lt;div id&#x3D;&quot;d2&quot; class&#x3D;&quot;c2 bg_red bg_orange&quot;&gt;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>页面效果：</p><p><img src="/../../../img/image-20220818101241668.png" alt="image-20220818101241668"></p><h2 id="4-1-Class操作"><a href="#4-1-Class操作" class="headerlink" title="4.1 Class操作"></a>4.1 Class操作</h2><p><strong>获取</strong>标签的class属性</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取d1标签（底层绿色标签）let divEle &#x3D; document.getElementById(&quot;d1&quot;)undefined&#x2F;&#x2F; 获取d1标签的所有classdivEle.classListDOMTokenList(3) [&#39;c1&#39;, &#39;bg_red&#39;, &#39;bg_green&#39;, value: &#39;c1 bg_red bg_green&#39;]</code></pre></div></figure><p><strong>添加&#x2F;移除</strong>标签的class属性</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 移除&quot;bg_red&quot;classdivEle.classList.remove(&#39;bg_red&#39;)undefined&#x2F;&#x2F; 添加&quot;bg_red&quot;classdivEle.classList.add(&#39;bg_red&#39;)undefined&#x2F;&#x2F; 移除&quot;bg_green&quot;classdivEle.classList.remove(&#39;bg_green&#39;)undefined&#x2F;&#x2F; 再添加&quot;bg_green&quot;classdivEle.classList.add(&#39;bg_green&#39;)undefined</code></pre></div></figure><p><strong>查询</strong>标签是否包含指定的class属性</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">divEle.classList.contains(&#39;bg_green&#39;)truedivEle.classList.remove(&#39;bg_green&#39;)undefineddivEle.classList.contains(&#39;bg_green&#39;)false</code></pre></div></figure><p><strong>toggle</strong>有则删除，无则添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">divEle.classList.toggle(&#39;bg_green&#39;)truedivEle.classList.toggle(&#39;bg_green&#39;)falsedivEle.classList.toggle(&#39;bg_green&#39;)truedivEle.classList.toggle(&#39;bg_green&#39;)falsedivEle.classList.toggle(&#39;bg_green&#39;)true</code></pre></div></figure><h2 id="4-2-CSS操作"><a href="#4-2-CSS操作" class="headerlink" title="4.2 CSS操作"></a>4.2 CSS操作</h2><p>以4.1的页面为案例，操作div(d1)的css</p><p>通过<code>style</code>可以直接对应的属性</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 背景色改为蓝色divEle.style.backgroundColor&#x3D;&#39;blue&#39;&#39;blue&#39;&#x2F;&#x2F; 圆角20pxdivEle.style.borderRadius&#x3D;&#39;20px&#39;&#39;20px&#39;&#x2F;&#x2F; 边框设置divEle.style.border&#x3D;&#39;3px solid red&#39;&#39;3px solid red&#39;</code></pre></div></figure><p>效果如下：</p><p><img src="/../../../img/image-20220818102533004.png" alt="image-20220818102533004"></p><h1 id="5-事件"><a href="#5-事件" class="headerlink" title="5 事件(*)"></a>5 事件(*)</h1><p>别听着这名字就跑路了，实际上就是按钮的点击事件</p><p>我们的案例html页面代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;input type&#x3D;&quot;button&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;btn01&quot; value&#x3D;&quot;点我有你好康&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p><font color=red><strong>在JS中绑定事件有两种方式</strong></font></p><p>第一种方式–行内绑定：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;input type&#x3D;&quot;button&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;btn01&quot; value&#x3D;&quot;点我有你好康&quot; onclick&#x3D;&quot;func1()&quot;&gt;    &lt;script&gt;        function func1() &#123;            alert(&quot;嘎子偷狗！&quot;)        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>第二种方式–通过ID绑定：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;input type&#x3D;&quot;button&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;btn01&quot; value&#x3D;&quot;点我有你好康&quot;&quot;&gt;    &lt;script&gt;        let btnEle &#x3D; document.getElementById(&quot;btn01&quot;)        btnEle.onclick &#x3D; function() &#123;            alert(&quot;潘嘎之交&quot;)        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果如下：</p><p><img src="/../../../img/image-20220818104606375.png" alt="image-20220818104606375"></p><h1 id="6-JS代码位置"><a href="#6-JS代码位置" class="headerlink" title="6 JS代码位置"></a>6 JS代码位置</h1><p>JS代码一般放在body的最下方，如果在前面，将出现“XXX未定义”的问题</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div&gt;HTML优先写&lt;&#x2F;div&gt;    &lt;script&gt;        &#x2F;&#x2F; 放这里！    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>还可以使用onload</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"># 等待浏览器窗口加载完毕之后再执行代码window.onload &#x3D; function () &#123;            &#x2F;&#x2F; 第一种绑定事件的方式            function func1() &#123;                alert(111)            &#125;            &#x2F;&#x2F; 第二种            let btnEle &#x3D; document.getElementById(&#39;d1&#39;);            btnEle.onclick &#x3D; function () &#123;                alert(222)            &#125;        &#125;</code></pre></div></figure><h1 id="7-原生JS事件绑定"><a href="#7-原生JS事件绑定" class="headerlink" title="7 原生JS事件绑定"></a>7 原生JS事件绑定</h1><p>通过几个案例学习</p><h2 id="7-1-开关灯案例"><a href="#7-1-开关灯案例" class="headerlink" title="7.1 开关灯案例"></a>7.1 开关灯案例</h2><p>点击按钮，div方块在“红色”和绿色之间切换</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        .bg_red &#123;            background-color: red;        &#125;        .bg_green &#123;            background-color: green;        &#125;        .c1 &#123;            width: 200px;            height: 200px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;d1&quot; class&#x3D;&quot;c1 bg_red bg_green&quot;&gt;&lt;&#x2F;div&gt;    &lt;button id&#x3D;&quot;d2&quot;&gt;变色&lt;&#x2F;button&gt;    &lt;script&gt;        let btnEle &#x3D; document.getElementById(&quot;d2&quot;)        let divEle &#x3D; document.getElementById(&quot;d1&quot;)        btnEle.onclick &#x3D; function() &#123;            &#x2F;&#x2F; 动态修改div类的属性            divEle.classList.toggle(&#39;bg_green&#39;)        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220822161548595.png" alt="image-20220822161548595"></p><p>点击变色按钮后：</p><p><img src="/../../../img/image-20220822161608377.png" alt="image-20220822161608377"></p><h2 id="7-2-input框获取焦点-失去焦点"><a href="#7-2-input框获取焦点-失去焦点" class="headerlink" title="7.2 input框获取焦点&#x2F;失去焦点"></a>7.2 input框获取焦点&#x2F;失去焦点</h2><p>新事件<code>onfocus</code>和<code>onblur</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;来看看嘛~&quot; id&#x3D;&quot;d1&quot;&gt;        &lt;script&gt;        let iEle &#x3D; document.getElementById(&#39;d1&#39;)        &#x2F;&#x2F; 获取焦点事件        iEle.onfocus &#x3D; function() &#123;            &#x2F;&#x2F; 将input框中的值去掉            iEle.value &#x3D; &#39;哎呀~鼠标点到我了&#39;        &#125;        &#x2F;&#x2F; 失去焦点事件        iEle.onblur &#x3D; function() &#123;            iEle.value &#x3D; &#39;完事走人&#39;        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220822163319837.png" alt="image-20220822163319837"></p><p>鼠标点击上去：</p><p><img src="/../../../img/image-20220822163338421.png" alt="image-20220822163338421"></p><p>鼠标移开：</p><p><img src="/../../../img/image-20220822163352708.png" alt="image-20220822163352708"></p><h2 id="7-3-实时展示当前时间"><a href="#7-3-实时展示当前时间" class="headerlink" title="7.3 实时展示当前时间"></a>7.3 实时展示当前时间</h2><p>点击“Start”按钮，实时刷新显示当前时间（1s一次），点击”End”按钮停止</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        #d1 &#123;            display: block;            width: 200px;            height: 200px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;我这显示当前时间&quot; id&#x3D;&quot;d1&quot;&gt;    &lt;div&gt;        &lt;button id&#x3D;&quot;d2&quot;&gt;Start&lt;&#x2F;button&gt;        &lt;button id&#x3D;&quot;d3&quot;&gt;End&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;        &lt;script&gt;        let iEle &#x3D; document.getElementById(&#39;d1&#39;)        let btnStartEle &#x3D; document.getElementById(&#39;d2&#39;)        let btnEndEle &#x3D; document.getElementById(&#39;d3&#39;)                &#x2F;&#x2F; 定义标识，用于标示开始和停止        var flag &#x3D; null         &#x2F;&#x2F; 显示时间的时间        function showtime() &#123;            &#x2F;&#x2F; 创建时间对象，获取当前时间            let currentTime &#x3D; new Date();            &#x2F;&#x2F; 将当前时间显示到input框中            iEle.value &#x3D; currentTime.toLocaleString()        &#125;        &#x2F;&#x2F; Start按钮绑定事件        btnStartEle.onclick &#x3D; function() &#123;            console.log(showtime())            if (!flag) &#123;                &#x2F;&#x2F; 1秒显示一次当前时间                t &#x3D; setInterval(showtime, 1000)            &#125;        &#125;        &#x2F;&#x2F; End按钮绑定事件        btnEndEle.onclick &#x3D; function() &#123;            &#x2F;&#x2F; 停止循环            clearInterval(t)            &#x2F;&#x2F; 将标志设为null            flag &#x3D; null            iEle.value &#x3D; &quot;计时停止&quot;        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220822165219698.png" alt="image-20220822165219698"></p><p>点击“Start”后，显示时间，一秒刷新一次</p><p><img src="/../../../img/image-20220822165240697.png" alt="image-20220822165240697"></p><p>点击“End”按钮后：</p><p><img src="/../../../img/image-20220822165308453.png" alt="image-20220822165308453"></p><h2 id="7-4-省市联动"><a href="#7-4-省市联动" class="headerlink" title="7.4 省市联动"></a>7.4 省市联动</h2><p>下拉框选择“省”，展示相应的“市区”</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;!-- 创建两个选择框 --&gt;    &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;d1&quot;&gt;        &lt;!-- 添加默认选项 --&gt;        &lt;option value&#x3D;&quot;&quot; seleted&#x3D;&quot;disabled&quot;&gt;--请选择--&lt;&#x2F;option&gt;    &lt;&#x2F;select&gt;    &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;d2&quot;&gt;&lt;&#x2F;select&gt;    &lt;script&gt;        &#x2F;&#x2F; 获取标签        let d1Ele &#x3D; document.getElementById(&#39;d1&#39;)        let d2Ele &#x3D; document.getElementById(&#39;d2&#39;)        &#x2F;&#x2F; 添加模拟数据        data &#x3D; &#123;            &quot;河北&quot;:[&quot;廊坊&quot;, &quot;邯郸&quot;, &quot;唐山&quot;],            &quot;北京&quot;:[&quot;朝阳区&quot;, &quot;海淀区&quot;, &quot;昌平区&quot;],            &quot;湖南&quot;:[&quot;长沙市&quot;, &quot;益阳市&quot;, &quot;常德市&quot;],            &quot;广东&quot;:[&quot;深圳市&quot;, &quot;广州市&quot;, &quot;佛山市&quot;]        &#125;        &#x2F;&#x2F; 标签添加数据        for(let key in data) &#123;            &#x2F;&#x2F; 将省信息作为一个option标签,插到d1中            &#x2F;&#x2F; 创建标签            let opEle &#x3D; document.createElement(&#39;option&#39;)            &#x2F;&#x2F; 设置标签的innerText            opEle.innerText &#x3D; key            &#x2F;&#x2F; 设置标签的value            opEle.value &#x3D; key            &#x2F;&#x2F; 将option标签追加到d1中            d1Ele.appendChild(opEle)        &#125;        &#x2F;&#x2F; 选择框文本域变化事件        d1Ele.onchange &#x3D; function() &#123;            &#x2F;&#x2F; 获取选择的省            let curPro &#x3D; d1Ele.value            &#x2F;&#x2F; 获取对应的市区信息            let curCityList &#x3D; data[curPro]            &#x2F;&#x2F; 清空d2中的所有option            d2Ele.innerHTML &#x3D; &quot;&quot;            &#x2F;&#x2F; 自己加一个请选择            let ss &#x3D; &quot;&lt;option disabled selected&gt;请选择&lt;&#x2F;option&gt;&quot;            d2Ele.innerHTML &#x3D; ss            &#x2F;&#x2F; for 循环所有的市,渲染到第二个select(d2)中            for (let i &#x3D; 0; i &lt; curCityList.length; i++) &#123;                let curCity &#x3D; curCityList[i]                &#x2F;&#x2F; 创建option标签                let cityEle &#x3D; document.createElement(&#39;option&#39;)                &#x2F;&#x2F; 标签添加value                cityEle.value &#x3D; curCity                &#x2F;&#x2F; 标签添加内容                cityEle.innerText &#x3D; curCity                &#x2F;&#x2F; d2追加标签                d2Ele.appendChild(cityEle)            &#125;        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p>可以选择设定的省</p><p><img src="/../../../img/image-20220823142032372.png" alt="image-20220823142032372"></p><p>通过省，显示对应的市区</p><p><img src="/../../../img/image-20220823142041796.png" alt="image-20220823142041796"></p><p>换一个，也显示正常</p><p><img src="/../../../img/image-20220823142051735.png" alt="image-20220823142051735"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>06_JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day54-JavaScript-01</title>
    <link href="/2022/08/08/03_Python/04_%E5%89%8D%E7%AB%AF/day54%E7%AC%94%E8%AE%B0-JS-01/"/>
    <url>/2022/08/08/03_Python/04_%E5%89%8D%E7%AB%AF/day54%E7%AC%94%E8%AE%B0-JS-01/</url>
    
    <content type="html"><![CDATA[<p>“第54天JavaScript（01）学习笔记”</p><h1 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1 JavaScript简介"></a>1 JavaScript简介</h1><p><strong><font color=blue>JavaScript(简称JS)</font></strong> 听起来是不是感觉跟Java的关系很大?</p><p>其实跟Java什么关系都没有, 只是为了<font color="red"><strong>蹭Java的热度</strong></font>,才起的这么个名字!</p><p>JS到底是什么?</p><ul><li>JavaScript 是脚本语言</li><li>JavaScript 是一种轻量级的编程语言。</li><li>JavaScript 是可插入 HTML 页面的编程代码。</li><li>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li><li>JavaScript 很容易学习</li></ul><p>第一个js程序</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;        &#x2F;&#x2F; 单行注释                &#x2F;*        多行注释        *&#x2F;                document.write(&quot;&lt;h1&gt;Hello World!&lt;&#x2F;h1&gt;&quot;)    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h1 id="2-JS变量"><a href="#2-JS变量" class="headerlink" title="2 JS变量"></a>2 JS变量</h1><h2 id="2-1-定义变量的两种方法"><a href="#2-1-定义变量的两种方法" class="headerlink" title="2.1 定义变量的两种方法"></a>2.1 定义变量的两种方法</h2><ul><li>var </li><li>let  (es6推出的新语法, 如果你的编辑器支持的版本是5.1那么无法使用let)</li></ul><p>案例代码如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;        &#x2F;&#x2F; var定义变量        var num1 &#x3D; 100        alert(num1)        &#x2F;&#x2F; let定义变量        let num2 &#x3D; 300        alert(num2)    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>let和var的区别是什么?  </p><ul><li><p>var是函数作用域，let是块作用域\</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (var num &#x3D; 0; num &lt; 100; num++)&#123;&#125;console.log(num) &#x2F;&#x2F; 输出100(说明函数内有效)for (let num2 &#x3D; 0; num &lt; 100; num++)&#123;&#125;console.log(num2) &#x2F;&#x2F; 输出错误, num2未定义(说明离开for循环块,就无效了)</code></pre></div></figure></li><li><p>let不能在定义之前访问该变量, 但是var可以\</p><p>var正常</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(num1)var num1 &#x3D; 300  &#x2F;&#x2F; 无报错，不输出东西</code></pre></div></figure><p>let报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(num1)let num1 &#x3D; 300  &#x2F;&#x2F; 无报错，不输出东西&#x2F;&#x2F; 报错:02-变量.html:14 Uncaught ReferenceError: Cannot access &#39;num1&#39; before initialization    at 02-变量.html:14:21</code></pre></div></figure></li><li><p>let不能被重新定义, 但是var可以</p><p>var正常</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var num1 &#x3D; 100console.log(num1)    &#x2F;&#x2F; 正常输出100var num1 &#x3D; 200console.log(num1)    &#x2F;&#x2F; 正常输出200</code></pre></div></figure><p>let报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let num1 &#x3D; 100console.log(100)let num1 &#x3D; 200console.log(200)&#x2F;&#x2F; 报错: Uncaught SyntaxError: Identifier &#39;num1&#39; has already been declared</code></pre></div></figure></li></ul><h2 id="2-2-变量的命名规范"><a href="#2-2-变量的命名规范" class="headerlink" title="2.2 变量的命名规范"></a>2.2 变量的命名规范</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">js变量的命名规范1.变量名只能是 数字 字母 下划线 $2.变量名命名规范(不遵循也可以)1.js中推荐使用驼峰式命名userNamedataOfDb2.python推荐使用下划线的方式user_namedata_of_db3.不能用关键字作为变量名不需要记忆 </code></pre></div></figure><h2 id="2-3-代码的书写位置"><a href="#2-3-代码的书写位置" class="headerlink" title="2.3 代码的书写位置"></a>2.3 代码的书写位置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.可以单独开设js文件书写2.还可以直接在浏览器提供的console界面书写在用浏览器书写js的时候 左上方的清空按钮只是清空当前页面 代码其实还在如果你想要重新来 最好重新开设一个 页面</code></pre></div></figure><h1 id="3-JS常量"><a href="#3-JS常量" class="headerlink" title="3 JS常量"></a>3 JS常量</h1><p>js中使用<code>const</code>定义常量, 不可被修改的变量</p><blockquote><p>补充: Python中没有真正意义上的常量,默认全大小代表常量,而JS中有真正意义上的常量</p></blockquote><p>案例代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const pi &#x3D; 3.14console.log(pi)pi &#x3D; 80 &#x2F;&#x2F; 报错：Uncaught TypeError: Assignment to constant variable.</code></pre></div></figure><h1 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4 数据类型"></a>4 数据类型</h1><p>js也是一门面向对象 的编程语言 即一切皆对象!!!</p><p>js&#x2F;python是一门拥有动态类型</p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">name &#x3D; &#39;jason&#39;name &#x3D; 123name &#x3D; [1,2,3,4]# name可以指向任意的数据类型 </code></pre></div></figure><h2 id="4-1-数值类型（Number）"><a href="#4-1-数值类型（Number）" class="headerlink" title="4.1 数值类型（Number）"></a>4.1 数值类型（Number）</h2><p>常用方法：<br>    parseInt()转换为Int类型<br>    parseFloat()转换为Float类型</p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义变量var a &#x3D; 11;var b &#x3D; 11.11;&#x2F;&#x2F; 如何查看当前数据类型typeof a;&#x2F;&#x2F; 查看参数的类型typeof a;typeof b;&quot;number&quot;&#x2F;&#x2F; 特殊的 NaN:数值类型 表示的意思是“不是一个数字” NOT A NUMBERparseInt(&#39;12312312&#39;)&#x2F;&#x2F; 正常将字符串转为Int类型12312312parseFloat(&#39;11.11&#39;)&#x2F;&#x2F; 正常将字符串转为浮点类型11.11parseInt(&#39;11.11&#39;)&#x2F;&#x2F; 正常将字符串转为Int类型，将去掉小数点后面的数11parseInt(&#39;123sdasdajs2312dasd&#39;)&#x2F;&#x2F; 只取前面的数123parseInt(&#39;asdasdad123sdasdajs2312dasd&#39;)&#x2F;&#x2F; 完全无法识别的转换为NaNNaN</code></pre></div></figure><h2 id="4-2-字符类型（String）"><a href="#4-2-字符类型（String）" class="headerlink" title="4.2 字符类型（String）"></a>4.2 字符类型（String）</h2><p>定义字符串的案例代码如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 使用【单引号】定义变量var s &#x3D; &#39;jason&#39;&#x2F;&#x2F; 自动识别成了字符类型typeof s&#39;string&#39;&#x2F;&#x2F; 也可以使用【双引号】定义字符串var s2 &#x3D; &quot;jason&quot;&#x2F;&#x2F; 自动识别成了字符类型typeof s2&#39;string&#39;&#x2F;&#x2F; 不能使用python的三引号方式定义多行文本的字符串var s3 &#x3D; &#39;&#39;&#39;jason&#39;&#39;&#39;VM894:1 Uncaught SyntaxError: Unexpected string&#x2F;&#x2F; JavaScript中使用【反引号】定义多行文本的字符串var s3 &#x3D; &#96;这是多行文字的演示这是多行文字的演示&#96;&#x2F;&#x2F; 输出s3s3&#39;\n这是多行文字\n的演示\n这是多行文字\n的演示\n&#39;</code></pre></div></figure><p>输出字符串的案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 通过$&#123;&#125;的方式输出字符串var age &#x3D; 18var name &#x3D; &quot;GLF&quot;var sss &#x3D; &#96;My name is $&#123;name&#125; and my age is $&#123;age&#125;&#96;&#x2F;&#x2F; 输出sss&#39;My name is GLF and my age is 18&#39;&#x2F;&#x2F; JS中推荐使用【+】号拼接字符串var year &#x3D; &#39;2022&#39;var day &#x3D; &#39;12&#39;var month &#x3D; &#39;08&#39;date &#x3D; &#96;Today is $&#123;year + &#39;-&#39; + month + day&#125;&#96;&#39;Today is 2022-0812&#39;date&#39;Today is 2022-0812&#39;</code></pre></div></figure><p>字符类型常用方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>length</td><td>返回字符串长度</td></tr><tr><td>trim()</td><td>移除空白</td></tr><tr><td>trimLeft()</td><td>移除左边的空白</td></tr><tr><td>trimRight()</td><td>移除右边的空白</td></tr><tr><td>charAt(n)</td><td>返回第n个字符</td></tr><tr><td>concat(value, ….)</td><td>拼接字符串</td></tr><tr><td>indexof(substring, start)</td><td>子序列位置</td></tr><tr><td>substring(from, to)</td><td>根据索引获取子序列</td></tr><tr><td>slice(start, end)</td><td>切片</td></tr><tr><td>toLowerCase()</td><td>小写</td></tr><tr><td>toUpperCase()</td><td>大写</td></tr><tr><td>split(delimiter, limit)</td><td>分割</td></tr></tbody></table><p><code>length</code>方法案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &#39;you are beautiful&#39;undefinedconsole.log(str.length);17</code></pre></div></figure><p>trim()方法案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let str2 &#x3D; &quot; my left and right have blank &quot;&#x2F;&#x2F; 输出 &quot;my left and right have blank&quot;console.log(str2.trim())&#x2F;&#x2F; 输出 &quot; my left and right have blank&quot;console.log(str2.trimRight())&#x2F;&#x2F; 输出 &quot;my left and right have blank &quot;console.log(str2.trimLeft())&#x2F;&#x2F; 不能像Python一样指定去除的内容var str &#x3D; &quot;$$Test string$$&quot;str.trim(&#39;$&#39;)&#39;$$Test string$$&#39; &#x2F;&#x2F; 去除$失败了</code></pre></div></figure><p><code>charAt()</code>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &quot;$$Test string$$&quot;&#x2F;&#x2F; 获取位置0和8的字符str.charAt(0)&#39;$&#39;str.charAt(8)&#39;t&#39;</code></pre></div></figure><p><code>indexOf()</code>案例</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &quot;$$Test string$$&quot;&#x2F;&#x2F; 获取&#39;st&#39;和&#39;str&#39;第一次出现的位置str.indexOf(&#39;st&#39;)4str.indexOf(&#39;str&#39;)7</code></pre></div></figure><p><code>substring()</code>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &quot;$$Test string$$&quot;&#x2F;&#x2F; 获取位置1-5的字串str.substr(1,5)&#39;$Test&#39;&#x2F;&#x2F; 也可以用负数，表示倒数var str &#x3D; &quot;12345678&quot;str.substr(-3, 20)&#x2F;&#x2F; 20超出范围，选到最后的位置&#39;678&#39;</code></pre></div></figure><p><code>slice()</code>案例（功能跟<code>substring()</code>类似，推荐使用这个）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &quot;12345678&quot;&#x2F;&#x2F; 切片(1，5)str.substr(1, 5)&#39;23456&#39;</code></pre></div></figure><p><code>toLowerCase()</code>和<code>toUpperCase()</code>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &#39;ToDay is MONDAY&#39;str.toLowerCase()&#39;today is monday&#39;str.toUpperCase()&#39;TODAY IS MONDAY&#39;</code></pre></div></figure><p><code>split()</code>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var name &#x3D; &quot;Jerry | Tom | Jemmy | Marry&quot;undefined&#x2F;&#x2F; 指定分割符分割name.split(&#39;|&#39;)(4) [&#39;Jerry &#39;, &#39; Tom &#39;, &#39; Jemmy &#39;, &#39; Marry&#39;]&#x2F;&#x2F; 第二个参数可以指定获取的元素个数name.split(&#39;|&#39;, 2)(2) [&#39;Jerry &#39;, &#39; Tom &#39;]name.split(&#39;|&#39;, 20)(4) [&#39;Jerry &#39;, &#39; Tom &#39;, &#39; Jemmy &#39;, &#39; Marry&#39;]</code></pre></div></figure><p><code>concat()</code>案例:</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str1 &#x3D; &quot;Hello everyone!&quot;undefinedvar str2 &#x3D; &quot;My name is Tom!&quot;undefined&#x2F;&#x2F; 拼接str1和str2str1.concat(str2)&#39;Hello everyone!My name is Tom!&#39;&#x2F;&#x2F; 非字符串类型会自动转换后拼接var phoneNumber &#x3D; 12345678undefinedstr1.concat(phoneNumber)&#39;Hello everyone!12345678&#39;</code></pre></div></figure><h2 id="4-3-布尔值-boolean"><a href="#4-3-布尔值-boolean" class="headerlink" title="4.3 布尔值(boolean)"></a>4.3 布尔值(boolean)</h2><p>JS布尔值的定义：</p><ul><li>在python中布尔值是首字母大写的<ul><li>True &#x2F; False</li></ul></li><li>但是在js中布尔值是全小写的<ul><li>true &#x2F; false</li></ul></li><li>布尔值是false的有哪些<ul><li>空字符串</li><li>0</li><li>null</li><li>undefined</li><li>NaN</li></ul></li></ul><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var isFalse &#x3D; falseundefinedvar isTrue &#x3D; trueundefined</code></pre></div></figure><h2 id="4-4-null与undefined的区别"><a href="#4-4-null与undefined的区别" class="headerlink" title="4.4 null与undefined的区别"></a>4.4 null与undefined的区别</h2><p>null</p><p>​表示值为空 一般都是指定或者清空一个变量时使用</p><p>如:</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">name &#x3D; &#39;jason&#39;name &#x3D; null</code></pre></div></figure><p>undefined</p><p>​表示声明了一个变量 但是没有做初始化操作(没有给值)</p><p>​函数没有指定返回值的时候 返回的也是undefined</p><h2 id="4-5-对象-数组"><a href="#4-5-对象-数组" class="headerlink" title="4.5 对象(数组)"></a>4.5 对象(数组)</h2><p>JS数组类似于Python中的列表<code>[]</code>，在JS中<code>一切皆为对象</code></p><h3 id="4-5-1-数组的定义"><a href="#4-5-1-数组的定义" class="headerlink" title="4.5.1 数组的定义"></a>4.5.1 数组的定义</h3><p>见案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义数组var list &#x3D; [11, &quot;abc&quot;, 33.44, false]undefined&#x2F;&#x2F; 获取数组元素list[3]false&#x2F;&#x2F; 类型是&#96;对象&#96;typeof(list)&#39;object&#39;</code></pre></div></figure><h3 id="4-5-2-数组的常用方法"><a href="#4-5-2-数组的常用方法" class="headerlink" title="4.5.2 数组的常用方法"></a>4.5.2 数组的常用方法</h3><p><code>length</code>获取数组长度</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var list &#x3D; [11, &quot;abc&quot;, 33.44, false]list.length4</code></pre></div></figure><p><code>push()</code>追加元素到尾部</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 追加元素，返回追加后的数组长度list.push(&quot;Hello&quot;)5&#x2F;&#x2F; 查看数组元素list(5) [11, &#39;abc&#39;, 33.44, false, &#39;Hello&#39;]</code></pre></div></figure><p><code>pop()</code>弹出尾部元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">list(5) [11, &#39;abc&#39;, 33.44, false, &#39;Hello&#39;]&#x2F;&#x2F; 弹出元素（从最后一个开始）list.pop()&#39;Hello&#39;list.pop()falselist.pop()33.44list(2) [11, &#39;abc&#39;]</code></pre></div></figure><p><code>unshift()</code>数组头部插入元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 查看数组元素list(3) [11, 11, &#39;abc&#39;]&#x2F;&#x2F; 头部插入元素list.unshift(&quot;Good&quot;)4&#x2F;&#x2F; 再次查看list(4) [&#39;Good&#39;, 11, 11, &#39;abc&#39;]</code></pre></div></figure><p><code>shift()</code>数组弹出头部元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 查看数组元素list(4) [&#39;Good&#39;, 11, 11, &#39;abc&#39;]&#x2F;&#x2F; 删除头部元素list.shift()&#39;Good&#39;&#x2F;&#x2F; 查看头部元素list(3) [11, 11, &#39;abc&#39;]</code></pre></div></figure><p><code>slice()</code>数组切割</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 查看数组元素list(4) [11, 11, &#39;abc&#39;, 555]&#x2F;&#x2F; 切割list.slice(1,3)(2) [11, &#39;abc&#39;]</code></pre></div></figure><p><code>reverse()</code>数组反转</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 查看数组元素list(4) [11, 11, &#39;abc&#39;, 555]&#x2F;&#x2F; 数组反转list.reverse()(4) [555, &#39;abc&#39;, 11, 11]</code></pre></div></figure><p><code>join()</code>将<code>数组元素</code>转换为<code>字符串</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 查看数组元素list(4) [555, &#39;abc&#39;, 11, 11]&#x2F;&#x2F; 转换为字符串（参数为&#96;拼接符号&#96;）list.join(&#39;$&#39;)&#39;555$abc$11$11&#39;</code></pre></div></figure><p><code>concat()</code>拼接数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 查看数组元素list(4) [555, &#39;abc&#39;, 11, 11]&#x2F;&#x2F; 拼接另一个数组list.concat([&#39;Duo&#39;, 888, &quot;hello&quot;])(7) [555, &#39;abc&#39;, 11, 11, &#39;Duo&#39;, 888, &#39;hello&#39;]&#x2F;&#x2F; 可以拼接多个数组list.concat([&#39;Duo&#39;, 888, &quot;hello&quot;], [666, 888])(9) [555, &#39;abc&#39;, 11, 11, &#39;Duo&#39;, 888, &#39;hello&#39;, 666, 888]</code></pre></div></figure><p><code>sort()</code>数组排序</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var list2 &#x3D; [666, 111, 222, 888, 999]undefined&#x2F;&#x2F; 数组排序list2.sort()(5) [111, 222, 666, 888, 999]</code></pre></div></figure><h3 id="4-5-3-三个比较重要的方法"><a href="#4-5-3-三个比较重要的方法" class="headerlink" title="4.5.3 三个比较重要的方法"></a>4.5.3 三个比较重要的方法</h3><p>1） <code>foreach()</code>遍历数组元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义数组var list1 &#x3D; [&quot;Changsha&quot;, &quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Taiwan&quot;]undefined&#x2F;&#x2F; 遍历数组（一个参数：显示值）var list1 &#x3D; [&quot;Changsha&quot;, &quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Taiwan&quot;]undefinedlist1.forEach(function(value)&#123;console.log(value)&#125;)VM942:1 ChangshaVM942:1 BeijingVM942:1 ShanghaiVM942:1 Taiwan&#x2F;&#x2F; 遍历数组（两个参数：显示值和下标）list1.forEach(function(value, index)&#123;console.log(value, index)&#125;, list1)VM541:1 Changsha 0VM541:1 Beijing 1VM541:1 Shanghai 2VM541:1 Taiwan 3undefine&#x2F;&#x2F; 遍历数组（三个参数：显示值、下标、数据来源）list1.forEach(function(value, index, arr)&#123;console.log(value, index, arr)&#125;)VM1237:1 Changsha 0 (4) [&#39;Changsha&#39;, &#39;Beijing&#39;, &#39;Shanghai&#39;, &#39;Taiwan&#39;]VM1237:1 Beijing 1 (4) [&#39;Changsha&#39;, &#39;Beijing&#39;, &#39;Shanghai&#39;, &#39;Taiwan&#39;]VM1237:1 Shanghai 2 (4) [&#39;Changsha&#39;, &#39;Beijing&#39;, &#39;Shanghai&#39;, &#39;Taiwan&#39;]VM1237:1 Taiwan 3 (4) [&#39;Changsha&#39;, &#39;Beijing&#39;, &#39;Shanghai&#39;, &#39;Taiwan&#39;]</code></pre></div></figure><p>2） <code>splice()</code>替换数组元素（<code>先删除后添加</code>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义数组var ll &#x3D; [&quot;11&quot;, &quot;22&quot;, &quot;33&quot;]undefined&#x2F;&#x2F; 从下标0开始，删除2个元素ll.splice(0, 2)(2) [&#39;11&#39;, &#39;22&#39;]&#x2F;&#x2F; 查看效果ll[&#39;33&#39;]&#x2F;&#x2F; 插入元素ll.push(&#39;66&#39;)2ll.push(&#39;88&#39;)3ll.push(&#39;99&#39;)4&#x2F;&#x2F; 查看数组元素ll(4) [&#39;33&#39;, &#39;66&#39;, &#39;88&#39;, &#39;99&#39;]&#x2F;&#x2F; 从下标1开始，删除2个元素，替换为&#39;9090&#39;插入ll.splice(1, 2, 9090)(2) [&#39;66&#39;, &#39;88&#39;]ll(3) [&#39;33&#39;, 9090, &#39;99&#39;]&#x2F;&#x2F; 后续追加参数为替换后新增的元素var ll2 &#x3D; [&#39;11&#39;, &#39;22&#39;, &#39;33&#39;, &#39;44&#39;]undefinedll2.splice(0, 2, &#39;Hello&#39;, &#39;Man&#39;, &#39;HAHA&#39;)(2) [&#39;11&#39;, &#39;22&#39;]&#x2F;&#x2F; 可见删除的两个元素被替换了ll2(5) [&#39;Hello&#39;, &#39;Man&#39;, &#39;HAHA&#39;, &#39;33&#39;, &#39;44&#39;]</code></pre></div></figure><p>3）<code>map()</code>遍历数组元素</p> <figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义数组var ll &#x3D; [&quot;11&quot;, &quot;22&quot;, &quot;33&quot;]undefined&#x2F;&#x2F; 输出数组元素（方法和forEach类似，也可以最多三个参数）ll.map(function(value)&#123;console.log(value)&#125;, ll)VM2621:1 11VM2621:1 22VM2621:1 33&#x2F;&#x2F; 三个参数输出数组ll.map(function(value, index, aaa)&#123;console.log(value, index, aaa)&#125;, ll)VM3143:1 11 0 (3) [&#39;11&#39;, &#39;22&#39;, &#39;33&#39;]VM3143:1 22 1 (3) [&#39;11&#39;, &#39;22&#39;, &#39;33&#39;]VM3143:1 33 2 (3) [&#39;11&#39;, &#39;22&#39;, &#39;33&#39;]&#x2F;&#x2F; 处理数组数据ll.map(function(value)&#123;return value * 2&#125;, ll)(3) [22, 44, 66]</code></pre></div></figure><h1 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5 运算符"></a>5 运算符</h1><h2 id="5-1-算术运算符"><a href="#5-1-算术运算符" class="headerlink" title="5.1 算术运算符"></a>5.1 算术运算符</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var x &#x3D; 10;var res1 &#x3D; x++;var res2 &#x3D; ++x;res1 10res2 12++表示自增1 类似于 +&#x3D;1加号在前先加后赋值 加号在后先赋值后加</code></pre></div></figure><h2 id="5-2-比较运算符"><a href="#5-2-比较运算符" class="headerlink" title="5.2 比较运算符"></a>5.2 比较运算符</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">1 &#x3D;&#x3D; &#39;1&#39;  # 弱等于  内部自动转换成相同的数据类型比较了true  1 &#x3D;&#x3D;&#x3D; &#39;1&#39;  # 强等于  内部不做类型转换1 !&#x3D; &#39;1&#39;false1 !&#x3D;&#x3D; &#39;2&#39;true</code></pre></div></figure><h2 id="5-3-逻辑运算符"><a href="#5-3-逻辑运算符" class="headerlink" title="5.3 逻辑运算符"></a>5.3 逻辑运算符</h2><p>”一定要注意到底什么时候返回的是布尔值 什么是返回的是数据“</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 两个都为真，返回最后一个真的值5 &amp;&amp; &#39;5&#39;&#39;5&#39;&#x2F;&#x2F; 左边为假，继续往后查找为真的值，并返回0 || 11&#x2F;&#x2F; 遇到假直接返回假的值，!5 &#x3D; false!5 &amp;&amp; &#39;5&#39;false</code></pre></div></figure><p><strong>逻辑运算符的返回值问题</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"># &amp;&amp; 且[运算符](https:&#x2F;&#x2F;so.csdn.net&#x2F;so&#x2F;search?q&#x3D;运算符&amp;spm&#x3D;1001.2101.3001.7020)(从左到右只要找到无法通过的值[false]就结束，不再检查后面的值，可以通过的值[true]就继续向右检查直到最后一个)console.log(5 &amp;&amp; 4);&#x2F;&#x2F;当结果为真时，返回最后一个为真的值4console.log(4 &amp;&amp; 5);&#x2F;&#x2F;当结果为真时，返回最后一个为真的值5 console.log(5 &amp;&amp; 4 &amp;&amp; 6);&#x2F;&#x2F;当结果为真时，多个值时返回最后一个为真的值6console.log(4 &amp;&amp; 0);&#x2F;&#x2F;当结果为假时，返回第一个为假的值0console.log(0 &amp;&amp; 4);&#x2F;&#x2F;当结果为假时，返回第一个为假的值0console.log(4 &amp;&amp; 0 &amp;&amp; false);&#x2F;&#x2F;当结果为假时，多个值时返回第一个为假的值0 console.log(false &amp;&amp; 0);&#x2F;&#x2F;当结果为假时，返回第一个为假的值falseconsole.log(0 &amp;&amp; false);&#x2F;&#x2F;当结果为假时，返回第一个为假的值0console.log(false &amp;&amp; 0 &amp;&amp; false);&#x2F;&#x2F;当结果为假时，多个值时返回第一个为假的值false# || 或运算符(从左到右只要找到可以通过的值[true]就结束，不再检查后面的值)console.log(0 || false);&#x2F;&#x2F;当结果为假时，返回最后一个为假的值falseconsole.log(false || 0);&#x2F;&#x2F;当结果为假时，返回最后一个为假的值0console.log(false || 0 || false);&#x2F;&#x2F;当结果为假时，返回最后一个为假的值falseconsole.log(2 || 0);&#x2F;&#x2F;当结果为真时，返回真的值2console.log(0 || 2);&#x2F;&#x2F;当结果为真时，返回真的值2console.log(0 || 4 || 3);&#x2F;&#x2F;当结果为真时，多个值时返回第一个为真的值4console.log(6 || 7);&#x2F;&#x2F;当结果为真时，返回第一个为真的值6console.log(7 || 6);&#x2F;&#x2F;当结果为真时，返回第一个为真的值7console.log(2 || 4 || 3);&#x2F;&#x2F;当结果为真时，多个值时返回第一个为真的值2</code></pre></div></figure><h2 id="5-4-赋值运算符"><a href="#5-4-赋值运算符" class="headerlink" title="5.4 赋值运算符"></a>5.4 赋值运算符</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x3D; +&#x3D; -&#x3D; *&#x3D; ....</code></pre></div></figure><h1 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6 流程控制"></a>6 流程控制</h1><h2 id="6-1-if判断"><a href="#6-1-if判断" class="headerlink" title="6.1 if判断"></a>6.1 if判断</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"># if判断var age &#x3D; 28;# if(条件)&#123;条件成立之后指向的代码块&#125;if (age&gt;18)&#123;  console.log(&#39;来啊 来啊&#39;)&#125;# if-elseif (age&gt;18)&#123;  console.log(&#39;来啊 来啊&#39;)&#125;else&#123;  console.log(&#39;没钱 滚蛋&#39;)&#125;# if-else if elseif (age&lt;18)&#123;  console.log(&quot;培养一下&quot;)&#125;else if(age&lt;24)&#123;  console.log(&#39;小姐姐你好 我是你的粉丝&#39;)&#125;else&#123;  console.log(&#39;你是个好人&#39;)&#125;</code></pre></div></figure><h2 id="6-2-switch-语句"><a href="#6-2-switch-语句" class="headerlink" title="6.2 switch 语句"></a>6.2 switch 语句</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var num &#x3D; 2;switch(num)&#123;  case 0:  console.log(&#39;喝酒&#39;);  break;  # 不加break 匹配到一个之后 就一直往下执行  case 1:  console.log(&#39;唱歌&#39;);  break;  case 2:  console.log(&#39;洗脚&#39;);  break;  case 3:  console.log(&#39;按摩&#39;);  break;  case 4:  console.log(&#39;营养快线&#39;);  break;  case 5:  console.log(&#39;老板慢走 欢迎下次光临&#39;);  break;  default:  console.log(&#39;条件都没有匹配上 默认走的流程&#39;)&#125;</code></pre></div></figure><h2 id="6-3-for循环"><a href="#6-3-for循环" class="headerlink" title="6.3 for循环"></a>6.3 for循环</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"># 打印0-9数字for(let i&#x3D;0;i&lt;10;i++)&#123;  console.log(i)&#125;# 题目1  循环打印出数组里面的每一个元素var l1 &#x3D; [111,222,333,444,555,666]for(let i&#x3D;0;i&lt;l1.length;i++)&#123;  console.log(l1[i])&#125;</code></pre></div></figure><h2 id="6-4-while循环"><a href="#6-4-while循环" class="headerlink" title="6.4 while循环"></a>6.4 while循环</h2><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var i &#x3D; 0while(i&lt;100)&#123;  console.log(i)  i++;&#125;</code></pre></div></figure><h2 id="6-5-三元运算符"><a href="#6-5-三元运算符" class="headerlink" title="6.5 三元运算符"></a>6.5 三元运算符</h2><p>三元运算符不要写的过于复杂 </p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"># python中三元运算符 res &#x3D; 1 if 1&gt;2 else 3# JS中三元运算  res &#x3D; 1 &gt; 2 ? 1 : 3 条件成立取问好后面的1 不成立取冒号后面的3var res &#x3D; 2 &gt; 5 ? 8 : 10 # 10var res &#x3D; 2 &gt; 5 ? 8 : ( 8 &gt; 5 ? 666 : 444 )  # 666</code></pre></div></figure><h2 id="6-6-函数"><a href="#6-6-函数" class="headerlink" title="6.6 函数"></a>6.6 函数</h2><h3 id="6-6-1-函数定义"><a href="#6-6-1-函数定义" class="headerlink" title="6.6.1 函数定义"></a>6.6.1 函数定义</h3><p>无参函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义函数function func1() &#123;    console.log(&quot;Hello&quot;)&#125;&#x2F;&#x2F; 调用func1()&#x2F;&#x2F; 输出 -- Hello</code></pre></div></figure><p>有参函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义函数function fcun2(a, b) &#123;    console.log(a + b)&#125;&#x2F;&#x2F; 调用函数fcun2(8, 99)&#x2F;&#x2F; 输出 -- 107&#x2F;&#x2F; 少了参数不会报错，第二个参数自动识别为&quot;undefined&quot;fcun2(8)&#x2F;&#x2F; 输出 -- NaN  &#x2F;&#x2F; 识别为 8 + undefined 所以是 &quot;Not A Number&quot;&#x2F;&#x2F; 多了参数也不报错，会自动按需求取fcun2(1, 3, 66, 77, 88)&#x2F;&#x2F; 输出 -- 4</code></pre></div></figure><h3 id="6-6-2-关键字arguments"><a href="#6-6-2-关键字arguments" class="headerlink" title="6.6.2 关键字arguments"></a>6.6.2 关键字<code>arguments</code></h3><p>用于获取函数接收到的所有参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func3(a, b, c) &#123;    console.log(arguments)&#125;func3(1,2,3)VM758:2 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</code></pre></div></figure><p>可以用于判断参数的数量</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func2(a,b)&#123;  if(arguments.length&lt;2)&#123;    console.log(&#39;传少了&#39;)  &#125;else if (arguments.length&gt;2)&#123;    console.log(&#39;传多了&#39;)  &#125;else&#123;    console.log(&#39;正常执行&#39;)  &#125;&#125;</code></pre></div></figure><h3 id="6-6-3-函数返回值"><a href="#6-6-3-函数返回值" class="headerlink" title="6.6.3 函数返回值"></a>6.6.3 函数返回值</h3><p>函数中使用<code>return</code>返回值</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义函数function func4(a, b) &#123;    return a + b&#125;&#x2F;&#x2F; 调用函数res &#x3D; func4(1, 2)3&#x2F;&#x2F; 输出值res3</code></pre></div></figure><p>JS能不能像Python一样返回多个值？ — <strong><font color=red>不能</font></strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func3(a, b, c) &#123;    return a,b,c&#125;&#x2F;&#x2F; 当返回多个值的时候，**只能拿到最后一个返回值**res &#x3D; func3(111, 222, 333)333res333</code></pre></div></figure><p>如何返回多个值呢？ —- 可以使用<code>数组</code>的方式返回</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func3(a, b, c) &#123;    return [a,b,c]&#125;res &#x3D; func3(1,2,3)(3) [1, 2, 3]res(3) [1, 2, 3]</code></pre></div></figure><h3 id="6-6-4-匿名函数"><a href="#6-6-4-匿名函数" class="headerlink" title="6.6.4 匿名函数"></a>6.6.4 匿名函数</h3><p>没有名字的函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建名函数function() &#123;    console.log(&quot;我是匿名函数&quot;)&#125;&#x2F;&#x2F; 使用匿名函数var res&#x3D; function() &#123;    console.log(&quot;我是匿名函数&quot;)&#125;&#x2F;&#x2F; 不带括号输出resƒ () &#123;    console.log(&quot;我是匿名函数&quot;)&#125;&#x2F;&#x2F; 带括号输出res()VM1565:2 我是匿名函数</code></pre></div></figure><h3 id="6-6-5-箭头函数（了解）"><a href="#6-6-5-箭头函数（了解）" class="headerlink" title="6.6.5 箭头函数（了解）"></a>6.6.5 箭头函数（了解）</h3><p>主要用来处理简单的业务逻辑</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建箭头函数var func1 &#x3D; (arg1, arg2) &#x3D;&gt; arg1 + arg2;&#x2F;&#x2F; 调用res &#x3D; func1(6, 8)14</code></pre></div></figure><p>箭头函数是什么意思？</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var func1 &#x3D; (arg1, arg2) &#x3D;&gt; arg1 + arg2;&#x2F;&#x2F; 相当于var func1 &#x3D; function(arg1, arg2) &#123;    return arg1 + arg2&#125;</code></pre></div></figure><h3 id="6-6-7-函数的全局变量和局部变量"><a href="#6-6-7-函数的全局变量和局部变量" class="headerlink" title="6.6.7 函数的全局变量和局部变量"></a>6.6.7 函数的全局变量和局部变量</h3><p>局部变量在函数内生效，优先使用局部变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 跟python查找变量的顺序一致var city &#x3D; &quot;BeiJing&quot;;function f() &#123;  var city &#x3D; &quot;ShangHai&quot;;  function inner()&#123;    var city &#x3D; &quot;ShenZhen&quot;;    console.log(city);  &#125;  inner();&#125;f();  &#x2F;&#x2F;输出&quot;ShenZhen&quot;</code></pre></div></figure><p>离开函数，局部变量将失效，优先使用全局变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var city &#x3D; &quot;BeiJing&quot;;function Bar() &#123;  console.log(city);&#125;function f() &#123;  var city &#x3D; &quot;ShangHai&quot;;  return Bar;&#125;var ret &#x3D; f();ret();  &#x2F;&#x2F; 打印结果是？ Beijing</code></pre></div></figure><p>如果是函数内部返回函数呢？</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var city &#x3D; &quot;BeiJing&quot;;function f()&#123;    var city &#x3D; &quot;ShangHai&quot;;    function inner()&#123;        console.log(city);    &#125;    return inner;&#125;var ret &#x3D; f();ret();&#x2F;&#x2F; 输出&quot;ShangHai&quot;</code></pre></div></figure><h2 id="6-7-自定义对象"><a href="#6-7-自定义对象" class="headerlink" title="6.7 自定义对象"></a>6.7 自定义对象</h2><h3 id="6-7-1-花括号的方式创建"><a href="#6-7-1-花括号的方式创建" class="headerlink" title="6.7.1 花括号的方式创建"></a>6.7.1 花括号的方式创建</h3><p>创建</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var d1 &#x3D; &#123;&#39;name&#39;:&#39;Goosh&#39;, age:18&#125;;console.log(typeof d1)&#x2F;&#x2F; 输出 object</code></pre></div></figure><p>使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(d1[&#39;name&#39;])&#x2F;&#x2F; 输出 Gooshconsole.log(d1[&#39;age&#39;]) &#x2F;&#x2F; 输出 18</code></pre></div></figure><p>循环遍历</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i in d1) &#123;    console.log(i, d1[i])&#125;&#x2F;&#x2F; 输出name Gooshage 18</code></pre></div></figure><h3 id="6-7-2-关键字new方式创建"><a href="#6-7-2-关键字new方式创建" class="headerlink" title="6.7.2 关键字new方式创建"></a>6.7.2 关键字<code>new</code>方式创建</h3><p>创建</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var d2 &#x3D; new Object()d2.name &#x3D; &#39;Goosh&#39;d2.age &#x3D; 18</code></pre></div></figure><p>循环遍历</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 遍历for (let i in d2) &#123;    console.log(i, d2[i])&#125;&#x2F;&#x2F; 输出name Gooshage 18</code></pre></div></figure><h2 id="6-8-Date对象"><a href="#6-8-Date对象" class="headerlink" title="6.8 Date对象"></a>6.8 Date对象</h2><p>创建Date对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var mydate &#x3D; Date()console.log(mydate)&#x2F;&#x2F; 输出Tue Aug 16 2022 09:44:40 GMT+0800 (中国标准时间)</code></pre></div></figure><p>自定义Date的方式一</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let mydate2 &#x3D; new Date(&#39;2200&#x2F;1&#x2F;1 11:11:11&#39;)console.log(mydate2.toLocaleString())&#x2F;&#x2F;输出2200&#x2F;1&#x2F;1 11:11:11</code></pre></div></figure><p>自定义Date的方式二</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let mydate3 &#x3D; new Date(2211, 11, 11, 22, 22, 22)console.log(mydate3)&#x2F;&#x2F; 输出Wed Dec 11 2211 22:22:22 GMT+0800 (中国标准时间)</code></pre></div></figure><h3 id="6-8-1-时间对象的具体方法"><a href="#6-8-1-时间对象的具体方法" class="headerlink" title="6.8.1 时间对象的具体方法"></a>6.8.1 时间对象的具体方法</h3><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let d6 &#x3D; new Date();d6.getDate()  获取日d6.getDay()获取星期d6.getMonth()获取月份(0-11)d6.getFullYear()获取完整的年份d6.getHours()获取小时d6.getMinutes()获取分钟d6.getSeconds()获取秒d6.getMilliseconds()  获取毫秒d6.getTime()时间戳</code></pre></div></figure><h2 id="6-9-JSON对象"><a href="#6-9-JSON对象" class="headerlink" title="6.9 JSON对象"></a>6.9 JSON对象</h2><p>用于<code>序列化</code>和<code>反序列化</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建对象let d7 &#x3D; &#123;&#39;name&#39;:&#39;Goosh&#39;, &#39;age&#39;:18&#125;&#x2F;&#x2F; 序列化let res7 &#x3D; JSON.stringify(d7)console.log(res7)&#x2F;&#x2F; 反序列化let d8 &#x3D; JSON.parse(res7)console.log(d8)</code></pre></div></figure><h2 id="6-10-RegExp对象（正则表达式）"><a href="#6-10-RegExp对象（正则表达式）" class="headerlink" title="6.10 RegExp对象（正则表达式）"></a>6.10 RegExp对象（正则表达式）</h2><h3 id="6-10-1-使用正则的两种方式"><a href="#6-10-1-使用正则的两种方式" class="headerlink" title="6.10.1 使用正则的两种方式"></a>6.10.1 使用正则的两种方式</h3><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 第一种方式let reg1 &#x3D; new RegExp(&#39;^[a-zA-Z][d-zD-Z0-9]&#123;5,11&#125;&#39;)&#x2F;&#x2F; 第二种方式（推荐）let reg2 &#x3D; &#x2F;^[a-zA-Z][d-zD-Z0-9]&#123;5,11&#125;&#x2F;&#x2F;&#x2F; 匹配内容res1 &#x3D; reg1.test(&#39;abcc123321&#39;)res2 &#x3D; reg2.test(&#39;76ehk88&#39;)res3 &#x3D; reg1.test(&#39;a76ehk88&#39;)&#x2F;&#x2F; 输出console.log(res1, res2, res3) &#x2F;&#x2F; 输出 false false true</code></pre></div></figure><h3 id="6-10-2match单项匹配"><a href="#6-10-2match单项匹配" class="headerlink" title="6.10.2match单项匹配"></a>6.10.2<code>match</code>单项匹配</h3><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let ss &#x3D; &#39;ds222 fdsgfd dsb dsb&#39;&#x2F;&#x2F; 非全局匹配res1 &#x3D; ss.match(&#x2F;s&#x2F;)console.log(res1)&#x2F;&#x2F; 输出内容(1) [&#39;s&#39;, index: 1, input: &#39;ds222 fdsgfd dsb dsb&#39;, groups: undefined]&#x2F;&#x2F; 全局匹配res1 &#x3D; ss.match(&#x2F;s&#x2F;g)console.log(res1)&#x2F;&#x2F; 输出内容(4) [&#39;s&#39;, &#39;s&#39;, &#39;s&#39;, &#39;s&#39;]</code></pre></div></figure><h3 id="6-10-3-全局匹配的吐槽点"><a href="#6-10-3-全局匹配的吐槽点" class="headerlink" title="6.10.3 全局匹配的吐槽点"></a>6.10.3 全局匹配的吐槽点</h3><p>吐槽点一：LastIndex导致匹配异常</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let reg3 &#x3D; &#x2F;^[a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;&#x2F;greg2.test(&#39;egondsb&#39;)reg3.test(&#39;egondsb&#39;)  # 全局模式有一个lastIndex属性truereg3.test(&#39;egondsb&#39;)falsereg3.test(&#39;egondsb&#39;)truereg3.test(&#39;egondsb&#39;)false&#x2F;&#x2F; 为什么会有这个现象？reg3.lastIndex&#x2F;&#x2F; 当前下标在00reg3.test(&#39;egondsb&#39;)&#x2F;&#x2F; 正常匹配truereg3.lastIndex&#x2F;&#x2F; 匹配完下标挪到了7的位置7reg3.test(&#39;egondsb&#39;)&#x2F;&#x2F; 再次匹配异常false</code></pre></div></figure><p>吐槽点二：什么都不传也能匹配成功</p><p>​什么都不传 默认传的是undefined, 而且是字符串！</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let reg4 &#x3D; &#x2F;^[a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;&#x2F;reg4.test()reg4.test()  &#x2F;&#x2F; 什么都不传 默认传的是undefined, 居然能匹配成功。。。truereg4.test()true&#x2F;&#x2F; 验证是Undefinedlet reg5 &#x3D; &#x2F;undefined&#x2F;console.log(reg4.test(&#39;Goosh&#39;))&#x2F;&#x2F; falseconsole.log(reg4.test())&#x2F;&#x2F; trueconsole.log(reg4.test(&#39;undefined&#39;))&#x2F;&#x2F; true</code></pre></div></figure><h2 id="6-11-Math对象"><a href="#6-11-Math对象" class="headerlink" title="6.11 Math对象"></a>6.11 Math对象</h2><p>常用数学处理对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">abs(x)      返回数的绝对值。exp(x)      返回 e 的指数。floor(x)    对数进行下舍入。log(x)      返回数的自然对数（底为e）。max(x,y)    返回 x 和 y 中的最高值。min(x,y)    返回 x 和 y 中的最低值。pow(x,y)    返回 x 的 y 次幂。random()    返回 0 ~ 1 之间的随机数。round(x)    把数四舍五入为最接近的整数。sin(x)      返回数的正弦。sqrt(x)     返回数的平方根。tan(x)      返回角的正切。</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>06_JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day53-CSS-03</title>
    <link href="/2022/08/08/03_Python/04_%E5%89%8D%E7%AB%AF/day53%E7%AC%94%E8%AE%B0-CSS-03/"/>
    <url>/2022/08/08/03_Python/04_%E5%89%8D%E7%AB%AF/day53%E7%AC%94%E8%AE%B0-CSS-03/</url>
    
    <content type="html"><![CDATA[<p>“第53天CSS03学习笔记”</p><h1 id="1-解决浮动带来的影响"><a href="#1-解决浮动带来的影响" class="headerlink" title="1 解决浮动带来的影响"></a>1 解决浮动带来的影响</h1><p>浮动会带来<code>父标签塌陷</code>的问题，什么是<code>父标签塌陷</code>？</p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;STYle&gt;        body &#123;            margin: 0;        &#125;        div &#123;            border: 5px solid;            width: 300px        &#125;        .P1 &#123;            background-color: coral;            height: 100px;            width: 100px;            margin: 0;            float: left;        &#125;        span &#123;            background-color: blue;            height: 200px;            width: 100px;            margin: 0;            display: block;            &#x2F;*左浮动*&#x2F;            float: left;        &#125;    &lt;&#x2F;STYle&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;!-- 创建父标签 --&gt;    &lt;div&gt;        &lt;!-- 创建子标签 --&gt;        &lt;p class&#x3D;&quot;P1&quot;&gt;&lt;&#x2F;p&gt;        &lt;span&gt;&lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>在理想情况下，应该是一个黑框包住两个色块，如下图所示：</p><p><img src="/../../../img/image-20220808092801800.png" alt="image-20220808092801800"></p><p>但是实际情况是这样的, 元素浮动后脱离文档流, 父DIV塌陷了：</p><p><img src="/../../../img/image-20220808092912191.png" alt="image-20220808092912191"></p><p>有3种方法处理这个问题：</p><h2 id="1-1-指定父标签的高度"><a href="#1-1-指定父标签的高度" class="headerlink" title="1.1 指定父标签的高度"></a>1.1 指定父标签的高度</h2><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">div &#123;    border: 5px solid;    width: 300px;    &#x2F;* 父标签添加高度 *&#x2F;    height: 200px;&#125;</code></pre></div></figure><h2 id="1-2-利用clear属性"><a href="#1-2-利用clear属性" class="headerlink" title="1.2 利用clear属性"></a>1.2 利用clear属性</h2><p>该标签的左边不能有浮动的元素, </p><p>原理: P4标签左边不能有浮动, 实际上是新起了一行, 把父标签撑起来了</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;STYle&gt;        body &#123;            margin: 0;        &#125;        div &#123;            border: 5px solid;            width: 300px        &#125;        .P1 &#123;            background-color: coral;            height: 100px;            width: 100px;            margin: 0;            float: left;        &#125;        span &#123;            background-color: blue;            height: 200px;            width: 100px;            margin: 0;            display: block;            &#x2F;*左浮动*&#x2F;            float: left;        &#125;        &#x2F;*P4标签clear*&#x2F;        .P4 &#123;            clear: left;        &#125;    &lt;&#x2F;STYle&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;!-- 创建父标签 --&gt;    &lt;div&gt;        &lt;!-- 创建子标签 --&gt;        &lt;p class&#x3D;&quot;P1&quot;&gt;&lt;&#x2F;p&gt;        &lt;span&gt;&lt;&#x2F;span&gt;        &lt;!-- 创建P4标签 --&gt;        &lt;p class&#x3D;&quot;P4&quot;&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h2 id="1-3-使用clearfix-推荐"><a href="#1-3-使用clearfix-推荐" class="headerlink" title="1.3 使用clearfix(推荐)"></a>1.3 使用clearfix(推荐)</h2><p>在写html页面之前 先提前写好处理浮动带来的影响的 css代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.clearfix:after &#123;    content: &#39;&#39;;    display: block;    clear: both;&#125;</code></pre></div></figure><p>谁塌陷就给谁用, 这里用到div元素上面</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;body&gt;    &lt;!-- 创建父标签 --&gt;    &lt;div class&#x3D;&quot;clearfix&quot;&gt;        &lt;!-- 创建子标签 --&gt;        &lt;p class&#x3D;&quot;P1&quot; &gt;&lt;&#x2F;p&gt;        &lt;span&gt;&lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;</code></pre></div></figure><h1 id="2-溢出属性"><a href="#2-溢出属性" class="headerlink" title="2 溢出属性"></a>2 溢出属性</h1><p>见名知意, 溢出属性用来控制溢出的部分, 案例代码如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        p &#123;            border: 2px solid;            width: 300px;            height: 200px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;p&gt;        童趣【作者】沈复 【朝代】清译文对照余忆童稚时，能张目对日，明察秋毫，见藐小之物必细察其纹理，故时有物外之趣。夏蚊成雷，私拟作群鹤舞于空中，心之所向，则或千或百，果然鹤也；昂首观之，项为之强。又留蚊于素帐中，徐喷以烟，使之冲烟而飞鸣，作青云白鹤观，果如鹤唳云端，为之怡然称快。余常于土墙凹凸处，花台小草丛杂处，蹲其身，使与台齐；定神细视，以丛草为林，以虫蚁为兽，以土砾凸者为丘，凹者为壑，神游其中，怡然自得。一日，见二虫斗草间，观之，兴正浓，忽有庞然大物，拔山倒树而来，盖一癞虾蟆，舌一吐而二虫尽为所吞。余年幼，方出神，不觉呀然一惊。神定，捉虾蟆，鞭数十，驱之别院。    &lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>可见文字溢出了</p><p><img src="/../../../img/image-20220808101749039.png" alt="image-20220808101749039"></p><p>通过溢出属性控制:</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">p &#123;    border: 2px solid;    width: 300px;    height: 200px;    &#x2F;* overflow: visible;  默认就是可见 溢出还是展示  *&#x2F;    &#x2F;* overflow: hidden;  溢出部分直接隐藏 *&#x2F;    overflow: scroll;  &#x2F;* 设置成上下滚动条的形式 *&#x2F;    &#x2F;* overflow: auto; *&#x2F;&#125;</code></pre></div></figure><p>比如使用scroll就是如下图样式:</p><p><img src="/../../../img/image-20220808102150792.png" alt="image-20220808102150792"></p><h1 id="3-定位"><a href="#3-定位" class="headerlink" title="3 定位"></a>3 定位</h1><ul><li><p>静态</p><p>所有的标签默认都是静态的static，无法改变位置</p></li><li><p>相对定位(了解)</p><p>相对于标签原来的位置做移动relative</p></li><li><p>绝对定位(常用)</p><p>相对于已经定位过的父标签做移动(如果没有父标签那么就以body为参照)</p><p>eg:小米网站购物车</p><p>当你不知道页面其他标签的位置和参数，只给了你一个父标签的参数，让你基于该标签左定位</p></li><li><p>固定定位(常用)</p><p>相对于浏览器窗口固定在某个位置</p><p>eg:右侧小广告</p></li></ul><h2 id="3-1-案例1–子绝父相"><a href="#3-1-案例1–子绝父相" class="headerlink" title="3.1 案例1–子绝父相"></a>3.1 案例1–子绝父相</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;style&gt;        body &#123;            margin: 0;        &#125;                &#x2F;* d1相对定位：相对于原来的位置，往下移动50px，往右移动50px *&#x2F;        #d1 &#123;            height: 100px;            width: 100px;            background-color: red;            left: 50px;  &#x2F;*从左往右   如果是负数 方向则相反*&#x2F;            top: 50px;  &#x2F;*从上往下    如果是负数 方向则相反*&#x2F;            &#x2F;*position: static;  !*默认是static无法修改位置*!*&#x2F;            position: relative;            &#x2F;*相对定位            标签由static变为relative它的性质就从原来没有定位的标签变成了已经定位过的标签            虽然你哪怕没有动 但是你的性质也已经改变了            *&#x2F;        &#125;        &#x2F;* d2属性改为相对定位 *&#x2F;        #d2 &#123;            height: 100px;            width: 200px;            background-color: blue;            position: relative;  &#x2F;*已经定位过了*&#x2F;        &#125;        &#x2F;* d3相对于父标签d2，往右移动200px, 往下移动100px *&#x2F;        #d3 &#123;            height: 200px;            width: 400px;            background-color: yellowgreen;            position: absolute;            left: 200px;            top: 100px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;   &lt;div id&#x3D;&quot;d1&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d2&quot;&gt;   &lt;div id&#x3D;&quot;d3&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果:</p><p><img src="/../../../img/image-20220808104234138.png" alt="image-20220808104234138"></p><h2 id="3-2-案例2–固定定位"><a href="#3-2-案例2–固定定位" class="headerlink" title="3.2 案例2–固定定位"></a>3.2 案例2–固定定位</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;style&gt;        body &#123;            margin: 0;        &#125;                &#x2F;* d4设置为固定定位，定在右下角 *&#x2F;        #d4 &#123;            position: fixed;  &#x2F;*写了fixed之后 定位就是依据浏览器窗口*&#x2F;            bottom: 10px;            right: 20px;            height: 50px;            width: 100px;            background-color: white;            border: 3px solid black;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div style&#x3D;&quot;height: 500px;background-color: red&quot;&gt;&lt;&#x2F;div&gt;&lt;div style&#x3D;&quot;height: 500px;background-color: greenyellow&quot;&gt;&lt;&#x2F;div&gt;&lt;div style&#x3D;&quot;height: 500px;background-color: blue&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d4&quot;&gt;回到顶部&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果:</p><p><img src="/../../../img/image-20220808103941331.png" alt="image-20220808103941331"></p><h1 id="4-浮动和定位是否脱离文档流"><a href="#4-浮动和定位是否脱离文档流" class="headerlink" title="4 浮动和定位是否脱离文档流"></a>4 浮动和定位是否脱离文档流</h1><p>浮动&#x2F;定位后的元素, <code>原来的位置</code>是否还保留呢?</p><ul><li>不脱离文档流<ul><li>相对定位</li></ul></li><li>脱离文档流<ul><li>绝对定位</li><li>固定定位</li><li>浮动</li></ul></li></ul><h1 id="5-z-index模态框"><a href="#5-z-index模态框" class="headerlink" title="5 z-index模态框"></a>5 z-index模态框</h1><p>什么是z-index模态框? 以百度登录界面为例:</p><p>百度登陆页面 其实是三层结构</p><ul><li>最底部是正常内容(z&#x3D;0)  最远的</li><li>黑色的透明区(z&#x3D;99)   中间层</li><li>白色的注册区域(z&#x3D;100)  离用户最近</li></ul><p>z-index其实就是一种<code>堆叠显示</code>的的方法,控制<code>谁在上层,谁在下层</code></p><p><strong><font color="red">数值越大, 越上层</font></strong></p><p>案例代码如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        body &#123;            margin: 0;        &#125;        .cover &#123;            background-color:deepskyblue;            border: 2px solid;            height: 500px;            width: 500px;                        position: fixed;    &#x2F;* 固定定位，脱离文档流 *&#x2F;            left: 50%;            top: 50%;            margin-left: -250px;            margin-top: -250px;            z-index: 99;        &#125;                .modal &#123;            background-color: rgba(20, 20, 20, 0.5);            height: 300px;            width: 300px;            &#x2F;* 将元素左上角定位到页面中心 *&#x2F;            position: fixed;            left: 50%;            top: 50%;            &#x2F;* 通过margin将元素的内容挪到中间 *&#x2F;            margin-left: -150px;            margin-top: -150px;            &#x2F;* 设置显示在最上层 *&#x2F;            z-index: 100;        &#125;            &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div class&#x3D;&quot;cover&quot;&gt;最底层的页面&lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;modal&quot;&gt;        &lt;h1&gt;登录页面&lt;&#x2F;h1&gt;        &lt;p&gt;账号&lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;密码&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;&lt;&#x2F;p&gt;        &lt;p&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;是兄弟就来点我&quot;&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果:</p><p><img src="/../../../img/image-20220808111427871.png" alt="image-20220808111427871"></p><h1 id="6-透明度"><a href="#6-透明度" class="headerlink" title="6 透明度"></a>6 透明度</h1><p>使用<code>opacity</code>设置透明度,案例代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        p &#123;            width: 300px;            height: 300px;            font-size: 80px;            background-color: cornflowerblue;            &#x2F;* color: rgba(0, 0, 0, 0.5); *&#x2F;            opacity: 0.5;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;p&gt;测试字体TEST&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>补充知识: opcity和rgba的区别?</p><p>在<code>没有设置透明</code>的情况下, 效果如下图:</p><p><img src="/../../../img/image-20220808142123596.png" alt="image-20220808142123596"></p><p>单独设置<code>opcity: 0.5</code>后如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">opacity: 0.5;</code></pre></div></figure><p><img src="/../../../img/image-20220808142213251.png" alt="image-20220808142213251"></p><p>单独设置<code>rgba透明度0.5</code>后,如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">color: rgba(0, 0, 0, 0.5);</code></pre></div></figure><p><img src="/../../../img/image-20220808142251359.png" alt="image-20220808142251359"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>05_CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day52-CSS-02</title>
    <link href="/2022/08/03/03_Python/04_%E5%89%8D%E7%AB%AF/day52%E7%AC%94%E8%AE%B0-CSS-02/"/>
    <url>/2022/08/03/03_Python/04_%E5%89%8D%E7%AB%AF/day52%E7%AC%94%E8%AE%B0-CSS-02/</url>
    
    <content type="html"><![CDATA[<p>“第52天CSS02学习笔记”</p><h1 id="1-分组与嵌套"><a href="#1-分组与嵌套" class="headerlink" title="1 分组与嵌套"></a>1 分组与嵌套</h1><h2 id="1-1-分组选择器"><a href="#1-1-分组选择器" class="headerlink" title="1.1 分组选择器"></a>1.1 分组选择器</h2><p>在样式表中有很多具有相同样式的元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">div &#123;    color: darkorange;&#125;p &#123;    color: darkorange;&#125;span &#123;    color: darkorange;&#125;</code></pre></div></figure><p>为减少代码， 可以使用分组选择器，多个选择器之间使用<code>逗号</code>分隔</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;style&gt;        &#x2F;*使用分组选择器*&#x2F;        div, p, span &#123;            color: darkorange;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div&gt;DIV&lt;&#x2F;div&gt;    &lt;p&gt;PPP&lt;&#x2F;p&gt;    &lt;span&gt;SPAN&lt;&#x2F;span&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h2 id="1-2-嵌套选择器"><a href="#1-2-嵌套选择器" class="headerlink" title="1.2 嵌套选择器"></a>1.2 嵌套选择器</h2><p>它可能适用于选择器内部的选择器的样式。</p><p>在下面的例子设置了四个样式：</p><ul><li><strong>p{ }</strong>: 为所有 <strong>p</strong> 元素指定一个样式。</li><li><strong>.marked{ }</strong>: 为所有 <strong>class&#x3D;”marked”</strong> 的元素指定一个样式。</li><li><strong>.marked p{ }</strong>: 为所有 <strong>class&#x3D;”marked”</strong> 元素内的 <strong>p</strong> 元素指定一个样式。</li><li><strong>p.marked{ }</strong>: 为所有 <strong>class&#x3D;”marked”</strong> 的 <strong>p</strong> 元素指定一个样式。</li></ul><p>案例代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">p&#123;    color:blue;    text-align:center;&#125;.marked&#123;    background-color:red;&#125;.marked p&#123;    color:white;&#125;p.marked&#123;    text-decoration:underline;&#125;</code></pre></div></figure><h1 id="2-伪类选择器"><a href="#2-伪类选择器" class="headerlink" title="2 伪类选择器"></a>2 伪类选择器</h1><p>伪类选择器以<code>标签:状态</code>的方式使用</p><p>案例代码:</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;style&gt;        body &#123;            background-color: darkseagreen;        &#125;        &#x2F;*链接未点击的样式*&#x2F;        a:link &#123;            color: red;        &#125;        &#x2F;*鼠标放在链接上的样式*&#x2F;        a:hover &#123;            color: aqua;        &#125;        &#x2F;*鼠标按住不放的样式*&#x2F;        a:active &#123;            color: black;        &#125;        &#x2F;*鼠标点击松开后的样式*&#x2F;        a:visited &#123;            color: blue;        &#125;        &#x2F;*鼠标放在标签上的样式*&#x2F;        p:hover &#123;            background-color: white;        &#125;        &#x2F;*鼠标聚焦到输入框的样式（鼠标点了input框）*&#x2F;        input:focus &#123;            background-color: deeppink;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;gsproj.github.io&quot;&gt;我的博客&lt;&#x2F;a&gt;    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;gsproj.github.io&quot;&gt;JUMP&lt;&#x2F;a&gt;    &lt;p&gt;点我进去康康&lt;&#x2F;p&gt;    &lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h1 id="3-伪元素选择器"><a href="#3-伪元素选择器" class="headerlink" title="3 伪元素选择器"></a>3 伪元素选择器</h1><p>伪元素通常用来实现””首字母大写””和清除浮动带来的“父标签塌陷”的的问题</p><p>案例代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        &#x2F;*伪元素实现首字母大写*&#x2F;        p:first-letter &#123;            font-size: 48px;            color: orange;        &#125;        &#x2F;*段前添加文字*&#x2F;        p:before &#123;            content: &#39;加在前面&#39;;            color: palevioletred;        &#125;        &#x2F;*段后添加文字*&#x2F;        p:after &#123;            content: &#39;加在后面&#39;;            color: palevioletred;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;p&gt;这是一段不起眼的文字&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>before和after加的文字是不能被鼠标选择的，效果如下：</p><p><img src="/../../../img/image-20220803163319946.png" alt="image-20220803163319946"></p><h1 id="4-选择器的优先级"><a href="#4-选择器的优先级" class="headerlink" title="4 选择器的优先级"></a>4 选择器的优先级</h1><p>选择器相同，书写顺序不同：</p><p>​就近原则：谁离标签<strong>更近</strong>，谁的优先级<strong>越高</strong></p><p>选择器不同：</p><p>​行内 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器</p><p>组合选择器通过计算权值对比：</p><table><thead><tr><th>选择器</th><th>权值</th></tr></thead><tbody><tr><td>! important</td><td>&gt;1000</td></tr><tr><td>内联样式</td><td>&gt;1000</td></tr><tr><td>id选择器 #</td><td>100</td></tr><tr><td>类选择器 .</td><td>10</td></tr><tr><td>伪类选择器</td><td>10</td></tr><tr><td>标签选择器</td><td>1</td></tr><tr><td>通用选择器 *</td><td>0</td></tr><tr><td>继承的样式</td><td>0</td></tr></tbody></table><h1 id="5-块标签与行内标签"><a href="#5-块标签与行内标签" class="headerlink" title="5 块标签与行内标签"></a>5 块标签与行内标签</h1><p>特点：</p><p><strong>块标签(block)</strong></p><p>​独占一行，可以设置长宽</p><p><strong>行内标签(inline)</strong></p><p>​多个标签在一行，设置长宽无效</p><p>案例代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;style&gt;        &#x2F;*块标签设置高宽有效*&#x2F;        p &#123;            background-color: deeppink;            border: 2px;            height: 200px;            width: 400px;        &#125;        &#x2F;*行内标签设置高宽无效*&#x2F;        span &#123;            background-color: deepskyblue;            border: 2px;            height: 200px;            width: 400px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;p&gt;块标签01&lt;&#x2F;p&gt;    &lt;p&gt;块标签02&lt;&#x2F;p&gt;    &lt;span&gt;行内标签01&lt;&#x2F;span&gt;    &lt;span&gt;行内标签02&lt;&#x2F;span&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220803164759050.png" alt="image-20220803164759050"></p><h1 id="6-字体属性"><a href="#6-字体属性" class="headerlink" title="6 字体属性"></a>6 字体属性</h1><p>修改字体样式，案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">p &#123;    &#x2F;*font-family: &quot;Arial Black&quot;,&quot;微软雅黑&quot;,&quot;...&quot;;  !*第一个不生效就用后面的 写多个备用*!*&#x2F;    &#x2F;*font-size: 24px;  !*字体大小*!*&#x2F;    &#x2F;*font-weight: inherit;  !*bolder lighter 100~900 inherit继承父元素的粗细值*!*&#x2F;    &#x2F;*color: red;  !*直接写颜色英文*!*&#x2F;    &#x2F;*color: #ee762e;  !*颜色编号*!*&#x2F;    &#x2F;*color: rgb(128,23,45);  !*三基色 数字  范围0-255*!*&#x2F;    &#x2F;*color: rgba(23, 128, 91, 0.9);  !*第四个参数是颜色的透明度 范围是0-1*!*&#x2F;&#125;</code></pre></div></figure><h1 id="7-文字属性"><a href="#7-文字属性" class="headerlink" title="7 文字属性"></a>7 文字属性</h1><p>修改文字居中、下划线等显示样式，案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">p &#123;            &#x2F;*text-align: center;  !*居中*!*&#x2F;            &#x2F;*text-align: right;*&#x2F;            &#x2F;*text-align: left;*&#x2F;            &#x2F;*text-align: justify;  !*两端对齐*!*&#x2F;            &#x2F;*text-decoration: underline;*&#x2F;            &#x2F;*text-decoration: overline;*&#x2F;            &#x2F;*text-decoration: line-through;*&#x2F;            &#x2F;*text-decoration: none;*&#x2F;            &#x2F;*在html中 有很多标签渲染出来的样式效果是一样的*&#x2F;            font-size: 16px;            text-indent: 32px;   &#x2F;*缩进32px*&#x2F;        &#125;        a &#123;            text-decoration: none;  &#x2F;*主要用于给a标签去掉自带的下划线  需要掌握*&#x2F;        &#125;</code></pre></div></figure><h1 id="8-背景图片"><a href="#8-背景图片" class="headerlink" title="8 背景图片"></a>8 背景图片</h1><p>给标签添加背景色&#x2F;背景图片, 案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;style&gt;        #d1 &#123;            height: 500px;            background-color: red;        &#125;        #d2 &#123;            height: 500px;            background-color: green;        &#125;        #d3 &#123;            height: 500px;            background-image: url(&quot;222.png&quot;);&#x2F;*添加背景图片*&#x2F;            background-attachment: fixed;&#x2F;*背景保持不动*&#x2F;            background-repeat: no-repeat;   &#x2F;*背景图不平铺*&#x2F;        &#125;        #d4 &#123;            height: 500px;            background-color: aqua;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;d1&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d2&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d3&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d4&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h1 id="9-边框"><a href="#9-边框" class="headerlink" title="9 边框"></a>9 边框</h1><p>设置元素的边框样式，案例代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;style&gt;        p &#123;            background-color: red;            border-width: 5px;            border-style: solid;            border-color: green;        &#125;        div &#123;            &#x2F;*border-left-width: 5px;*&#x2F;            &#x2F;*border-left-color: red;*&#x2F;            &#x2F;*border-left-style: dotted;*&#x2F;            &#x2F;*border-right-width: 10px;*&#x2F;            &#x2F;*border-right-color: greenyellow;*&#x2F;            &#x2F;*border-right-style: solid;*&#x2F;            &#x2F;*border-top-width: 15px;*&#x2F;            &#x2F;*border-top-color: deeppink;*&#x2F;            &#x2F;*border-top-style: dashed;*&#x2F;            &#x2F;*border-bottom-width: 10px;*&#x2F;            &#x2F;*border-bottom-color: tomato;*&#x2F;            &#x2F;*border-bottom-style: solid;*&#x2F;            border: 3px solid red;  &#x2F;*三者位置可以随意写*&#x2F;        &#125;        #d1 &#123;            background-color: greenyellow;            height: 400px;            width: 400px;            border-radius: 50%;  &#x2F;*设置边框椭圆：直接写50%即可 长宽一样就是圆 不一样就是椭圆*&#x2F;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;p&gt;这是一个有趣的故事&lt;&#x2F;p&gt;&lt;div&gt;乌拉阿拉蕾&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d1&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h1 id="10-display属性"><a href="#10-display属性" class="headerlink" title="10 display属性"></a>10 display属性</h1><p>display属性常用方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">display:none隐藏元素，位置不占用display:block转换为块元素（独占一行，可调节高宽）display:inline转换为行内元素（非独占一行，不可调节高宽）display:inline-block转换为行内块元素（非独占一行，可调节高宽）</code></pre></div></figure><p>另一个隐藏属性的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">visibility: hidden</code></pre></div></figure><p>与<code>display:none</code>的区别：隐藏的属性**<font color='red'>仍然占用位置</font>**</p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;style&gt;        &#x2F;*#d1 &#123;*&#x2F;        &#x2F;*    !*display: none;  !*隐藏标签不展示到前端页面并且原来的位置也不再占有了 但是还存在于文档上*!*!*&#x2F;        &#x2F;*    display: inline;  !*将标签设置为行内标签的特点*!*&#x2F;        &#x2F;*&#125;*&#x2F;        &#x2F;*#d2 &#123;*&#x2F;        &#x2F;*    display: inline;*&#x2F;        &#x2F;*&#125;*&#x2F;        &#x2F;*#d1 &#123;*&#x2F;        &#x2F;*    display: block;  !*将标签设置成块儿级标签的特点*!*&#x2F;        &#x2F;*&#125;*&#x2F;        &#x2F;*#d2 &#123;*&#x2F;        &#x2F;*    display: block;*&#x2F;        &#x2F;*&#125;*&#x2F;        &#x2F;*#d1 &#123;*&#x2F;        &#x2F;*    display: inline-block;*&#x2F;        &#x2F;*&#125;*&#x2F;        &#x2F;*#d2 &#123;*&#x2F;        &#x2F;*    display: inline-block;  !*标签即可以在一行显示又可以设置长宽*!*&#x2F;        &#x2F;*&#125;*&#x2F;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div style&#x3D;&quot;display: none&quot;&gt;div1&lt;&#x2F;div&gt;&lt;div&gt;div2&lt;&#x2F;div&gt;&lt;div style&#x3D;&quot;visibility: hidden&quot;&gt;单纯的隐藏 位置还在&lt;&#x2F;div&gt;  &lt;div&gt;div4&lt;&#x2F;div&gt;&lt;!--&lt;div id&#x3D;&quot;d1&quot; style&#x3D;&quot;height: 100px;width: 100px;background-color: red&quot;&gt;01&lt;&#x2F;div&gt;--&gt;&lt;!--&lt;div id&#x3D;&quot;d2&quot; style&#x3D;&quot;height: 100px;width: 100px;background-color: greenyellow&quot;&gt;02&lt;&#x2F;div&gt;--&gt;&lt;!--&lt;span id&#x3D;&quot;d1&quot; style&#x3D;&quot;height: 100px;width: 100px;background-color: red&quot;&gt;span&lt;&#x2F;span&gt;--&gt;&lt;!--&lt;span id&#x3D;&quot;d2&quot; style&#x3D;&quot;height: 100px;width: 100px;background-color: greenyellow&quot;&gt;span&lt;&#x2F;span&gt;--&gt;&lt;!--&lt;div id&#x3D;&quot;d1&quot; style&#x3D;&quot;height: 100px;width: 100px;background-color: red&quot;&gt;01&lt;&#x2F;div&gt;--&gt;&lt;!--&lt;div id&#x3D;&quot;d2&quot; style&#x3D;&quot;height: 100px;width: 100px;background-color: greenyellow&quot;&gt;02&lt;&#x2F;div&gt;--&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h1 id="11-盒子模型"><a href="#11-盒子模型" class="headerlink" title="11 盒子模型"></a>11 盒子模型</h1><p>什么是盒子模型？</p><ul><li>就以快递盒为例</li><li>快递盒与快递盒之间的距离(标签与标签之间的距离 margin外边距)</li><li>盒子的厚度(标签的边框 border)</li><li>盒子里面的物体到盒子的距离(内容到边框的距离  padding内边距)</li><li>物体的大小(内容 content)</li></ul><p>如果你想要调整标签与标签之间的距离 你就可以调整margin</p><blockquote><p>补充：浏览器会自带8px的margin，一般情况下我们在写页面的时候，上来就会先将body的margin去除</p></blockquote><p><img src="/../../../img/image-20220804084912153.png" alt="image-20220804084912153"></p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;style&gt;        body &#123;            margin: 0;  &#x2F;*上下左右全是0            &#x2F;*margin: 10px 20px;  !* 第一个上下 第二个左右*!*&#x2F;            &#x2F;*margin: 10px 20px 30px;  !*第一个上  第二个左右  第三个下*!*&#x2F;            &#x2F;*margin: 10px 20px 30px 40px;  !*上 右 下 左*!*&#x2F;        &#125;        &#x2F;*p &#123;*&#x2F;        &#x2F;*    margin-left: 0;*&#x2F;        &#x2F;*    margin-top: 0;*&#x2F;        &#x2F;*    margin-right: 0;*&#x2F;        &#x2F;*    margin-bottom: 0;*&#x2F;        &#x2F;*&#125;*&#x2F;        #d1 &#123;            margin-bottom: 50px;        &#125;        #d2 &#123;            margin-top: 20px;  &#x2F;*不叠加 只取大的*&#x2F;        &#125;        #dd &#123;            margin: 0 auto;  &#x2F;*只能做到标签的水平居中*&#x2F;        &#125;        p &#123;            border: 3px solid red;            &#x2F;*padding-left: 10px;*&#x2F;            &#x2F;*padding-top: 20px;*&#x2F;            &#x2F;*padding-right: 20px;*&#x2F;            &#x2F;*padding-bottom: 50px;*&#x2F;            &#x2F;*padding: 10px;*&#x2F;            &#x2F;*padding: 10px 20px;*&#x2F;            &#x2F;*padding: 10px 20px 30px;*&#x2F;            &#x2F;*padding: 10px 20px 30px 40px;*&#x2F;  &#x2F;*规律和margin一模一样*&#x2F;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--    &lt;p style&#x3D;&quot;border: 1px solid red;&quot; id&#x3D;&quot;d1&quot;&gt;ppp&lt;&#x2F;p&gt;--&gt;&lt;!--    &lt;p style&#x3D;&quot;border: 1px solid orange;&quot; id&#x3D;&quot;d2&quot;&gt;ppp&lt;&#x2F;p&gt;--&gt;&lt;!--&lt;div style&#x3D;&quot;border: 3px solid red;height: 400px;width: 400px&quot;&gt;--&gt;&lt;!--    &lt;div id&#x3D;&#39;dd&#39; style&#x3D;&quot;border: 1px solid orange;height: 50px;width: 50px;background-color: blue;&quot;&gt;&lt;&#x2F;div&gt;--&gt;&lt;!--&lt;&#x2F;div&gt;--&gt;&lt;p&gt;ppp&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><h1 id="12-浮动"><a href="#12-浮动" class="headerlink" title="12 浮动"></a>12 浮动</h1><p>浮动的元素，没有块级和行内一说，本身多大浮起来之后就占多大</p><p>案例代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">只要是设计到页面的布局一般都是用浮动来提前规划好&lt;style&gt;        body &#123;            margin: 0;        &#125;        #d1 &#123;            height: 200px;            width: 200px;            background-color: red;            float: left;  &#x2F;*浮动  浮到空中往左飘*&#x2F;        &#125;        #d2 &#123;            height: 200px;            width: 200px;            background-color: greenyellow;            float: right;   &#x2F;*浮动 浮到空中往右飘*&#x2F;        &#125;&lt;&#x2F;style&gt;</code></pre></div></figure><p><code>overflow:hidden</code>超出部分隐藏，用来解决外边距塌陷问题：</p><p>父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷。</p><h1 id="13-浮动带来的影响"><a href="#13-浮动带来的影响" class="headerlink" title="13 浮动带来的影响"></a>13 浮动带来的影响</h1>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>05_CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day51-CSS-01</title>
    <link href="/2022/08/02/03_Python/04_%E5%89%8D%E7%AB%AF/day51%E7%AC%94%E8%AE%B0-CSS-01/"/>
    <url>/2022/08/02/03_Python/04_%E5%89%8D%E7%AB%AF/day51%E7%AC%94%E8%AE%B0-CSS-01/</url>
    
    <content type="html"><![CDATA[<p>“第51天CSS01学习笔记”</p><h1 id="1-引入CSS的三种方式"><a href="#1-引入CSS的三种方式" class="headerlink" title="1 引入CSS的三种方式"></a>1 引入CSS的三种方式</h1><p>引入CSS共有三种方式，分别是</p><ul><li>style标签内部直接书写（用于演示效果）</li><li>link标签引入外部css文件（最正规、多用的方式）</li><li>行内式(一般不用)</li></ul><p>使用方式如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--学习css引入CSS的三种方法--&gt;&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot;          content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;!--    方式一：通过style引入--&gt;    &lt;style&gt;        h1 &#123;            color: green;        &#125;    &lt;&#x2F;style&gt;&lt;!--    方式三：通过link引入外部文件(使用最多)--&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;03_被引入的CSS.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;这是H1标题&lt;&#x2F;h1&gt;&lt;!--    方式二：行内式引入--&gt;    &lt;h2 style&#x3D;&quot;color:red&quot;&gt;这是H2标题&lt;&#x2F;h2&gt;    &lt;h3&gt;这是H3标题&lt;&#x2F;h3&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>其中文件<code>03_被引入的CSS.css</code>的内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;*这是被引用的CSS文件这是注释的方法 *&#x2F;h3 &#123;    color: cornflowerblue;&#125;</code></pre></div></figure><p>引用CSS后的效果：</p><p><img src="/../../../img/image-20220801141907551.png" alt="image-20220801141907551"></p><h1 id="2-CSS选择器"><a href="#2-CSS选择器" class="headerlink" title="2 CSS选择器"></a>2 CSS选择器</h1><p>选择器共分为三种，分别是</p><ul><li>基础选择器</li><li>组合选择器</li><li>属性选择器</li></ul><p>接下来将一一介绍它们的使用方法</p><h2 id="2-1-基础选择器"><a href="#2-1-基础选择器" class="headerlink" title="2.1 基础选择器"></a>2.1 基础选择器</h2><p>基础选择器具分为：</p><ul><li>ID选择器</li><li>类选择器</li><li>元素&#x2F;标签选择器</li><li>通用选择器</li></ul><p>使用方法如下代码所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--学习CSS选择器的用法--&gt;&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot;          content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;!--    引入CSS--&gt;    &lt;style&gt;        &#x2F;*ID选择器*&#x2F;        #id01 &#123;            &#x2F;*找到id值是&quot;id01&quot;的标签，改变文字颜色*&#x2F;            color: blueviolet;        &#125;        &#x2F;*类选择器*&#x2F;        .class01 &#123;            &#x2F;*找到class值是&quot;class01&quot;的标签，改变文字颜色*&#x2F;            color: deeppink;        &#125;        span &#123;            &#x2F;*找到所有span标签，改变文字颜色*&#x2F;            color: blue;        &#125;        * &#123;            &#x2F;*将html页面所有的标签全部找到，并修改字体类型和大小*&#x2F;            font-family: 幼圆;            font-size: 50px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div&gt;        &lt;p id&#x3D;&quot;id01&quot;&gt;这是演示文字01&lt;&#x2F;p&gt;        &lt;p class&#x3D;&quot;class01&quot;&gt;这是演示文字02&lt;&#x2F;p&gt;        &lt;p class&#x3D;&quot;class01&quot;&gt;这是演示文字03&lt;&#x2F;p&gt;        &lt;span&gt;这是演示文字03&lt;&#x2F;span&gt;        &lt;span&gt;这是演示文字04&lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>选择器效果：</p><p><img src="/../../../img/image-20220801143520201.png" alt="image-20220801143520201"></p><h2 id="2-2-组合选择器"><a href="#2-2-组合选择器" class="headerlink" title="2.2 组合选择器"></a>2.2 组合选择器</h2><p>组合选择器分为四种：</p><ul><li>后代选择器（所有后代）</li><li>子元素选择器（儿子）</li><li>相邻兄弟选择器</li><li>后续兄弟选择器</li></ul><h3 id="2-2-1-后代选择器："><a href="#2-2-1-后代选择器：" class="headerlink" title="2.2.1 后代选择器："></a>2.2.1 后代选择器：</h3><blockquote><p>选取某元素的后代元素</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;style&gt;&#x2F;*后代选择器：修改&lt;div&gt;所有后代&lt;p&gt;的背景色  *&#x2F;div p&#123;background-color:yellow;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;段落 1。 在 div 中。&lt;&#x2F;p&gt;&lt;p&gt;段落 2。 在 div 中。&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;p&gt;段落 3。不在 div 中。&lt;&#x2F;p&gt;&lt;p&gt;段落 4。不在 div 中。&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220801163330446.png" alt="image-20220801163330446"></p><h3 id="2-2-2-子元素选择器"><a href="#2-2-2-子元素选择器" class="headerlink" title="2.2.2 子元素选择器"></a>2.2.2 子元素选择器</h3><blockquote><p>选取某元素的（直接&#x2F;一级）子元素</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;style&gt;&#x2F;*子元素选择器：*&#x2F;&#x2F;*给&lt;div&gt;的儿子&lt;p&gt;设置背景色*&#x2F;div&gt;p&#123;background-color:yellow;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;Welcome to My Homepage&lt;&#x2F;h1&gt;&lt;div&gt;&lt;h2&gt;My name is Donald&lt;&#x2F;h2&gt;&lt;p&gt;I live in Duckburg.&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;span&gt;&lt;p&gt;I will not be styled.&lt;&#x2F;p&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;p&gt;My best friend is Mickey.&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220801163723386.png" alt="image-20220801163723386"></p><h3 id="2-2-3-相邻兄弟选择器"><a href="#2-2-3-相邻兄弟选择器" class="headerlink" title="2.2.3 相邻兄弟选择器"></a>2.2.3 相邻兄弟选择器</h3><blockquote><p>选择<code>紧接</code>在<code>指定元素</code>后的元素，且二者有相同父元素。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;style&gt;&#x2F;*选择紧接在&lt;div&gt;后的&lt;p&gt;，修改背景色*&#x2F;div+p&#123;background-color:yellow;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;文章标题&lt;&#x2F;h1&gt;&lt;div&gt;    &lt;h2&gt;DIV 内部标题&lt;&#x2F;h2&gt;    &lt;p&gt;DIV 内部段落。&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;p&gt;DIV 之后的第一个 P 元素。&lt;&#x2F;p&gt;&lt;p&gt;DIV 之后的第二个 P 元素。&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220801164015184.png" alt="image-20220801164015184"></p><h3 id="2-2-4-后续兄弟选择器"><a href="#2-2-4-后续兄弟选择器" class="headerlink" title="2.2.4 后续兄弟选择器"></a>2.2.4 后续兄弟选择器</h3><blockquote><p>选择<code>指定元素</code>后的元素，且二者有相同父元素。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;style&gt;&#x2F;*选择&lt;div&gt;后，跟&lt;div&gt;有相同父亲的&lt;p&gt;*&#x2F;div~p&#123;background-color:yellow;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt;之前段落，不会添加背景颜色。&lt;&#x2F;p&gt;&lt;div&gt;    &lt;p&gt;段落 1。 在 div 中。&lt;&#x2F;p&gt;    &lt;p&gt;段落 2。 在 div 中。&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;p&gt;段落 3。不在 div 中。&lt;&#x2F;p&gt;&lt;p&gt;段落 4。不在 div 中。&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220801164412943.png" alt="image-20220801164412943"></p><h2 id="2-3-属性选择器"><a href="#2-3-属性选择器" class="headerlink" title="2.3 属性选择器"></a>2.3 属性选择器</h2><p>分为三种：</p><ul><li>使用【属性】选择</li><li>使用【属性 + 值】选择</li><li>使用【属性 + 值 + 标签】选择</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--学习CSS属性选择器的使用--&gt;&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot;          content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;    &lt;style&gt;        &#x2F;*选择有name&#x3D;”username“属性的标签，设置背景色*&#x2F;        input[name&#x3D;&quot;username&quot;] &#123;            background-color: pink;        &#125;        &#x2F;*选择有name属性的标签，设置背景色*&#x2F;        [name] &#123;            background-color: yellowgreen;        &#125;        &#x2F;*选择有name&#x3D;”date“属性的&lt;input&gt;标签，设置背景色*&#x2F;        input[name&#x3D;&quot;date&quot;] &#123;            background-color: cornflowerblue;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div&gt;        &lt;label for&#x3D;&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;        &lt;input name&#x3D;&quot;username&quot; id&#x3D;&quot;username&quot;&gt;    &lt;&#x2F;div&gt;    &lt;div&gt;        &lt;label for&#x3D;&quot;passwd&quot;&gt;密码&lt;&#x2F;label&gt;        &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;passwd&quot; id&#x3D;&quot;passwd&quot;&gt;    &lt;&#x2F;div&gt;    &lt;div&gt;日期        &lt;input type&#x3D;&quot;data&quot; name&#x3D;&quot;date&quot;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220801165549457.png" alt="image-20220801165549457"></p><h1 id="3-id-name-class区别"><a href="#3-id-name-class区别" class="headerlink" title="3 id&#x2F;name&#x2F;class区别"></a>3 id&#x2F;name&#x2F;class区别</h1><blockquote><p>“知己知彼，百战不殆”</p></blockquote><p>他们的区别：</p><ul><li>id：标签唯一标识，好比我们身份证号码，具有唯一性。JS常用document,getGlementBy(id).</li><li>class：标签的类别，可重复使用，CSS常用。</li><li>name：标签的名称，与from表单配合使用提交数据后台</li></ul><p>id，class一般是页面使用，name一般是后台交互使用</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>05_CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动硬盘无法弹出的解决方法</title>
    <link href="/2022/07/31/06_%E6%9D%82%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/31/06_%E6%9D%82%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="移动硬盘无法弹出的解决方法"><a href="#移动硬盘无法弹出的解决方法" class="headerlink" title="移动硬盘无法弹出的解决方法"></a>移动硬盘无法弹出的解决方法</h1><p>当弹出移动硬盘的时候，容易遇到无法弹出的问题：</p><p><img src="/../../img/image-20230731140000033.png" alt="image-20230731140000033"></p><p>那么为了保护移动介质中的数据此时我们应该如何正常弹出设备呢？</p><p>1、此时应该在开始菜单下输入eventvwr命令打开事件查看器，如下图：</p><p><img src="/../../img/image-20230731140030865.png" alt="image-20230731140030865"></p><p>2、然后回车打开事件查看器，找到windows日志-系统，如下图：</p><p><img src="/../../img/image-20230731140056180.png" alt="image-20230731140056180"></p><p>3、然后在系统菜单下找到警告日志，右键属性，找到弹出移动介质报错的信息，定位弹出异常原因，如下图：</p><p><img src="/../../img/image-20230731140110708.png" alt="image-20230731140110708"></p><p>4、然后打开任务管理器，确认日志中提到的进程没有关联其他影响运行的进程，将进程结束，如下图：</p><p><img src="/../../img/image-20230731140123831.png" alt="image-20230731140123831"></p><p>5、再次进行移动介质的弹出操作，发现可以正常弹出移动介质设备了</p><p><img src="/../../img/image-20230731140149389.png" alt="image-20230731140149389"></p><p>本文转载自：<a href="https://blog.51cto.com/xiaozc/5662073">https://blog.51cto.com/xiaozc/5662073</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-HTML</title>
    <link href="/2022/07/28/03_Python/04_%E5%89%8D%E7%AB%AF/01_HTML/"/>
    <url>/2022/07/28/03_Python/04_%E5%89%8D%E7%AB%AF/01_HTML/</url>
    
    <content type="html"><![CDATA[<p>“Python的进阶方向之一：Web开发，在这之前需要了解常用的前端知识，这篇文章主要介绍HTML的简单使用”</p><h1 id="1-创建表格"><a href="#1-创建表格" class="headerlink" title="1 创建表格"></a>1 创建表格</h1><blockquote><p>作用：<code>table</code>标签用于展示数据</p></blockquote><h2 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h2><p>一组数据需要以表格方式展示，例如：</p><table><thead><tr><th>Name</th><th>Age</th><th>Height</th></tr></thead><tbody><tr><td>Tank</td><td>18</td><td>172</td></tr><tr><td>Jodan</td><td>20</td><td>190</td></tr><tr><td>Timi</td><td>8</td><td>200</td></tr></tbody></table><h2 id="1-2-数据表格化"><a href="#1-2-数据表格化" class="headerlink" title="1.2 数据表格化"></a>1.2 数据表格化</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table&gt;    &lt;thead&gt;# 表格头        &lt;tr&gt;# 一个tr表示一行            &lt;th&gt;Name&lt;&#x2F;th&gt;# th加粗文本            &lt;th&gt;Age&lt;&#x2F;th&gt;            &lt;th&gt;Height&lt;&#x2F;th&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;thead&gt;    &lt;tbody&gt;# 表格内容        &lt;tr&gt;            &lt;td&gt;Tank&lt;&#x2F;td&gt;# td正常文本            &lt;td&gt;18&lt;&#x2F;td&gt;            &lt;td&gt;172&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;....    &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;</code></pre></div></figure><p>效果如下图:</p><p><img src="/../../../img/image-20220727140746808.png" alt="image-20220727140746808"></p><p>给表格添加外边框</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table border&#x3D;&quot;1&quot;&gt;</code></pre></div></figure><p>效果如下图：</p><p><img src="/../../../img/image-20220727141229882.png" alt="image-20220727141229882"></p><h2 id="1-3-单元格-行-合并"><a href="#1-3-单元格-行-合并" class="headerlink" title="1.3 单元格(行)合并"></a>1.3 单元格<code>(行)</code>合并</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;td colspan&#x3D;&quot;2&quot;&gt;Tank&lt;&#x2F;td&gt;</code></pre></div></figure><p>效果如下图：</p><p><img src="/../../../img/image-20220727160233609.png" alt="image-20220727160233609"></p><h2 id="1-4-单元格-列-合并"><a href="#1-4-单元格-列-合并" class="headerlink" title="1.4 单元格(列)合并"></a>1.4 单元格<code>(列)</code>合并</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;td rowspan&#x3D;&quot;2&quot;&gt;20&lt;&#x2F;td&gt;</code></pre></div></figure><p>效果如下图:</p><p><img src="/../../../img/image-20220727160337780.png" alt="image-20220727160337780"></p><h1 id="2-创建表单"><a href="#2-创建表单" class="headerlink" title="2 创建表单"></a>2 创建表单</h1><blockquote><p>作用：</p><p>获取前端用户输入的数据（用户输入的，用户选择的，用户上传的等）</p><p>基于网络发送给后端服务器</p></blockquote><p>2.1 创建表单</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;&quot;&gt;&lt;&#x2F;form&gt;</code></pre></div></figure><p>其中<code>action</code>的作用与参数：</p><p>作用：</p><p>​控制数据提交的后端路径(给哪个服务端提交数据)</p><p>参数：</p><ul><li>什么都不写：默认就是朝当前页面所在的url提交数据</li><li>写全路径：<a href="https://www.baidu.com/">https://www.baidu.com</a>  朝百度服务端提交</li><li>只写路径后缀<code>action=&quot;/index/&quot;</code>：<br>自动识别出当前服务端的ip和port拼接到前面，即：<code>host:port/index/</code></li></ul><h2 id="2-2-input标签"><a href="#2-2-input标签" class="headerlink" title="2.2 input标签"></a>2.2 input标签</h2><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot;&gt;&lt;&#x2F;input</code></pre></div></figure><p><strong>input标签的常用<code>type</code></strong></p><ul><li><p>text:普通文本</p></li><li><p>password:密文</p></li><li><p>date:日期</p></li><li><p>submit:用来触发form表单提交数据的动作，点击后表单清空，内容被提交</p></li><li><p>button:就是一个普普通通的按钮 本身没有任何的功能 但是它是最有用的，学完js之后可以给它自定义各种功能</p></li><li><p>reset:重置内容，表单内容清空，内容不提交</p></li><li><p>radio:单选</p><p>默认选中要加checked&#x3D;’checked’</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; checked&#x3D;&#39;checked&#39;&gt;男</code></pre></div></figure><p>当标签的属性名和属性值一样的时候可以简写</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; checked&gt;女</code></pre></div></figure></li><li><p>checkbox:多选</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;input type&#x3D;&quot;checkbox&quot; checked&gt;DBJ</code></pre></div></figure></li><li><p>file:获取文件  也可以使用<code>multiple</code>一次性获取多个文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;input type&#x3D;&quot;file&quot; multiple&gt;</code></pre></div></figure></li><li><p>hidden:隐藏当前input框</p></li></ul><p><strong>input标签常用<code>属性</code>：</strong></p><ul><li><p>value: 添加默认值</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;label for&#x3D;&quot;d1&quot;&gt;username:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;d1&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;默认值&quot;&gt;&lt;&#x2F;label&gt;</code></pre></div></figure></li><li><p>disable：禁用控件</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;label for&#x3D;&quot;d1&quot;&gt;username:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;d1&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;默认值&quot; disable&gt;&lt;&#x2F;label&gt;</code></pre></div></figure></li><li><p>readonly：控件只读</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;label for&#x3D;&quot;d1&quot;&gt;username:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;d1&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;默认值&quot; readonly&gt;&lt;&#x2F;label&gt;</code></pre></div></figure></li></ul><h2 id="2-3-label标签"><a href="#2-3-label标签" class="headerlink" title="2.3 label标签"></a>2.3 label标签</h2><p>实现<code>点击输入框的名称</code>就能<code>将光标定位到输入框</code></p><p>使用案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;label for&#x3D;&quot;passwd&quot;&gt;Password:    &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;passwd&quot;&gt;&lt;&#x2F;label&gt;</code></pre></div></figure><h2 id="2-4-select标签"><a href="#2-4-select标签" class="headerlink" title="2.4 select标签"></a>2.4 select标签</h2><p>select标签 默认是单选 可以加mutiple参数变多选 默认选中selected</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; multiple&gt;    &lt;option value&#x3D;&quot;&quot; selected&gt;新垣结衣&lt;&#x2F;option&gt;    &lt;option value&#x3D;&quot;&quot; selected&gt;斯佳丽&lt;&#x2F;option&gt;    &lt;option value&#x3D;&quot;&quot;&gt;明老师&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;</code></pre></div></figure><p>可以使用<code>optgroup</code>标签给选项分组</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;    &lt;optgroup label&#x3D;&quot;上海&quot;&gt;        &lt;option value&#x3D;&quot;&quot; selected&gt;浦东&lt;&#x2F;option&gt;        &lt;option value&#x3D;&quot;&quot; selected&gt;黄埔&lt;&#x2F;option&gt;        &lt;option value&#x3D;&quot;&quot; selected&gt;青埔&lt;&#x2F;option&gt;    &lt;&#x2F;optgroup&gt;    &lt;optgroup label&#x3D;&quot;北京&quot;&gt;        &lt;option value&#x3D;&quot;&quot; selected&gt;朝阳&lt;&#x2F;option&gt;        &lt;option value&#x3D;&quot;&quot; selected&gt;昌平&lt;&#x2F;option&gt;        &lt;option value&#x3D;&quot;&quot; selected&gt;沙河&lt;&#x2F;option&gt;    &lt;&#x2F;optgroup&gt;&lt;&#x2F;select&gt;</code></pre></div></figure><h2 id="2-5-案例"><a href="#2-5-案例" class="headerlink" title="2.5 案例"></a>2.5 案例</h2><p>整合2.1-2.4的案例</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot;          content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--    学习表单标签的使用--&gt;    &lt;h1&gt;注册页面&lt;&#x2F;h1&gt;    &lt;form action&#x3D;&quot;&quot;&gt;&lt;!--        创建输入框--&gt;        &lt;p&gt;            &lt;!--        label标签的两种用法 &#45;&#45; 不包住的方式--&gt;            &lt;label for&#x3D;&quot;username&quot;&gt;Username&lt;&#x2F;label&gt;            &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot;&gt;        &lt;&#x2F;p&gt;        &lt;p&gt;            &lt;!--        label标签的两种用法 &#45;&#45; 包住的方式--&gt;            &lt;label for&#x3D;&quot;passwd&quot;&gt;Password:                &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;passwd&quot;&gt;            &lt;&#x2F;label&gt;        &lt;&#x2F;p&gt;        &lt;p&gt;            &lt;label for&#x3D;&quot;birthday&quot;&gt;Birthday:                &lt;input type&#x3D;&quot;date&quot; id&#x3D;&quot;birthday&quot;&gt;            &lt;&#x2F;label&gt;        &lt;&#x2F;p&gt;        &lt;p&gt;Gender            &lt;input type&#x3D;&quot;radio&quot; checked&#x3D;&quot;checked&quot; name&#x3D;&quot;gender&quot;&gt;boy            &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot;&gt;girl        &lt;&#x2F;p&gt;        &lt;p&gt;Hobby            &lt;input type&#x3D;&quot;checkbox&quot; checked name&#x3D;&quot;hobby&quot;&gt;video games            &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot;&gt;football            &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot;&gt;basketball        &lt;&#x2F;p&gt;        &lt;p&gt;偶像 &lt;!--选项--&gt;            &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; multiple&gt;                &lt;option value&#x3D;&quot;&quot; selected&gt;新垣结衣&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;&quot; selected&gt;小明&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;&quot; selected&gt;小花&lt;&#x2F;option&gt;            &lt;&#x2F;select&gt;        &lt;&#x2F;p&gt;        &lt;p&gt;住址 &lt;!--选项分组--&gt;            &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;                &lt;optgroup label&#x3D;&quot;上海&quot;&gt;                    &lt;option value&#x3D;&quot;&quot; selected&gt;浦东&lt;&#x2F;option&gt;                    &lt;option value&#x3D;&quot;&quot; selected&gt;黄埔&lt;&#x2F;option&gt;                    &lt;option value&#x3D;&quot;&quot; selected&gt;青埔&lt;&#x2F;option&gt;                &lt;&#x2F;optgroup&gt;                &lt;optgroup label&#x3D;&quot;北京&quot;&gt;                    &lt;option value&#x3D;&quot;&quot; selected&gt;朝阳&lt;&#x2F;option&gt;                    &lt;option value&#x3D;&quot;&quot; selected&gt;昌平&lt;&#x2F;option&gt;                    &lt;option value&#x3D;&quot;&quot; selected&gt;沙河&lt;&#x2F;option&gt;                &lt;&#x2F;optgroup&gt;            &lt;&#x2F;select&gt;        &lt;&#x2F;p&gt;        &lt;p&gt;输入框            &lt;textarea name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; cols&#x3D;&quot;30&quot; rows&#x3D;&quot;10&quot; maxlength&#x3D;&quot;20&quot;&gt;            &lt;&#x2F;textarea&gt;        &lt;&#x2F;p&gt;        &lt;p&gt;文件上传            &lt;input type&#x3D;&quot;file&quot; multiple&gt;        &lt;&#x2F;p&gt;        &lt;p&gt;            &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;            &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;清空&quot;&gt;            &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;普通按钮&quot;&gt;        &lt;&#x2F;p&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>效果：</p><p><img src="/../../../img/image-20220728165553604.png" alt="image-20220728165553604"></p><h1 id="3-Flask框架的基本使用"><a href="#3-Flask框架的基本使用" class="headerlink" title="3 Flask框架的基本使用"></a>3 Flask框架的基本使用</h1><h2 id="3-1-第一个flask框架后端"><a href="#3-1-第一个flask框架后端" class="headerlink" title="3.1 第一个flask框架后端"></a>3.1 第一个flask框架后端</h2><p>使用Flask框架编写一个后端程序，首先需要安装Flask</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip3 install FLASK</code></pre></div></figure><p>编写后端代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, requestapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;index&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])def index():    return &#39;OK&#39;;app.run()</code></pre></div></figure><p>查看运行效果：</p><p><img src="/../../../img/image-20220729110925144.png" alt="image-20220729110925144"></p><h2 id="3-2-Form表单提交数据"><a href="#3-2-Form表单提交数据" class="headerlink" title="3.2 Form表单提交数据"></a>3.2 Form表单提交数据</h2><p>修改2.5的前端代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">...&lt;!--    学习表单标签的使用--&gt;    &lt;h1&gt;注册页面&lt;&#x2F;h1&gt;    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;index&quot; method&#x3D;&#39;post&#39;&gt;...</code></pre></div></figure><p>打开html页面，点击提交，将显示”OK”</p><blockquote><p>补充:</p><p>method方法的<code>post</code>和<code>get</code>有什么不同？</p><ul><li><p>post：提交数据隐藏</p></li><li><p>get：form表单默认提交数据的方式 是get请求  数据是直接放在url后面的，如下图：</p></li></ul><p><img src="/../../../img/image-20220729111744825.png" alt="image-20220729111744825"></p><p>其中<code>gender=on</code>中的<code>gender</code>由<code>name</code>属性定义，而<code>on</code>是其值</p></blockquote><h2 id="3-3-Form表单提交”选择标签”的数据"><a href="#3-3-Form表单提交”选择标签”的数据" class="headerlink" title="3.3 Form表单提交”选择标签”的数据"></a>3.3 Form表单提交”选择标签”的数据</h2><p>“”针对用户选择的标签（如select、radio、checkbox等），光有<code>name</code>属性是不够的，还需要提前给这些标签添加内容<code>value</code>值“</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p&gt;Gender&lt;input type&#x3D;&quot;radio&quot; checked&#x3D;&quot;checked&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;boy&quot;&gt;boy&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;girl&quot;&gt;girl&lt;&#x2F;p&gt;&lt;p&gt;Hobby    &lt;input type&#x3D;&quot;checkbox&quot; checked name&#x3D;&quot;hobby&quot; value&#x3D;&quot;videogames&quot;&gt;video games    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;football&quot;&gt;football    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;basketball&quot;&gt;basketball&lt;&#x2F;p&gt;</code></pre></div></figure><p>后端代码修改，添加输出前端数据的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, requestapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;index&#x2F;&#39;, methods&#x3D;[&#39;Get&#39;, &#39;Post&#39;])def index():    print(request.form)# 输出从前端获取的数据    return &#39;OK&#39;;app.run()</code></pre></div></figure><p>输出结果如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">ImmutableMultiDict([(&#39;username&#39;, &#39;dsa&#39;), (&#39;password&#39;, &#39;321432&#39;), (&#39;birthday&#39;, &#39;2022-07-14&#39;), (&#39;gender&#39;, &#39;girl&#39;), (&#39;hobby&#39;, &#39;videogames&#39;), (&#39;hobby&#39;, &#39;football&#39;), (&#39;偶像&#39;, &#39;小明&#39;), (&#39;偶像&#39;, &#39;小花&#39;), (&#39;dsa&#39;, &#39;黄埔&#39;), (&#39;textarea&#39;, &#39;       4443243t     &#39;)])127.0.0.1 - - [29&#x2F;Jul&#x2F;2022 14:33:22] &quot;POST &#x2F;index HTTP&#x2F;1.1&quot; 308 -127.0.0.1 - - [29&#x2F;Jul&#x2F;2022 14:33:22] &quot;POST &#x2F;index&#x2F; HTTP&#x2F;1.1&quot; 200 -</code></pre></div></figure><h2 id="3-4-Form表单提交文件"><a href="#3-4-Form表单提交文件" class="headerlink" title="3.4 Form表单提交文件"></a>3.4 Form表单提交文件</h2><p>form表单提交文件需要注意</p><ol><li><p><code>method</code>必须是<code>post</code></p></li><li><p><code>enctype=&quot;multipart/form-data&quot;</code></p><p>enctype类似于数据提交的编码格式</p><p>​默认是urlencoded 只能够提交普通的文本数据</p><p>​formdata 就可以支持提交文件数据</p></li></ol><p>因此需要修改前端代码，添加<code>entype</code>属性：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">...&lt;!--    学习表单标签的使用--&gt;    &lt;h1&gt;注册页面&lt;&#x2F;h1&gt;    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;index&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;...</code></pre></div></figure><p>并给<code>input</code>标签添加<code>name</code>属性</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p&gt;文件上传    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;myfile&quot;&gt;&lt;&#x2F;p&gt;</code></pre></div></figure><p>后端获取文件，保存到本地：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, requestapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;index&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])def index():    # 获取表单提交过来的非文件数据    print(request.form)    # 获取文件数据    print(request.files)    file_obj &#x3D; request.files.get(&#39;myfile&#39;)    print(file_obj.name)    file_obj.save(file_obj.name)    # 保存文件    return &#39;OK&#39;app.run()</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>04_HTML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统自启动应用</title>
    <link href="/2022/07/22/06_%E6%9D%82%E8%AE%B0/Linux%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8/"/>
    <url>/2022/07/22/06_%E6%9D%82%E8%AE%B0/Linux%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>“前言：工作上有这方面的需求，特记录下来，方便之后参考”</p><h3 id="1-创建rc-local服务文件🌞"><a href="#1-创建rc-local服务文件🌞" class="headerlink" title="1 创建rc-local服务文件🌞"></a>1 创建rc-local服务文件🌞</h3><p>创建文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">sudo vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;rc-local.service</code></pre></div></figure><p>内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[Unit]Description&#x3D;&#x2F;etc&#x2F;rc.local CompatibilityConditionPathExists&#x3D;&#x2F;etc&#x2F;rc.local[Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;etc&#x2F;rc.local startTimeoutSec&#x3D;0StandardOutput&#x3D;ttyRemainAfterExit&#x3D;yesSysVStartPriority&#x3D;99[Install]WantedBy&#x3D;multi-user.target</code></pre></div></figure><h3 id="2-激活rc-local服务🌞"><a href="#2-激活rc-local服务🌞" class="headerlink" title="2 激活rc-local服务🌞"></a>2 激活rc-local服务🌞</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl enable rc-local.service</code></pre></div></figure><h3 id="3-添加服务文件🌞"><a href="#3-添加服务文件🌞" class="headerlink" title="3 添加服务文件🌞"></a>3 添加服务文件🌞</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;etc&#x2F;rc.local</code></pre></div></figure><p>内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;sh -e# #rc.local# #This script is executed at the end of each multiuser runlevel.# Make sure that the script will &quot;exit 0&quot; on success or any other# value on error.# #In order to enable or disable this script just change the execution# bits.# #By default this script does nothing.# 下面是要开机启动的命令# 启动nginx&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf# 启动redis&#x2F;home&#x2F;sofware&#x2F;redis&#x2F;redis-4.8.0&#x2F;src&#x2F;redis-server &#x2F;home&#x2F;sofware&#x2F;redis&#x2F;redis-4.8.0&#x2F;redis.conf# 启动nacos&#x2F;bin&#x2F;bash -f &#x2F;home&#x2F;Software&#x2F;nacos&#x2F;startup.sh -m standaloneexit 0</code></pre></div></figure><p>给脚本文件添加执行权限  </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#给予脚本执行权限sudo chmod +x &#x2F;etc&#x2F;rc.local</code></pre></div></figure><h3 id="4-启动rc-local服务🌞"><a href="#4-启动rc-local服务🌞" class="headerlink" title="4 启动rc-local服务🌞"></a>4 启动rc-local服务🌞</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemc start rc-local.service</code></pre></div></figure><h3 id="5-查看服务启动情况🌞"><a href="#5-查看服务启动情况🌞" class="headerlink" title="5 查看服务启动情况🌞"></a>5 查看服务启动情况🌞</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status rc-local</code></pre></div></figure><p>正常情况下<code>Active</code>状态显示<code>active(exited)</code>  </p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Github IO如何绑定域名</title>
    <link href="/2022/07/20/06_%E6%9D%82%E8%AE%B0/Githubio%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <url>/2022/07/20/06_%E6%9D%82%E8%AE%B0/Githubio%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“如何将自己的域名绑定到Github IO”</p></blockquote><h2 id="1-获取原地址IP"><a href="#1-获取原地址IP" class="headerlink" title="1 获取原地址IP"></a>1 获取原地址IP</h2><p>通过ping获取</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@3yserver ~]# ping gsproj.github.ioPING gsproj.github.io (185.199.110.153) 56(84) bytes of data.64 bytes from cdn-185-199-110-153.github.com (185.199.110.153): icmp_seq&#x3D;1 ttl&#x3D;54 time&#x3D;36.1 ms64 bytes from cdn-185-199-110-153.github.com (185.199.110.153): icmp_seq&#x3D;2 ttl&#x3D;54 time&#x3D;36.0 ms64 bytes from cdn-185-199-110-153.github.com (185.199.110.153): icmp_seq&#x3D;3 ttl&#x3D;54 time&#x3D;35.9 ms64 bytes from cdn-185-199-110-153.github.com (185.199.110.153): icmp_seq&#x3D;4 ttl&#x3D;54 time&#x3D;35.9 ms64 bytes from cdn-185-199-110-153.github.com (185.199.110.153): icmp_seq&#x3D;5 ttl&#x3D;54 time&#x3D;38.3 ms64 bytes from cdn-185-199-110-153.github.com (185.199.110.153): icmp_seq&#x3D;6 ttl&#x3D;54 time&#x3D;36.1 ms</code></pre></div></figure><h2 id="2-在CDN将IP地址和域名绑定"><a href="#2-在CDN将IP地址和域名绑定" class="headerlink" title="2 在CDN将IP地址和域名绑定"></a>2 在CDN将IP地址和域名绑定</h2><p><img src="/../../img/image-20220718111616313.png" alt="image-20220718111616313"></p><h2 id="3-域名申请网站填写DNS解析地址"><a href="#3-域名申请网站填写DNS解析地址" class="headerlink" title="3 域名申请网站填写DNS解析地址"></a>3 域名申请网站填写DNS解析地址</h2><p><img src="/../../img/image-20220718112050165.png" alt="image-20220718112050165"></p><h2 id="3-确保新域名能ping通，解析正常"><a href="#3-确保新域名能ping通，解析正常" class="headerlink" title="3 确保新域名能ping通，解析正常"></a>3 确保新域名能ping通，解析正常</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@3yserver ~]# ping codefish.cfPING codefish.cf (104.21.96.42) 56(84) bytes of data.64 bytes from 104.21.96.42 (104.21.96.42): icmp_seq&#x3D;1 ttl&#x3D;59 time&#x3D;2.63 ms64 bytes from 104.21.96.42 (104.21.96.42): icmp_seq&#x3D;2 ttl&#x3D;59 time&#x3D;2.64 ms64 bytes from 104.21.96.42 (104.21.96.42): icmp_seq&#x3D;3 ttl&#x3D;59 time&#x3D;2.73 ms64 bytes from 104.21.96.42 (104.21.96.42): icmp_seq&#x3D;4 ttl&#x3D;59 time&#x3D;2.71 ms64 bytes from 104.21.96.42 (104.21.96.42): icmp_seq&#x3D;5 ttl&#x3D;59 time&#x3D;2.62 ms</code></pre></div></figure><blockquote><p>PS: 此处IP不是185开头的IP，是因为cloudflare做了代理，不影响使用，可以通就可以</p></blockquote><h2 id="4-在Github添加域名"><a href="#4-在Github添加域名" class="headerlink" title="4 在Github添加域名"></a>4 在Github添加域名</h2><p><img src="/../../img/image-20220718111923212.png" alt="image-20220718111923212"></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day48-数据库（五）</title>
    <link href="/2022/07/19/03_Python/03_MySQL/day48-%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%94)/"/>
    <url>/2022/07/19/03_Python/03_MySQL/day48-%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查询平均年龄在25岁以上的部门名称&quot;&quot;&quot;只要是多表查询 就有两种思路    联表    子查询&quot;&quot;&quot;# 联表操作1 先拿到部门和员工表 拼接之后的结果2 分析语义 得出需要进行分组    select dep.name from emp inner join dep    on emp.dep_id &#x3D; dep.id        group by dep.name        having avg(age) &gt; 25        ;&quot;&quot;&quot;涉及到多表操作的时候 一定要加上表的前缀&quot;&quot;&quot;# 子查询select name from dep where id in(select dep_id from emp group by dep_id     having avg(age) &gt; 25);# 关键字exists(了解)只返回布尔值 True False    返回True的时候外层查询语句执行    返回False的时候外层查询语句不再执行select * from emp where exists     (select id from dep where id&gt;3);                   select * from emp where exists     (select id from dep where id&gt;300);</code></pre></div></figure><h1 id="今日内容概要"><a href="#今日内容概要" class="headerlink" title="今日内容概要"></a>今日内容概要</h1><ul><li>navicat可视化界面操作数据库</li><li>数据库查询题目讲解(多表操作)</li><li>python如何操作MySQL(pymysql模块)</li><li>sql注入问题</li><li>pymysql模块增删改查数据操作</li></ul><h3 id="一、Navicat软件"><a href="#一、Navicat软件" class="headerlink" title="一、Navicat软件"></a>一、Navicat软件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;一开始学习python的时候 下载python解释器然后直接在终端书写pycharm能够更加方便快捷的帮助你书写python代码excel word pdf我们在终端操作MySQL 也没有自动提示也无法保存等等 不方便开发Navicat内部封装了所有的操作数据库的命令 用户在使用它的时候只需要鼠标点点即可完成操作 无需书写sql语句&quot;&quot;&quot;</code></pre></div></figure><p><strong>安装</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">直接百度搜索 有破解版的也有非破解非破解的有试用期 你如果不嫌麻烦 你就用使用到期之后重新装再使用 或者破解一下也很简单https:&#x2F;&#x2F;www.cr173.com&#x2F;soft&#x2F;126934.html    下载完成后是一个压缩包 直接解压 然后点击安装 有提醒直接点击next即可navicat能够充当多个数据库的客户端navicat图形化界面有时候反应速度较慢 你可以选择刷新或者关闭当前窗口再次打开即可当你有一些需求该软件无法满足的时候 你就自己动手写sql</code></pre></div></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1 MySQL是不区分大小写的验证码忽略大小写内部统一转大写或者小写比较即可upperlower2 MySQL建议所有的关键字写大写3 MySQL中的注释 有两种--#4 在navicat中如何快速的注释和解注释ctrl + ？  加注释ctrl + ？  基于上述操作再来一次就是解开注释如果你的navicat版本不一致还有可能是ctrl + shift + ？解开注释&quot;&quot;&quot;</code></pre></div></figure><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;课下一定要把握上课将的这几道题全部自己独立的理解并写出来在解决sql查询问题的时候 不要慌一步一步慢慢来  最终能够东拼西凑出来就过关了！！！&quot;&quot;&quot;-- 1、查询所有的课程的名称以及对应的任课老师姓名-- SELECT-- course.cname,-- teacher.tname -- FROM-- course-- INNER JOIN teacher ON course.teacher_id &#x3D; teacher.tid;-- 4、查询平均成绩大于八十分的同学的姓名和平均成绩-- SELECT-- student.sname,-- t1.avg_num -- FROM-- student-- INNER JOIN (-- SELECT-- score.student_id,-- avg( num ) AS avg_num -- FROM-- score-- INNER JOIN student ON score.student_id &#x3D; student.sid -- GROUP BY-- score.student_id -- HAVING-- AVG( num ) &gt; 80 -- ) AS t1 ON student.sid &#x3D; t1.student_id;-- 7、 查询没有报李平老师课的学生姓名# 分步操作# 1 先找到李平老师教授的课程id# 2 再找所有报了李平老师课程的学生id# 3 之后去学生表里面取反 就可以获取到没有报李平老师课程的学生姓名-- SELECT-- student.sname -- FROM-- student -- WHERE-- sid NOT IN (-- SELECT DISTINCT-- score.student_id -- FROM-- score -- WHERE-- score.course_id IN ( SELECT course.cid FROM teacher INNER JOIN course ON teacher.tid &#x3D; course.teacher_id WHERE teacher.tname &#x3D; &#39;李平老师&#39; ) -- );-- 8、 查询没有同时选修物理课程和体育课程的学生姓名--     (只要选了一门的 选了两门和没有选的都不要)# 1 先查物理和体育课程的id# 2 再去获取所有选了物理和体育的学生数据# 3 按照学生分组 利用聚合函数count筛选出只选了一门的学生id# 4 依旧id获取学生姓名-- SELECT-- student.sname -- FROM-- student -- WHERE-- student.sid IN (-- SELECT-- score.student_id -- FROM-- score -- WHERE-- score.course_id IN ( SELECT course.cid FROM course WHERE course.cname IN ( &#39;物理&#39;, &#39;体育&#39; ) ) -- GROUP BY-- score.student_id -- HAVING-- COUNT( score.course_id ) &#x3D; 1 -- );-- 9、 查询挂科超过两门(包括两门)的学生姓名和班级# 1 先筛选出所有分数小于60的数据# 2 按照学生分组 对数据进行计数获取大于等于2的数据SELECTclass.caption,student.sname FROMclassINNER JOIN student ON class.cid &#x3D; student.class_id WHEREstudent.sid IN (SELECTscore.student_id FROMscore WHEREscore.num &lt; 60 GROUP BY score.student_id HAVING COUNT( score.course_id ) &gt;&#x3D; 2 );</code></pre></div></figure><h3 id="pymysql模块"><a href="#pymysql模块" class="headerlink" title="pymysql模块"></a>pymysql模块</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;支持python代码操作数据库MySQL&quot;&quot;&quot;pip3 install pymysql</code></pre></div></figure><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;利用一些语法的特性 书写一些特点的语句实现固定的语法MySQL利用的是MySQL的注释语法select * from user where name&#x3D;&#39;jason&#39; -- jhsadklsajdkla&#39; and password&#x3D;&#39;&#39;select * from user where name&#x3D;&#39;xxx&#39; or 1&#x3D;1 -- sakjdkljakldjasl&#39; and password&#x3D;&#39;&#39;&quot;&quot;&quot;日常生活中很多软件在注册的时候都不能含有特殊符号因为怕你构造出特定的语句入侵数据库 不安全# 敏感的数据不要自己做拼接 交给execute帮你拼接即可# 结合数据库完成一个用户的登录功能？import pymysqlconn &#x3D; pymysql.connect(    host &#x3D; &#39;127.0.0.1&#39;,    port &#x3D; 3306,    user &#x3D; &#39;root&#39;,    password &#x3D; &#39;123456&#39;,    database &#x3D; &#39;day48&#39;,    charset &#x3D; &#39;utf8&#39;  # 编码千万不要加-)  # 链接数据库cursor &#x3D; conn.cursor(cursor&#x3D;pymysql.cursors.DictCursor)username &#x3D; input(&#39;&gt;&gt;&gt;:&#39;)password &#x3D; input(&#39;&gt;&gt;&gt;:&#39;)sql &#x3D; &quot;select * from user where name&#x3D;%s and password&#x3D;%s&quot;# 不要手动拼接数据 先用%s占位 之后将需要拼接的数据直接交给execute方法即可print(sql)rows &#x3D; cursor.execute(sql,(username,password))  # 自动识别sql里面的%s用后面元组里面的数据替换if rows:    print(&#39;登录成功&#39;)    print(cursor.fetchall())else:    print(&#39;用户名密码错误&#39;)</code></pre></div></figure><p><strong>作业布置</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1 navicat自己玩一玩2 练习题一定要搞懂 照着我的思路一遍遍的看敲3 熟悉pymysql的使用4 sql注入产生的原因和解决方法 了解5 思考:如何结合mysql实现用户的注册和登录功能？&quot;&quot;&quot;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>03_MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>54-附录九：Type Hinting</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/54_%E9%99%84%E5%BD%95%E4%B9%9D%EF%BC%9ATypeHinting/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/54_%E9%99%84%E5%BD%95%E4%B9%9D%EF%BC%9ATypeHinting/</url>
    
    <content type="html"><![CDATA[<p>类型提示 <strong>Type hinting</strong>（最低Python版本为3.5）</p><p>python3新增类型提示功能，例如我们可以为函数增加类型提示信息，而不影响函数本身的执行：</p><p>注释的一般规则是参数名后跟一个冒号（：），然后再跟一个expression，这个expression可以是任何形式。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">def func(a: &#39;spam&#39;, b: (1, 10), c: float) -&gt; int:    return a + b + c &gt;&gt;&gt; func(1, 2, 3)6</code></pre></div></figure><p>返回值的形式是 -&gt; int，annotation可被保存为函数的attributes。查看所有的annotation，可通过如下语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; func.__annotations__&#123;&#39;c&#39;: &lt;class &#39;float&#39;&gt;, &#39;a&#39;: &#39;spam&#39;, &#39;b&#39;: (1, 10), &#39;return&#39;: &lt;class &#39;int&#39;&gt;&#125;</code></pre></div></figure><p>如果为函数增加了注释，可不可以继续使用默认参数呢？答案是肯定的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; def func(a: &#39;spam&#39; &#x3D; 4, b: (1, 10) &#x3D; 5, c: float &#x3D; 6) -&gt; int:...   return a + b + c... &gt;&gt;&gt; func(1, 2, 3)6&gt;&gt;&gt; func()15&gt;&gt;&gt; func(1, c&#x3D;10)16&gt;&gt;&gt; func.__annotations__&#123;&#39;c&#39;: &lt;class &#39;float&#39;&gt;, &#39;a&#39;: &#39;spam&#39;, &#39;b&#39;: (1, 10), &#39;return&#39;: &lt;class &#39;int&#39;&gt;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day47-数据库（四）</title>
    <link href="/2022/07/18/03_Python/03_MySQL/day47-%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9B%9B)/"/>
    <url>/2022/07/18/03_Python/03_MySQL/day47-%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<p>“Day47-数据库(四)学习笔记”</p><h1 id="一、单表查询"><a href="#一、单表查询" class="headerlink" title="一、单表查询"></a>一、单表查询</h1><h2 id="1-1-前期表准备"><a href="#1-1-前期表准备" class="headerlink" title="1.1 前期表准备"></a>1.1 前期表准备</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">create table emp(  id int not null unique auto_increment,  name varchar(20) not null,  sex enum(&#39;male&#39;,&#39;female&#39;) not null default &#39;male&#39;, #大部分是男的  age int(3) unsigned not null default 28,  hire_date date not null,  post varchar(50),  post_comment varchar(100),  salary double(15,2),  office int, #一个部门一个屋子  depart_id int);#插入记录#三个部门：教学，销售，运营insert into emp(name,sex,age,hire_date,post,salary,office,depart_id) values(&#39;jason&#39;,&#39;male&#39;,18,&#39;20170301&#39;,&#39;张江第一帅形象代言&#39;,7300.33,401,1), #以下是教学部(&#39;tom&#39;,&#39;male&#39;,78,&#39;20150302&#39;,&#39;teacher&#39;,1000000.31,401,1),(&#39;kevin&#39;,&#39;male&#39;,81,&#39;20130305&#39;,&#39;teacher&#39;,8300,401,1),(&#39;tony&#39;,&#39;male&#39;,73,&#39;20140701&#39;,&#39;teacher&#39;,3500,401,1),(&#39;owen&#39;,&#39;male&#39;,28,&#39;20121101&#39;,&#39;teacher&#39;,2100,401,1),(&#39;jack&#39;,&#39;female&#39;,18,&#39;20110211&#39;,&#39;teacher&#39;,9000,401,1),(&#39;jenny&#39;,&#39;male&#39;,18,&#39;19000301&#39;,&#39;teacher&#39;,30000,401,1),(&#39;sank&#39;,&#39;male&#39;,48,&#39;20101111&#39;,&#39;teacher&#39;,10000,401,1),(&#39;哈哈&#39;,&#39;female&#39;,48,&#39;20150311&#39;,&#39;sale&#39;,3000.13,402,2),#以下是销售部门(&#39;呵呵&#39;,&#39;female&#39;,38,&#39;20101101&#39;,&#39;sale&#39;,2000.35,402,2),(&#39;西西&#39;,&#39;female&#39;,18,&#39;20110312&#39;,&#39;sale&#39;,1000.37,402,2),(&#39;乐乐&#39;,&#39;female&#39;,18,&#39;20160513&#39;,&#39;sale&#39;,3000.29,402,2),(&#39;拉拉&#39;,&#39;female&#39;,28,&#39;20170127&#39;,&#39;sale&#39;,4000.33,402,2),(&#39;僧龙&#39;,&#39;male&#39;,28,&#39;20160311&#39;,&#39;operation&#39;,10000.13,403,3), #以下是运营部门(&#39;程咬金&#39;,&#39;male&#39;,18,&#39;19970312&#39;,&#39;operation&#39;,20000,403,3),(&#39;程咬银&#39;,&#39;female&#39;,18,&#39;20130311&#39;,&#39;operation&#39;,19000,403,3),(&#39;程咬铜&#39;,&#39;male&#39;,18,&#39;20150411&#39;,&#39;operation&#39;,18000,403,3),(&#39;程咬铁&#39;,&#39;female&#39;,18,&#39;20140512&#39;,&#39;operation&#39;,17000,403,3);# 个别同学的电脑在插入中文的时候还是会出现乱码或者空白的现象 你可以将字符编码统一设置成GBK</code></pre></div></figure><p>当表字段特别多 展示的时候错乱 可以使用<code>\G</code>分行展示:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">select * from emp\G;</code></pre></div></figure><p>使用后输出信息分段</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">....*************************** 17. row ***************************          id: 17        name: 程咬铜         sex: male         age: 18   hire_date: 2015-04-11        post: operationpost_comment: NULL      salary: 18000.00      office: 403   depart_id: 3*************************** 18. row ***************************....</code></pre></div></figure><h2 id="1-2-几个重要关键字的执行顺序"><a href="#1-2-几个重要关键字的执行顺序" class="headerlink" title="1.2 几个重要关键字的执行顺序"></a>1.2 几个重要关键字的执行顺序</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 书写顺序select id,name from emp where id &gt; 3;# 执行顺序fromwhereselect&quot;&quot;&quot;虽然执行顺序和书写顺序不一致 你在写sql语句的时候可能不知道怎么写你就按照书写顺序的方式写sqlselect * 先用*号占位之后去补全后面的sql语句最后将*号替换后你想要的具体字段明天会一直使用 这里先理解&quot;&quot;&quot;</code></pre></div></figure><h2 id="1-3-where筛选条件"><a href="#1-3-where筛选条件" class="headerlink" title="1.3 where筛选条件"></a>1.3 where筛选条件</h2><p>作用：是对整体数据的一个筛选操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.查询id大于等于3小于等于6的数据select id,name,age from emp where id&gt;&#x3D;3 and id&lt;&#x3D;6;select id,name from emp where id between 3 and 6;  # 两者等价# 2.查询薪资是20000或者18000或者17000的数据select * from emp where salary&#x3D;20000 or salary&#x3D;18000 or salary&#x3D;17000;select * from emp where salary in (20000,18000,17000);# 3.查询员工姓名中包含字母o的员工的姓名和薪资&quot;&quot;&quot;模糊查询like%  匹配任意多个字符_  匹配任意单个字符&quot;&quot;&quot;select name,salary from emp where name like &#39;%o%&#39;;# 4.查询员工姓名是由四个字符组成的 姓名和薪资  char_length()   _select name,salary from emp where name like &#39;____&#39;;select name,salary from emp where char_length(name) &#x3D; 4;# 5.查询id小于3或者id大于6的数据select * from emp where id not between 3 and 6;# 6.查询薪资不在20000,18000,17000范围的数据select * from emp where salary not in (20000,18000,17000);# 7.查询岗位描述为空的员工姓名和岗位名  针对null不用等号 用isselect name,post from emp where post_comment &#x3D; NULL; # 查不出结果select name,post from emp where post_comment is NULL;# 正常</code></pre></div></figure><h2 id="1-4-group-by分组"><a href="#1-4-group-by分组" class="headerlink" title="1.4 group by分组"></a>1.4 group by分组</h2><p>什么时候需要分组？</p><p>​关键字 ：每个、平均、最高、最低 </p><p>分组的应用场景：</p><ul><li>男女比例</li><li>部门平均薪资</li><li>部门秃头率</li><li>国家之间数据统计</li></ul><h3 id="1-4-1-按照部门分组（非严格模式，了解即可）"><a href="#1-4-1-按照部门分组（非严格模式，了解即可）" class="headerlink" title="1.4.1 按照部门分组（非严格模式，了解即可）"></a>1.4.1 按照部门分组（非严格模式，了解即可）</h3><p>在未设置严格模式的情况下， 可以使用如下命令查询<code>按照部门分组</code>的数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from emp group by post;</code></pre></div></figure><p>输出数据：</p><p><img src="/../../../img/image-20220930102443143.png" alt="image-20220930102443143"></p><p>返回的数据实际上是有问题的，返回的是分组之后<code>每个组的第一条数据</code>，但是这不符合分组的规范，</p><p>分组之后不应该考虑单个数据，而应该<code>以组为操作单位</code>(分组之后 没办法直接获取组内单个数据)</p><p><font color=red>在严格模式下，该命令会直接报错</font></p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from emp group by post;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;day47.emp.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by</code></pre></div></figure><h3 id="1-4-2-按照部门分组（严格模式，掌握）"><a href="#1-4-2-按照部门分组（严格模式，掌握）" class="headerlink" title="1.4.2 按照部门分组（严格模式，掌握）"></a>1.4.2 按照部门分组（严格模式，掌握）</h3><p>设置严格模式之后，分组默认只能拿到分组的依据，比如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 按照post分组select post from emp group by post;  # 输出+--------------------+| post               |+--------------------+| 张江第一帅形象代言 || teacher            || sale               || operation          |+--------------------+</code></pre></div></figure><p>按照什么分组就只能拿到分组字段，其他字段不能直接获取，需要借助于一些方法(<code>聚合函数</code>)</p><p>常用聚合函数：</p><ul><li>max最大值</li><li>min    最小值</li><li>sum   求和</li><li>count  数量</li><li>avg     平均值</li></ul><p>分组查询案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.获取每个部门的最高薪资select post,max(salary) from emp group by post;select post as &#39;部门&#39;,max(salary) as &#39;最高薪资&#39; from emp group by post;# 推荐select post &#39;部门&#39;,max(salary) &#39;最高薪资&#39; from emp group by post;# 不推荐# as可以给字段起别名 也可以直接省略不写 但是不推荐 因为省略的话语意不明确 容易错乱# 2.获取每个部门的最低薪资select post,min(salary) from emp group by post;# 3.获取每个部门的平均薪资select post,avg(salary) from emp group by post;# 4.获取每个部门的工资总和select post,sum(salary) from emp group by post;# 5.获取每个部门的人数select post,count(id) from emp group by post;  # 常用 符合逻辑select post,count(salary) from emp group by post;select post,count(age) from emp group by post;select post,count(post_comment) from emp group by post;  null不行# 6.查询分组之后的部门名称和每个部门下所有的员工姓名 # group_concat不单单可以支持你获取分组之后的其他字段值 还支持拼接操作select post,group_concat(name) from emp group by post;select post,group_concat(name,&#39;_DSB&#39;) from emp group by post;&#39;&#39;&#39;+--------------------+-----------------------------------------------------------------+| 部门               | 名字                                                            |+--------------------+-----------------------------------------------------------------+| operation          | 僧龙_DSB,程咬金_DSB,程咬银_DSB,程咬铜_DSB,程咬铁_DSB            || sale               | 哈哈_DSB,呵呵_DSB,西西_DSB,乐乐_DSB,拉拉_DSB                    || teacher            | tom_DSB,kevin_DSB,tony_DSB,owen_DSB,jack_DSB,jenny_DSB,sank_DSB || 张江第一帅形象代言 | jason_DSB                                                       |+--------------------+-----------------------------------------------------------------+&#39;&#39;&#39;select post,group_concat(name,&#39;:&#39;,salary) from emp group by post;# concat不分组的时候用 select concat(&#39;NAME:&#39;,name),concat(&#39;SAL:&#39;,salary) from emp;# 补充 as语法不单单可以给字段起别名 还可以给表临时起别名select emp.id,emp.name from emp;  select emp.id,emp.name from emp as t1;   # 报错select t1.id,t1.name from emp as t1;# 查询每个人的年薪  12薪select name,salary*12 from emp;</code></pre></div></figure><h2 id="1-5-分组注意事项"><a href="#1-5-分组注意事项" class="headerlink" title="1.5 分组注意事项"></a>1.5 分组注意事项</h2><ol><li><p>关键字where和group by同时出现的时候<strong>group by必须在where的后面</strong></p></li><li><p>where筛选条件不能使用聚合函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select id,name,age from emp where max(salary) &gt; 3000;ERROR 1111 (HY000): Invalid use of group function</code></pre></div></figure></li><li><p>不分组的情况下使用聚合函数，默认整体就是一组</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select max(salary) from emp;+-------------+| max(salary) |+-------------+|  1000000.31 |+-------------+</code></pre></div></figure></li></ol><h2 id="1-6-分组之后的筛选条件-having"><a href="#1-6-分组之后的筛选条件-having" class="headerlink" title="1.6 分组之后的筛选条件(having)"></a>1.6 分组之后的筛选条件(having)</h2><p>数据分组之后，再进行一遍筛选</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;having的语法根where是一致的只不过having是在分组之后进行的过滤操作即having是可以直接使用聚合函数的&quot;&quot;&quot;# 统计各部门年龄在30岁以上的员工平均工资并且保留平均薪资大于10000的部门select post,avg(salary) from emp where age&gt;30     group by post        having avg(salary) &gt; 10000        ;</code></pre></div></figure><h2 id="1-7-distinct去重"><a href="#1-7-distinct去重" class="headerlink" title="1.7 distinct去重"></a>1.7 distinct去重</h2><p>必须是完全一样的数据才可以去重！！！</p><p>一定不要将主键忽视了，有主键存在的情况下 是不可能去重的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">select distinct id,age from emp;# 因为有主键存在，去重失败select distinct age from emp;# age数据一样，去重成功</code></pre></div></figure><h2 id="1-8-order-by排序"><a href="#1-8-order-by排序" class="headerlink" title="1.8 order by排序"></a>1.8 order by排序</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">select * from emp order by salary;select * from emp order by salary asc;# 默认升序，asc可以省略不写select * from emp order by salary desc; # 降序# 先按照age降序排  如果碰到age相同 则再按照salary升序排select * from emp order by age desc,salary asc;# 统计各部门年龄在10岁以上的员工平均工资并且保留平均薪资大于1000的部门,然后对平均工资降序排序select post,avg(salary) from emp where age&gt;10     group by post        having avg(salary) &gt; 1000        order by avg(salary) desc        ;</code></pre></div></figure><h2 id="1-9-limit限制展示条数"><a href="#1-9-limit限制展示条数" class="headerlink" title="1.9 limit限制展示条数"></a>1.9 limit限制展示条数</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">select * from emp;&quot;&quot;&quot;针对数据过多的情况 我们通常都是做分页处理&quot;&quot;&quot;select * from emp limit 3;  # 只展示三条数据select * from emp limit 0,5;select * from emp limit 5,5;&#39;&#39;&#39;第一个参数是起始位置第二个参数是展示条数&#39;&#39;&#39;</code></pre></div></figure><h2 id="1-10-正则"><a href="#1-10-正则" class="headerlink" title="1.10 正则"></a>1.10 正则</h2><p>where后面也可以接正则表达式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">select * from emp where name regexp &#39;^j.*(n|y)$&#39;;</code></pre></div></figure><h1 id="二、多表操作"><a href="#二、多表操作" class="headerlink" title="二、多表操作"></a>二、多表操作</h1><h2 id="2-1-前期表准备"><a href="#2-1-前期表准备" class="headerlink" title="2.1 前期表准备"></a>2.1 前期表准备</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#建表create table dep(id int,name varchar(20) );create table emp(id int primary key auto_increment,name varchar(20),sex enum(&#39;male&#39;,&#39;female&#39;) not null default &#39;male&#39;,age int,dep_id int);#插入数据insert into dep values(200,&#39;技术&#39;),(201,&#39;人力资源&#39;),(202,&#39;销售&#39;),(203,&#39;运营&#39;);insert into emp(name,sex,age,dep_id) values(&#39;jason&#39;,&#39;male&#39;,18,200),(&#39;egon&#39;,&#39;female&#39;,48,201),(&#39;kevin&#39;,&#39;male&#39;,18,201),(&#39;nick&#39;,&#39;male&#39;,28,202),(&#39;owen&#39;,&#39;male&#39;,18,203),(&#39;jerry&#39;,&#39;female&#39;,18,204);</code></pre></div></figure><h2 id="2-2-联表查询"><a href="#2-2-联表查询" class="headerlink" title="2.2 联表查询"></a>2.2 联表查询</h2><p>联表查询：多张表一起查询，获取有用的数据。也可以称为“多表查询”，“拼表查询”</p><p>最简单的联表查询：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">select * from dep,emp;  # 结果   两个表混一起的&#96;笛卡尔乘积&#96;&quot;&quot;&quot;了解即可 不知道也没关系&quot;&quot;&quot;</code></pre></div></figure><p>正确用法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">select * from emp,dep where emp.dep_id &#x3D; dep.id;</code></pre></div></figure><p>输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">+----+-------+--------+------+--------+------+----------+| id | name  | sex    | age  | dep_id | id   | name     |+----+-------+--------+------+--------+------+----------+|  1 | jason | male   |   18 |    200 |  200 | 技术     ||  2 | egon  | female |   48 |    201 |  201 | 人力资源 ||  3 | kevin | male   |   18 |    201 |  201 | 人力资源 ||  4 | nick  | male   |   28 |    202 |  202 | 销售     ||  5 | owen  | male   |   18 |    203 |  203 | 运营     |+----+-------+--------+------+--------+------+----------+</code></pre></div></figure><p>MySQL也知道 你在后面查询数据过程中 肯定会经常用到拼表操作，所以特地开设了对应的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">- inner join  内连接- left join   左连接- right join  右连接- union全连接</code></pre></div></figure><h3 id="2-2-1-内连接"><a href="#2-2-1-内连接" class="headerlink" title="2.2.1 内连接"></a>2.2.1 内连接</h3><p>拼接两张表中的<code>公有部分</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select emp.name, dep.name from emp inner join dep on emp.dep_id &#x3D; dep.id;+-------+----------+| name  | name     |+-------+----------+| jason | 技术     || egon  | 人力资源 || kevin | 人力资源 || nick  | 销售     || owen  | 运营     |+-------+----------+</code></pre></div></figure><h3 id="2-2-2-左连接"><a href="#2-2-2-左连接" class="headerlink" title="2.2.2 左连接"></a>2.2.2 左连接</h3><p>左表所有的数据都展示出来 没有对应的项就用NULL</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select emp.name, dep.name from emp left join dep on emp.dep_id &#x3D; dep.id;+-------+----------+| name  | name     |+-------+----------+| jason | 技术     || egon  | 人力资源 || kevin | 人力资源 || nick  | 销售     || owen  | 运营     || jerry | NULL     |+-------+----------+</code></pre></div></figure><h3 id="2-2-3-右连接"><a href="#2-2-3-右连接" class="headerlink" title="2.2.3 右连接"></a>2.2.3 右连接</h3><p>右表所有的数据都展示出来 没有对应的项就用NULL</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select emp.name, dep.name from emp right join dep on emp.dep_id &#x3D; dep.id;+-------+----------+| name  | name     |+-------+----------+| jason | 技术     || kevin | 人力资源 || egon  | 人力资源 || nick  | 销售     || owen  | 运营     |+-------+----------+</code></pre></div></figure><h3 id="2-2-4-全连接"><a href="#2-2-4-全连接" class="headerlink" title="2.2.4 全连接"></a>2.2.4 全连接</h3><p>全连接  左右两表所有的数据都展示出来</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mysql&gt; select emp.name, dep.name from emp left join dep on emp.dep_id &#x3D; dep.id    -&gt; union    -&gt; select emp.name, dep.name from emp right join dep on emp.dep_id &#x3D; dep.id;+-------+----------+| name  | name     |+-------+----------+| jason | 技术     || egon  | 人力资源 || kevin | 人力资源 || nick  | 销售     || owen  | 运营     || jerry | NULL     |+-------+----------+</code></pre></div></figure><h2 id="2-5-子查询"><a href="#2-5-子查询" class="headerlink" title="2.5 子查询"></a>2.5 子查询</h2><p>子查询就是我们平时解决问题的思路，将一个查询语句的结果当做另外一个查询语句的条件去用，</p><p>查询部门是技术或者人力资源的员工信息案例如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 先获取部门的id号select id from dep where name&#x3D;&#39;技术&#39; or name &#x3D; &#39;人力资源&#39;;+------+| id   |+------+|  200 ||  201 |+------+# 再使用&#96;子查询&#96;去员工表里面筛选出对应的员工select name from emp where dep_id in (select id from dep where name&#x3D;&#39;技术&#39; or name &#x3D; &#39;人力资源&#39;);    # 其实就是相当于select name from emp where dep_id in (200,201);</code></pre></div></figure><h1 id="三、作业"><a href="#三、作业" class="headerlink" title="三、作业"></a>三、作业</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.整理今日内容2.完成下列分组查询练习题(以课上建表代码为参考)1. 查询岗位名以及岗位包含的所有员工名字2. 查询岗位名以及各岗位内包含的员工个数3. 查询公司内男员工和女员工的个数4. 查询岗位名以及各岗位的平均薪资5. 查询岗位名以及各岗位的最高薪资6. 查询岗位名以及各岗位的最低薪资7. 查询男员工与男员工的平均薪资，女员工与女员工的平均薪资3.练习拼表操作并理解其意义4.理解子查询思路体会其意义</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>03_MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>53-附录八：Collections之容器数据类型</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/53_%E9%99%84%E5%BD%95%E5%85%AB%EF%BC%9Acollections--%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/53_%E9%99%84%E5%BD%95%E5%85%AB%EF%BC%9Acollections--%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>collections模块：<a href="https://link.zhihu.com/?target=https://yiyibooks.cn/xx/python_352/library/collections.html">https://yiyibooks.cn/xx/python_</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day46-数据库（三）</title>
    <link href="/2022/07/18/03_Python/03_MySQL/day46-%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%89)/"/>
    <url>/2022/07/18/03_Python/03_MySQL/day46-%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>“Day46-数据库(三)学习笔记”</p><h1 id="一、约束条件补充"><a href="#一、约束条件补充" class="headerlink" title="一、约束条件补充"></a>一、约束条件补充</h1><p>我们已学习了三个约束条件，分别是：null&#x2F;not null、unsigned、zerofill, 接下来将补充学习4个常用的约束条件。</p><p>它们分别是：default、unique、primary key、auto_increment</p><h2 id="1-1-default-默认值"><a href="#1-1-default-默认值" class="headerlink" title="1.1 default(默认值)"></a>1.1 default(默认值)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 创建表t1create table t1(id int,    name char(16));# 补充知识点  插入数据的时候可以指定字段insert into t1(name,id) values(&#39;jason&#39;,1);# default约束条件create table t2(id int,    name char(16),    gender enum(&#39;male&#39;,&#39;female&#39;,&#39;others&#39;) default &#39;male&#39;);# 只插入id和name，gender将默认位maleinsert into t2(id,name) values(1,&#39;jason&#39;);# 也可以三个字段都插入insert into t2 values(2,&#39;egon&#39;,&#39;female&#39;);</code></pre></div></figure><h2 id="1-2-unique-唯一"><a href="#1-2-unique-唯一" class="headerlink" title="1.2 unique(唯一)"></a>1.2 unique(唯一)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 单列唯一mysql&gt; create table t3(id int unique, name char(16));mysql&gt; insert into t3 values(1, &#39;张三&#39;);# 正常Query OK, 1 row affected (0.01 sec)mysql&gt; insert into t3 values(1, &#39;李四&#39;);# 报错ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;t3.id&#39;# 联合唯一&quot;&quot;&quot;ip和port单个都可以重复 但是加载一起必须是唯一的&quot;&quot;&quot;mysql&gt; create table t4 (id int, ip char(16),                        port int,                        unique(id, port)                       );mysql&gt; insert into t4 values(1, &#39;127.0.0.1&#39;, 3308); # 正常mysql&gt; insert into t4 values(2, &#39;127.0.0.1&#39;, 3309); # 只同id，正常mysql&gt; insert into t4 values(2, &#39;168.0.0.2&#39;, 3308); # 只同port，正常mysql&gt; insert into t4 values(2, &#39;127.0.0.1&#39;, 3308); # ip和port都相同，报错ERROR 1062 (23000): Duplicate entry &#39;2-3308&#39; for key &#39;t4.id&#39;</code></pre></div></figure><h2 id="1-3-primary-key-主键"><a href="#1-3-primary-key-主键" class="headerlink" title="1.3 primary key(主键)"></a>1.3 primary key(主键)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1.单单从约束效果上来看primary key等价于not null + unique非空且唯一！！！&quot;&quot;&quot;create table t5(id int primary key);insert into t5 values(null);  报错insert into t5 values(1),(1);  报错insert into t5 values(1),(2); &quot;&quot;&quot;2.它除了有约束效果之外 它还是Innodb存储引擎组织数据的依据Innodb存储引擎在创建表的时候必须要有primary key因为它类似于书的目录 能够帮助提示查询效率并且也是建表的依据&quot;&quot;&quot;# 1 一张表中有且只有一个主键 如果你没有设置主键 那么会从上往下搜索直到遇到一个非空且唯一的字段将它自动升级为主键create table t6(id int,    name char(16),    age int not null unique,# 将自动升级位主键    addr char(32) not null unique);# 2 如果表中没有主键也没有其他任何的非空且唯一字段 那么Innodb会采用自己内部提供的一个隐藏字段作为主键，隐藏意味着你无法使用到它 就无法提示查询速度# 3 一张表中通常都应该有一个主键字段 并且通常将id&#x2F;uid&#x2F;sid字段作为主键# 单个字段主键create table t5(    id int primary keyname char(16));# 联合主键(多个字段联合起来作为表的主键 本质还是一个主键)create table t7(    ip char(16),    port int,    primary key(ip,port));&quot;&quot;&quot;也意味着 以后我们在创建表的时候id字段一定要加primary key&quot;&quot;&quot;</code></pre></div></figure><h2 id="1-4-auto-increment-自增"><a href="#1-4-auto-increment-自增" class="headerlink" title="1.4 auto_increment(自增)"></a>1.4 auto_increment(自增)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 当编号特别多的时候 人为的去维护太麻烦create table t8(id int primary key auto_increment,    name char(16));insert into t8(name) values(&#39;jason&#39;),(&#39;egon&#39;),(&#39;kevin&#39;);# 注意auto_increment通常都是加在主键上的，不能给普通字段加，否则会报错create table t9(id int primary key auto_increment,    name char(16),    cid int auto_increment);ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key</code></pre></div></figure><p><strong>结论</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;以后在创建表的id(数据的唯一标识id、uid、sid)字段的时候id int primary key auto_increment&quot;&quot;&quot;</code></pre></div></figure><p><strong>补充</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">delete from t1 where id&#x3D;1 删除表中数据后 主键的自增不会停止，可以使用wheretruncate t1  清空表所有数据并且重置主键，不能使用where</code></pre></div></figure><h1 id="二、表与表之间建关系"><a href="#二、表与表之间建关系" class="headerlink" title="二、表与表之间建关系"></a>二、表与表之间建关系</h1><h2 id="2-1-什么是表关系"><a href="#2-1-什么是表关系" class="headerlink" title="2.1 什么是表关系"></a>2.1 什么是表关系</h2><p>当我们有需要，需要定义一张员工表，表中有很多字段</p><table><thead><tr><th>编号</th><th>姓名</th><th>性别</th><th>部门名称</th><th>部门信息</th></tr></thead><tbody><tr><td>id</td><td>name</td><td>gender</td><td>dep_name</td><td>dep_desc</td></tr></tbody></table><p>该表有三个问题：</p><ol><li>该表的组织结构不是很清晰(可忽视)</li><li>浪费硬盘空间(可忽视)</li><li>数据的扩展性极差(无法忽视的)</li></ol><p>就类似于将所有代码都写在了一个py文件里，有些混乱</p><p>如何优化？ 可以将员工表拆分位员工表和部门表，此时就需要使用<code>外键(foreign key)</code>将表与表关联到一起</p><h2 id="2-2-表关系"><a href="#2-2-表关系" class="headerlink" title="2.2 表关系"></a>2.2 表关系</h2><p>表与表之间最多只有四种关系</p><ol><li>一对多关系（多对一也叫一对多）</li><li>多对多关系</li><li>一对一</li><li>没有关系</li></ol><p>接下来分别介绍前三种关系</p><h3 id="2-2-1-一对多关系"><a href="#2-2-1-一对多关系" class="headerlink" title="2.2.1 一对多关系"></a>2.2.1 一对多关系</h3><p>思考：员工表与部门表的关系</p><p>一个员工能否对应多个部门？ — 不能</p><p>一个部门能否对应多个员工？ — 可以</p><p> 得出结论：员工表与部门表示单向的一对多，所以表关系就是一对多</p><blockquote><p>☀️PS：</p><p>foreign key定义准则：</p><ol><li>一对多表关系   外键字段建在多的一方</li><li>在创建表的时候 一定要先建被关联表</li><li>在录入数据的时候 也必须先录入被关联表</li></ol></blockquote><p>员工表( <em>employee</em>)和部门表(<em>department</em>)一对多关系的案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 创建部门表（先创建被关联表）mysql&gt; create table dep(    -&gt; id int primary key auto_increment,    -&gt; dep_name char(16),    -&gt; dep_desc char(32)    -&gt; );# 创建员工表mysql&gt; create table emp(    -&gt; id int primary key auto_increment,    -&gt; name char(16),    -&gt; gender enum(&#39;male&#39;, &#39;female&#39;, &#39;other&#39;) default &#39;male&#39;,    -&gt; dep_id int,    -&gt; foreign key(dep_id) references dep(id)# 员工是多的一方，外键写这    -&gt; );    # 部门表插入数据，成功mysql&gt; insert into dep(dep_name, dep_desc) values(&#39;财务部&#39;, &#39;报销效率高半年能下&#39;), (&#39;管理部&#39;, &#39;入职流程一条龙&#39;), (&#39;技术部&#39;, &#39;蓝翔CV班&#39;);mysql&gt; select * from dep;+----+----------+--------------------+| id | dep_name | dep_desc           |+----+----------+--------------------+|  1 | 财务部   | 报销效率高半年能下 ||  2 | 管理部   | 入职流程一条龙     ||  3 | 技术部   | 蓝翔CV班           |+----+----------+--------------------+# 员工表插入数据，成功mysql&gt; insert into emp(name, gender, dep_id) values(&#39;张三&#39;,&#39;male&#39;, 1), (&#39;李四&#39;,&#39;female&#39;,2), (&#39;王五&#39;, &#39;other&#39;,1);mysql&gt; select * from emp;+----+------+--------+--------+| id | name | gender | dep_id |+----+------+--------+--------+|  1 | 张三 | male   |      1 ||  2 | 李四 | female |      2 ||  3 | 王五 | other  |      1 |+----+------+--------+--------+# 员工表插入数据，如果外键不存在，将插入失败mysql&gt; insert into emp(name, gender, dep_id) values(&#39;杨六&#39;,&#39;male&#39;, 5);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (&#96;day46&#96;.&#96;emp&#96;, CONSTRAINT &#96;emp_ibfk_1&#96; FOREIGN KEY (&#96;dep_id&#96;) REFERENCES &#96;dep&#96; (&#96;id&#96;))</code></pre></div></figure><h3 id="2-2-2-级联更新-级联删除"><a href="#2-2-2-级联更新-级联删除" class="headerlink" title="2.2.2 级联更新&#x2F;级联删除"></a>2.2.2 级联更新&#x2F;级联删除</h3><p>在2.2.1的案例中，我们可以正常添加数据，但如果需要修改&#x2F;删除表中的数据，就会显得有点麻烦</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 修改dep表中的id字段，失败，已关联外键mysql&gt; update dep set id&#x3D;200 where id&#x3D;2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (&#96;day46&#96;.&#96;emp&#96;, CONSTRAINT &#96;emp_ibfk_1&#96; FOREIGN KEY (&#96;dep_id&#96;) REFERENCES &#96;dep&#96; (&#96;id&#96;))# 删除dep表中的数据，失败，已关联外键mysql&gt; delete from dep where id&#x3D;2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (&#96;day46&#96;.&#96;emp&#96;, CONSTRAINT &#96;emp_ibfk_1&#96; FOREIGN KEY (&#96;dep_id&#96;) REFERENCES &#96;dep&#96; (&#96;id&#96;))</code></pre></div></figure><p>需要先删除对应的员工数据，之后再删除&#x2F;修改部门数据，操作太过繁琐</p><p>需要真正做到数据之间有关系，要做到：</p><p>更新就同步更新—-<code>级联更新</code></p><p>删除就同步删除—-<code>级联删除</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table emp(id int primary key auto_increment,    name char(16),    gender enum(&#39;male&#39;,&#39;female&#39;,&#39;others&#39;) default &#39;male&#39;,    dep_id int,    foreign key(dep_id) references dep(id)     on update cascade  # 同步更新    on delete cascade  # 同步删除);# 再尝试更新， 成功mysql&gt; update dep set id&#x3D;200 where id&#x3D;2;+----+------+--------+--------+| id | name | gender | dep_id |+----+------+--------+--------+|  1 | 张三 | male   |      1 ||  2 | 李四 | female |    200 ||  3 | 王五 | other  |      1 |+----+------+--------+--------+# 再尝试删除，成功mysql&gt; delete from dep where id&#x3D;1;+----+------+--------+--------+| id | name | gender | dep_id |+----+------+--------+--------+|  2 | 李四 | female |    200 |+----+------+--------+--------+</code></pre></div></figure><h3 id="2-2-3-多对多"><a href="#2-2-3-多对多" class="headerlink" title="2.2.3 多对多"></a>2.2.3 多对多</h3><p>以图书表和作者表为例，</p><p>一本书可以有多个作者</p><p>一个作者也可以有多本书</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;图书表和作者表&quot;&quot;&quot;create table book(id int primary key auto_increment,    title varchar(32),    price int,    author_id int,    foreign key(author_id) references author(id)     on update cascade  # 同步更新    on delete cascade  # 同步删除);create table author(id int primary key auto_increment,    name varchar(32),    age int,    book_id int,    foreign key(book_id) references book(id)     on update cascade  # 同步更新    on delete cascade  # 同步删除);&quot;&quot;&quot;按照上述的方式创建 一个都别想成功！！！其实我们只是想记录书籍和作者的关系针对多对多字段表关系 不能在两张原有的表中创建外键需要你单独再开设一张 专门用来存储两张表数据之间的关系&quot;&quot;&quot;create table book(id int primary key auto_increment,    title varchar(32),    price int);create table author(id int primary key auto_increment,    name varchar(32),    age int);create table book2author(id int primary key auto_increment,    author_id int,    book_id int,    foreign key(author_id) references author(id)     on update cascade  # 同步更新    on delete cascade,  # 同步删除    foreign key(book_id) references book(id)     on update cascade  # 同步更新    on delete cascade  # 同步删除);# 创建数据的顺序先给book&#x2F;author表添加数据再给book2author表添加数据</code></pre></div></figure><h3 id="2-2-4-一对一"><a href="#2-2-4-一对一" class="headerlink" title="2.2.4 一对一"></a>2.2.4 一对一</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;id name age addr phone hobby email........如果一个表的字段特别多 每次查询又不是所有的字段都能用得到将表一分为二  用户表用户表id name age用户详情表id addr phone hobby email........站在用户表一个用户能否对应多个用户详情   不能！！！站在详情表一个详情能否属于多个用户      不能！！！结论:单向的一对多都不成立 那么这个时候两者之间的表关系就是一对一或者没有关系(好判断)&quot;&quot;&quot;# 一对一 外键字段建在任意一方都可以 但是推荐你建在查询频率比较高的表中create table authordetail(id int primary key auto_increment,    phone int,    addr varchar(64));create table author(id int primary key auto_increment,    name varchar(32),    age int,    authordetail_id int unique, # 约束条件&#96;unique&#96;别漏     foreign key(authordetail_id) references authordetail(id)     on update cascade  # 同步更新    on delete cascade  # 同步删除)</code></pre></div></figure><h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5 总结"></a>2.2.5 总结</h3><figure><div class="code-wrapper"><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">&quot;&quot;&quot;表关系的建立需要用到foreign key一对多外键字段建在多的一方多对多自己开设第三张存储一对一建在任意一方都可以 但是推荐你建在查询频率较高的表中判断表之间关系的方式换位思考！！！员工与部门图书与作者作者与作者详情&quot;&quot;&quot;</code></pre></div></figure><h1 id="三、表操作"><a href="#三、表操作" class="headerlink" title="三、表操作"></a>三、表操作</h1><h2 id="3-1-修改表-了解"><a href="#3-1-修改表-了解" class="headerlink" title="3.1 修改表(了解)"></a>3.1 修改表(了解)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># MySQL对大小写是不敏感的# 1、修改表名alter table 表名 rename 新表名;# 2、增加字段alter table 表名 add 字段名 字段类型(宽度)  约束条件;alter table 表名 add 字段名 字段类型(宽度)  约束条件 first;alter table 表名 add 字段名 字段类型(宽度)  约束条件 after 字段名; # 3、删除字段alter table 表名 drop 字段名;# 4、修改字段alter table 表名 modify 字段名 字段类型(宽度) 约束条件;alter table 表名 change 旧字段名 新字段名 字段类型(宽度) 约束条件;</code></pre></div></figure><h2 id="3-2-复制表-了解"><a href="#3-2-复制表-了解" class="headerlink" title="3.2 复制表(了解)"></a>3.2 复制表(了解)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;我们sql语句查询的结果其实也是一张虚拟表&quot;&quot;&quot;create table 表名 select * from 旧表;  # 不能复制主键 外键 ...# 案例create table new_dep2 select * from dep where id &gt; 3;</code></pre></div></figure><h1 id="四、练习"><a href="#四、练习" class="headerlink" title="四、练习"></a>四、练习</h1><p>练习：账号信息表，用户组，主机表，主机组</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#用户表create table user(id int not null unique auto_increment,username varchar(20) not null,password varchar(50) not null,primary key(username,password));#用户组表create table usergroup(id int primary key auto_increment,groupname varchar(20) not null unique);#主机表create table host(id int primary key auto_increment,ip char(15) not null unique default &#39;127.0.0.1&#39;);#业务线表create table business(id int primary key auto_increment,business varchar(20) not null unique);#建关系：user与usergroupcreate table user2usergroup(id int not null unique auto_increment,user_id int not null,group_id int not null,primary key(user_id,group_id),foreign key(user_id) references user(id),foreign key(group_id) references usergroup(id));#建关系：host与businesscreate table host2business(id int not null unique auto_increment,host_id int not null,business_id int not null,primary key(host_id,business_id),foreign key(host_id) references host(id),foreign key(business_id) references business(id));#建关系：user与hostcreate table user2host(id int not null unique auto_increment,user_id int not null,host_id int not null,primary key(user_id,host_id),foreign key(user_id) references user(id),foreign key(host_id) references host(id));</code></pre></div></figure><p>练习:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 班级表cidcaption# 学生表sid sname gender class_id# 老师表tidtname# 课程表cidcnameteacher_id# 成绩表sidstudent_id course_id number</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>03_MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>52-附录七：Collections之OrderedDict</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/52_%E9%99%84%E5%BD%95%E4%B8%83%EF%BC%9Acollections%E4%B9%8BOrderedDict/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/52_%E9%99%84%E5%BD%95%E4%B8%83%EF%BC%9Acollections%E4%B9%8BOrderedDict/</url>
    
    <content type="html"><![CDATA[<h2 id="collections之OrderedDict😀"><a href="#collections之OrderedDict😀" class="headerlink" title="collections之OrderedDict😀"></a><strong>collections之OrderedDict</strong>😀</h2><p> 如果想让字典有序，可以使用collections.OrderedDict，它现在在C中实现，这使其快4到100倍。</p><p>##1、collections.OrderedDict的基本使用  将类OrderedDict实例化会得到一个dict子类的实例，支持通常的dict方法。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from collections import OrderedDictod&#x3D;OrderedDict()print(isinstance(od,OrderedDict)) # Trueprint(isinstance(od,dict)) # True</code></pre></div></figure><p> OrderedDict是记住键首次插入顺序的字典。如果新条目覆盖现有条目，则原始插入位置保持不变。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">od[&#39;name&#39;] &#x3D; &#39;egon&#39;od[&#39;age&#39;] &#x3D; 18od[&#39;gender&#39;] &#x3D; &#39;male&#39;print(od) # OrderedDict([(&#39;name&#39;, &#39;egon&#39;), (&#39;age&#39;, 18), (&#39;gender&#39;, &#39;male&#39;)])od[&#39;age&#39;]&#x3D;19print(od) # OrderedDict([(&#39;name&#39;, &#39;egon&#39;), (&#39;age&#39;, 19), (&#39;gender&#39;, &#39;male&#39;)])</code></pre></div></figure><p> 删除条目并重新插入会将其移动到末尾。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">del od[&#39;age&#39;]od[&#39;age&#39;]&#x3D;20print(od) # OrderedDict([(&#39;name&#39;, &#39;egon&#39;), (&#39;gender&#39;, &#39;male&#39;), (&#39;age&#39;, 20)])</code></pre></div></figure><h2 id="2、方法popitem-last-True"><a href="#2、方法popitem-last-True" class="headerlink" title="2、方法popitem(last&#x3D;True)"></a><strong>2、方法popitem(last&#x3D;True)</strong></h2><p> 调用有序字典的popitem()方法会删除并返回(key, value)对。如果last为真，则以LIFO(后进先出)顺序返回这些键值对，如果为假，则以FIFO(先进先出)顺序返回。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from collections import OrderedDictod&#x3D;OrderedDict()od[&#39;k1&#39;]&#x3D;&#39;egon&#39;od[&#39;k2&#39;]&#x3D;&#39;tom&#39;od[&#39;k3&#39;]&#x3D;&#39;jack&#39;print(od.popitem(last&#x3D;False))print(od.popitem(last&#x3D;False))print(od.popitem(last&#x3D;False))&#39;&#39;&#39;(&#39;k1&#39;, &#39;egon&#39;)(&#39;k2&#39;, &#39;tom&#39;)(&#39;k3&#39;, &#39;jack&#39;)&#39;&#39;&#39;</code></pre></div></figure><h2 id="3、方法move-to-end-key-last-True"><a href="#3、方法move-to-end-key-last-True" class="headerlink" title="3、方法move_to_end(key, last&#x3D;True)"></a><strong>3、方法move_to_end(key, last&#x3D;True)</strong></h2><p> 该方法用于将一个已存在的key移动到有序字典的任一端。如果last为True（默认值），则移动到末尾，如果last为False，则移动到开头。如果key不存在，引发KeyError</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from collections import OrderedDictod &#x3D; OrderedDict()od &#x3D; OrderedDict.fromkeys(&#39;abcde&#39;)od.move_to_end(&#39;b&#39;)print(&#39;&#39;.join(od.keys())) # acdebod.move_to_end(&#39;b&#39;, last&#x3D;False)print(&#39;&#39;.join(od.keys())) # bacde</code></pre></div></figure><h2 id="4、OrderDict对象之间的相等性判断"><a href="#4、OrderDict对象之间的相等性判断" class="headerlink" title="4、OrderDict对象之间的相等性判断"></a><strong>4、OrderDict对象之间的相等性判断</strong></h2><p> OrderedDict对象之间的相等性判断是顺序敏感的</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">判断：od1 &#x3D;&#x3D; od2底层实现相当于：list(od1.items()) &#x3D;&#x3D; list(od2.items())</code></pre></div></figure><p>OrderedDict对象与其他映射对象之间的相等性测试与常规字典类似，对顺序不敏感，所以我们可以在使用常规字典的任何位置替换为OrderedDict对象，并不会影响使用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">od1&#x3D;OrderedDict()od2&#x3D;OrderedDict()od3&#x3D;OrderedDict()od1[&#39;k1&#39;]&#x3D;111od1[&#39;k2&#39;]&#x3D;222od1[&#39;k3&#39;]&#x3D;333od2[&#39;k1&#39;]&#x3D;111od2[&#39;k2&#39;]&#x3D;222od2[&#39;k3&#39;]&#x3D;333od3[&#39;k1&#39;]&#x3D;111od3[&#39;k3&#39;]&#x3D;333od3[&#39;k2&#39;]&#x3D;222print(od1 &#x3D;&#x3D; od2) # OrderDict之间的相等判断，即list(od1.items())&#x3D;&#x3D;list(od2.items())，所以结果为Trueprint(od1 &#x3D;&#x3D; od3) # OrderDict之间的相等判断，即list(od1.items())&#x3D;&#x3D;list(od3.items())，所以结果为Falsed&#x3D;&#123;&#39;k1&#39;:111,&#39;k3&#39;:333,&#39;k2&#39;:222&#125; # 定义常规字典print(od1 &#x3D;&#x3D; d) # OrderDict对象与常规字典比较，对顺序不敏感，所以结果为True</code></pre></div></figure><h2 id="5、OrderedDict构造函数和update"><a href="#5、OrderedDict构造函数和update" class="headerlink" title="5、OrderedDict构造函数和update()"></a><strong>5、OrderedDict构造函数和update()</strong></h2><p> OrderedDict构造函数和update()方法都可以接受关键字参数，但是它们的顺序丢失，因为OrderedDict构造函数和update()方法都属于Python的函数调用，而Python的函数调用语义使用常规无序字典传递关键字参数。请在python2中测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from collections import OrderedDictod1&#x3D;OrderedDict(x&#x3D;1,y&#x3D;2,z&#x3D;3)print(od1) # 顺序错乱：OrderedDict([(&#39;y&#39;, 2), (&#39;x&#39;, 1), (&#39;z&#39;, 3)])od2&#x3D;OrderedDict()od2.update(a&#x3D;1)od2.update(b&#x3D;2)od2.update(c&#x3D;3)print(od2) # 顺序正常：OrderedDict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])od3&#x3D;OrderedDict()od3.update(d&#x3D;4,e&#x3D;5,f&#x3D;6)print(od3) # 顺序错乱：OrderedDict([(&#39;e&#39;, 5), (&#39;d&#39;, 4), (&#39;f&#39;, 6)])</code></pre></div></figure><h2 id="6、OrderedDict与sort结合"><a href="#6、OrderedDict与sort结合" class="headerlink" title="6、OrderedDict与sort结合"></a><strong>6、OrderedDict与sort结合</strong></h2><p> 由于有序字典会记住其插入顺序，因此可以与排序结合使用以创建排序字典：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt;&gt;&gt;&gt; # 标准未排序的常规字典&gt;&gt;&gt; d &#x3D; &#123;&#39;banana&#39;: 3, &#39;apple&#39;: 4, &#39;pear&#39;: 1, &#39;orange&#39;: 2&#125;&gt;&gt;&gt; # 按照key排序的字典&gt;&gt;&gt; OrderedDict(sorted(d.items(), key&#x3D;lambda t: t[0]))OrderedDict([(&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2), (&#39;pear&#39;, 1)])&gt;&gt;&gt; # 按照value排序的字典&gt;&gt;&gt; OrderedDict(sorted(d.items(), key&#x3D;lambda t: t[1]))OrderedDict([(&#39;pear&#39;, 1), (&#39;orange&#39;, 2), (&#39;banana&#39;, 3), (&#39;apple&#39;, 4)])&gt;&gt;&gt; # 按照key的长度排序的字典&gt;&gt;&gt; OrderedDict(sorted(d.items(), key&#x3D;lambda t: len(t[0])))OrderedDict([(&#39;pear&#39;, 1), (&#39;apple&#39;, 4), (&#39;orange&#39;, 2), (&#39;banana&#39;, 3)])</code></pre></div></figure><h2 id="7、自定义OrderDict变体"><a href="#7、自定义OrderDict变体" class="headerlink" title="7、自定义OrderDict变体"></a><strong>7、自定义OrderDict变体</strong></h2><p> 我们通过继承OrderDict类来实现在原有的基础之上上定制化我们的子类（即OrderDict变体）。</p><p> 比如我们在用新条目覆盖现有条目时，我们不想像OrderDict原先那样保留原始的插入位置，而是将覆盖的条目移动到结尾，实现如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">class LastUpdatedOrderedDict(OrderedDict):    &#39;Store items in the order the keys were last added&#39;    def __setitem__(self, key, value):        if key in self:            del self[key]        OrderedDict.__setitem__(self, key, value)od5&#x3D;LastUpdatedOrderedDict()od5[&#39;k1&#39;]&#x3D;111od5[&#39;k2&#39;]&#x3D;222od5[&#39;k3&#39;]&#x3D;333print(od5) # LastUpdatedOrderedDict([(&#39;k1&#39;, 111), (&#39;k2&#39;, 222), (&#39;k3&#39;, 333)])od5[&#39;k2&#39;]&#x3D;2222222222print(od5) # 覆盖的值跑到末尾，LastUpdatedOrderedDict([(&#39;k1&#39;, 111), (&#39;k3&#39;, 333), (&#39;k2&#39;, 2222222222)])</code></pre></div></figure><p>##8、OrderDict与collections.Counter结合</p><p> 有序字典可以与Counter类结合，以便计数器记住首次遇到的顺序元素：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from collections import OrderedDict,Counterclass OrderedCounter(Counter, OrderedDict):    &#39;Counter that remembers the order elements are first encountered&#39;    def __repr__(self):        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&#39;)        return &#39;%s(%r)&#39; % (self.__class__.__name__, OrderedDict(self))    def __reduce__(self):        return self.__class__, (OrderedDict(self),)c1 &#x3D; Counter([&#39;bbb&#39;,&#39;ccc&#39;,&#39;aaa&#39;,&#39;aaa&#39;,&#39;ccc&#39;])print(c1)  # 顺序错乱：Counter(&#123;&#39;ccc&#39;: 2, &#39;aaa&#39;: 2, &#39;bbb&#39;: 1&#125;)c2&#x3D;OrderedCounter([&#39;bbb&#39;,&#39;ccc&#39;,&#39;aaa&#39;,&#39;aaa&#39;,&#39;ccc&#39;])print(c2)  # 顺序保持原有：OrderedCounter(OrderedDict([(&#39;bbb&#39;, 1), (&#39;ccc&#39;, 2), (&#39;aaa&#39;, 2)]))</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>51-附录六：轻松搞定位运算</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/51_%E9%99%84%E5%BD%95%E5%85%AD%EF%BC%9A%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/51_%E9%99%84%E5%BD%95%E5%85%AD%EF%BC%9A%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a><strong>一 前言</strong></h2><p> 位运算，一个极容易被低端码农忽视的地带，因为它略微需要用一丢丢智商，真的只有那么一丢丢，但高手与low手的差距往往就是长这么一丢丢，能达到的深度就截然不同了，今天egon就来给大家聊一聊位运算那些风骚且高级的操作，但要理解位运算，得从机器数与真值说起，请看大屏幕</p><h2 id="二-真值、机器数-原码、反码、补码"><a href="#二-真值、机器数-原码、反码、补码" class="headerlink" title="二 真值、机器数(原码、反码、补码)"></a><strong>二 真值、机器数(原码、反码、补码)</strong></h2><p> “真值”指的就是数本身，例如-10，真值就是-10</p><p> 一个数在计算机中的二进制表示形式，叫做这个数的机器数</p><p> 在计算机中，用来表示有符号数的机器数有三种，即原码、反码、补码</p><p> 三种表示方法均有“符号位”和“数值位”两部分</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">1、符号位都是占据最高位，用0表示“正数”，用1表示“负数”2、数值位，三种表示方法各不相同</code></pre></div></figure><p> 整型数字有8位、16位、32位、64位几种，篇幅问题，我们先单以8位整型为例来介绍</p><p> 在介绍之前，egon先来先扫一下盲，估计会扫死99%的人</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">问：8位二进制数可以表示的数值范围是多少，99%的人张口就来：-128~127ok，8位二进制数，最高位需要用来表示符号，那么剩下的7位用来表示数值于是，最大数为1111 1111&#x3D;&gt;+127，最小0111 1111&#x3D;&gt;-127，卧槽，得出的结论是8位二进制数可以表示的数值范围是-127到+127，傻逼了吧你，哈哈哈灵魂拷问：-128到底怎么来的？？？ 真相是这样的：  8位二进制数用7位表示数值，那么7位2进制数000 0000的值为0  那么,它前面加上符号位0,还表示0吧?  那好,如果它前面加上1呢,仍然表示0?这不是重复了么?  一个0,怎么用两个值来表示呢！！！  所以1000 0000就表示-128啦，</code></pre></div></figure><p> ok，我们接下来就在8位二进制数，即-128~127的范围内取值来介绍它的原码、反码、补码</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">1、正数：原码、反码、补码都一样   真值：3   原码：0000 0011   最高位为0，表示正数   反码：0000 0011   补码：0000 00112、负数：原码、反码、补码不同   真值：-3   原码：1000 0011   最高位为1，表示负数   反码：1111 1100   由原码演变而来，原码的符号位不变，数值位全部取反   补码：1111 1101   在反码的基础上+1</code></pre></div></figure><p> 为了大家能够清晰地看到”真值“与”补码“之间的相互转换，egon画了如下两幅图</p><p><img src="https://pic4.zhimg.com/80/v2-d9ef172e92108c6f76749ae4cf4b49d7_720w.jpg" alt="img"></p><p> 在计算机系统中，数值一律用补码来存储 ！！！  主要原因：使用补码，可以将符号位和其它位统一处理；同时，减法也可按加法来处理，需要注意的是两个用 补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃，处理完后我们如上图所示用补码反推出真值即可，例如计算机在计算8-3的时候，会这么做8+（-3），具体如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;反码-&gt;补码    真值：8    原码：0000 1000      反码：0000 1000    补码：0000 1000    真值：-3    原码：1000 0011      反码：1111 1100    补码：1111 1101第二步：补码之间的运算，此处为相加    8的补码：0000 1000   -3的补码：1111 1101  相加得补码：0000 0101 # 补码相加，高位有进位会被舍弃    第三步：补码-&gt;反码-&gt;原码-&gt;真值    上一步得到的补码结果：0000 0101    符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位    补码-&gt;反码-&gt;原码：0000 0101        原码-&gt;真值：5</code></pre></div></figure><p>练习：8+（-9）</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：8    原码：0000 1000      反码：0000 1000    补码：0000 1000    真值：-9    原码：1000 1001      反码：1111 0110    补码：1111 0111第二步：补码之间的运算，此处为相加    8的补码：0000 1000   -9的补码：1111 0111  相加得补码：1111 1111     第三步：补码-&gt;反码-&gt;原码-&gt;真值 补码-&gt;反码        补码结果：1111 1111        符号位是1，为负数，参照上图2的步骤        补码-&gt;反码：-1，得到反码：1111 1110        反码-&gt;原码：符号位不变，其余位取反，得到原码：1000 0001        原码-&gt;真值：-1</code></pre></div></figure><p> 非常震撼人心的设计，有了补码以后，减法都可以当做加法去运算，你可知道，这将极大地简化计算机的运算设计。不仅如此！！！</p><p> 我们即将介绍的位运算也都是基于补码进行的，所以，你还会觉得egon在啰嗦吗？呵呵</p><h2 id="三-位运算"><a href="#三-位运算" class="headerlink" title="三 位运算"></a><strong>三 位运算</strong></h2><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">按位与&amp;：两位全为1，结果才为1，否则为0按位或|：两位只要存在一个1，结果就为1，否则为0按位异或^：只有在两位不相同，即一个为0一个为1的情况下，结果才为1，否则为0&lt;&lt; n：各二进制位全部左移n位，高位丢弃，低位补0&gt;&gt; n: 各二进制位全部右移n位，如果是正数，则高位补0，如果是负数则高位补1</code></pre></div></figure><p>####3.1 按位与&amp;</p><p>示例1：8 &amp; -3</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;反码-&gt;补码    真值：8    原码：0000 1000      反码：0000 1000    补码：0000 1000    真值：-3    原码：1000 0011      反码：1111 1100    补码：1111 1101第二步：补码之间的运算，此处为&amp;    8的补码：0000 1000   -3的补码：1111 1101    &amp;得补码：0000 1000    第三步：补码-&gt;反码-&gt;原码-&gt;真值    上一步得到的补码结果：0000 1000    符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位    补码-&gt;反码-&gt;原码：0000 1000        原码-&gt;真值：8</code></pre></div></figure><p>示例2：-8 &amp; -9</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：-8    原码：1000 1000      反码：1111 0111    补码：1111 1000    真值：-9    原码：1000 1001      反码：1111 0110    补码：1111 0111第二步：补码之间的运算，此处为&amp;   -8的补码：1111 1000   -9的补码：1111 0111    &amp;得补码：1111 0000     第三步：补码-&gt;反码-&gt;原码-&gt;真值 补码-&gt;反码        补码结果：1111 0000         符号位是1，为负数，参照上图2的步骤        补码-&gt;反码：-1，得到反码：1110 1111        反码-&gt;原码：符号位不变，其余位取反，得到原码：1001 0000        原码-&gt;真值：-16</code></pre></div></figure><p>####3.2 按位或|</p><p>示例1：-8 | -9</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：-8    原码：1000 1000      反码：1111 0111    补码：1111 1000    真值：-9    原码：1000 1001      反码：1111 0110    补码：1111 0111第二步：补码之间的运算，此处为|   -8的补码：1111 1000   -9的补码：1111 0111    |得补码：1111 1111     第三步：补码-&gt;反码-&gt;原码-&gt;真值 补码-&gt;反码        补码结果：1111 1111         符号位是1，为负数，参照上图2的步骤        补码-&gt;反码：-1，得到反码：1111 1110        反码-&gt;原码：符号位不变，其余位取反，得到原码：1000 0001        原码-&gt;真值：-1</code></pre></div></figure><p>####3.3 按位异或^</p><p>示例1：-8 ^ -9</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：-8    原码：1000 1000      反码：1111 0111    补码：1111 1000    真值：-9    原码：1000 1001      反码：1111 0110    补码：1111 0111第二步：补码之间的运算，此处为^   -8的补码：1111 1000   -9的补码：1111 0111    ^得补码：0000 1111     第三步：补码-&gt;反码-&gt;原码-&gt;真值    上一步得到的补码结果：0000 1111    符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位    补码-&gt;反码-&gt;原码：0000 1111        原码-&gt;真值：15</code></pre></div></figure><p>示例2：^ -8 单独一个^代表取反的意思(适用于go，不适用于python)</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：-8    原码：1000 1000      反码：1111 0111    补码：1111 1000第二步：   -8的补码：1111 1000 ^取反得补码：0000 0111     第三步：补码-&gt;反码-&gt;原码-&gt;真值    上一步得到的补码结果：0000 0111    符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位    补码-&gt;反码-&gt;原码：0000 0111        原码-&gt;真值：7</code></pre></div></figure><p>####3.4 向左位移&lt;&lt; n</p><p>示范1：-8 &lt;&lt; 3</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：-8    原码：1000 1000      反码：1111 0111    补码：1111 1000第二步：&lt;&lt; n 各二进制位全部左移n位，高位丢弃，低位补0    补码：1111 1000    &lt;&lt;3: 1100 0000    第三步：补码-&gt;反码-&gt;原码-&gt;真值 补码-&gt;反码        补码结果：1100 0000        符号位是1，为负数，参照上图2的步骤        补码-&gt;反码：-1，得到反码：1011 1111        反码-&gt;原码：符号位不变，其余位取反，得到原码：1100 0000        原码-&gt;真值：-64</code></pre></div></figure><p>####3.5 向右位移&gt;&gt; n</p><p>示范1：-8 &gt;&gt; 3</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：-8    原码：1000 1000      反码：1111 0111    补码：1111 1000第二步：&gt;&gt; n 各二进制位全部右移n位，如果是正数，则高位补0，如果是负数则高位补1    补码：1111 1000    &gt;&gt;3: 1111 1111    第三步：补码-&gt;反码-&gt;原码-&gt;真值 补码-&gt;反码        补码结果：1111 1111        符号位是1，为负数，参照上图2的步骤        补码-&gt;反码：-1，得到反码：1111 1110        反码-&gt;原码：符号位不变，其余位取反，得到原码：1000 0001        原码-&gt;真值：-1</code></pre></div></figure><p>示范2：8 &gt;&gt; 3</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：8    原码：0000 1000      反码：0000 1000    补码：0000 1000第二步：&gt;&gt; n 各二进制位全部右移n位，如果是正数，则高位补0，如果是负责则高位补1    补码：0000 1000    &gt;&gt;3: 0000 0001    第三步：补码-&gt;反码-&gt;原码-&gt;真值    上一步得到的补码结果：0000 0001    符号位是0，为正数，那么就简单了，正数的原、反、补码都一样，所以一步到位    补码-&gt;反码-&gt;原码：0000 0001        原码-&gt;真值：1</code></pre></div></figure><p>示范3：-300 &gt;&gt; 8</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">第一步：真值-&gt;原码-&gt;补码    真值：-300      原码：1000 0001 0010 1100 # -300 已经超过了8位二进制能表示的范围，需要用16位表示    反码：1111 1110 1101 0011    补码：1111 1110 1101 0100第二步：&gt;&gt; n 各二进制位全部右移n位，如果是正数，则高位补0，如果是负责则高位补1    补码：1111 1110 1101 0100    &gt;&gt;8: 1111 1111 1111 1110    第三步：补码-&gt;反码-&gt;原码-&gt;真值 补码-&gt;反码        补码结果：1111 1111 1111 1110        符号位是1，为负数，参照上图2的步骤        补码-&gt;反码：-1，得到反码：1111 1111 1111 1101        反码-&gt;原码：符号位不变，其余位取反，得到原码：1000 0000 0000 0010        原码-&gt;真值：-2</code></pre></div></figure><h2 id="四-位运算高级操作"><a href="#四-位运算高级操作" class="headerlink" title="四 位运算高级操作"></a><strong>四 位运算高级操作</strong></h2><p>位运算是 cpu 直接支持的，效率最高，位运算可能在平常的编程中使用的并不多，但涉及到底层优化，一些算法及源码可能会经常遇见，下面来介绍一下风骚的操作</p><p>####4.1 用位运算 &amp; 取代 % 取模</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">X % 2^n &#x3D; X &amp; (2^n – 1)注意：用位运算 &amp; 来取代 % 取模需要被取模的数必须是2的幂才成立</code></pre></div></figure><p>示范1：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">10 % (2^3) 等于 10 &amp; (2^3-1)即10 % 8 等于 10 &amp; 7</code></pre></div></figure><p>示范2：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">10 % (2^2) 等于 10 &amp; (2^2-1)即10 % 4 等于 10 &amp; 3</code></pre></div></figure><p>####4.2 将一个数左移 n 位，相当于乘以了 2 的 n 次方，右移n位，相当于除以2的n次方取整</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">10 &lt;&lt; 3 等同于10 * 2^3 10 &gt;&gt; 3 等同于10 &#x2F; 3</code></pre></div></figure><h3 id="4-3-判断奇偶"><a href="#4-3-判断奇偶" class="headerlink" title="4.3 判断奇偶"></a><strong>4.3 判断奇偶</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">我们可以利用 &amp; 运算符的特性，来判断二进制数第一位是0还是1。用if ((a &amp; 1) &#x3D;&#x3D; 0) 代替 if (a % 2 &#x3D;&#x3D; 0)来判断a是不是偶数。</code></pre></div></figure><h3 id="4-4-交互数值"><a href="#4-4-交互数值" class="headerlink" title="4.4 交互数值"></a><strong>4.4 交互数值</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">1、借助临时变量来交互数值    a:&#x3D;10    b:&#x3D;20    temp:&#x3D;a    a&#x3D;b    b&#x3D;temp fmt.Println(a,b) &#x2F;&#x2F; 结果20 102、借助累加和如果考虑到内存，不希望使用临时变量（其实就是为了炫酷），可以这样实现：    a:&#x3D;10    b:&#x3D;20    a &#x3D; a + b    b &#x3D; a - b    a &#x3D; a - b    fmt.Println(a,b) &#x2F;&#x2F; 结果20 10    从数学角度来分析一下- 第一步：a &#x3D; a + b- 第二步：b &#x3D; a - b &#x3D; (a + b) - b &#x3D; a- 第三步：a &#x3D; a - b &#x3D; (a + b) - b &#x3D; (a + b) - a &#x3D; b3、使用 ^ 位运算符如果想要更炫酷一点可以使用 ^ 来帮忙实现：先来了解一下 ^ 的几个特性：a ^ a &#x3D; 0a ^ 0 &#x3D; a(a ^ b) ^ c &#x3D; a ^ (b ^ c)代码：    a:&#x3D;10    b:&#x3D;20    a ^&#x3D; b;    b ^&#x3D; a;    a ^&#x3D; b;    fmt.Println(a,b) &#x2F;&#x2F; 结果20 10从数学角度来分析一下：- 第一步：a &#x3D; a ^ b- 第二步：b &#x3D; a ^ b &#x3D; (a ^ b) ^ b &#x3D; a ^ (b ^ b) &#x3D; a ^ 0 &#x3D; a- 第三步：a &#x3D; a ^ b &#x3D; (a ^ b) ^ b &#x3D; (a ^ a) ^ b &#x3D; b ^ 0 &#x3D; b</code></pre></div></figure><p>####4.5 项目中的应用</p><p>在项目中可以用位运算进行一些状态的运算，效率极其高，例如：现在我们有一些爱好需求，这些爱好有 足球 羽毛球 乒乓球 篮球 游泳 如果按照整数的形式去定义，那就有无数多种情况，毕竟可以两两组合嘛，python中的列表、go中的数组都不是最佳选择</p><p>可以直接用二进制位表示，1代表爱好，0代表没有该爱好</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">爱好：只有足球表示：1 0 0 0 0爱好：乒乓球、游泳表示：0 0 1 0 1</code></pre></div></figure><p>接下来就可以用位运算进行一些风骚的操作啦，例如</p><p>#####应用1：检查是否存在某个爱好</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">喜欢足球的状态是：1 0 0 0 0      小明的喜好：0 1 0 1 0 与&amp;计算的结果为：0 0 0 0 0，返回位false，所以小明不存在喜好足球的状态</code></pre></div></figure><p>#####应用2：添加某个爱好</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">喜欢足球：   1 0 0 0 0小明的喜好： 0 1 0 1 0 或|运算之后： 1 1 0 1 0</code></pre></div></figure><h3 id="应用3：移除某个爱好"><a href="#应用3：移除某个爱好" class="headerlink" title="应用3：移除某个爱好"></a><strong>应用3：移除某个爱好</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">（传入）喜好足球 ： 1 0 0 0 0    小明的喜好：   1 0 1 0 1先将足球取反^ ：   0 1 1 1 1   再进与&amp;运算：   0 0 1 0 1</code></pre></div></figure><p>以上风骚操作均适用于python！！！egon忙忙叨叨写了一天，希望能够帮助到你</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day45-数据库（二）</title>
    <link href="/2022/07/18/03_Python/03_MySQL/day45-%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/"/>
    <url>/2022/07/18/03_Python/03_MySQL/day45-%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>“Day45-数据库(二)学习笔记”</p><h1 id="一、存储引擎"><a href="#一、存储引擎" class="headerlink" title="一、存储引擎"></a>一、存储引擎</h1><p>日常生活中文件格式有很多中，并且针对不同的文件格式会有对应不同存储方式和处理机制(比如txt、pdf、word、</p><p>mp4等等)</p><p>针对不同的数据应该有对应的不同的处理机制来存储</p><p><code>存储引擎</code>就是<code>不同的处理机制</code></p><h2 id="1-1-MySQL主要存储引擎"><a href="#1-1-MySQL主要存储引擎" class="headerlink" title="1.1 MySQL主要存储引擎"></a>1.1 MySQL主要存储引擎</h2><ul><li><p>Innodb</p><p>是MySQL5.5版本及之后默认的存储引擎</p><p>存储数据更加的安全</p></li><li><p>myisam</p><p>是MySQL5.5版本之前默认的存储引擎</p><p>速度要比Innodb更快 但是我们更加注重的是数据的安全</p></li><li><p>memory</p><p>内存引擎(数据全部存放在内存中) 断电数据丢失</p></li><li><p>blackhole</p><p>无论存什么，都立刻消失(黑洞)</p></li></ul><h2 id="1-2-查看和设置存储引擎："><a href="#1-2-查看和设置存储引擎：" class="headerlink" title="1.2 查看和设置存储引擎："></a>1.2 查看和设置存储引擎：</h2><p>1、查看所有存储引擎</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show engines;# 输出+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |+--------------------+---------+---------------------------------------------------------------....| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         || InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        || BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         |.....</code></pre></div></figure><p>2、设置存储引擎</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 设置存储引擎create table t1(id int) engine&#x3D;innodb;create table t2(id int) engine&#x3D;myisam;create table t3(id int) engine&#x3D;blackhole;create table t4(id int) engine&#x3D;memory;# 存数据后的表现insert into t1 values(1);insert into t2 values(1);insert into t3 values(1);# 存进去后查不到数据：Empty setinsert into t4 values(1);# 服务端重启后查不到数据，没重启之前可以（模拟断电）</code></pre></div></figure><h1 id="二、创建表的完整语法"><a href="#二、创建表的完整语法" class="headerlink" title="二、创建表的完整语法"></a>二、创建表的完整语法</h1><h2 id="2-1-创建表的语法"><a href="#2-1-创建表的语法" class="headerlink" title="2.1 创建表的语法"></a>2.1 创建表的语法</h2><p>创建表的基本语法为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">create table 表名(字段名1 类型(宽度) 约束条件,    字段名2 类型(宽度) 约束条件,    字段名3 类型(宽度) 约束条件);</code></pre></div></figure><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table t5(id int,                 name char(12),                 age int);</code></pre></div></figure><h2 id="2-2-创建表的注意事项"><a href="#2-2-创建表的注意事项" class="headerlink" title="2.2 创建表的注意事项"></a>2.2 创建表的注意事项</h2><p>1、在同一张表中字段名不能重复</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; create table t6(id int, name char(12), id int);ERROR 1060 (42S21): Duplicate column name &#39;id&#39;</code></pre></div></figure><p>2、宽度和约束条件是可选的(可写可不写) 而<code>字段名和字段类型是必须</code>的，约束条件写的话 也支持写多个</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">字段名1 类型(宽度) 约束条件1 约束条件2...,</code></pre></div></figure><p>少些了会报错，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; create table t7(id);ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;)&#39; at line 1</code></pre></div></figure><p>3、最后一行不能有逗号，否则会报错：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; create table t6(id int,                        name char(12),                        age int,);ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;)&#39; at line 1</code></pre></div></figure><h2 id="2-3-宽度和约束条件"><a href="#2-3-宽度和约束条件" class="headerlink" title="2.3 宽度和约束条件"></a>2.3 宽度和约束条件</h2><h3 id="2-3-1-宽度"><a href="#2-3-1-宽度" class="headerlink" title="2.3.1 宽度"></a>2.3.1 宽度</h3><p>宽度：一般情况下指的是对存储数据的限制</p><p>比如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 创建表create table t7(name char);  默认宽度是1# 插入数据&#39;jason&#39;insert into t7 values(&#39;jason&#39;);# 报错ERROR 1406 (22001): Data too long for column &#39;name&#39; at row 1# 插入数据NULLinsert into t7 values(null);  关键字NULLQuery OK, 1 row affected (0.00 sec)# 插入数据&#39;j&#39;insert into t7 values(&#39;j&#39;);Query OK, 1 row affected (0.00 sec)</code></pre></div></figure><p>关于宽度的限制，跟<code>严格模式</code>有关，</p><p>5.6版本默认没有开启严格模式 规定只能存一个字符你给了多个字符，那么我会自动帮你截取</p><p>5.7版本及以上或者开启了严格模式 那么规定只能存几个，就不能超，</p><p>一旦超出范围立刻报错 Data too long for ….</p><h3 id="2-3-2-约束条件"><a href="#2-3-2-约束条件" class="headerlink" title="2.3.2 约束条件"></a>2.3.2 约束条件</h3><p>约束条件：是指在宽度的基础之上增加的额外的约束</p><p>比如限制是可以插入空值的约束条件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">null：可以插入NULLnot null：不能插入NULL</code></pre></div></figure><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 创建表create table t6(id int null, name char(10) not null, age int);# 插入数据01，正常mysql&gt; insert into t6 values(1, &#39;大蒜&#39;, 10);Query OK, 1 row affected (0.00 sec)# 插入数据02，正常mysql&gt; insert into t6 values(null, &#39;小葱&#39;, 10);Query OK, 1 row affected (0.00 sec)# 插入数据03，报错mysql&gt; insert into t6 values(null, NULL, 10);ERROR 1048 (23000): Column &#39;name&#39; cannot be null</code></pre></div></figure><h1 id="三、基本数据类型"><a href="#三、基本数据类型" class="headerlink" title="三、基本数据类型"></a>三、基本数据类型</h1><h2 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a>3.1 整型</h2><h3 id="3-1-1-整型分类"><a href="#3-1-1-整型分类" class="headerlink" title="3.1.1 整型分类"></a>3.1.1 整型分类</h3><table><thead><tr><th>类型</th><th>无符号范围</th><th>有符号范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128 到 127</td><td>0 到 255</td></tr><tr><td>SMALLINT</td><td>-32768 到 32768</td><td>0 到 65535</td></tr><tr><td>MEDUIMINT</td><td>-8388608 到 8388607</td><td>0 到 16777215</td></tr><tr><td>INT</td><td>-2147483648 到 2147483647</td><td>0 到 4294967295</td></tr><tr><td>BIGINT</td><td>-9223372036854775808 到 9223372036854775807</td><td>0 到 18446744073709551615</td></tr></tbody></table><h3 id="3-1-2-无符号和有符号"><a href="#3-1-2-无符号和有符号" class="headerlink" title="3.1.2 无符号和有符号"></a>3.1.2 无符号和有符号</h3><p>以TINYINT为例，有两个疑问：</p><p>是否有符号？ — 整型默认情况下都是带符号的</p><p>超出会如何？ — 超出限制只存最大可接受值</p><p>来验证这两个问题：</p><p><strong>有符号插入：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 创建表create table t8(id tinyint, age tinyint);# 插入数据，过大会报错mysql&gt; insert into t8 values(-129, 256);ERROR 1264 (22003): Out of range value for column &#39;id&#39; at row 1# 正常范围可以插入mysql&gt; insert into t8 values(-128, 127);Query OK, 1 row affected (0.00 sec)</code></pre></div></figure><p><strong>无符号插入</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 修改为有符号mysql&gt; alter table t8 change age age tinyint unsigned;mysql&gt; alter table t8 change id id tinyint unsigned;# 插入数据，成功mysql&gt; insert into t8 values(0, 255);Query OK, 1 row affected (0.00 sec)# 插入数据，失败，超出范围mysql&gt; insert into t8 values(-127, 128);ERROR 1264 (22003): Out of range value for column &#39;id&#39; at row 1</code></pre></div></figure><blockquote><p>☀️补充：</p><p>整型也可以使用括号指定宽度，这个宽度到底是干嘛的？</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">&gt;# 创建表，并指定整型宽度&gt;create table t12(id int(8));&gt;insert into t12 values(123456789);&gt;# 即使超过了8位，也能成功&gt;mysql&gt; insert into t9 values(123456789);&gt;Query OK, 1 row affected (0.00 sec)</code></pre></div></figure><p>这是因为：只有整型括号里面的数字不是表示限制位数<br>id int(8)<br>如果数字没有超出8位 那么默认用空格填充至8位<br>如果数字超出了8位 那么有几位就存几位(但是还是要遵守最大范围)</p><p>可以在创建时设置<code>zerofill</code>,用0填充至8位</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">&gt;mysql&gt; create table t10(id int(8) unsigned zerofill);&gt;Query OK, 0 rows affected, 2 warnings (0.01 sec)&gt;mysql&gt; insert into t10 values(1);&gt;Query OK, 1 row affected (0.00 sec)&gt;mysql&gt; select * from t10;&gt;+----------+&gt;| id       |&gt;+----------+&gt;| 00000001 |&gt;+----------+&gt;1 row in set (0.00 sec)</code></pre></div></figure></blockquote><p>针对整型字段 括号内无需指定宽度 因为它默认的宽度以及足够显示所有的数据了</p><h2 id="3-2-严格模式"><a href="#3-2-严格模式" class="headerlink" title="3.2 严格模式"></a>3.2 严格模式</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、如何查看严格模式show variables like &quot;%mode&quot;;或者select @@sql_mode模糊匹配&#x2F;查询关键字 like%:匹配任意多个字符        _:匹配任意单个字符# 2、修改严格模式set session  只在当前窗口有效    set global   全局有效        # 临时关闭严格模式（具体内容依据#1命令得到的结果为准，去除ONLY_FULL_GROUP_BY即可）    set global sql_mode &#x3D; &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;    修改完之后 重新进入服务端即可</code></pre></div></figure><h2 id="3-3-浮点型"><a href="#3-3-浮点型" class="headerlink" title="3.3 浮点型"></a>3.3 浮点型</h2><ul><li><p>分类</p><p>FLOAT、DOUBLE、DECIMAL</p></li><li><p>作用</p><p>身高、体重、薪资</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 存储限制float(255,30)  # 总共255位 小数部分占30位double(255,30)  # 总共255位 小数部分占30位decimal(65,30)  # 总共65位 小数部分占30位# 精确度验证create table t15(id float(255,30));create table t16(id double(255,30));create table t17(id decimal(65,30));&quot;&quot;&quot;你们在前期不要给我用反向键 所有的命令全部手敲！！！增加熟练度&quot;&quot;&quot;insert into t15 values(1.111111111111111111111111111111);insert into t16 values(1.111111111111111111111111111111);insert into t17 values(1.111111111111111111111111111111);float &lt; double &lt; decimal# 要结合实际应用场景 三者都能使用</code></pre></div></figure></li></ul><h2 id="3-4-字符类型"><a href="#3-4-字符类型" class="headerlink" title="3.4 字符类型"></a>3.4 字符类型</h2><ul><li><p>分类</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;char定长char(4) 数据超过四个字符直接报错 不够四个字符空格补全varchar变长varchar(4)  数据超过四个字符直接报错 不够有几个存几个&quot;&quot;&quot;create table t18(name char(4));create table t19(name varchar(4));insert into t18 values(&#39;a&#39;);insert into t19 values(&#39;a&#39;);# 介绍一个小方法 char_length统计字段长度select char_length(name) from t18;select char_length(name) from t19;&quot;&quot;&quot;首先可以肯定的是 char硬盘上存的绝对是真正的数据 带有空格的但是在显示的时候MySQL会自动将多余的空格剔除&quot;&quot;&quot;# 再次修改sql_mode 让MySQL不要做自动剔除操作set global sql_mode &#x3D; &#39;STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH&#39;;</code></pre></div></figure><h4 id="char与varchar对比"><a href="#char与varchar对比" class="headerlink" title="char与varchar对比"></a>char与varchar对比</h4><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;char缺点:浪费空间优点:存取都很简单直接按照固定的字符存取数据即可jason egon alex wusir tank 存按照五个字符存 取也直接按照五个字符取varchar优点:节省空间缺点:存取较为麻烦1bytes+jason 1bytes+egon 1bytes+alex 1bytes+tank 存的时候需要制作报头取的时候也需要先读取报头 之后才能读取真实数据以前基本上都是用的char 其实现在用varchar的也挺多&quot;&quot;&quot;补充:    进来公司之后你完全不需要考虑字段类型和字段名    因为产品经理给你发的邮件上已经全部指明了</code></pre></div></figure></li></ul><h2 id="3-5-时间类型"><a href="#3-5-时间类型" class="headerlink" title="3.5 时间类型"></a>3.5 时间类型</h2><ul><li><p>分类</p><p>| 类型     | 案例                            |</p></li></ul><p>| ——– | ——————————- |<br>  | date     | 年月日：2020-5-4                |<br>| datetime | 年月日时分秒：2020-5-4 11:11:11 |<br>  | time     | 时分秒：11:11:11                |<br>| year     | 年：2020                        |</p><p>案例如下：</p>  <figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">create table student(id int,    name varchar(16),    born_year year,    birth date,    study_time time,    reg_time datetime);insert into student values(1,&#39;egon&#39;,&#39;1880&#39;,&#39;1880-11-11&#39;,&#39;11:11:11&#39;,&#39;2020-11-11 11:11:11&#39;);</code></pre></div></figure><h2 id="3-6-枚举与集合类型"><a href="#3-6-枚举与集合类型" class="headerlink" title="3.6 枚举与集合类型"></a>3.6 枚举与集合类型</h2><ul><li><p>分类</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;枚举(enum)  多选一集合(set)   多选多&quot;&quot;&quot;</code></pre></div></figure></li><li><p>具体使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">  # 1、使用枚举  create table user(  id int,      name char(16),      gender enum(&#39;male&#39;,&#39;female&#39;,&#39;others&#39;)  );  # 插入数据，正常  insert into user values(1,&#39;jason&#39;,&#39;male&#39;);    # 插入数据，报错  insert into user values(2,&#39;egon&#39;,&#39;xxxxooo&#39;);   # 枚举字段 后期在存数据的时候只能从枚举里面选择一个存储       # 2、使用集合  create table teacher(  id int,      name char(16),      gender enum(&#39;male&#39;,&#39;female&#39;,&#39;others&#39;),      hobby set(&#39;read&#39;,&#39;DBJ&#39;,&#39;hecha&#39;)  );  insert into teacher values(1,&#39;jason&#39;,&#39;male&#39;,&#39;read&#39;);  # 正常insert into teacher values(2,&#39;egon&#39;,&#39;female&#39;,&#39;DBJ,hecha&#39;);  # 正常  insert into teacher values(3,&#39;tank&#39;,&#39;others&#39;,&#39;生蚝&#39;); # 报错</code></pre></div></figure></li></ul><h1 id="集合可以只写一个-但是不能写没有列举的"><a href="#集合可以只写一个-但是不能写没有列举的" class="headerlink" title="集合可以只写一个  但是不能写没有列举的"></a>集合可以只写一个  但是不能写没有列举的</h1>  <figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">  </code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>03_MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>50-附录五：性能测试之timeit</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/50_%E9%99%84%E5%BD%95%E4%BA%94%EF%BC%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8Btimeit/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/50_%E9%99%84%E5%BD%95%E4%BA%94%EF%BC%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8Btimeit/</url>
    
    <content type="html"><![CDATA[<h2 id="一、timeit模块的使用"><a href="#一、timeit模块的使用" class="headerlink" title="一、timeit模块的使用"></a><strong>一、timeit模块的使用</strong></h2><p>timeit模块下主要有两个函数十分有用，分别为timeit.timeit、timeit.repeat</p><h3 id="1-1-timeit-timeit的使用"><a href="#1-1-timeit-timeit的使用" class="headerlink" title="1.1 timeit.timeit的使用"></a><strong>1.1 timeit.timeit的使用</strong></h3><p> timeit.timeit参数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># stmt指定要执行的语句&#x2F;statement,值可以是字符串形式的表达式，也可以是一个函数，或者是一个变量的形式。# number指定stmt语句执行的次数，默认值为一百万次# setup这个参数可以将stmt的环境传进去。比如各种import以及参数。多个值用分号；分隔开# timer 指定计数器函数，使用默认time.perf_counter就好，详见下一小节</code></pre></div></figure><p> stmt参数使用示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from timeit import timeit, repeat# 1、stmt值为字符串表达式res1 &#x3D; timeit(stmt&#x3D;&quot;[i for i in range(1000)]&quot;, number&#x3D;100)#2、stmt值为一个变量statement &#x3D; &quot;&quot;&quot;l &#x3D; []for i in range(1000):    l.append(i)&quot;&quot;&quot;res2 &#x3D; timeit(stmt&#x3D;statement, number&#x3D;100)#3、stmt值为一个函数def foo():    l &#x3D; []    for i in range(1000):        l.append(i)res3 &#x3D; timeit(stmt&#x3D;foo, number&#x3D;100)&quot;&quot;&quot;注意：如果stmt&#x3D;&quot;foo()&quot;，那么必须通过setupo来导入from __main__ import foo如下res3&#x3D;timeit(stmt&#x3D;&quot;foo()&quot;,setup&#x3D;&#39;from __main__ import foo&#39;,number&#x3D;10)&quot;&quot;&quot;print(res1)  # 0.003296864000731148print(res2)  # 0.008153499999025371print(res3)  # 0.008153499999025371</code></pre></div></figure><p> setup参数使用示例</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from timeit import timeitres&#x3D;timeit(stmt&#x3D;&quot;json.loads(json_data)&quot;,number&#x3D;1000,           setup&#x3D;&quot;import json;data&#x3D;&#123;&#39;name&#39;:&#39;egon&#39;,&#39;age&#39;:18&#125;;json_data&#x3D;json.dumps(data)&quot;           )print(res)</code></pre></div></figure><p>###1.2 timeit.repeat</p><p> 其实repeat就比timeit多了一个参数，参数名与函数名一致，也叫repeat，用来指定重复的次数</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from timeit import timeit, repeatres &#x3D; repeat(stmt&#x3D;&quot;[i for i in range(1000)]&quot;, number&#x3D;100,repeat&#x3D;3)print(res)# repeat&#x3D;3，所以返回的列表中包含三个元素，所代表的含义依次为：# 1、第一个100次执行指定语句所耗费时间# 2、第二个100次执行指定语句所耗费时间# 3、第三个100次执行指定语句所耗费时间[0.0033898779984156135, 0.003476719997706823, 0.00342772699877969]</code></pre></div></figure><p>##二、编写通用计时装饰器</p><p> python2和python3里面的计时函数是不一样的，所以推荐建议使用timeit模块中的timeit.default_timer()，它会根据平台不同选取合适的计时函数，详解如下</p><p> 由timeit.default_timer()的官方文档可知，计时时间精度和平台以及使用的函数有关：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&quot;Define a default timer, in a platform-specific manner. On Windows, time.clock() has microsecond granularity, but time.time()’s granularity is 1&#x2F;60th of a second. On Unix, time.clock() has 1&#x2F;100th of a second granularity, and time.time() is much more precise. On either platform, default_timer() measures wall clock time, not the CPU time. This means that other processes running on the same computer may interfere with the timing.&quot;翻译过来就是：“定义在默认的计时器中，针对不同平台采用不同方式。在Windows上，time.clock()具有微秒精度，但是time.time()精度是1&#x2F;60s。在Unix上，time.clock()有1&#x2F;100s精度，而且time.time()精度远远更高。在另外的平台上，default_timer()测量的是墙上时钟时间，不是CPU时间。这意味着同一计算机的其他进程可能影响计时。”</code></pre></div></figure><p> 具体区别可以查看python2和3中timeit的实现</p><p> 在python2中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">if sys.platform &#x3D;&#x3D; &quot;win32&quot;:    # On Windows, the best timer is time.clock()    default_timer &#x3D; time.clockelse:    # On most other platforms the best timer is time.time()    default_timer &#x3D; time.time</code></pre></div></figure><p>在python3中：default_timer &#x3D; time.perf_counter</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">由time.clock()的官方文档可以看出：&quot;Deprecated since version 3.3: The behaviour of this function depends on the platform: use perf_counter() or process_time() instead, depending on your requirements, to have a well defined behaviour.&quot;翻译过来就是：“python3.3版本后time.clock()就过时了：这个函数的行为受平台影响，用time.perf_counter()”或者time.process_time()代替来得到一个定义更好的行为，具体取决于你的需求。”</code></pre></div></figure><p> 更多详细信息请看官方文档中的time.get_clock_info()</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;time.html#time.get_clock_info</code></pre></div></figure><p> 综上，我们可以定一个同时适用于Python2和Python3解释器的通用计时装饰器</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">import timeitdef clock(func):    def clocked(*args, **kwargs):        start &#x3D; timeit.default_timer()        res &#x3D; func(*args, **kwargs)        run_time &#x3D; timeit.default_timer() - start        func_name &#x3D; func.__name__        arg_str &#x3D; &#39;, &#39;.join(repr(arg) for arg in args)        print(&#39;调用&gt;&gt;&gt;%s(%s)   返回值&gt;&gt;&gt;%r   耗时&gt;&gt;&gt;%0.8fs&#39; % (func_name, arg_str, res, run_time))        return res    return clocked@clockdef func(n):    &quot;&quot;&quot;累计加1&quot;&quot;&quot;    res&#x3D;0    for i in range(n):        res+&#x3D;1    return resif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    func(10000000)</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>49-附录四：Python格式化字符串的4种方式</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/49_%E9%99%84%E5%BD%95%E5%9B%9B%EF%BC%9APython%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%844%E4%B8%AD%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/49_%E9%99%84%E5%BD%95%E5%9B%9B%EF%BC%9APython%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%844%E4%B8%AD%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Python格式化字符串的4中方式"><a href="#Python格式化字符串的4中方式" class="headerlink" title="Python格式化字符串的4中方式"></a><strong>Python格式化字符串的4中方式</strong></h2><h2 id="一：-号"><a href="#一：-号" class="headerlink" title="一：%号"></a><strong>一：%号</strong></h2><p> %号格式化字符串的方式从Python诞生之初就已经存在，时至今日，python官方也并未弃用%号，但也并不推荐这种格式化方式。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 1、格式的字符串（即%s）与被格式化的字符串（即传入的值）必须按照位置一一对应# ps：当需格式化的字符串过多时，位置极容易搞混print(&#39;%s asked %s to do something&#39; % (&#39;egon&#39;, &#39;lili&#39;))  # egon asked lili to do somethingprint(&#39;%s asked %s to do something&#39; % (&#39;lili&#39;, &#39;egon&#39;))  # lili asked egon to do something# 2、可以通过字典方式格式化，打破了位置带来的限制与困扰print(&#39;我的名字是 %(name)s, 我的年龄是 %(age)s.&#39; % &#123;&#39;name&#39;: &#39;egon&#39;, &#39;age&#39;: 18&#125;)kwargs&#x3D;&#123;&#39;name&#39;: &#39;egon&#39;, &#39;age&#39;: 18&#125;print(&#39;我的名字是 %(name)s, 我的年龄是 %(age)s.&#39; % kwargs)</code></pre></div></figure><h2 id="二：str-format"><a href="#二：str-format" class="headerlink" title="二：str.format"></a><strong>二：str.format</strong></h2><p> 该<code>format</code>方法是在Python 2.6中引入的，是字符串类型的内置方法。因为str.format的方式在性能和使用的灵活性上都比%号更胜一筹，所以推荐使用</p><p><em>2.1 使用位置参数</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 按照位置一一对应print(&#39;&#123;&#125; asked &#123;&#125; to do something&#39;.format(&#39;egon&#39;, &#39;lili&#39;))  # egon asked lili to do somethingprint(&#39;&#123;&#125; asked &#123;&#125; to do something&#39;.format(&#39;lili&#39;, &#39;egon&#39;))  # lili asked egon to do something</code></pre></div></figure><p><em>2.2 使用索引</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 使用索引取对应位置的值print(&#39;&#123;0&#125;&#123;0&#125;&#123;1&#125;&#123;0&#125;&#39;.format(&#39;x&#39;,&#39;y&#39;)) # xxyx</code></pre></div></figure><p><em>2.3 使用关键字参数or字典</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 可以通过关键字or字典方式的方式格式化，打破了位置带来的限制与困扰print(&#39;我的名字是 &#123;name&#125;, 我的年龄是 &#123;age&#125;.&#39;.format(age&#x3D;18, name&#x3D;&#39;egon&#39;))kwargs &#x3D; &#123;&#39;name&#39;: &#39;egon&#39;, &#39;age&#39;: 18&#125;print(&#39;我的名字是 &#123;name&#125;, 我的年龄是 &#123;age&#125;.&#39;.format(**kwargs)) # 使用**进行解包操作</code></pre></div></figure><p><em>2.4 填充与格式化</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 先取到值,然后在冒号后设定填充格式：[填充字符][对齐方式][宽度]# *&lt;10：左对齐，总共10个字符，不够的用*号填充print(&#39;&#123;0:*&lt;10&#125;&#39;.format(&#39;开始执行&#39;)) # 开始执行******# *&gt;10：右对齐，总共10个字符，不够的用*号填充print(&#39;&#123;0:*&gt;10&#125;&#39;.format(&#39;开始执行&#39;)) # ******开始执行# *^10：居中显示，总共10个字符，不够的用*号填充print(&#39;&#123;0:*^10&#125;&#39;.format(&#39;开始执行&#39;)) # ***开始执行***</code></pre></div></figure><p><em>2.5 精度与进制</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">print(&#39;&#123;salary:.3f&#125;&#39;.format(salary&#x3D;1232132.12351))  #精确到小数点后3位，四舍五入，结果为：1232132.124print(&#39;&#123;0:b&#125;&#39;.format(123))  # 转成二进制，结果为：1111011print(&#39;&#123;0:o&#125;&#39;.format(9))  # 转成八进制，结果为：11print(&#39;&#123;0:x&#125;&#39;.format(15))  # 转成十六进制，结果为：fprint(&#39;&#123;0:,&#125;&#39;.format(99812939393931))  # 千分位格式化，结果为：99,812,939,393,931</code></pre></div></figure><h2 id="三：f-Strings"><a href="#三：f-Strings" class="headerlink" title="三：f-Strings"></a><strong>三：f-Strings</strong></h2><p>str.format() 比 %格式化高级了一些，但是它还是有自己的缺陷。当需要传入的字符串过多时，仍然会显得非常冗长。与在Python 3.6中引入 了f-strings，不仅比str.format更简洁，性能上也更胜一筹</p><p> f<code>-</code>string是以f或F开头的字符串， 核心在于字符串中符号{}的使用</p><p><em>3.1 {}中可以是变量名</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">name &#x3D; &#39;egon&#39;age &#x3D; 18print(f&#39;&#123;name&#125; &#123;age&#125;&#39;)  # egon 18print(F&#39;&#123;age&#125; &#123;name&#125;&#39;)  # 18 egon</code></pre></div></figure><p><em>3.2 {}中可以是表达式</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 可以在&#123;&#125;中放置任意合法的Python表达式，会在运行时计算# 比如：数学表达式print(f&#39;&#123;3*3&#x2F;2&#125;&#39;) # 4.5# 比如：函数的调用def foo(n):    print(&#39;foo say hello&#39;)    return nprint(f&#39;&#123;foo(10)&#125;&#39;) # 会调用foo(10),然后打印其返回值# 比如：调用对象的方法name&#x3D;&#39;EGON&#39;print(f&#39;&#123;name.lower()&#125;&#39;) # egon</code></pre></div></figure><p><em>3.3 在类中的使用</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; class Person(object):...     def __init__(self, name, age):...         self.name &#x3D; name...         self.age &#x3D; age...     def __str__(self):...         return f&#39;&#123;self.name&#125;:&#123;self.age&#125;&#39;...     def __repr__(self):...         return f&#39;&#x3D;&#x3D;&#x3D;&gt;&#123;self.name&#125;:&#123;self.age&#125;&lt;&#x3D;&#x3D;&#x3D;&#39;... &gt;&gt;&gt; &gt;&gt;&gt; obj&#x3D;Person(&#39;egon&#39;,18)&gt;&gt;&gt; print(obj) # 触发__str__egon:18&gt;&gt;&gt; obj        # 触发__repr__&#x3D;&#x3D;&#x3D;&gt;egon:18&lt;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; # 在f-Strings中的使用&gt;&gt;&gt; f&#39;&#123;obj&#125;&#39;   # 触发__str__&#39;egon:18&#39;&gt;&gt;&gt; f&#39;&#123;obj!r&#125;&#39; # 触发__repr__&#39;&#x3D;&#x3D;&#x3D;&gt;egon:18&lt;&#x3D;&#x3D;&#x3D;&#39;  </code></pre></div></figure><p><em>3.3 多行f-Stings</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 当格式化字符串过长时，如下列表infoname &#x3D; &#39;Egon&#39;age &#x3D; 18gender &#x3D; &#39;male&#39;hobbie1&#x3D;&#39;play&#39;hobbie2&#x3D;&#39;music&#39;hobbie3&#x3D;&#39;read&#39;info &#x3D; [f&#39;名字：&#123;name&#125;年龄：&#123;age&#125;性别：&#123;gender&#125;&#39;,f&#39;第一个爱好：&#123;hobbie1&#125;第二个爱好：&#123;hobbie2&#125;第三个爱好：&#123;hobbie3&#125;&#39;] # 我们可以回车分隔到多行，注意每行前都有一个finfo &#x3D; [    # 第一个元素    f&#39;名字：&#123;name&#125;&#39;    f&#39;年龄：&#123;age&#125;&#39;    f&#39;性别：&#123;gender&#125;&#39;,    # 第二个元素    f&#39;第一个爱好：&#123;hobbie1&#125;&#39;    f&#39;第二个爱好：&#123;hobbie2&#125;&#39;    f&#39;第三个爱好：&#123;hobbie3&#125;&#39;]print(info)# [&#39;名字：Egon年龄：18性别：male&#39;, &#39;第一个爱好：play第二个爱好：music第三个爱好：read&#39;]</code></pre></div></figure><p><em>3.4 引号的嵌套</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 当字符串嵌套发送冲突时，与正常的字符串处理方式是一样的# 1、外层为单引号，内层嵌套也为单引号，并且想要输入的内容也为单引号，那么外层需要改用双引号print(&quot;my name is &#39;egon&#39;&quot;)# 2、外层为单引号，内层嵌套也为单引号，并且想要输入的内容也为单引号，需要用到转义print(&#39;my name is \&#39;egon\&#39;&#39;)</code></pre></div></figure><p><em>3.5注意</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#1、反斜杠可以用来进行字符转义，但不能用在&#123;&#125;的表达式中f&#39;&#123;1\2&#125;&#39; # 语法错误#2、注释#号也不能出现在&#123;&#125;的表达式中f&#39;&#123;x#&#125;&#39; # 语法错误</code></pre></div></figure><p><em>3.6 括号的处理</em></p><p>基于3.5我们得知，不能在{}内出现反斜杠\，所以，当我们的输出的结果中需要包含{}时，下面的做法就是错误的</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">print(f&#39;\&#123;天王盖地虎\&#125;&#39;)</code></pre></div></figure><p>类似于输出%号的做法</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; print(&#39;%s%%&#39; %30)30%</code></pre></div></figure><p>若想输出{},那么需要在原有的基础上再套一层，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">print(f&#39;&#123;&#123;天王盖地虎&#125;&#125;&#39;) # &#123;天王盖地虎&#125;print(f&#39;&#123;&#123;&#123;&#123;天王盖地虎&#125;&#125;&#125;&#125;&#39;) # &#123;&#123;天王盖地虎&#125;&#125;</code></pre></div></figure><p>性能对比&#x3D;&gt;f_Stings性能最高</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from timeit import timeitdef test_s():    name &#x3D; &#39;Egon&#39;    age &#x3D; 18    return &#39;%s:%s.&#39; % (name, age)def test_format():    name &#x3D; &#39;Egon&#39;    age &#x3D; 18    return &#39;&#123;&#125;:&#123;&#125;.&#39;.format(name, age)def test_f_strings():    name &#x3D; &#39;Egon&#39;    age &#x3D; 18    return f&#39;&#123;name&#125;:&#123;age&#125;.&#39;res1 &#x3D; timeit(test_s, number&#x3D;1000000)res2 &#x3D; timeit(test_format, number&#x3D;1000000)res3 &#x3D; timeit(test_f_strings, number&#x3D;1000000)print(res1) # 0.3709844550030539print(res2) # 0.47834375899401493print(res3) # 0.3111891380031011, 最快</code></pre></div></figure><p>##四：标准库模板</p><p> 从Python 2.4起，Python标准库string引入了Template也可以用来格式化字符串，所以说，与前三种方式的一个显著区别就是：Template并属于python语言的核心语法特征，使用方式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from string import Templatename&#x3D;&#39;EGON&#39;t &#x3D; Template(&#39;Hello $name!&#39;)res&#x3D;t.substitute(name&#x3D;name)print(res)  # Hello EGON!</code></pre></div></figure><p>另外一个不同的地方是这个模板字符串不支持类似str.format那样的进制转换，需要我们自己处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">from string import Templatename&#x3D;&#39;EGON&#39;templ_string &#x3D; &#39;Hello $name, there is a $error error!!!&#39;res&#x3D;Template(templ_string).substitute(name&#x3D;name, error&#x3D;hex(12345))print(res) # Hello EGON, there is a 0x3039 error!!!</code></pre></div></figure><p>使用模板字符串Template的最佳的时机就是当你的程序需要处理由用户提供的输入内容时。模板字符串是最保险的选择，因为可以降低复杂性。</p><p>其他一些复杂的字符串格式化技巧的可能会给你的程序带来安全漏洞</p><h2 id="五：总结四种方式的应用场景"><a href="#五：总结四种方式的应用场景" class="headerlink" title="五：总结四种方式的应用场景"></a><strong>五：总结四种方式的应用场景</strong></h2><p>1、如果格式化的字符串是由用户输入的，那么基于安全性考虑，推荐使用Template</p><p>2、如果使用的python3.6+版本的解释器，推荐使用f-Stings</p><p>3、如果要兼容python2.x版本的python解释器，推荐使用str.format</p><p>4、如果不是测试的代码，不推荐使用%</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>48-附录三：Python是解释型的强类型动态语言</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/48_%E9%99%84%E5%BD%95%E4%B8%89%EF%BC%9APython%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B%E7%9A%84%E5%BC%BA%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/48_%E9%99%84%E5%BD%95%E4%B8%89%EF%BC%9APython%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B%E7%9A%84%E5%BC%BA%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-编译型or解释型"><a href="#一、-编译型or解释型" class="headerlink" title="一、 编译型or解释型"></a><strong>一、 编译型or解释型</strong></h2><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#1.1 编译型略#1.2 解释型（python属于解释型）略</code></pre></div></figure><h2 id="二、强类型or弱类型"><a href="#二、强类型or弱类型" class="headerlink" title="二、强类型or弱类型"></a><strong>二、强类型or弱类型</strong></h2><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#2.1 强类型语言（python属于强类型）   数据类型不可以被忽略的语言 即变量的数据类型一旦被定义，那就不会再改变，除非进行强转。 在python中，例如：name &#x3D; &#39;egon&#39;，这个变量name在被赋值的那一刻，数据类型就被确定死了，是字符型，值为&#39;egon&#39;。 #2.2 弱类型语言：  数据类型可以被忽略的语言 比如linux中的shell中定义一个变量，是随着调用方式的不同，数据类型可随意切换的那种。  </code></pre></div></figure><h2 id="三、动态型or静态型"><a href="#三、动态型or静态型" class="headerlink" title="三、动态型or静态型"></a><strong>三、动态型or静态型</strong></h2><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#3.1 动态语言（python属于动态语言）  运行时才进行数据类型检查 即在变量赋值时，就确定了变量的数据类型，不用事先给变量指定数据类型  #3.2 静态语言  需要事先给变量进行数据类型定义  </code></pre></div></figure><p>所以综上所述，Python是一门解释型的强类型动态语言</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>47-附录二：GIL新解</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/47_%E9%99%84%E5%BD%95%E4%BA%8C%EF%BC%9AGIL%E6%96%B0%E8%A7%A3/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/47_%E9%99%84%E5%BD%95%E4%BA%8C%EF%BC%9AGIL%E6%96%B0%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一：cpu和GIL必须都具备才可以执行代码；"><a href="#一：cpu和GIL必须都具备才可以执行代码；" class="headerlink" title="一：cpu和GIL必须都具备才可以执行代码；"></a><strong>一：cpu和GIL必须都具备才可以执行代码；</strong></h2><p> 拿到cpu权限-》拿到GIL解释器锁-》执行代码</p><p> 在python3.2之后GIL有了新的实现，目的是为了解决that GIL thrashing问题，这是Antoine Pitrou的功劳</p><h2 id="二：GIL解释器锁会在两种情况下释放"><a href="#二：GIL解释器锁会在两种情况下释放" class="headerlink" title="二：GIL解释器锁会在两种情况下释放"></a><strong>二：GIL解释器锁会在两种情况下释放</strong></h2><h3 id="2-1、主动释放：自己主动交出来"><a href="#2-1、主动释放：自己主动交出来" class="headerlink" title="2.1、主动释放：自己主动交出来"></a><strong>2.1、主动释放：自己主动交出来</strong></h3><p>遇到IO操作或者分配的cpu时间片到时间了</p><p>注意，GIL存在的意义在于维护线程安全，x&#x3D;10涉及到io操作，如果也被当成普通的io操作，主动交出GIL，那么一定会出现数据不安全问题，所以x&#x3D;10一定是被区分对待了</p><p>至于x&#x3D;10如何实现的被区分对待，这其实很好理解，任何的io操作都是向操作系统发送系统调用，即调用操作系统的某一接口实现的，比如变量赋值操作肯定是调用了一种接口，文件读写操作肯定也是调用了一种接口，网络io也是调用了某一种接口，这就给区分对待提供了实现的依据，即变量赋值操作并不属于主动释放的范畴，这样GIL在线程安全方面才会有所作为</p><h3 id="2-2、被动释放"><a href="#2-2、被动释放" class="headerlink" title="2.2、被动释放"></a><strong>2.2、被动释放</strong></h3><p>python3.2之后定义了一个全局变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&#x2F;* Python&#x2F;ceval.c *&#x2F;...static volatile int gil_drop_request &#x3D; 0;</code></pre></div></figure><p>注意当只有一个线程时，该线程会一直运行，不会释放GIL，当有多个线程时</p><p>例如thead1，thread2</p><p>如果thread1一直没有主动释放掉GIL，那肯定不会让他一直运行下去啊</p><p>实际上在thread1运行的过程时，thread2就会执行一个cv_wait(gil,TIMEOUT)的函数</p><p>（默认TIMEOUT值为5milliseconds，但是可以修改），一旦到了时间，就会将全局变量</p><p>gil_drop_request &#x3D; 1;，线程thread1就会被强制释放GIL，然后线程thread2开始运行并</p><p>返回一个ack给线程thread1，线程thread1开始调用cv_wait(gil,TIMEOUT)</p><h2 id="三：详见图解"><a href="#三：详见图解" class="headerlink" title="三：详见图解"></a><strong>三：详见图解</strong></h2><p>见Part4</p><p><strong><a href="https://link.zhihu.com/?target=http://www.dabeaz.com/python/UnderstandingGIL.pdf">http://www.dabeaz.com/python/Under</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>46-附录一：PEPB规范</title>
    <link href="/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/46_%E9%99%84%E5%BD%95%E4%B8%80%EF%BC%9APEP8%E8%A7%84%E8%8C%83/"/>
    <url>/2022/07/18/03_Python/08-%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85/46_%E9%99%84%E5%BD%95%E4%B8%80%EF%BC%9APEP8%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一-PEP8规范是什么？"><a href="#一-PEP8规范是什么？" class="headerlink" title="一 PEP8规范是什么？"></a><strong>一 PEP8规范是什么？</strong></h2><p> PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。</p><p> 每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。</p><p> 尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。</p><h2 id="二-PEP8规范相关内容"><a href="#二-PEP8规范相关内容" class="headerlink" title="二 PEP8规范相关内容"></a><strong>二 PEP8规范相关内容</strong></h2><p> 我们可以从Python官方网站的**<a href="https://link.zhihu.com/?target=https://www.python.org/dev/peps/pep-0008/">PEP 8链接</a>**中找到该文档，下面我们对该文档的关键部分做一个简单的总结。</p><h3 id="2-1-空格的使用"><a href="#2-1-空格的使用" class="headerlink" title="2.1 空格的使用"></a><strong>2.1 空格的使用</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#1、使用空格来表示缩进而不要用制表符（Tab）。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C&#x2F;C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。#2、和语法相关的每一层缩进都用4个空格来表示。#3、每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。#4、函数和类的定义，代码前后都要用两个空行进行分隔。#5、在同一个类中，各个方法之间应该用一个空行进行分隔。#6、二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。</code></pre></div></figure><h3 id="2-2-标识符命名"><a href="#2-2-标识符命名" class="headerlink" title="2.2 标识符命名"></a><strong>2.2 标识符命名</strong></h3><p> PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#1、变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。#2、类中受保护的实例属性，应该以一个下划线开头。#3、类中私有的实例属性，应该以两个下划线开头。#4、类和异常的命名，应该每个单词首字母大写。#5、模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。#6、类的实例方法，应该把第一个参数命名为self以表示对象自身。#7、类的类方法，应该把第一个参数命名为cls以表示该类自身。</code></pre></div></figure><h3 id="2-3-表达式和语句"><a href="#2-3-表达式和语句" class="headerlink" title="2.3 表达式和语句"></a><strong>2.3 表达式和语句</strong></h3><p> 在Python之禅（可以使用import this查看）中有这么一句名言：“There should be one– and preferably only one –obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#1、采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。#2、不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。#3、就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。#4、import语句总是放在文件开头的地方。#5、引入模块的时候，from math import sqrt比import math更好。#6、如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>12_附录补充</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day44-数据库（一）</title>
    <link href="/2022/07/18/03_Python/03_MySQL/day44_%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/"/>
    <url>/2022/07/18/03_Python/03_MySQL/day44_%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>“Day44-数据库(一)学习笔记”</p><h1 id="一-、数据库管理软件的由来"><a href="#一-、数据库管理软件的由来" class="headerlink" title="一 、数据库管理软件的由来"></a>一 、数据库管理软件的由来</h1><p>数据库管理软件是怎么来的？</p><h2 id="1-1-数据的保存问题"><a href="#1-1-数据的保存问题" class="headerlink" title="1.1 数据的保存问题"></a>1.1 数据的保存问题</h2><p>数据要想永久保存，都是保存于文件中，毫无疑问，一个文件仅仅只能存在于某一台机器上。</p><p>如果我们暂且忽略直接基于文件来存取数据的效率问题，并且假设程序所有的组件都运行在一台机器上，那么用文</p><p>件存取数据，并没有问题。</p><p>很不幸，这些假设都是你自己意淫出来的，上述假设存在以下几个问题。。。。。。</p><p><strong>1、程序所有的组件就不可能运行在一台机器上</strong></p><ul><li>因为这台机器一旦挂掉则意味着整个软件的崩溃，并且程序的执行效率依赖于承载它的硬件，而一台机器机器的性能总归是有限的，受限于目前的硬件水平，就一台机器的性能垂直进行扩展是有极限的。</li><li>于是我们只能通过水平扩展来增强我们系统的整体性能，这就需要我们将程序的各个组件分布于多台机器去执行。</li></ul><p><strong>2、数据安全问题</strong></p><ul><li><p>根据1的描述，我们将程序的各个组件分布到各台机器，但需知各组件仍然是一个整体，言外之意，所有组件的数据还是要共享的。但每台机器上的组件都只能操作本机的文件，这就导致了数据必然不一致。</p></li><li><p>于是我们想到了将数据与应用程序分离：把文件存放于一台机器，然后将多台机器通过网络去访问这台机器上的文件（用socket实现），即共享这台机器上的文件,共享则意味着竞争，会发生数据不安全，需要加锁处理。。。。</p></li></ul><p><strong>3、并发</strong></p><p>根据2的描述，我们必须写一个socket服务端来管理这台机器（数据库服务器）上的文件，然后写一个socket客户端，完成如下功能：</p><ol><li>远程连接（支持并发）</li><li>打开文件</li><li>读写（加锁）</li><li>关闭文件</li></ol><h2 id="1-2-由此而生的管理软件："><a href="#1-2-由此而生的管理软件：" class="headerlink" title="1.2 由此而生的管理软件："></a>1.2 由此而生的管理软件：</h2><p>我们在编写任何程序之前，都需要事先写好基于网络<code>操作一台主机上数据文件</code>的程序（socket服务端与客户端程</p><p>序），于是有人将此类程序写成一个专门的处理软件，这就是mysql等数据库管理软件的由来，但mysql解决的不</p><p>仅仅是数据共享的问题，还有查询效率，安全性等一系列问题，总之，把程序员从数据管理中解脱出来，专注于自</p><p>己的程序逻辑的编写。</p><h1 id="二、数据库概述"><a href="#二、数据库概述" class="headerlink" title="二、数据库概述"></a>二、数据库概述</h1><h2 id="2-1-什么是数据（Data）"><a href="#2-1-什么是数据（Data）" class="headerlink" title="2.1 什么是数据（Data）"></a>2.1 什么是数据（Data）</h2><p>数据：描述事务的符号记录</p><p>符号：既可以是数字，也可以是文字、图片，图像、声音、语言等</p><p>数据由多种表现形式，它们都可以经过数字化后存入计算机</p><p>在计算机中描述一个事物，就需要抽取这一事物的典型特征，组成一条记录，就相当于文件里的一行内容，如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 egon,male,18,1999,山东,计算机系,2017,oldboy</code></pre></div></figure><p>单纯的一条记录并没有任何意义，如果我们按逗号作为分隔，依次定义各个<code>字段</code>的意思，相当于定义表的标题</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 name,sex,age,birth,born_addr,major,entrance_time,school #字段2 egon,male,18,1999,山东,计算机系,2017,gschool #记录</code></pre></div></figure><p>这样我们就可以了解egon，性别为男，年龄18岁，出生于1999年，出生地为山东，2017年考入gschool</p><h2 id="2-2-什么是数据库（DataBase）"><a href="#2-2-什么是数据库（DataBase）" class="headerlink" title="2.2 什么是数据库（DataBase）"></a>2.2 什么是数据库（DataBase）</h2><p>数据库：即存放数据的仓库，只不过这个仓库是在计算机存储设备上，而且数据是按一定的格式存放的</p><h2 id="2-3-什么是数据库管理系统（DBMS）"><a href="#2-3-什么是数据库管理系统（DBMS）" class="headerlink" title="2.3 什么是数据库管理系统（DBMS）"></a>2.3 什么是数据库管理系统（DBMS）</h2><p>在了解了Data与DB的概念后，如何科学地组织和存储数据，如何高效获取和维护数据成了关键</p><p>这就用到了一个系统软件—数据库管理系统</p><p>如MySQL、Oracle、SQLite、Access、MS SQL Server</p><p>mysql主要用于大型门户，例如搜狗、新浪等，它主要的优势就是开放源代码，因为开放源代码这个数据库是免费</p><p>的，他现在是甲骨文公司的产品。</p><p>oracle主要用于银行、铁路、飞机场等。该数据库功能强大，软件费用高。也是甲骨文公司的产品。</p><p>sql server是微软公司的产品，主要应用于大中型企业，如联想、方正等。</p><h2 id="2-4-数据库服务器、数据管理系统、数据库、表与记录的关系（重点理解！！！）"><a href="#2-4-数据库服务器、数据管理系统、数据库、表与记录的关系（重点理解！！！）" class="headerlink" title="2.4 数据库服务器、数据管理系统、数据库、表与记录的关系（重点理解！！！）"></a>2.4 数据库服务器、数据管理系统、数据库、表与记录的关系（重点理解！！！）</h2><table><thead><tr><th>描述</th><th>案例</th><th>备注</th></tr></thead><tbody><tr><td>记录</td><td>1，刘海龙，324245234，22</td><td>文件中的一行内容</td></tr><tr><td>表</td><td>student，scholl，class_list</td><td>文件</td></tr><tr><td>数据库</td><td>oldboy_stu</td><td>文件夹</td></tr><tr><td>数据库管理系统</td><td>mysql</td><td>软件</td></tr><tr><td>数据库服务器</td><td>一台计算机</td><td>服务器</td></tr></tbody></table><p>图示如下：</p><p><img src="https://pic3.zhimg.com/80/v2-bfdd92b482a8d0c473a92e1d2651f3aa_720w.jpg" alt="img"></p><h1 id="三、MySQL介绍"><a href="#三、MySQL介绍" class="headerlink" title="三、MySQL介绍"></a>三、MySQL介绍</h1><h2 id="3-1-什么是MySQL"><a href="#3-1-什么是MySQL" class="headerlink" title="3.1 什么是MySQL"></a>3.1 什么是MySQL</h2><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关</p><p>系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数</p><p>据库管理系统) 应用软件之一。</p><p>常用客户端软件</p><ul><li>mysql自带：如mysql命令，mysqldump命令等</li><li>python模块：如pymysql</li></ul><h2 id="3-2-数据库管理软件分类"><a href="#3-2-数据库管理软件分类" class="headerlink" title="3.2 数据库管理软件分类"></a>3.2 数据库管理软件分类</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#分两大类：　　关系型：如sqllite，db2，oracle，access，sql server，MySQL，注意：sql语句通用　　非关系型：mongodb，redis，memcache#可以简单的理解为：    关系型数据库需要有表结构    非关系型数据库是key-value存储的，没有表结构</code></pre></div></figure><h1 id="四、下载安装"><a href="#四、下载安装" class="headerlink" title="四、下载安装"></a>四、下载安装</h1><p><strong>Linux版本</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#二进制rpm包安装yum -y install mysql-server mysql</code></pre></div></figure><p>源码安装mysql</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.解压tar包cd &#x2F;softwaretar -xzvf mysql-5.6.21-linux-glibc2.5-x86_64.tar.gzmv mysql-5.6.21-linux-glibc2.5-x86_64 mysql-5.6.212.添加用户与组groupadd mysqluseradd -r -g mysql mysqlchown -R mysql:mysql mysql-5.6.213.安装数据库su mysqlcd mysql-5.6.21&#x2F;scripts.&#x2F;mysql_install_db --user&#x3D;mysql --basedir&#x3D;&#x2F;software&#x2F;mysql-5.6.21 --datadir&#x3D;&#x2F;software&#x2F;mysql-5.6.21&#x2F;data4.配置文件cd &#x2F;software&#x2F;mysql-5.6.21&#x2F;support-filescp my-default.cnf &#x2F;etc&#x2F;my.cnfcp mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqlvim &#x2F;etc&#x2F;init.d&#x2F;mysql   #若mysql的安装目录是&#x2F;usr&#x2F;local&#x2F;mysql,则可省略此步修改文件中的两个变更值basedir&#x3D;&#x2F;software&#x2F;mysql-5.6.21datadir&#x3D;&#x2F;software&#x2F;mysql-5.6.21&#x2F;data5.配置环境变量vim &#x2F;etc&#x2F;profileexport MYSQL_HOME&#x3D;&quot;&#x2F;software&#x2F;mysql-5.6.21&quot;export PATH&#x3D;&quot;$PATH:$MYSQL_HOME&#x2F;bin&quot;source &#x2F;etc&#x2F;profile6.添加自启动服务chkconfig --add mysqlchkconfig mysql on7.启动mysqlservice mysql start8.登录mysql及改密码与配置远程访问mysqladmin -u root password &#39;your_password&#39;     #修改root用户密码mysql -u root -p     #登录mysql,需要输入密码mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;your_password&#39; WITH GRANT OPTION;     #允许root用户远程访问mysql&gt;FLUSH PRIVILEGES;     #刷新权限</code></pre></div></figure><p>源码安装mariadb</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1. 解压tar zxvf  mariadb-5.5.31-linux-x86_64.tar.gz   mv mariadb-5.5.31-linux-x86_64 &#x2F;usr&#x2F;local&#x2F;mysql &#x2F;&#x2F;必需这样，很多脚本或可执行程序都会直接访问这个目录2. 权限groupadd mysql             &#x2F;&#x2F;增加 mysql 属组 useradd -g mysql mysql     &#x2F;&#x2F;增加 mysql 用户 并归于mysql 属组 chown mysql:mysql -Rf  &#x2F;usr&#x2F;local&#x2F;mysql    &#x2F;&#x2F; 设置 mysql 目录的用户及用户组归属。 chmod +x -Rf &#x2F;usr&#x2F;local&#x2F;mysql    &#x2F;&#x2F;赐予可执行权限 3. 拷贝配置文件cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;my-medium.cnf &#x2F;etc&#x2F;my.cnf     &#x2F;&#x2F;复制默认mysql配置 文件到&#x2F;etc目录 4. 初始化&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;scripts&#x2F;mysql_install_db --user&#x3D;mysql          &#x2F;&#x2F;初始化数据库 cp  &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server    &#x2F;etc&#x2F;init.d&#x2F;mysql    &#x2F;&#x2F;复制mysql服务程序 到系统目录 chkconfig  mysql on     &#x2F;&#x2F;添加mysql 至系统服务并设置为开机启动 service  mysql  start  &#x2F;&#x2F;启动mysql5. 环境变量配置vim &#x2F;etc&#x2F;profile   &#x2F;&#x2F;编辑profile,将mysql的可执行路径加入系统PATHexport PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin:$PATH source &#x2F;etc&#x2F;profile  &#x2F;&#x2F;使PATH生效。6. 账号密码mysqladmin -u root password &#39;yourpassword&#39; &#x2F;&#x2F;设定root账号及密码mysql -u root -p  &#x2F;&#x2F;使用root用户登录mysqluse mysql  &#x2F;&#x2F;切换至mysql数据库。select user,host,password from user; &#x2F;&#x2F;查看系统权限drop user &#39;&#39;@&#39;localhost&#39;; &#x2F;&#x2F;删除不安全的账户drop user root@&#39;::1&#39;;drop user root@127.0.0.1;select user,host,password from user; &#x2F;&#x2F;再次查看系统权限，确保不安全的账户均被删除。flush privileges;  &#x2F;&#x2F;刷新权限7. 一些必要的初始配置1）修改字符集为UTF8vi &#x2F;etc&#x2F;my.cnf在[client]下面添加 default-character-set &#x3D; utf8在[mysqld]下面添加 character_set_server &#x3D; utf82）增加错误日志vi &#x2F;etc&#x2F;my.cnf在[mysqld]下面添加：log-error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;error.loggeneral-log-file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql.log3) 设置为不区分大小写，linux下默认会区分大小写。vi &#x2F;etc&#x2F;my.cnf在[mysqld]下面添加：lower_case_table_name&#x3D;1修改完重启：#service  mysql  restart</code></pre></div></figure><p><strong>Window版本</strong></p><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、下载：MySQL Community Server 5.7.16http:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;mysql&#x2F;#2、解压如果想要让MySQL安装在指定目录，那么就将解压后的文件夹移动到指定目录，如：C:\mysql-5.7.16-winx64#3、添加环境变量【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --&gt; 【将MySQL的bin目录路径追加到变值值中，用 ； 分割】#4、初始化mysqld --initialize-insecure#5、启动MySQL服务mysqld # 启动MySQL服务#6、启动MySQL客户端并连接MySQL服务mysql -u root -p # 连接MySQL服务器</code></pre></div></figure><p>将MySQL服务制作成windows服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">上一步解决了一些问题，但不够彻底，因为在执行【mysqd】启动MySQL服务器时，当前终端会被hang住，那么做一下设置即可解决此问题：注意：--install前，必须用mysql启动命令的绝对路径# 制作MySQL的Windows服务，在终端执行此命令：&quot;c:\mysql-5.7.16-winx64\bin\mysqld&quot; --install# 移除MySQL的Windows服务，在终端执行此命令：&quot;c:\mysql-5.7.16-winx64\bin\mysqld&quot; --remove注册成服务之后，以后再启动和关闭MySQL服务时，仅需执行如下命令：# 启动MySQL服务net start mysql# 关闭MySQL服务net stop mysql</code></pre></div></figure><h1 id="五、mysql软件基本管理"><a href="#五、mysql软件基本管理" class="headerlink" title="五、mysql软件基本管理"></a>五、mysql软件基本管理</h1><h2 id="5-1-启动查看"><a href="#5-1-启动查看" class="headerlink" title="5.1 启动查看"></a>5.1 启动查看</h2><p>linux平台下查看</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">[root@egon ~]# systemctl start mariadb #启动[root@egon ~]# systemctl enable mariadb #设置开机自启动Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;mariadb.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;mariadb.service.[root@egon ~]# ps aux |grep mysqld |grep -v grep #查看进程，mysqld_safe为启动mysql的脚本文件，内部调用mysqld命令mysql     3329  0.0  0.0 113252  1592 ?        Ss   16:19   0:00 &#x2F;bin&#x2F;sh &#x2F;usr&#x2F;bin&#x2F;mysqld_safe --basedir&#x3D;&#x2F;usrmysql     3488  0.0  2.3 839276 90380 ?        Sl   16:19   0:00 &#x2F;usr&#x2F;libexec&#x2F;mysqld --basedir&#x3D;&#x2F;usr --datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql --plugin-dir&#x3D;&#x2F;usr&#x2F;lib64&#x2F;mysql&#x2F;plugin --log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log --pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid --socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock[root@egon ~]# netstat -an |grep 3306 #查看端口tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN  [root@egon ~]# ll -d &#x2F;var&#x2F;lib&#x2F;mysql #权限不对，启动不成功，注意user和groupdrwxr-xr-x 5 mysql mysql 4096 Jul 20 16:28 &#x2F;var&#x2F;lib&#x2F;mysql</code></pre></div></figure><p>You must reset your password using ALTER USER statement before executing this statement.</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">安装完mysql 之后，登陆以后，不管运行任何命令，总是提示这个mac mysql error You must reset your password using ALTER USER statement before executing this statement.解决方法：step 1: SET PASSWORD &#x3D; PASSWORD(&#39;your new password&#39;);step 2: ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;step 3: flush privileges;</code></pre></div></figure><h2 id="5-2-登录，设置密码"><a href="#5-2-登录，设置密码" class="headerlink" title="5.2 登录，设置密码"></a>5.2 登录，设置密码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">初始状态下，管理员root，密码为空，默认只允许从本机登录localhost设置密码[root@egon ~]# mysqladmin -uroot password &quot;123&quot;        设置初始密码 由于原密码为空，因此-p可以不用[root@egon ~]# mysqladmin -uroot -p&quot;123&quot; password &quot;456&quot;        修改mysql密码,因为已经有密码了，所以必须输入原密码才能设置新密码命令格式:[root@egon ~]# mysql -h172.31.0.2 -uroot -p456[root@egon ~]# mysql -uroot -p[root@egon ~]# mysql                    以root用户登录本机，密码为空</code></pre></div></figure><h2 id="5-3-忘记密码"><a href="#5-3-忘记密码" class="headerlink" title="5.3 忘记密码"></a>5.3 忘记密码</h2><p><strong>linux平台下，破解密码的两种方式</strong></p><p>方法一：删除授权库mysql，重新初始化</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">[root@egon ~]# rm -rf &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql #所有授权信息全部丢失！！！[root@egon ~]# systemctl restart mariadb[root@egon ~]# mysql</code></pre></div></figure><p>方法二：启动时，跳过授权库</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">[root@egon ~]# vim &#x2F;etc&#x2F;my.cnf    #mysql主配置文件[mysqld]skip-grant-table[root@egon ~]# systemctl restart mariadb[root@egon ~]# mysqlMariaDB [(none)]&gt; update mysql.user set password&#x3D;password(&quot;123&quot;) where user&#x3D;&quot;root&quot; and host&#x3D;&quot;localhost&quot;;MariaDB [(none)]&gt; flush privileges;MariaDB [(none)]&gt; \q[root@egon ~]# #打开&#x2F;etc&#x2F;my.cnf去掉skip-grant-table,然后重启[root@egon ~]# systemctl restart mariadb[root@egon ~]# mysql -u root -p123 #以新密码登录</code></pre></div></figure><p><strong>windows平台下，5.7版本mysql，破解密码的两种方式：</strong></p><p>方式一</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1 关闭mysql#2 在cmd中执行：mysqld --skip-grant-tables#3 在cmd中执行：mysql#4 执行如下sql：update mysql.user set authentication_string&#x3D;password(&#39;&#39;) where user &#x3D; &#39;root&#39;;flush privileges;#5 tskill mysqld #或taskkill -f &#x2F;PID 7832#6 重新启动mysql</code></pre></div></figure><p>方式二</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 关闭mysql，可以用tskill mysqld将其杀死#2. 在解压目录下，新建mysql配置文件my.ini#3. my.ini内容,指定[mysqld]skip-grant-tables#4.启动mysqld#5.在cmd里直接输入mysql登录，然后操作update mysql.user set authentication_string&#x3D;password(&#39;&#39;) where user&#x3D;&#39;root and host&#x3D;&#39;localhost&#39;;flush privileges;#6.注释my.ini中的skip-grant-tables，然后启动myqsld，然后就可以以新密码登录了</code></pre></div></figure><h2 id="5-4-在windows下，为mysql服务指定配置文件"><a href="#5-4-在windows下，为mysql服务指定配置文件" class="headerlink" title="5.4 在windows下，为mysql服务指定配置文件"></a>5.4 在windows下，为mysql服务指定配置文件</h2><p><strong>强调：配置文件中的注释可以有中文，但是配置项中不能出现中文</strong></p><p>my.ini</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#在mysql的解压目录下，新建my.ini,然后配置#1. 在执行mysqld命令时，下列配置会生效，即mysql服务启动时生效[mysqld];skip-grant-tablesport&#x3D;3306character_set_server&#x3D;utf8default-storage-engine&#x3D;innodbinnodb_file_per_table&#x3D;1#解压的目录basedir&#x3D;E:\mysql-5.7.19-winx64#data目录datadir&#x3D;E:\my_data #在mysqld --initialize时，就会将初始数据存入此处指定的目录，在初始化之后，启动mysql时，就会去这个目录里找数据#2. 针对客户端命令的全局配置，当mysql客户端命令执行时，下列配置生效[client]port&#x3D;3306default-character-set&#x3D;utf8user&#x3D;rootpassword&#x3D;123#3. 只针对mysql这个客户端的配置，2中的是全局配置，而此处的则是只针对mysql这个命令的局部配置[mysql];port&#x3D;3306;default-character-set&#x3D;utf8user&#x3D;egonpassword&#x3D;4573#！！！如果没有[mysql],则用户在执行mysql命令时的配置以[client]为准</code></pre></div></figure><h2 id="5-5-统一字符编码"><a href="#5-5-统一字符编码" class="headerlink" title="5.5 统一字符编码"></a>5.5 统一字符编码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 修改配置文件[mysqld]default-character-set&#x3D;utf8 [client]default-character-set&#x3D;utf8 [mysql]default-character-set&#x3D;utf8#mysql5.5以上：修改方式有所改动[mysqld]character-set-server&#x3D;utf8collation-server&#x3D;utf8_general_ci[client]default-character-set&#x3D;utf8[mysql]default-character-set&#x3D;utf8#2. 重启服务#3. 查看修改结果：\sshow variables like &#39;%char%&#39;</code></pre></div></figure><h1 id="六、初识SQL语句"><a href="#六、初识SQL语句" class="headerlink" title="六、初识SQL语句"></a>六、初识SQL语句</h1><h2 id="6-1-SQL语句分类"><a href="#6-1-SQL语句分类" class="headerlink" title="6.1 SQL语句分类"></a>6.1 SQL语句分类</h2><p>SQL语言主要用于存取数据、查询数据、更新数据和管理关系数据库系统,SQL语言由IBM开发。SQL语言分为3种类型：</p><ol><li>DDL语句    数据库定义语言： 数据库、表、视图、索引、存储过程，例如CREATE DROP ALTER</li><li>DML语句    数据库操纵语言： 插入数据INSERT、删除数据DELETE、更新数据UPDATE、查询数据SELECT</li><li>DCL语句    数据库控制语言： 例如控制用户的访问权限GRANT、REVOKE</li></ol><h2 id="6-2-基本SQL语句"><a href="#6-2-基本SQL语句" class="headerlink" title="6.2 基本SQL语句"></a>6.2 基本SQL语句</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 操作库        增：create database db1 charset utf8;        查：show databases; # 查所有            show create database db1; # 查单个        改：alter database db1 charset latin1;        删: drop database db1;#2. 操作表    先切换到文件夹下：use db1        增：create table t1(id int,name char);        查：show tables;        改：alter table t1 modify name char(3); # 字段改属性        alter table t8 change id id tinyint unsigned; # 字段改属性和约束条件            alter table t1 change name name1 char(2); # 字段改名            alter table t1 add(age tinyint)# 添加字段            alter table t8 drop column &#96;age&#96;; # 删除字段        删：drop table t1;#3. 操作记录        增：insert into t1 values(1,&#39;egon1&#39;),(2,&#39;egon2&#39;),(3,&#39;egon3&#39;);        查：select * from t1;        改：update t1 set name&#x3D;&#39;sb&#39; where id&#x3D;2;        删：delete from t1 where id&#x3D;1;        清空表：            delete from t1; #如果有自增id，新增的数据，仍然是以删除前的最后一样作为起始。            truncate table t1;数据量大，删除速度比上一条快，且直接从零开始，            auto_increment 表示：自增            primary key 表示：约束（不能重复且不能为空）；加速查找</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>03_MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>38-并发编程（七）</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/38_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/38_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一-IO模型介绍"><a href="#一-IO模型介绍" class="headerlink" title="一 IO模型介绍"></a>一 IO模型介绍</h3><p><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/7430066.html%23_label4">为了更好地了解IO模型，我们需要事先回顾下：同步、异步、阻塞、非阻塞</a></p><p>同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。</p><p>本文讨论的背景是Linux环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I&#x2F;O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂。本文中的流程图也是截取自参考文献。</p><p>Stevens在文章中一共比较了五种IO Model： * blocking IO * nonblocking IO * IO multiplexing * signal driven IO * asynchronous IO 由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。</p><p>再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1）等待数据准备 (Waiting for the data to be ready)#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</code></pre></div></figure><p>记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况。</p><p>补充：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、输入操作：read、readv、recv、recvfrom、recvmsg共5个函数，如果会阻塞状态，则会经理wait data和copy data两个阶段，如果设置为非阻塞则在wait 不到data时抛出异常#2、输出操作：write、writev、send、sendto、sendmsg共5个函数，在发送缓冲区满了会阻塞在原地，如果设置为非阻塞，则会抛出异常#3、接收外来链接：accept，与输入操作类似#4、发起外出链接：connect，与输出操作类似</code></pre></div></figure><h3 id="二-阻塞IO-blocking-IO"><a href="#二-阻塞IO-blocking-IO" class="headerlink" title="二 阻塞IO(blocking IO)"></a>二 阻塞IO(blocking IO)</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="https://pic2.zhimg.com/80/v2-57c6feedfeb28710a17b925dd35066a1_720w.jpg" alt="img"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。</p><p>而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 <strong>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</strong></p><p>几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，使用这些接口可以很方便的构建服务器&#x2F;客户机的模型。然而大部分的socket接口都是阻塞型的。如下图</p><p>ps：所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。</p><p><img src="https://pic2.zhimg.com/80/v2-b349f2082980d93cf9e4682d56452071_720w.jpg" alt="img"></p><p>实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。</p><p>一个简单的解决方案：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。</code></pre></div></figure><p>该方案的问题是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#开启多进程或都线程的方式，在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。</code></pre></div></figure><p>改进方案：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。</code></pre></div></figure><p>改进后方案其实也存在着问题：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</code></pre></div></figure><p><strong>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</strong></p><h3 id="三-非阻塞IO-non-blocking-IO"><a href="#三-非阻塞IO-non-blocking-IO" class="headerlink" title="三 非阻塞IO(non-blocking IO)"></a>三 非阻塞IO(non-blocking IO)</h3><p>Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://pic2.zhimg.com/80/v2-de6969a3184e17de058a61ab1f3f67cd_720w.jpg" alt="img"></p><p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。</p><p>也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p><p><strong>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</strong></p><p>非阻塞IO示例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 服务端import socketimport timeserver&#x3D;socket.socket()server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)server.bind((&#39;127.0.0.1&#39;,8083))server.listen(5)server.setblocking(False)r_list&#x3D;[]w_list&#x3D;&#123;&#125;while 1:    try:        conn,addr&#x3D;server.accept()        r_list.append(conn)    except BlockingIOError:        # 强调强调强调：！！！非阻塞IO的精髓在于完全没有阻塞！！！        # time.sleep(0.5) # 打开该行注释纯属为了方便查看效果        print(&#39;在做其他的事情&#39;)        print(&#39;rlist: &#39;,len(r_list))        print(&#39;wlist: &#39;,len(w_list))        # 遍历读列表，依次取出套接字读取内容        del_rlist&#x3D;[]        for conn in r_list:            try:                data&#x3D;conn.recv(1024)                if not data:                    conn.close()                    del_rlist.append(conn)                    continue                w_list[conn]&#x3D;data.upper()            except BlockingIOError: # 没有收成功，则继续检索下一个套接字的接收                continue            except ConnectionResetError: # 当前套接字出异常，则关闭，然后加入删除列表，等待被清除                conn.close()                del_rlist.append(conn)        # 遍历写列表，依次取出套接字发送内容        del_wlist&#x3D;[]        for conn,data in w_list.items():            try:                conn.send(data)                del_wlist.append(conn)            except BlockingIOError:                continue        # 清理无用的套接字,无需再监听它们的IO操作        for conn in del_rlist:            r_list.remove(conn)        for conn in del_wlist:            w_list.pop(conn)#客户端import socketimport osclient&#x3D;socket.socket()client.connect((&#39;127.0.0.1&#39;,8083))while 1:    res&#x3D;(&#39;%s hello&#39; %os.getpid()).encode(&#39;utf-8&#39;)    client.send(res)    data&#x3D;client.recv(1024)    print(data.decode(&#39;utf-8&#39;))</code></pre></div></figure><p><strong>但是非阻塞IO模型绝不被推荐。</strong></p><p>我们不能否则其优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在“”同时“”执行）。</p><p>但是也难掩其缺点：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 循环调用recv()将大幅度推高CPU占用率；这也是我们在代码中留一句time.sleep(2)的原因,否则在低配主机下极容易出现卡机情况#2. 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</code></pre></div></figure><p><em><strong>*此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。*</strong></em></p><h3 id="四-多路复用IO-IO-multiplexing"><a href="#四-多路复用IO-IO-multiplexing" class="headerlink" title="四 多路复用IO(IO multiplexing)"></a>四 多路复用IO(IO multiplexing)</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select&#x2F;epoll，大概就都能明白了。有些地方也称这种IO方式为<strong>事件驱动IO</strong>(event driven IO)。我们都知道，select&#x2F;epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select&#x2F;epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="https://pic2.zhimg.com/80/v2-2a460241583789b2d961f5f48b325779_720w.jpg" alt="img"></p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><p><strong>强调：</strong></p><p><strong>1. 如果处理的连接数不是很高的话，使用select&#x2F;epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong></p><p><strong>2. 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</strong></p><p><strong>结论: select的优势在于可以处理多个连接，不适用于单个连接</strong></p><p>select网络IO模型</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#服务端from socket import *import selectserver &#x3D; socket(AF_INET, SOCK_STREAM)server.bind((&#39;127.0.0.1&#39;,8093))server.listen(5)server.setblocking(False)print(&#39;starting...&#39;)rlist&#x3D;[server,]wlist&#x3D;[]wdata&#x3D;&#123;&#125;while True:    rl,wl,xl&#x3D;select.select(rlist,wlist,[],0.5)    print(wl)    for sock in rl:        if sock &#x3D;&#x3D; server:            conn,addr&#x3D;sock.accept()            rlist.append(conn)        else:            try:                data&#x3D;sock.recv(1024)                if not data:                    sock.close()                    rlist.remove(sock)                    continue                wlist.append(sock)                wdata[sock]&#x3D;data.upper()            except Exception:                sock.close()                rlist.remove(sock)    for sock in wl:        sock.send(wdata[sock])        wlist.remove(sock)        wdata.pop(sock)#客户端from socket import *client&#x3D;socket(AF_INET,SOCK_STREAM)client.connect((&#39;127.0.0.1&#39;,8093))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if not msg:continue    client.send(msg.encode(&#39;utf-8&#39;))    data&#x3D;client.recv(1024)    print(data.decode(&#39;utf-8&#39;))client.close()</code></pre></div></figure><p><strong>select监听fd变化的过程分析：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#用户进程创建socket对象，拷贝监听的fd到内核空间，每一个fd会对应一张系统文件表，内核空间的fd响应到数据后，就会发送信号给用户进程数据已到；#用户进程再发送系统调用，比如（accept）将内核空间的数据copy到用户空间，同时作为接受数据端内核空间的数据清除，这样重新监听时fd再有新的数据又可以响应到了（发送端因为基于TCP协议所以需要收到应答后才会清除）。</code></pre></div></figure><p><strong>该模型的优点：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。</code></pre></div></figure><p><strong>该模型的缺点：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了&#x2F;dev&#x2F;poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。#其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。</code></pre></div></figure><h3 id="五-异步IO-Asynchronous-I-O"><a href="#五-异步IO-Asynchronous-I-O" class="headerlink" title="五 异步IO(Asynchronous I&#x2F;O)"></a>五 异步IO(Asynchronous I&#x2F;O)</h3><p>Linux下的asynchronous IO其实用得不多，从内核2.6版本才开始引入。先看一下它的流程：</p><p><img src="https://pic2.zhimg.com/80/v2-ede97f17d1ca1e7f23bd62aae2548c55_720w.jpg" alt="img"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h3 id="六-IO模型比较分析"><a href="#六-IO模型比较分析" class="headerlink" title="六 IO模型比较分析"></a>六 IO模型比较分析</h3><p>到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。 先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p>再说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的： A synchronous I&#x2F;O operation causes the requesting process to be blocked until that I&#x2F;O operationcompletes; An asynchronous I&#x2F;O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，四个IO模型可以分为两大类，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO这一类，而 asynchronous I&#x2F;O后一类 。</p><p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p>各个IO Model的比较如图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-627ffa49acfdc032a65dbe350b0ac444_720w.jpg" alt="img"></p><p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h3 id="七-selectors模块"><a href="#七-selectors模块" class="headerlink" title="七 selectors模块"></a>七 selectors模块</h3><p>select,poll,epoll</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">IO复用：为了解释这个名词，首先来理解下复用这个概念，复用也就是共用的意思，这样理解还是有些抽象，为此，咱们来理解下复用在通信领域的使用，在通信领域中为了充分利用网络连接的物理介质，往往在同一条网络链路上采用时分复用或频分复用的技术使其在同一链路上传输多路信号，到这里我们就基本上理解了复用的含义，即公用某个“介质”来尽可能多的做同一类(性质)的事，那IO复用的“介质”是什么呢？为此我们首先来看看服务器编程的模型，客户端发来的请求服务端会产生一个进程来对其进行服务，每当来一个客户请求就产生一个进程来服务，然而进程不可能无限制的产生，因此为了解决大量客户端访问的问题，引入了IO复用技术，即：一个进程可以同时对多个客户请求进行服务。也就是说IO复用的“介质”是进程(准确的说复用的是select和poll，因为进程也是靠调用select和poll来实现的)，复用一个进程(select和poll)来对多个IO进行服务，虽然客户端发来的IO是并发的但是IO所需的读写数据多数情况下是没有准备好的，因此就可以利用一个函数(select和poll)来监听IO所需的这些数据的状态，一旦IO有数据可以进行读写了，进程就来对这样的IO进行服务。理解完IO复用后，我们在来看下实现IO复用中的三个API(select、poll和epoll)的区别和联系select，poll，epoll都是IO多路复用的机制，I&#x2F;O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。三者的原型如下所示：int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);int poll(struct pollfd *fds, nfds_t nfds, int timeout);int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 1.select的第一个参数nfds为fdset集合中最大描述符值加1，fdset是一个位数组，其大小限制为__FD_SETSIZE（1024），位数组的每一位代表其对应的描述符是否需要被检查。第二三四参数表示需要关注读、写、错误事件的文件描述符位数组，这些参数既是输入参数也是输出参数，可能会被内核修改用于标示哪些描述符上发生了关注的事件，所以每次调用select前都需要重新初始化fdset。timeout参数为超时时间，该结构会被内核修改，其值为超时剩余的时间。 select的调用步骤如下：（1）使用copy_from_user从用户空间拷贝fdset到内核空间（2）注册回调函数__pollwait（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll 来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数 据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是 current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout 指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。（8）把fd_set从内核空间拷贝到用户空间。总结下select的几大缺点：（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（3）select支持的文件描述符数量太小了，默认是10242．  poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。 poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，相比处理fdset来说，poll效率更高。poll返回后，需要对pollfd中的每个元素检查其revents值，来得指事件是否发生。3．直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，被公认为Linux2.6下性能最好的多路I&#x2F;O就绪通知方法。epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select&#x2F;poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll 和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函 数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注 册要监听的事件类型；epoll_wait则是等待事件的产生。　　对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定 EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝 一次。　　对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在 epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调 函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用 schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。　　对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子, 在1GB内存的机器上大约是10万左右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看,一般来说这个数目和系统内存关系很大。总结：（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销。</code></pre></div></figure><p>这三种IO多路复用模型在不同的平台有着不同的支持，而epoll在windows下就不支持，好在我们有selectors模块，帮我们默认选择当前平台下最合适的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#服务端from socket import *import selectorssel&#x3D;selectors.DefaultSelector()def accept(server_fileobj,mask):    conn,addr&#x3D;server_fileobj.accept()    sel.register(conn,selectors.EVENT_READ,read)def read(conn,mask):    try:        data&#x3D;conn.recv(1024)        if not data:            print(&#39;closing&#39;,conn)            sel.unregister(conn)            conn.close()            return        conn.send(data.upper()+b&#39;_SB&#39;)    except Exception:        print(&#39;closing&#39;, conn)        sel.unregister(conn)        conn.close()server_fileobj&#x3D;socket(AF_INET,SOCK_STREAM)server_fileobj.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)server_fileobj.bind((&#39;127.0.0.1&#39;,8088))server_fileobj.listen(5)server_fileobj.setblocking(False) #设置socket的接口为非阻塞sel.register(server_fileobj,selectors.EVENT_READ,accept) #相当于网select的读列表里append了一个文件句柄server_fileobj,并且绑定了一个回调函数acceptwhile True:    events&#x3D;sel.select() #检测所有的fileobj，是否有完成wait data的    for sel_obj,mask in events:        callback&#x3D;sel_obj.data #callback&#x3D;accpet        callback(sel_obj.fileobj,mask) #accpet(server_fileobj,1)#客户端from socket import *c&#x3D;socket(AF_INET,SOCK_STREAM)c.connect((&#39;127.0.0.1&#39;,8088))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;)    if not msg:continue    c.send(msg.encode(&#39;utf-8&#39;))    data&#x3D;c.recv(1024)    print(data.decode(&#39;utf-8&#39;))</code></pre></div></figure><p>作业:基于selectors模块实现并发的FTP</p><p><a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/1qYPrHCg">参考:链接: https://pan.baidu.com/s/1qYPrHCg 密码: 9is4</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>37-并发编程（六）</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/37_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E7%A8%8B/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/37_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一-引子"><a href="#一-引子" class="headerlink" title="一 引子"></a>一 引子</h3><p>本节的主题是基于单线程来实现并发，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发，为此我们需要先回顾下并发的本质：切换+保存状态</p><p>cpu正在运行一个任务，会在两种情况下切走去执行其他的任务（切换由操作系统强制控制），一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长或有一个优先级更高的程序替代了它</p><p><img src="https://pic1.zhimg.com/80/v2-1b816bea5d7900ca5faad9abdee1cec4_720w.jpg" alt="img"></p><p>ps：在介绍进程理论时，提及进程的三种执行状态，而线程才是执行单位，所以也可以将上图理解为线程的三种状态</p><p>一：其中第二种情况并不能提升效率，只是为了让cpu能够雨露均沾，实现看起来所有任务都被“同时”执行的效果，如果多个任务都是纯计算的，这种切换反而会降低效率。为此我们可以基于yield来验证。yield本身就是一种在单线程下可以保存任务运行状态的方法，我们来简单复习一下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1 yiled可以保存状态，yield的状态保存与操作系统的保存线程状态很像，但是yield是代码级别控制的，更轻量级#2 send可以把一个函数的结果传给另外一个函数，以此实现单线程内程序之间的切换</code></pre></div></figure><p>单纯地切换反而会降低运行效率</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;1、协程：    单线程实现并发    在应用程序里控制多个任务的切换+保存状态    优点：        应用程序级别速度要远远高于操作系统的切换    缺点：        多个任务一旦有一个阻塞没有切，整个线程都阻塞在原地        该线程内的其他的任务都不能执行了        一旦引入协程，就需要检测单线程下所有的IO行为,        实现遇到IO就切换,少一个都不行，以为一旦一个任务阻塞了，整个线程就阻塞了，        其他的任务即便是可以计算，但是也无法运行了2、协程序的目的：    想要在单线程下实现并发    并发指的是多个任务看起来是同时运行的    并发&#x3D;切换+保存状态&#39;&#39;&#39;#串行执行import timedef func1():    for i in range(10000000):        i+1def func2():    for i in range(10000000):        i+1start &#x3D; time.time()func1()func2()stop &#x3D; time.time()print(stop - start)#基于yield并发执行import timedef func1():    while True:        yielddef func2():    g&#x3D;func1()    for i in range(10000000):        i+1        next(g)start&#x3D;time.time()func2()stop&#x3D;time.time()print(stop-start)</code></pre></div></figure><p>二：第一种情况的切换。在任务一遇到io情况下，切到任务二去执行，这样就可以利用任务一阻塞的时间完成任务二的计算，效率的提升就在于此。</p><p>yield不能检测IO，实现遇到IO自动切换</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timedef func1():    while True:        print(&#39;func1&#39;)        yielddef func2():    g&#x3D;func1()    for i in range(10000000):        i+1        next(g)        time.sleep(3)        print(&#39;func2&#39;)start&#x3D;time.time()func2()stop&#x3D;time.time()print(stop-start)</code></pre></div></figure><p><strong>对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。</strong></p><p>协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。#2. 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换</code></pre></div></figure><h3 id="二-协程介绍"><a href="#二-协程介绍" class="headerlink" title="二 协程介绍"></a>二 协程介绍</h3><p>协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：<strong>协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。、</strong></p><p>需要强调的是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）#2. 单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</code></pre></div></figure><p>对比操作系统控制线程的切换，用户在单线程内控制协程的切换</p><p>优点如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级#2. 单线程内就可以实现并发的效果，最大限度地利用cpu</code></pre></div></figure><p>缺点如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程#2. 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程</code></pre></div></figure><p>总结协程特点：</p><ol><li><strong>必须在只有一个单线程里实现并发</strong></li><li><strong>修改共享数据不需加锁</strong></li><li><strong>用户程序里自己保存多个控制流的上下文栈</strong></li><li><strong>附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））</strong></li></ol><h3 id="三-Greenlet"><a href="#三-Greenlet" class="headerlink" title="三 Greenlet"></a>三 Greenlet</h3><p>如果我们在单个线程内有20个任务，要想实现在多个任务之间切换，使用yield生成器的方式过于麻烦（需要先得到初始化一次的生成器，然后再调用send。。。非常麻烦），而使用greenlet模块可以非常简单地实现这20个任务直接的切换</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#安装pip3 install greenletfrom greenlet import greenletdef eat(name):    print(&#39;%s eat 1&#39; %name)    g2.switch(&#39;egon&#39;)    print(&#39;%s eat 2&#39; %name)    g2.switch()def play(name):    print(&#39;%s play 1&#39; %name)    g1.switch()    print(&#39;%s play 2&#39; %name)g1&#x3D;greenlet(eat)g2&#x3D;greenlet(play)g1.switch(&#39;egon&#39;)#可以在第一次switch时传入参数，以后都不需要</code></pre></div></figure><p>单纯的切换（在没有io的情况下或者没有重复开辟内存空间的操作），反而会降低程序的执行速度</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#顺序执行import timedef f1():    res&#x3D;1    for i in range(100000000):        res+&#x3D;idef f2():    res&#x3D;1    for i in range(100000000):        res*&#x3D;istart&#x3D;time.time()f1()f2()stop&#x3D;time.time()print(&#39;run time is %s&#39; %(stop-start)) #10.985628366470337#切换from greenlet import greenletimport timedef f1():    res&#x3D;1    for i in range(100000000):        res+&#x3D;i        g2.switch()def f2():    res&#x3D;1    for i in range(100000000):        res*&#x3D;i        g1.switch()start&#x3D;time.time()g1&#x3D;greenlet(f1)g2&#x3D;greenlet(f2)g1.switch()stop&#x3D;time.time()print(&#39;run time is %s&#39; %(stop-start)) # 52.763017892837524</code></pre></div></figure><p>greenlet只是提供了一种比generator更加便捷的切换方式，当切到一个任务执行时如果遇到io，那就原地阻塞，仍然是没有解决遇到IO自动切换来提升效率的问题。</p><p>单线程里的这20个任务的代码通常会既有计算操作又有阻塞操作，我们完全可以在执行任务1时遇到阻塞，就利用阻塞的时间去执行任务2。。。。如此，才能提高效率，这就用到了Gevent模块。</p><h3 id="四-Gevent介绍"><a href="#四-Gevent介绍" class="headerlink" title="四 Gevent介绍"></a>四 Gevent介绍</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#安装pip3 install gevent</code></pre></div></figure><p>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是<strong>Greenlet</strong>, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#用法g1&#x3D;gevent.spawn(func,1,,2,3,x&#x3D;4,y&#x3D;5)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的g2&#x3D;gevent.spawn(func2)g1.join() #等待g1结束g2.join() #等待g2结束#或者上述两步合作一步：gevent.joinall([g1,g2])g1.value#拿到func1的返回值</code></pre></div></figure><p><strong>遇到IO阻塞时会自动切换任务</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import geventdef eat(name):    print(&#39;%s eat 1&#39; %name)    gevent.sleep(2)    print(&#39;%s eat 2&#39; %name)def play(name):    print(&#39;%s play 1&#39; %name)    gevent.sleep(1)    print(&#39;%s play 2&#39; %name)g1&#x3D;gevent.spawn(eat,&#39;egon&#39;)g2&#x3D;gevent.spawn(play,name&#x3D;&#39;egon&#39;)g1.join()g2.join()#或者gevent.joinall([g1,g2])print(&#39;主&#39;)</code></pre></div></figure><p><strong>上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,</strong></p><p><strong>而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了</strong></p><p><strong>from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前</strong></p><p><strong>或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from gevent import monkey;monkey.patch_all()import geventimport timedef eat():    print(&#39;eat food 1&#39;)    time.sleep(2)    print(&#39;eat food 2&#39;)def play():    print(&#39;play 1&#39;)    time.sleep(1)    print(&#39;play 2&#39;)g1&#x3D;gevent.spawn(eat)g2&#x3D;gevent.spawn(play_phone)gevent.joinall([g1,g2])print(&#39;主&#39;)</code></pre></div></figure><p>我们可以用threading.current_thread().getName()来查看每个g1和g2，查看的结果为DummyThread-n，即假线程</p><h3 id="五-Gevent之同步与异步"><a href="#五-Gevent之同步与异步" class="headerlink" title="五 Gevent之同步与异步"></a>五 Gevent之同步与异步</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from gevent import spawn,joinall,monkey;monkey.patch_all()import timedef task(pid):    &quot;&quot;&quot;    Some non-deterministic task    &quot;&quot;&quot;    time.sleep(0.5)    print(&#39;Task %s done&#39; % pid)def synchronous():    for i in range(10):        task(i)def asynchronous():    g_l&#x3D;[spawn(task,i) for i in range(10)]    joinall(g_l)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    print(&#39;Synchronous:&#39;)    synchronous()    print(&#39;Asynchronous:&#39;)    asynchronous()#上面程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn。 初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，后者阻塞当前流程，并执行所有给定的greenlet。执行流程只会在 所有greenlet执行完后才会继续向下走。</code></pre></div></figure><h3 id="六-Gevent之应用举例一"><a href="#六-Gevent之应用举例一" class="headerlink" title="六 Gevent之应用举例一"></a>六 Gevent之应用举例一</h3><p>协程应用：爬虫</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from gevent import monkey;monkey.patch_all()import geventimport requestsimport timedef get_page(url):    print(&#39;GET: %s&#39; %url)    response&#x3D;requests.get(url)    if response.status_code &#x3D;&#x3D; 200:        print(&#39;%d bytes received from %s&#39; %(len(response.text),url))start_time&#x3D;time.time()gevent.joinall([    gevent.spawn(get_page,&#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;),    gevent.spawn(get_page,&#39;https:&#x2F;&#x2F;www.yahoo.com&#x2F;&#39;),    gevent.spawn(get_page,&#39;https:&#x2F;&#x2F;github.com&#x2F;&#39;),])stop_time&#x3D;time.time()print(&#39;run time is %s&#39; %(stop_time-start_time))</code></pre></div></figure><h3 id="七-Gevent之应用举例二"><a href="#七-Gevent之应用举例二" class="headerlink" title="七 Gevent之应用举例二"></a>七 Gevent之应用举例二</h3><p>通过gevent实现单线程下的socket并发（from gevent import monkey;monkey.patch_all()一定要放到导入socket模块之前，否则gevent无法识别socket的阻塞）</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from gevent import monkey;monkey.patch_all()from socket import *import gevent#如果不想用money.patch_all()打补丁,可以用gevent自带的socket# from gevent import socket# s&#x3D;socket.socket()def server(server_ip,port):    s&#x3D;socket(AF_INET,SOCK_STREAM)    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)    s.bind((server_ip,port))    s.listen(5)    while True:        conn,addr&#x3D;s.accept()        gevent.spawn(talk,conn,addr)def talk(conn,addr):    try:        while True:            res&#x3D;conn.recv(1024)            print(&#39;client %s:%s msg: %s&#39; %(addr[0],addr[1],res))            conn.send(res.upper())    except Exception as e:        print(e)    finally:        conn.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    server(&#39;127.0.0.1&#39;,8080)</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *client&#x3D;socket(AF_INET,SOCK_STREAM)client.connect((&#39;127.0.0.1&#39;,8080))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if not msg:continue    client.send(msg.encode(&#39;utf-8&#39;))    msg&#x3D;client.recv(1024)    print(msg.decode(&#39;utf-8&#39;))</code></pre></div></figure><p>多线程并发多个客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Threadfrom socket import *import threadingdef client(server_ip,port):    c&#x3D;socket(AF_INET,SOCK_STREAM) #套接字对象一定要加到函数内，即局部名称空间内，放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了    c.connect((server_ip,port))    count&#x3D;0    while True:        c.send((&#39;%s say hello %s&#39; %(threading.current_thread().getName(),count)).encode(&#39;utf-8&#39;))        msg&#x3D;c.recv(1024)        print(msg.decode(&#39;utf-8&#39;))        count+&#x3D;1if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    for i in range(500):        t&#x3D;Thread(target&#x3D;client,args&#x3D;(&#39;127.0.0.1&#39;,8080))        t.start()</code></pre></div></figure><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=156">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=156<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>36-并发编程（五）</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/36_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%89/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/36_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一-threading模块介绍"><a href="#一-threading模块介绍" class="headerlink" title="一 threading模块介绍"></a>一 threading模块介绍</h3><p>multiprocess模块的完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍</p><p><a href="https://link.zhihu.com/?target=https://docs.python.org/3/library/threading.html?highlight=threading%23">官网链接：https://docs.python.org/3/library/threading.html?highlight=threading#</a></p><h3 id="二-开启线程的两种方式"><a href="#二-开启线程的两种方式" class="headerlink" title="二 开启线程的两种方式"></a>二 开启线程的两种方式</h3><p>方式一</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#方式一from threading import Threadimport timedef sayhi(name):    time.sleep(2)    print(&#39;%s say hello&#39; %name)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    t&#x3D;Thread(target&#x3D;sayhi,args&#x3D;(&#39;egon&#39;,))    t.start()    print(&#39;主线程&#39;)</code></pre></div></figure><p>方式二</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#方式二from threading import Threadimport timeclass Sayhi(Thread):    def __init__(self,name):        super().__init__()        self.name&#x3D;name    def run(self):        time.sleep(2)        print(&#39;%s say hello&#39; % self.name)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    t &#x3D; Sayhi(&#39;egon&#39;)    t.start()    print(&#39;主线程&#39;)</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-4f7843543503e3a1836297921f9bb69e_720w.jpg" alt="img"></p><h3 id="三-在一个进程下开启多个线程与在一个进程下开启多个子进程的区别"><a href="#三-在一个进程下开启多个线程与在一个进程下开启多个子进程的区别" class="headerlink" title="三 在一个进程下开启多个线程与在一个进程下开启多个子进程的区别"></a>三 在一个进程下开启多个线程与在一个进程下开启多个子进程的区别</h3><p>1 谁的开启速度快</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Threadfrom multiprocessing import Processimport osdef work():    print(&#39;hello&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    #在主进程下开启线程    t&#x3D;Thread(target&#x3D;work)    t.start()    print(&#39;主线程&#x2F;主进程&#39;)    &#39;&#39;&#39;    打印结果:    hello    主线程&#x2F;主进程    &#39;&#39;&#39;    #在主进程下开启子进程    t&#x3D;Process(target&#x3D;work)    t.start()    print(&#39;主线程&#x2F;主进程&#39;)    &#39;&#39;&#39;    打印结果:    主线程&#x2F;主进程    hello    &#39;&#39;&#39;</code></pre></div></figure><p>2 瞅一瞅pid</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Threadfrom multiprocessing import Processimport osdef work():    print(&#39;hello&#39;,os.getpid())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    #part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样    t1&#x3D;Thread(target&#x3D;work)    t2&#x3D;Thread(target&#x3D;work)    t1.start()    t2.start()    print(&#39;主线程&#x2F;主进程pid&#39;,os.getpid())    #part2:开多个进程,每个进程都有不同的pid    p1&#x3D;Process(target&#x3D;work)    p2&#x3D;Process(target&#x3D;work)    p1.start()    p2.start()    print(&#39;主线程&#x2F;主进程pid&#39;,os.getpid())</code></pre></div></figure><p>3 同一进程内的线程共享该进程的数据？</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from  threading import Threadfrom multiprocessing import Processimport osdef work():    global n    n&#x3D;0if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # n&#x3D;100    # p&#x3D;Process(target&#x3D;work)    # p.start()    # p.join()    # print(&#39;主&#39;,n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100    n&#x3D;1    t&#x3D;Thread(target&#x3D;work)    t.start()    t.join()    print(&#39;主&#39;,n) #查看结果为0,因为同一进程内的线程之间共享进程内的数据</code></pre></div></figure><h3 id="四-练习"><a href="#四-练习" class="headerlink" title="四 练习"></a>四 练习</h3><p>练习一：</p><p>多线程并发的socket服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*_#!&#x2F;usr&#x2F;bin&#x2F;env pythonimport multiprocessingimport threadingimport sockets&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.bind((&#39;127.0.0.1&#39;,8080))s.listen(5)def action(conn):    while True:        data&#x3D;conn.recv(1024)        print(data)        conn.send(data.upper())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    while True:        conn,addr&#x3D;s.accept()        p&#x3D;threading.Thread(target&#x3D;action,args&#x3D;(conn,))        p.start()</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*_#!&#x2F;usr&#x2F;bin&#x2F;env pythonimport sockets&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&#39;127.0.0.1&#39;,8080))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if not msg:continue    s.send(msg.encode(&#39;utf-8&#39;))    data&#x3D;s.recv(1024)    print(data)</code></pre></div></figure><p>练习二：三个任务，一个接收用户输入，一个将用户输入的内容格式化成大写，一个将格式化后的结果存入文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Threadmsg_l&#x3D;[]format_l&#x3D;[]def talk():    while True:        msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()        if not msg:continue        msg_l.append(msg)def format_msg():    while True:        if msg_l:            res&#x3D;msg_l.pop()            format_l.append(res.upper())def save():    while True:        if format_l:            with open(&#39;db.txt&#39;,&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:                res&#x3D;format_l.pop()                f.write(&#39;%s\n&#39; %res)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    t1&#x3D;Thread(target&#x3D;talk)    t2&#x3D;Thread(target&#x3D;format_msg)    t3&#x3D;Thread(target&#x3D;save)    t1.start()    t2.start()    t3.start()</code></pre></div></figure><h3 id="五-线程相关的其他方法"><a href="#五-线程相关的其他方法" class="headerlink" title="五 线程相关的其他方法"></a>五 线程相关的其他方法</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Thread实例对象的方法  # isAlive(): 返回线程是否活动的。  # getName(): 返回线程名。  # setName(): 设置线程名。threading模块提供的一些方法：  # threading.currentThread(): 返回当前的线程变量。  # threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。  # threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。from threading import Threadimport threadingfrom multiprocessing import Processimport osdef work():    import time    time.sleep(3)    print(threading.current_thread().getName())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    #在主进程下开启线程    t&#x3D;Thread(target&#x3D;work)    t.start()    print(threading.current_thread().getName())    print(threading.current_thread()) #主线程    print(threading.enumerate()) #连同主线程在内有两个运行的线程    print(threading.active_count())    print(&#39;主线程&#x2F;主进程&#39;)    &#39;&#39;&#39;    打印结果:    MainThread    &lt;_MainThread(MainThread, started 140735268892672)&gt;    [&lt;_MainThread(MainThread, started 140735268892672)&gt;, &lt;Thread(Thread-1, started 123145307557888)&gt;]    主线程&#x2F;主进程    Thread-1    &#39;&#39;&#39;</code></pre></div></figure><p>主线程等待子线程结束</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Threadimport timedef sayhi(name):    time.sleep(2)    print(&#39;%s say hello&#39; %name)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    t&#x3D;Thread(target&#x3D;sayhi,args&#x3D;(&#39;egon&#39;,))    t.start()    t.join()    print(&#39;主线程&#39;)    print(t.is_alive())    &#39;&#39;&#39;    egon say hello    主线程    False    &#39;&#39;&#39;</code></pre></div></figure><h3 id="六-守护线程"><a href="#六-守护线程" class="headerlink" title="六 守护线程"></a>六 守护线程</h3><p><strong>无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁</strong></p><p><strong>需要强调的是：运行完毕并非终止运行</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1.对主进程来说，运行完毕指的是主进程代码运行完毕#2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</code></pre></div></figure><p><strong>详细解释：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，#2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。from threading import Threadimport timedef sayhi(name):    time.sleep(2)    print(&#39;%s say hello&#39; %name)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    t&#x3D;Thread(target&#x3D;sayhi,args&#x3D;(&#39;egon&#39;,))    t.setDaemon(True) #必须在t.start()之前设置    t.start()    print(&#39;主线程&#39;)    print(t.is_alive())    &#39;&#39;&#39;    主线程    True    &#39;&#39;&#39;</code></pre></div></figure><p>迷惑人的例子</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Threadimport timedef foo():    print(123)    time.sleep(1)    print(&quot;end123&quot;)def bar():    print(456)    time.sleep(3)    print(&quot;end456&quot;)t1&#x3D;Thread(target&#x3D;foo)t2&#x3D;Thread(target&#x3D;bar)t1.daemon&#x3D;Truet1.start()t2.start()print(&quot;main-------&quot;)</code></pre></div></figure><h3 id="七-Python-GIL-Global-Interpreter-Lock"><a href="#七-Python-GIL-Global-Interpreter-Lock" class="headerlink" title="七 Python GIL(Global Interpreter Lock)"></a>七 Python GIL(Global Interpreter Lock)</h3><p><strong><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/7449853.html">链接：http://www.cnblogs.com/linhaifeng/articles/7449853.html</a></strong></p><h3 id="八-同步锁"><a href="#八-同步锁" class="headerlink" title="八 同步锁"></a>八 同步锁</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">三个需要注意的点：#1.线程抢的是GIL锁，GIL锁相当于执行权限，拿到执行权限后才能拿到互斥锁Lock，其他线程也可以抢到GIL，但如果发现Lock仍然没有被释放则阻塞，即便是拿到执行权限GIL也要立刻交出来#2.join是等待所有，即整体串行，而锁只是锁住修改共享数据的部分，即部分串行，要想保证数据安全的根本原理在于让并发变成串行，join与互斥锁都可以实现，毫无疑问，互斥锁的部分串行效率要更高#3. 一定要看本小节最后的GIL与互斥锁的经典分析</code></pre></div></figure><p><strong>GIL VS Lock</strong></p><p><strong>机智的同学可能会问到这个问题，就是既然你之前说过了，Python已经有一个GIL来保证同一时间只能有一个线程来执行了，为什么这里还需要lock?</strong></p><p><strong>首先我们需要达成共识：锁的目的是为了保护共享的数据，同一时间只能有一个线程来修改共享的数据</strong></p><p><strong>然后，我们可以得出结论：保护不同的数据就应该加不同的锁。</strong></p><p><strong>最后，问题就很明朗了，GIL 与Lock是两把锁，保护的数据不一样，前者是解释器级别的（当然保护的就是解释器级别的数据，比如垃圾回收的数据），后者是保护用户自己开发的应用程序的数据，很明显GIL不负责这件事，只能用户自定义加锁处理，即Lock</strong></p><p><strong>过程分析：所有线程抢的是GIL锁，或者说所有线程抢的是执行权限</strong></p><p><strong>线程1抢到GIL锁，拿到执行权限，开始执行，然后加了一把Lock，还没有执行完毕，即线程1还未释放Lock，有可能线程2抢到GIL锁，开始执行，执行过程中发现Lock还没有被线程1释放，于是线程2进入阻塞，被夺走执行权限，有可能线程1拿到GIL，然后正常执行到释放Lock。。。这就导致了串行运行的效果</strong></p><p><strong>既然是串行，那我们执行</strong></p><p><strong>t1.start()</strong></p><p><strong>t1.join</strong></p><p><strong>t2.start()</strong></p><p><strong>t2.join()</strong></p><p><strong>这也是串行执行啊，为何还要加Lock呢，需知join是等待t1所有的代码执行完，相当于锁住了t1的所有代码，而Lock只是锁住一部分操作共享数据的代码。</strong></p><p>详细</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">因为Python解释器帮你自动定期进行内存回收，你可以理解为python解释器里有一个独立的线程，每过一段时间它起wake up做一次全局轮询看看哪些内存数据是可以被清空的，此时你自己的程序 里的线程和 py解释器自己的线程是并发运行的，假设你的线程删除了一个变量，py解释器的垃圾回收线程在清空这个变量的过程中的clearing时刻，可能一个其它线程正好又重新给这个还没来及得清空的内存空间赋值了，结果就有可能新赋值的数据被删除了，为了解决类似的问题，python解释器简单粗暴的加了锁，即当一个线程运行时，其它人都不能动，这样就解决了上述的问题，  这可以说是Python早期版本的遗留问题。from threading import Threadimport os,timedef work():    global n    temp&#x3D;n    time.sleep(0.1)    n&#x3D;temp-1if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    n&#x3D;100    l&#x3D;[]    for i in range(100):        p&#x3D;Thread(target&#x3D;work)        l.append(p)        p.start()    for p in l:        p.join()    print(n) #结果可能为99</code></pre></div></figure><p><strong>锁通常被用来实现对共享资源的同步访问。为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该锁，则当前线程需等待其被释放），待资源访问完后，再调用release方法释放锁：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import threadingR&#x3D;threading.Lock()R.acquire()&#39;&#39;&#39;对公共数据的操作&#39;&#39;&#39;R.release()from threading import Thread,Lockimport os,timedef work():    global n    lock.acquire()    temp&#x3D;n    time.sleep(0.1)    n&#x3D;temp-1    lock.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    lock&#x3D;Lock()    n&#x3D;100    l&#x3D;[]    for i in range(100):        p&#x3D;Thread(target&#x3D;work)        l.append(p)        p.start()    for p in l:        p.join()    print(n) #结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</code></pre></div></figure><p>GIL锁与互斥锁综合分析（重点！！！）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">分析：　　#1.100个线程去抢GIL锁，即抢执行权限     #2. 肯定有一个线程先抢到GIL（暂且称为线程1），然后开始执行，一旦执行就会拿到lock.acquire()     #3. 极有可能线程1还未运行完毕，就有另外一个线程2抢到GIL，然后开始运行，但线程2发现互斥锁lock还未被线程1释放，于是阻塞，被迫交出执行权限，即释放GIL    #4.直到线程1重新抢到GIL，开始从上次暂停的位置继续执行，直到正常释放互斥锁lock，然后其他的线程再重复2 3 4的过程</code></pre></div></figure><p>互斥锁与join的区别（重点！！！）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#不加锁:并发执行,速度快,数据不安全from threading import current_thread,Thread,Lockimport os,timedef task():    global n    print(&#39;%s is running&#39; %current_thread().getName())    temp&#x3D;n    time.sleep(0.5)    n&#x3D;temp-1if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    n&#x3D;100    lock&#x3D;Lock()    threads&#x3D;[]    start_time&#x3D;time.time()    for i in range(100):        t&#x3D;Thread(target&#x3D;task)        threads.append(t)        t.start()    for t in threads:        t.join()    stop_time&#x3D;time.time()    print(&#39;主:%s n:%s&#39; %(stop_time-start_time,n))&#39;&#39;&#39;Thread-1 is runningThread-2 is running......Thread-100 is running主:0.5216062068939209 n:99&#39;&#39;&#39;#不加锁:未加锁部分并发执行,加锁部分串行执行,速度慢,数据安全from threading import current_thread,Thread,Lockimport os,timedef task():    #未加锁的代码并发运行    time.sleep(3)    print(&#39;%s start to run&#39; %current_thread().getName())    global n    #加锁的代码串行运行    lock.acquire()    temp&#x3D;n    time.sleep(0.5)    n&#x3D;temp-1    lock.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    n&#x3D;100    lock&#x3D;Lock()    threads&#x3D;[]    start_time&#x3D;time.time()    for i in range(100):        t&#x3D;Thread(target&#x3D;task)        threads.append(t)        t.start()    for t in threads:        t.join()    stop_time&#x3D;time.time()    print(&#39;主:%s n:%s&#39; %(stop_time-start_time,n))&#39;&#39;&#39;Thread-1 is runningThread-2 is running......Thread-100 is running主:53.294203758239746 n:0&#39;&#39;&#39;#有的同学可能有疑问:既然加锁会让运行变成串行,那么我在start之后立即使用join,就不用加锁了啊,也是串行的效果啊#没错:在start之后立刻使用jion,肯定会将100个任务的执行变成串行,毫无疑问,最终n的结果也肯定是0,是安全的,但问题是#start后立即join:任务内的所有代码都是串行执行的,而加锁,只是加锁的部分即修改共享数据的部分是串行的#单从保证数据安全方面,二者都可以实现,但很明显是加锁的效率更高.from threading import current_thread,Thread,Lockimport os,timedef task():    time.sleep(3)    print(&#39;%s start to run&#39; %current_thread().getName())    global n    temp&#x3D;n    time.sleep(0.5)    n&#x3D;temp-1if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    n&#x3D;100    lock&#x3D;Lock()    start_time&#x3D;time.time()    for i in range(100):        t&#x3D;Thread(target&#x3D;task)        t.start()        t.join()    stop_time&#x3D;time.time()    print(&#39;主:%s n:%s&#39; %(stop_time-start_time,n))&#39;&#39;&#39;Thread-1 start to runThread-2 start to run......Thread-100 start to run主:350.6937336921692 n:0 #耗时是多么的恐怖&#39;&#39;&#39;</code></pre></div></figure><h3 id="九-死锁现象与递归锁"><a href="#九-死锁现象与递归锁" class="headerlink" title="九 死锁现象与递归锁"></a>九 死锁现象与递归锁</h3><p>进程也有死锁与递归锁，在进程那里忘记说了，放到这里一切说了额</p><p>所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Thread,Lockimport timemutexA&#x3D;Lock()mutexB&#x3D;Lock()class MyThread(Thread):    def run(self):        self.func1()        self.func2()    def func1(self):        mutexA.acquire()        print(&#39;\033[41m%s 拿到A锁\033[0m&#39; %self.name)        mutexB.acquire()        print(&#39;\033[42m%s 拿到B锁\033[0m&#39; %self.name)        mutexB.release()        mutexA.release()    def func2(self):        mutexB.acquire()        print(&#39;\033[43m%s 拿到B锁\033[0m&#39; %self.name)        time.sleep(2)        mutexA.acquire()        print(&#39;\033[44m%s 拿到A锁\033[0m&#39; %self.name)        mutexA.release()        mutexB.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    for i in range(10):        t&#x3D;MyThread()        t.start()&#39;&#39;&#39;Thread-1 拿到A锁Thread-1 拿到B锁Thread-1 拿到B锁Thread-2 拿到A锁然后就卡住，死锁了&#39;&#39;&#39;</code></pre></div></figure><p>解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。</p><p>这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">mutexA&#x3D;mutexB&#x3D;threading.RLock() #一个线程拿到锁，counter加1,该线程内又碰到加锁的情况，则counter继续加1，这期间所有其他线程都只能等待，等待该线程释放所有锁，即counter递减到0为止</code></pre></div></figure><h3 id="十-信号量Semaphore"><a href="#十-信号量Semaphore" class="headerlink" title="十 信号量Semaphore"></a>十 信号量Semaphore</h3><p>同进程的一样</p><p>Semaphore管理一个内置的计数器， 每当调用acquire()时内置计数器-1； 调用release() 时内置计数器+1； 计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()。</p><p>实例：(同时只有5个线程可以获得semaphore,即可以限制最大连接数为5)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Thread,Semaphoreimport threadingimport time# def func():#     if sm.acquire():#         print (threading.currentThread().getName() + &#39; get semaphore&#39;)#         time.sleep(2)#         sm.release()def func():    sm.acquire()    print(&#39;%s get sm&#39; %threading.current_thread().getName())    time.sleep(3)    sm.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    sm&#x3D;Semaphore(5)    for i in range(23):        t&#x3D;Thread(target&#x3D;func)        t.start()</code></pre></div></figure><p><strong>与进程池是完全不同的概念，进程池Pool(4)，最大只能产生4个进程，而且从头到尾都只是这四个进程，不会产生新的，而信号量是产生一堆线程&#x2F;进程</strong></p><p><a href="https://link.zhihu.com/?target=http://url.cn/5DMsS9r">互斥锁与信号量推荐博客：http://url.cn/5DMsS9r</a></p><h3 id="十一-Event"><a href="#十一-Event" class="headerlink" title="十一 Event"></a>十一 Event</h3><p>同进程的一样</p><p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">event.isSet()：返回event的状态值；event.wait()：如果 event.isSet()&#x3D;&#x3D;False将阻塞线程；event.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；event.clear()：恢复event的状态值为False。</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-9da62d0885d8f90d6d2959bd720feddb_720w.jpg" alt="img"></p><p>例如，有多个工作线程尝试链接MySQL，我们想要在链接前确保MySQL服务正常才让那些工作线程去连接MySQL服务器，如果连接不成功，都会去尝试重新连接。那么我们就可以采用threading.Event机制来协调各个工作线程的连接操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Thread,Eventimport threadingimport time,randomdef conn_mysql():    count&#x3D;1    while not event.is_set():        if count &gt; 3:            raise TimeoutError(&#39;链接超时&#39;)        print(&#39;&lt;%s&gt;第%s次尝试链接&#39; % (threading.current_thread().getName(), count))        event.wait(0.5)        count+&#x3D;1    print(&#39;&lt;%s&gt;链接成功&#39; %threading.current_thread().getName())def check_mysql():    print(&#39;\033[45m[%s]正在检查mysql\033[0m&#39; % threading.current_thread().getName())    time.sleep(random.randint(2,4))    event.set()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    event&#x3D;Event()    conn1&#x3D;Thread(target&#x3D;conn_mysql)    conn2&#x3D;Thread(target&#x3D;conn_mysql)    check&#x3D;Thread(target&#x3D;check_mysql)    conn1.start()    conn2.start()    check.start()</code></pre></div></figure><h3 id="十二-条件Condition（了解）"><a href="#十二-条件Condition（了解）" class="headerlink" title="十二 条件Condition（了解）"></a>十二 条件Condition（了解）</h3><p>使得线程等待，只有满足某条件时，才释放n个线程</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import threadingdef run(n):    con.acquire()    con.wait()    print(&quot;run the thread: %s&quot; %n)    con.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    con &#x3D; threading.Condition()    for i in range(10):        t &#x3D; threading.Thread(target&#x3D;run, args&#x3D;(i,))        t.start()    while True:        inp &#x3D; input(&#39;&gt;&gt;&gt;&#39;)        if inp &#x3D;&#x3D; &#39;q&#39;:            break        con.acquire()        con.notify(int(inp))        con.release()def condition_func():    ret &#x3D; False    inp &#x3D; input(&#39;&gt;&gt;&gt;&#39;)    if inp &#x3D;&#x3D; &#39;1&#39;:        ret &#x3D; True    return retdef run(n):    con.acquire()    con.wait_for(condition_func)    print(&quot;run the thread: %s&quot; %n)    con.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    con &#x3D; threading.Condition()    for i in range(10):        t &#x3D; threading.Thread(target&#x3D;run, args&#x3D;(i,))        t.start()</code></pre></div></figure><h3 id="十三-定时器"><a href="#十三-定时器" class="headerlink" title="十三 定时器"></a>十三 定时器</h3><p><strong>定时器，指定n秒后执行某操作</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Timerdef hello():    print(&quot;hello, world&quot;)t &#x3D; Timer(1, hello)t.start()  # after 1 seconds, &quot;hello, world&quot; will be printed</code></pre></div></figure><p>验证码定时器</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from threading import Timerimport random,timeclass Code:    def __init__(self):        self.make_cache()    def make_cache(self,interval&#x3D;5):        self.cache&#x3D;self.make_code()        print(self.cache)        self.t&#x3D;Timer(interval,self.make_cache)        self.t.start()    def make_code(self,n&#x3D;4):        res&#x3D;&#39;&#39;        for i in range(n):            s1&#x3D;str(random.randint(0,9))            s2&#x3D;chr(random.randint(65,90))            res+&#x3D;random.choice([s1,s2])        return res    def check(self):        while True:            inp&#x3D;input(&#39;&gt;&gt;: &#39;).strip()            if inp.upper() &#x3D;&#x3D;  self.cache:                print(&#39;验证成功&#39;,end&#x3D;&#39;\n&#39;)                self.t.cancel()                breakif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    obj&#x3D;Code()    obj.check()</code></pre></div></figure><h3 id="十四-线程queue"><a href="#十四-线程queue" class="headerlink" title="十四 线程queue"></a>十四 线程queue</h3><p>queue队列 ：使用import queue，用法与进程Queue一样</p><p>queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p><ul><li>*<strong>class* <code>queue.``Queue</code>(*maxsize&#x3D;0*) #先进先出</strong></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import queueq&#x3D;queue.Queue()q.put(&#39;first&#39;)q.put(&#39;second&#39;)q.put(&#39;third&#39;)print(q.get())print(q.get())print(q.get())&#39;&#39;&#39;结果(先进先出):firstsecondthird&#39;&#39;&#39;</code></pre></div></figure><p>*<strong>class* <code>queue.``LifoQueue</code>(*maxsize&#x3D;0*) #last in fisrt out</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import queueq&#x3D;queue.LifoQueue()q.put(&#39;first&#39;)q.put(&#39;second&#39;)q.put(&#39;third&#39;)print(q.get())print(q.get())print(q.get())&#39;&#39;&#39;结果(后进先出):thirdsecondfirst&#39;&#39;&#39;</code></pre></div></figure><p>*<strong>class* <code>queue.``PriorityQueue</code>(*maxsize&#x3D;0*) #存储数据时可设置优先级的队列</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import queueq&#x3D;queue.PriorityQueue()#put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高q.put((20,&#39;a&#39;))q.put((10,&#39;b&#39;))q.put((30,&#39;c&#39;))print(q.get())print(q.get())print(q.get())&#39;&#39;&#39;结果(数字越小优先级越高,优先级高的优先出队):(10, &#39;b&#39;)(20, &#39;a&#39;)(30, &#39;c&#39;)&#39;&#39;&#39;</code></pre></div></figure><p><strong><code>其他</code></strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Constructor for a priority queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite.The lowest valued entries are retrieved first (the lowest valued entry is the one returned by sorted(list(entries))[0]). A typical pattern for entries is a tuple in the form: (priority_number, data).exception queue.EmptyException raised when non-blocking get() (or get_nowait()) is called on a Queue object which is empty.exception queue.FullException raised when non-blocking put() (or put_nowait()) is called on a Queue object which is full.Queue.qsize()Queue.empty() #return True if empty  Queue.full() # return True if full Queue.put(item, block&#x3D;True, timeout&#x3D;None)Put item into the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case).Queue.put_nowait(item)Equivalent to put(item, False).Queue.get(block&#x3D;True, timeout&#x3D;None)Remove and return an item from the queue. If optional args block is true and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Otherwise (block is false), return an item if one is immediately available, else raise the Empty exception (timeout is ignored in that case).Queue.get_nowait()Equivalent to get(False).Two methods are offered to support tracking whether enqueued tasks have been fully processed by daemon consumer threads.Queue.task_done()Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task is complete.If a join() is currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received for every item that had been put() into the queue).Raises a ValueError if called more times than there were items placed in the queue.Queue.join() block直到queue被消费完毕</code></pre></div></figure><h3 id="十五-Python标准模块–concurrent-futures"><a href="#十五-Python标准模块–concurrent-futures" class="headerlink" title="十五 Python标准模块–concurrent.futures"></a>十五 Python标准模块–concurrent.futures</h3><p><strong><a href="https://link.zhihu.com/?target=https://docs.python.org/dev/library/concurrent.futures.html">https://docs.python.org/dev/library/concurrent.futures.html</a></strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1 介绍concurrent.futures模块提供了高度封装的异步调用接口ThreadPoolExecutor：线程池，提供异步调用ProcessPoolExecutor: 进程池，提供异步调用Both implement the same interface, which is defined by the abstract Executor class.#2 基本方法#submit(fn, *args, **kwargs)异步提交任务#map(func, *iterables, timeout&#x3D;None, chunksize&#x3D;1) 取代for循环submit的操作#shutdown(wait&#x3D;True) 相当于进程池的pool.close()+pool.join()操作wait&#x3D;True，等待池内所有任务执行完毕回收完资源后才继续wait&#x3D;False，立即返回，并不会等待池内的任务执行完毕但不管wait参数为何值，整个程序都会等到所有任务执行完毕submit和map必须在shutdown之前#result(timeout&#x3D;None)取得结果#add_done_callback(fn)回调函数</code></pre></div></figure><p>ProcessPoolExecutor</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#介绍The ProcessPoolExecutor class is an Executor subclass that uses a pool of processes to execute calls asynchronously. ProcessPoolExecutor uses the multiprocessing module, which allows it to side-step the Global Interpreter Lock but also means that only picklable objects can be executed and returned.class concurrent.futures.ProcessPoolExecutor(max_workers&#x3D;None, mp_context&#x3D;None)An Executor subclass that executes calls asynchronously using a pool of at most max_workers processes. If max_workers is None or not given, it will default to the number of processors on the machine. If max_workers is lower or equal to 0, then a ValueError will be raised.#用法from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorimport os,time,randomdef task(n):    print(&#39;%s is runing&#39; %os.getpid())    time.sleep(random.randint(1,3))    return n**2if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    executor&#x3D;ProcessPoolExecutor(max_workers&#x3D;3)    futures&#x3D;[]    for i in range(11):        future&#x3D;executor.submit(task,i)        futures.append(future)    executor.shutdown(True)    print(&#39;+++&gt;&#39;)    for future in futures:        print(future.result())</code></pre></div></figure><p>ThreadPoolExecutor</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#介绍ThreadPoolExecutor is an Executor subclass that uses a pool of threads to execute calls asynchronously.class concurrent.futures.ThreadPoolExecutor(max_workers&#x3D;None, thread_name_prefix&#x3D;&#39;&#39;)An Executor subclass that uses a pool of at most max_workers threads to execute calls asynchronously.Changed in version 3.5: If max_workers is None or not given, it will default to the number of processors on the machine, multiplied by 5, assuming that ThreadPoolExecutor is often used to overlap I&#x2F;O instead of CPU work and the number of workers should be higher than the number of workers for ProcessPoolExecutor.New in version 3.6: The thread_name_prefix argument was added to allow users to control the threading.Thread names for worker threads created by the pool for easier debugging.#用法与ProcessPoolExecutor相同</code></pre></div></figure><p>map的用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorimport os,time,randomdef task(n):    print(&#39;%s is runing&#39; %os.getpid())    time.sleep(random.randint(1,3))    return n**2if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    executor&#x3D;ThreadPoolExecutor(max_workers&#x3D;3)    # for i in range(11):    #     future&#x3D;executor.submit(task,i)    executor.map(task,range(1,12)) #map取代了for+submit</code></pre></div></figure><p>回调函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorfrom multiprocessing import Poolimport requestsimport jsonimport osdef get_page(url):    print(&#39;&lt;进程%s&gt; get %s&#39; %(os.getpid(),url))    respone&#x3D;requests.get(url)    if respone.status_code &#x3D;&#x3D; 200:        return &#123;&#39;url&#39;:url,&#39;text&#39;:respone.text&#125;def parse_page(res):    res&#x3D;res.result()    print(&#39;&lt;进程%s&gt; parse %s&#39; %(os.getpid(),res[&#39;url&#39;]))    parse_res&#x3D;&#39;url:&lt;%s&gt; size:[%s]\n&#39; %(res[&#39;url&#39;],len(res[&#39;text&#39;]))    with open(&#39;db.txt&#39;,&#39;a&#39;) as f:        f.write(parse_res)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    urls&#x3D;[        &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,        &#39;https:&#x2F;&#x2F;www.python.org&#39;,        &#39;https:&#x2F;&#x2F;www.openstack.org&#39;,        &#39;https:&#x2F;&#x2F;help.github.com&#x2F;&#39;,        &#39;http:&#x2F;&#x2F;www.sina.com.cn&#x2F;&#39;    ]    # p&#x3D;Pool(3)    # for url in urls:    #     p.apply_async(get_page,args&#x3D;(url,),callback&#x3D;pasrse_page)    # p.close()    # p.join()    p&#x3D;ProcessPoolExecutor(3)    for url in urls:        p.submit(get_page,url).add_done_callback(parse_page) #parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果</code></pre></div></figure><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=142">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=142<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>35-并发编程（四）</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/35_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/35_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一-什么是线程"><a href="#一-什么是线程" class="headerlink" title="一 什么是线程"></a>一 什么是线程</h3><p>在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程</p><p>线程顾名思义，就是一条流水线工作的过程，一条流水线必须属于一个车间，一个车间的工作过程是一个进程</p><p>车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一个流水线</p><p>流水线的工作需要电源，电源就相当于cpu</p><p>所以，<strong>进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。</strong></p><p>多线程（即多个控制线程）的概念是，在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。</p><p>例如，北京地铁与上海地铁是不同的进程，而北京地铁里的13号线是一个线程，北京地铁所有的线路共享北京地铁所有的资源，比如所有的乘客可以被所有线路拉。</p><h3 id="二-线程的创建开销小"><a href="#二-线程的创建开销小" class="headerlink" title="二 线程的创建开销小"></a>二 线程的创建开销小</h3><p>创建进程的开销要远大于线程？</p><p>如果我们的软件是一个工厂，该工厂有多条流水线，流水线工作需要电源，电源只有一个即cpu（单核cpu）</p><p>一个车间就是一个进程，一个车间至少一条流水线（一个进程至少一个线程）</p><p>创建一个进程，就是创建一个车间（申请空间，在该空间内建至少一条流水线）</p><p>而建线程，就只是在一个车间内造一条流水线，无需申请空间，所以创建开销小</p><p>进程之间是竞争关系，线程之间是协作关系？</p><p>车间直接是竞争&#x2F;抢电源的关系，竞争（不同的进程直接是竞争关系，是不同的程序员写的程序运行的，迅雷抢占其他进程的网速，360把其他进程当做病毒干死） 一个车间的不同流水线式协同工作的关系（同一个进程的线程之间是合作关系，是同一个程序写的程序内开启动，迅雷内的线程是合作关系，不会自己干自己）</p><h3 id="三-线程与进程的区别"><a href="#三-线程与进程的区别" class="headerlink" title="三 线程与进程的区别"></a>三 线程与进程的区别</h3><ol><li>Threads share the address space of the process that created it; processes have their own address space.</li><li>Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.</li><li>Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes.</li><li>New threads are easily created; new processes require duplication of the parent process.</li><li>Threads can exercise considerable control over threads of the same process; processes can only exercise control over child processes.</li><li>Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process does not affect child processes.</li></ol><h3 id="四-为何要用多线程"><a href="#四-为何要用多线程" class="headerlink" title="四 为何要用多线程"></a>四 为何要用多线程</h3><p>多线程指的是，在一个进程中开启多个线程，简单的讲：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。详细的讲分为4点：</p><p>\1. 多线程共享一个进程的地址空间</p><p>\2. 线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-100倍，在有大量线程需要动态和快速修改时，这一特性很有用</p><p>\3. 若多个线程都是cpu密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I&#x2F;O处理，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。</p><p>\4. 在多cpu系统中，为了最大限度的利用多核，可以开启多个线程，比开进程开销要小的多。（这一条并不适用于python）</p><h3 id="五-多线程的应用举例"><a href="#五-多线程的应用举例" class="headerlink" title="五 多线程的应用举例"></a>五 多线程的应用举例</h3><p><img src="https://pic4.zhimg.com/80/v2-23bf6d2fefc642b0e5e0beb35a1e0fb3_720w.jpg" alt="img"></p><p>开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。</p><h3 id="六-经典的线程模型（了解）"><a href="#六-经典的线程模型（了解）" class="headerlink" title="六 经典的线程模型（了解）"></a>六 经典的线程模型（了解）</h3><p>多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程</p><p>而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。</p><p>多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。</p><p><img src="https://pic4.zhimg.com/80/v2-c4ada42e8dac0fd7a35dbca9a76221a7_720w.jpg" alt="img"></p><p>不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。</p><p>类似于进程，每个线程也有自己的堆栈</p><p><img src="https://pic1.zhimg.com/80/v2-c26f5bb3bb75125b6f9038b50152c924_720w.jpg" alt="img"></p><p>不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。</p><p>线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：</p><p>\1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程</p><p>如果是，那么附近中某个线程被阻塞，那么copy到子进程后，copy版的线程也要被阻塞吗，想一想nginx的多线程模式接收用户连接。</p><p>\2. 在同一个进程中，如果一个线程关闭了问题，而另外一个线程正准备往该文件内写内容呢？</p><p> 如果一个线程注意到没有内存了，并开始分配更多的内存，在工作一半时，发生线程切换，新的线程也发现内存不够用了，又开始分配更多的内存，这样内存就被分配了多次，这些问题都是多线程编程的典型问题，需要仔细思考和设计。</p><h3 id="七-POSIX线程（了解）"><a href="#七-POSIX线程（了解）" class="headerlink" title="七 POSIX线程（了解）"></a>七 POSIX线程（了解）</h3><p>为了实现可移植的线程程序,IEEE在IEEE标准1003.1c中定义了线程标准，它定义的线程包叫Pthread。大部分UNIX系统都支持该标准，简单介绍如下</p><p><img src="https://pic4.zhimg.com/80/v2-855ddca7baa57baf9a5242a8167369b3_720w.jpg" alt="img"></p><h3 id="八-在用户空间实现的线程（了解）"><a href="#八-在用户空间实现的线程（了解）" class="headerlink" title="八 在用户空间实现的线程（了解）"></a>八 在用户空间实现的线程（了解）</h3><p>线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。</p><p>用户级线程内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu,目前Linux pthread大体是这么做的。</p><p><img src="https://pic1.zhimg.com/80/v2-4d55e64ce7c111b39a037000248719c0_720w.jpg" alt="img"></p><p>在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。</p><h3 id="九-在内核空间实现的线程（了解）"><a href="#九-在内核空间实现的线程（了解）" class="headerlink" title="九 在内核空间实现的线程（了解）"></a>九 在内核空间实现的线程（了解）</h3><p>内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。</p><p><img src="https://pic4.zhimg.com/80/v2-d9b31239c632ccb1f4b3c39679ee5c07_720w.jpg" alt="img"></p><h3 id="十-用户级与内核级线程的对比（了解）"><a href="#十-用户级与内核级线程的对比（了解）" class="headerlink" title="十 用户级与内核级线程的对比（了解）"></a>十 用户级与内核级线程的对比（了解）</h3><p><strong>一： 以下是用户级线程和内核级线程的区别：</strong></p><ol><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</li><li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</li><li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li><li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</li></ol><p><strong>二： 内核线程的优缺点</strong></p><p><strong>优点：</strong></p><ol><li>当有多个处理机时，一个进程的多个线程可以同时执行。</li></ol><p><strong>缺点：</strong></p><ol><li>由内核进行调度。</li></ol><p><strong>三： 用户进程的*<em>优缺点*</em></strong></p><p><strong>优点：</strong></p><ol><li>线程的调度不需要内核直接参与，控制简单。</li><li>可以在不支持线程的操作系统中实现。</li><li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</li><li>允许每个进程定制自己的调度算法，线程管理比较灵活。</li><li>线程能够利用的表空间和堆栈空间比内核级线程多。</li><li>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。</li></ol><p><strong>缺点：</strong></p><ol><li>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</li></ol><h3 id="十一-混合实现（了解）"><a href="#十一-混合实现（了解）" class="headerlink" title="十一 混合实现（了解）"></a>十一 混合实现（了解）</h3><p>用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程</p><p><img src="https://pic1.zhimg.com/80/v2-0b049f0e481ee80e53331194d7f2c044_720w.jpg" alt="img"></p><h3 id="十二-线程小故事"><a href="#十二-线程小故事" class="headerlink" title="十二 线程小故事"></a>十二 线程小故事</h3><p><a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?amp;srcid=0330UDNmQ&mid=403498894&__biz=MjM5NzA1MTcyMA==&idx=2&scene=2&sn=219c1a6001b5bb7e6bdc7963b1af8450">我是一个线程mp.weixin.qq.com&#x2F;s?amp;srcid&#x3D;0330UDNmQ&amp;mid&#x3D;403498894&amp;__biz&#x3D;MjM5NzA1MTcyMA%3D%3D&amp;idx&#x3D;2&amp;scene&#x3D;2&amp;sn&#x3D;219c1a6001b5bb7e6bdc7963b1af8450<img src="https://pic2.zhimg.com/v2-76083704a8583ebe0c3bc264e45cec4d_180x120.jpg" alt="img"></a></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=141">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=141<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>34-并发编程（三）</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/34_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%89/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/34_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一-multiprocessing模块介绍"><a href="#一-multiprocessing模块介绍" class="headerlink" title="一 multiprocessing模块介绍"></a>一 multiprocessing模块介绍</h3><p>python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（os.cpu_count()查看），在python中大部分情况需要使用多进程。Python提供了multiprocessing。 multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。</p><p>multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。</p><p>需要再次强调的一点是：与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。</p><h3 id="二-Process类的介绍"><a href="#二-Process类的介绍" class="headerlink" title="二 Process类的介绍"></a>二 Process类的介绍</h3><p><strong>创建进程的类</strong>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）强调：1. 需要使用关键字的方式来指定参数2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</code></pre></div></figure><p><strong>参数介绍：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 group参数未使用，值始终为None2 3 target表示调用对象，即子进程要执行的任务4 5 args表示调用对象的位置参数元组，args&#x3D;(1,2,&#39;egon&#39;,)6 7 kwargs表示调用对象的字典,kwargs&#x3D;&#123;&#39;name&#39;:&#39;egon&#39;,&#39;age&#39;:18&#125;8 9 name为子进程的名称</code></pre></div></figure><p><strong>方法介绍：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 p.start()：启动进程，并调用该子进程中的p.run()  2 p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法   3  4 p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 5 p.is_alive():如果p仍然运行，返回True 6  7 p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</code></pre></div></figure><p><strong>属性介绍：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置2 3 p.name:进程的名称4 5 p.pid：进程的pid6 7 p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)8 9 p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</code></pre></div></figure><h3 id="三-Process类的使用"><a href="#三-Process类的使用" class="headerlink" title="三 Process类的使用"></a>三 Process类的使用</h3><p><strong>注意：在windows中Process()必须放到# if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:下</strong></p><p>详细解释</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Since Windows has no fork, the multiprocessing module starts a new Python process and imports the calling module. If Process() gets called upon import, then this sets off an infinite succession of new processes (or until your machine runs out of resources). This is the reason for hiding calls to Process() insideif __name__ &#x3D;&#x3D; &quot;__main__&quot;since statements inside this if-statement will not get called upon import.由于Windows没有fork，多处理模块启动一个新的Python进程并导入调用模块。 如果在导入时调用Process（），那么这将启动无限继承的新进程（或直到机器耗尽资源）。 这是隐藏对Process（）内部调用的原，使用if __name__ &#x3D;&#x3D; “__main __”，这个if语句中的语句将不会在导入时被调用。</code></pre></div></figure><p><strong>创建并开启子进程的两种方式</strong></p><p>方法一</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#开进程的方法一:import timeimport randomfrom multiprocessing import Processdef piao(name):    print(&#39;%s piaoing&#39; %name)    time.sleep(random.randrange(1,5))    print(&#39;%s piao end&#39; %name)p1&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;egon&#39;,)) #必须加,号p2&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;alex&#39;,))p3&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;wupeqi&#39;,))p4&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;yuanhao&#39;,))p1.start()p2.start()p3.start()p4.start()print(&#39;主线程&#39;)</code></pre></div></figure><p>方法二</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#开进程的方法二:import timeimport randomfrom multiprocessing import Processclass Piao(Process):    def __init__(self,name):        super().__init__()        self.name&#x3D;name    def run(self):        print(&#39;%s piaoing&#39; %self.name)        time.sleep(random.randrange(1,5))        print(&#39;%s piao end&#39; %self.name)p1&#x3D;Piao(&#39;egon&#39;)p2&#x3D;Piao(&#39;alex&#39;)p3&#x3D;Piao(&#39;wupeiqi&#39;)p4&#x3D;Piao(&#39;yuanhao&#39;)p1.start() #start会自动调用runp2.start()p3.start()p4.start()print(&#39;主线程&#39;)</code></pre></div></figure><p><strong>进程直接的内存空间是隔离的</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Processn&#x3D;100 #在windows系统中应该把全局变量定义在if __name__ &#x3D;&#x3D; &#39;__main__&#39;之上就可以了def work():    global n    n&#x3D;0    print(&#39;子进程内: &#39;,n)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    p&#x3D;Process(target&#x3D;work)    p.start()    print(&#39;主进程内: &#39;,n)</code></pre></div></figure><p>练习1：把上周所学的socket通信变成并发的形式</p><p>server端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from socket import *from multiprocessing import Processserver&#x3D;socket(AF_INET,SOCK_STREAM)server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)server.bind((&#39;127.0.0.1&#39;,8080))server.listen(5)def talk(conn,client_addr):    while True:        try:            msg&#x3D;conn.recv(1024)            if not msg:break            conn.send(msg.upper())        except Exception:            breakif __name__ &#x3D;&#x3D; &#39;__main__&#39;: #windows下start进程一定要写到这下面    while True:        conn,client_addr&#x3D;server.accept()        p&#x3D;Process(target&#x3D;talk,args&#x3D;(conn,client_addr))        p.start()</code></pre></div></figure><p>多个client端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from socket import *client&#x3D;socket(AF_INET,SOCK_STREAM)client.connect((&#39;127.0.0.1&#39;,8080))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if not msg:continue    client.send(msg.encode(&#39;utf-8&#39;))    msg&#x3D;client.recv(1024)    print(msg.decode(&#39;utf-8&#39;))</code></pre></div></figure><p>这么实现有没有问题？？？</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">每来一个客户端，都在服务端开启一个进程，如果并发来一个万个客户端，要开启一万个进程吗，你自己尝试着在你自己的机器上开启一万个，10万个进程试一试。解决方法：进程池</code></pre></div></figure><p><em><strong>*Process对象的join方法*</strong></em></p><p>join：主进程等，等待子进程结束</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Processimport timeimport randomclass Piao(Process):    def __init__(self,name):        self.name&#x3D;name        super().__init__()    def run(self):        print(&#39;%s is piaoing&#39; %self.name)        time.sleep(random.randrange(1,3))        print(&#39;%s is piao end&#39; %self.name)p&#x3D;Piao(&#39;egon&#39;)p.start()p.join(0.0001) #等待p停止,等0.0001秒就不再等了print(&#39;开始&#39;)</code></pre></div></figure><p>有了join，程序不就是串行了吗？？？</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Processimport timeimport randomdef piao(name):    print(&#39;%s is piaoing&#39; %name)    time.sleep(random.randint(1,3))    print(&#39;%s is piao end&#39; %name)p1&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;egon&#39;,))p2&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;alex&#39;,))p3&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;yuanhao&#39;,))p4&#x3D;Process(target&#x3D;piao,args&#x3D;(&#39;wupeiqi&#39;,))p1.start()p2.start()p3.start()p4.start()#有的同学会有疑问:既然join是等待进程结束,那么我像下面这样写,进程不就又变成串行的了吗?#当然不是了,必须明确：p.join()是让谁等？#很明显p.join()是让主线程等待p的结束，卡住的是主线程而绝非进程p，#详细解析如下：#进程只要start就会在开始运行了,所以p1-p4.start()时,系统中已经有四个并发的进程了#而我们p1.join()是在等p1结束,没错p1只要不结束主线程就会一直卡在原地,这也是问题的关键#join是让主线程等,而p1-p4仍然是并发执行的,p1.join的时候,其余p2,p3,p4仍然在运行,等#p1.join结束,可能p2,p3,p4早已经结束了,这样p2.join,p3.join.p4.join直接通过检测，无需等待# 所以4个join花费的总时间仍然是耗费时间最长的那个进程运行的时间p1.join()p2.join()p3.join()p4.join()print(&#39;主线程&#39;)#上述启动进程与join进程可以简写为# p_l&#x3D;[p1,p2,p3,p4]# # for p in p_l:#     p.start()# # for p in p_l:#     p.join()</code></pre></div></figure><p><strong>Process对象的其他方法或属性（了解）</strong></p><p>terminate与is_alive</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#进程对象的其他方法一:terminate,is_alivefrom multiprocessing import Processimport timeimport randomclass Piao(Process):    def __init__(self,name):        self.name&#x3D;name        super().__init__()    def run(self):        print(&#39;%s is piaoing&#39; %self.name)        time.sleep(random.randrange(1,5))        print(&#39;%s is piao end&#39; %self.name)p1&#x3D;Piao(&#39;egon1&#39;)p1.start()p1.terminate()#关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活print(p1.is_alive()) #结果为Trueprint(&#39;开始&#39;)print(p1.is_alive()) #结果为False</code></pre></div></figure><p>name与pid</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Processimport timeimport randomclass Piao(Process):    def __init__(self,name):        # self.name&#x3D;name        # super().__init__() #Process的__init__方法会执行self.name&#x3D;Piao-1,        #                    #所以加到这里,会覆盖我们的self.name&#x3D;name        #为我们开启的进程设置名字的做法        super().__init__()        self.name&#x3D;name    def run(self):        print(&#39;%s is piaoing&#39; %self.name)        time.sleep(random.randrange(1,3))        print(&#39;%s is piao end&#39; %self.name)p&#x3D;Piao(&#39;egon&#39;)p.start()print(&#39;开始&#39;)print(p.pid) #查看pid</code></pre></div></figure><p><strong><img src="https://pic4.zhimg.com/80/v2-1891198a21b860d672d8ac2fae66da97_720w.jpg" alt="img"></strong></p><p><strong>僵尸进程与孤儿进程（了解）</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">参考博客：http:&#x2F;&#x2F;www.cnblogs.com&#x2F;Anker&#x2F;p&#x2F;3271773.html一：僵尸进程（有害）　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。详解如下我们知道在unix&#x2F;linux中，正常情况下子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束，如果子进程一结束就立刻回收其全部资源，那么在父进程内将无法获取子进程的状态信息。因此，UNⅨ提供了一种机制可以保证父进程可以在任意时刻获取子进程结束时的状态信息：1、在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）2、直到父进程通过wait &#x2F; waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait &#x2F; waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。　　任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。二：孤儿进程（无害）　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。　　孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。我们来测试一下（创建完子进程后，主进程所在的这个脚本就退出了，当父进程先于子进程结束时，子进程会被init收养，成为孤儿进程，而非僵尸进程），文件内容import osimport sysimport timepid &#x3D; os.getpid()ppid &#x3D; os.getppid()print &#39;im father&#39;, &#39;pid&#39;, pid, &#39;ppid&#39;, ppidpid &#x3D; os.fork()#执行pid&#x3D;os.fork()则会生成一个子进程#返回值pid有两种值：#    如果返回的pid值为0，表示在子进程当中#    如果返回的pid值&gt;0，表示在父进程当中if pid &gt; 0:    print &#39;father died..&#39;    sys.exit(0)# 保证主线程退出完毕time.sleep(1)print &#39;im child&#39;, os.getpid(), os.getppid()执行文件，输出结果：im father pid 32515 ppid 32015father died..im child 32516 1看，子进程已经被pid为1的init进程接收了，所以僵尸进程在这种情况下是不存在的，存在只有孤儿进程而已，孤儿进程声明周期结束自然会被init来销毁。三：僵尸进程危害场景：　　例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。四：测试#1、产生僵尸进程的程序test.py内容如下#coding:utf-8from multiprocessing import Processimport time,osdef run():    print(&#39;子&#39;,os.getpid())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    p&#x3D;Process(target&#x3D;run)    p.start()    print(&#39;主&#39;,os.getpid())    time.sleep(1000)#2、在unix或linux系统上执行[root@vm172-31-0-19 ~]# python3  test.py &amp;[1] 18652[root@vm172-31-0-19 ~]# 主 18652子 18653[root@vm172-31-0-19 ~]# ps aux |grep ZUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot     18653  0.0  0.0      0     0 pts&#x2F;0    Z    20:02   0:00 [python3] &lt;defunct&gt; #出现僵尸进程root     18656  0.0  0.0 112648   952 pts&#x2F;0    S+   20:02   0:00 grep --color&#x3D;auto Z[root@vm172-31-0-19 ~]# top #执行top命令发现1zombietop - 20:03:42 up 31 min,  3 users,  load average: 0.01, 0.06, 0.12Tasks:  93 total,   2 running,  90 sleeping,   0 stopped,   1 zombie%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  1016884 total,    97184 free,    70848 used,   848852 buff&#x2F;cacheKiB Swap:        0 total,        0 free,        0 used.   782540 avail Mem   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                                                        root      20   0   29788   1256    988 S  0.3  0.1   0:01.50 elfin                                                                                                                      #3、等待父进程正常结束后会调用wait／waitpid去回收僵尸进程但如果父进程是一个死循环，永远不会结束，那么该僵尸进程就会一直存在，僵尸进程过多，就是有害的解决方法一：杀死父进程解决方法二：对开启的子进程应该记得使用join，join会回收僵尸进程参考python2源码注释class Process(object):    def join(self, timeout&#x3D;None):        &#39;&#39;&#39;        Wait until child process terminates        &#39;&#39;&#39;        assert self._parent_pid &#x3D;&#x3D; os.getpid(), &#39;can only join a child process&#39;        assert self._popen is not None, &#39;can only join a started process&#39;        res &#x3D; self._popen.wait(timeout)        if res is not None:            _current_process._children.discard(self)join方法中调用了wait，告诉系统释放僵尸进程。discard为从自己的children中剔除解决方法三：http:&#x2F;&#x2F;blog.csdn.net&#x2F;u010571844&#x2F;article&#x2F;details&#x2F;50419798</code></pre></div></figure><p><strong>思考：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Processimport time,osdef task():    print(&#39;%s is running&#39; %os.getpid())    time.sleep(3)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    p&#x3D;Process(target&#x3D;task)    p.start()    p.join() # 等待进程p结束后，join函数内部会发送系统调用wait，去告诉操作系统回收掉进程p的id号    print(p.pid) #？？？此时能否看到子进程p的id号    print(&#39;主&#39;)</code></pre></div></figure><p>答案</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#答案：可以#分析：p.join()是像操作系统发送请求，告知操作系统p的id号不需要再占用了，回收就可以，此时在父进程内还可以看到p.pid,但此时的p.pid是一个无意义的id号，因为操作系统已经将该编号回收打个比方：我党相当于操作系统，控制着整个中国的硬件，每个人相当于一个进程，每个人都需要跟我党申请一个身份证号该号码就相当于进程的pid，人死后应该到我党那里注销身份证号，p.join()就相当于要求我党回收身份证号，但p的家人（相当于主进程）仍然持有p的身份证，但此刻的身份证已经没有意义</code></pre></div></figure><h3 id="四-守护进程"><a href="#四-守护进程" class="headerlink" title="四 守护进程"></a>四 守护进程</h3><p>主进程创建守护进程</p><p>其一：守护进程会在主进程代码执行结束后就终止</p><p>其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p><p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Processimport timeimport randomclass Piao(Process):    def __init__(self,name):        self.name&#x3D;name        super().__init__()    def run(self):        print(&#39;%s is piaoing&#39; %self.name)        time.sleep(random.randrange(1,3))        print(&#39;%s is piao end&#39; %self.name)p&#x3D;Piao(&#39;egon&#39;)p.daemon&#x3D;True #一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行p.start()print(&#39;主&#39;)</code></pre></div></figure><p>迷惑人的例子</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#主进程代码运行完毕,守护进程就会结束from multiprocessing import Processfrom threading import Threadimport timedef foo():    print(123)    time.sleep(1)    print(&quot;end123&quot;)def bar():    print(456)    time.sleep(3)    print(&quot;end456&quot;)p1&#x3D;Process(target&#x3D;foo)p2&#x3D;Process(target&#x3D;bar)p1.daemon&#x3D;Truep1.start()p2.start()print(&quot;main-------&quot;) #打印该行则主进程代码结束,则守护进程p1应该被终止,可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止</code></pre></div></figure><h3 id="五-进程同步-锁"><a href="#五-进程同步-锁" class="headerlink" title="五 进程同步(锁)"></a>五 进程同步(锁)</h3><p>进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,</p><p>而共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理</p><p>part1：多个进程共享同一打印终端</p><p>并发运行,效率高,但竞争同一打印终端,带来了打印错乱</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#并发运行,效率高,但竞争同一打印终端,带来了打印错乱from multiprocessing import Processimport os,timedef work():    print(&#39;%s is running&#39; %os.getpid())    time.sleep(2)    print(&#39;%s is done&#39; %os.getpid())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    for i in range(3):        p&#x3D;Process(target&#x3D;work)        p.start()</code></pre></div></figure><p>加锁：由并发变成了串行,牺牲了运行效率,但避免了竞争</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#由并发变成了串行,牺牲了运行效率,但避免了竞争from multiprocessing import Process,Lockimport os,timedef work(lock):    lock.acquire()    print(&#39;%s is running&#39; %os.getpid())    time.sleep(2)    print(&#39;%s is done&#39; %os.getpid())    lock.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    lock&#x3D;Lock()    for i in range(3):        p&#x3D;Process(target&#x3D;work,args&#x3D;(lock,))        p.start()</code></pre></div></figure><p>part2：多个进程共享同一文件</p><p>文件当数据库，模拟抢票</p><p>并发运行，效率高，但竞争写同一文件，数据写入错乱</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#文件db的内容为：&#123;&quot;count&quot;:1&#125;#注意一定要用双引号，不然json无法识别from multiprocessing import Process,Lockimport time,json,randomdef search():    dic&#x3D;json.load(open(&#39;db.txt&#39;))    print(&#39;\033[43m剩余票数%s\033[0m&#39; %dic[&#39;count&#39;])def get():    dic&#x3D;json.load(open(&#39;db.txt&#39;))    time.sleep(0.1) #模拟读数据的网络延迟    if dic[&#39;count&#39;] &gt;0:        dic[&#39;count&#39;]-&#x3D;1        time.sleep(0.2) #模拟写数据的网络延迟        json.dump(dic,open(&#39;db.txt&#39;,&#39;w&#39;))        print(&#39;\033[43m购票成功\033[0m&#39;)def task(lock):    search()    get()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    lock&#x3D;Lock()    for i in range(100): #模拟并发100个客户端抢票        p&#x3D;Process(target&#x3D;task,args&#x3D;(lock,))        p.start()</code></pre></div></figure><p>加锁：购票行为由并发变成了串行，牺牲了运行效率，但保证了数据安全</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#文件db的内容为：&#123;&quot;count&quot;:1&#125;#注意一定要用双引号，不然json无法识别from multiprocessing import Process,Lockimport time,json,randomdef search():    dic&#x3D;json.load(open(&#39;db.txt&#39;))    print(&#39;\033[43m剩余票数%s\033[0m&#39; %dic[&#39;count&#39;])def get():    dic&#x3D;json.load(open(&#39;db.txt&#39;))    time.sleep(0.1) #模拟读数据的网络延迟    if dic[&#39;count&#39;] &gt;0:        dic[&#39;count&#39;]-&#x3D;1        time.sleep(0.2) #模拟写数据的网络延迟        json.dump(dic,open(&#39;db.txt&#39;,&#39;w&#39;))        print(&#39;\033[43m购票成功\033[0m&#39;)def task(lock):    search()    lock.acquire()    get()    lock.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    lock&#x3D;Lock()    for i in range(100): #模拟并发100个客户端抢票        p&#x3D;Process(target&#x3D;task,args&#x3D;(lock,))        p.start()</code></pre></div></figure><p>总结：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。1 队列和管道都是将数据存放于内存中2 队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</code></pre></div></figure><h3 id="六-队列（推荐使用）"><a href="#六-队列（推荐使用）" class="headerlink" title="六 队列（推荐使用）"></a>六 队列（推荐使用）</h3><p>进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的</p><p><strong>创建队列的类（底层就是以管道和锁定的方式实现）</strong>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">1 Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</code></pre></div></figure><p><strong>参数介绍：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">1 maxsize是队列中允许最大项数，省略则无大小限制。</code></pre></div></figure><p><strong>方法介绍：</strong></p><p>主要方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 q.put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。2 q.get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常.3  4 q.get_nowait():同q.get(False)5 q.put_nowait():同q.put(False)6 7 q.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。8 q.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。9 q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样</code></pre></div></figure><p>其他方法(了解)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 q.cancel_join_thread():不会在进程退出时自动连接后台线程。可以防止join_thread()方法阻塞2 q.close():关闭队列，防止队列中加入更多数据。调用此方法，后台线程将继续写入那些已经入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将调用此方法。关闭队列不会在队列使用者中产生任何类型的数据结束信号或异常。例如，如果某个使用者正在被阻塞在get()操作上，关闭生产者中的队列不会导致get()方法返回错误。3 q.join_thread()：连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread方法可以禁止这种行为</code></pre></div></figure><p><strong>应用：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;multiprocessing模块支持进程间通信的两种主要形式:管道和队列都是基于消息传递实现的,但是队列接口&#39;&#39;&#39;from multiprocessing import Process,Queueimport timeq&#x3D;Queue(3)#put ,get ,put_nowait,get_nowait,full,emptyq.put(3)q.put(3)q.put(3)print(q.full()) #满了print(q.get())print(q.get())print(q.get())print(q.empty()) #空了</code></pre></div></figure><p><strong>生产者消费者模型</strong></p><p><em>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</em></p><p><strong>为什么要使用生产者和消费者模式</strong></p><p><em>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</em></p><p><strong>什么是生产者消费者模式</strong></p><p><em>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</em></p><p><em>基于队列实现生产者消费者模型</em></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res&#x3D;q.get()        time.sleep(random.randint(1,3))        print(&#39;\033[45m%s 吃 %s\033[0m&#39; %(os.getpid(),res))def producer(q):    for i in range(10):        time.sleep(random.randint(1,3))        res&#x3D;&#39;包子%s&#39; %i        q.put(res)        print(&#39;\033[44m%s 生产了 %s\033[0m&#39; %(os.getpid(),res))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    q&#x3D;Queue()    #生产者们:即厨师们    p1&#x3D;Process(target&#x3D;producer,args&#x3D;(q,))    #消费者们:即吃货们    c1&#x3D;Process(target&#x3D;consumer,args&#x3D;(q,))    #开始    p1.start()    c1.start()    print(&#39;主&#39;)</code></pre></div></figure><p>生产者消费者模型总结</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#生产者消费者模型总结    #程序中有两类角色        一类负责生产数据（生产者）        一类负责处理数据（消费者）    #引入生产者消费者模型为了解决的问题是：        平衡生产者与消费者之间的工作能力，从而提高程序整体处理数据的速度    #如何实现：        生产者&lt;--&gt;队列&lt;——&gt;消费者    #生产者消费者模型实现类程序的解耦和</code></pre></div></figure><p>此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p><p>解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环</p><p>生产者在生产完毕后发送结束信号None</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res&#x3D;q.get()        if res is None:break #收到结束信号则结束        time.sleep(random.randint(1,3))        print(&#39;\033[45m%s 吃 %s\033[0m&#39; %(os.getpid(),res))def producer(q):    for i in range(10):        time.sleep(random.randint(1,3))        res&#x3D;&#39;包子%s&#39; %i        q.put(res)        print(&#39;\033[44m%s 生产了 %s\033[0m&#39; %(os.getpid(),res))    q.put(None) #发送结束信号if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    q&#x3D;Queue()    #生产者们:即厨师们    p1&#x3D;Process(target&#x3D;producer,args&#x3D;(q,))    #消费者们:即吃货们    c1&#x3D;Process(target&#x3D;consumer,args&#x3D;(q,))    #开始    p1.start()    c1.start()    print(&#39;主&#39;)</code></pre></div></figure><p>注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号</p><p>主进程在生产者生产完毕后发送结束信号None</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res&#x3D;q.get()        if res is None:break #收到结束信号则结束        time.sleep(random.randint(1,3))        print(&#39;\033[45m%s 吃 %s\033[0m&#39; %(os.getpid(),res))def producer(q):    for i in range(2):        time.sleep(random.randint(1,3))        res&#x3D;&#39;包子%s&#39; %i        q.put(res)        print(&#39;\033[44m%s 生产了 %s\033[0m&#39; %(os.getpid(),res))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    q&#x3D;Queue()    #生产者们:即厨师们    p1&#x3D;Process(target&#x3D;producer,args&#x3D;(q,))    #消费者们:即吃货们    c1&#x3D;Process(target&#x3D;consumer,args&#x3D;(q,))    #开始    p1.start()    c1.start()    p1.join()    q.put(None) #发送结束信号    print(&#39;主&#39;)</code></pre></div></figure><p>但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决</p><p>有几个消费者就需要发送几次结束信号：相当low</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Process,Queueimport time,random,osdef consumer(q):    while True:        res&#x3D;q.get()        if res is None:break #收到结束信号则结束        time.sleep(random.randint(1,3))        print(&#39;\033[45m%s 吃 %s\033[0m&#39; %(os.getpid(),res))def producer(name,q):    for i in range(2):        time.sleep(random.randint(1,3))        res&#x3D;&#39;%s%s&#39; %(name,i)        q.put(res)        print(&#39;\033[44m%s 生产了 %s\033[0m&#39; %(os.getpid(),res))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    q&#x3D;Queue()    #生产者们:即厨师们    p1&#x3D;Process(target&#x3D;producer,args&#x3D;(&#39;包子&#39;,q))    p2&#x3D;Process(target&#x3D;producer,args&#x3D;(&#39;骨头&#39;,q))    p3&#x3D;Process(target&#x3D;producer,args&#x3D;(&#39;泔水&#39;,q))    #消费者们:即吃货们    c1&#x3D;Process(target&#x3D;consumer,args&#x3D;(q,))    c2&#x3D;Process(target&#x3D;consumer,args&#x3D;(q,))    #开始    p1.start()    p2.start()    p3.start()    c1.start()    p1.join() #必须保证生产者全部生产完毕,才应该发送结束信号    p2.join()    p3.join()    q.put(None) #有几个消费者就应该发送几次结束信号None    q.put(None) #发送结束信号    print(&#39;主&#39;)</code></pre></div></figure><p>其实我们的思路无非是发送结束信号而已，有另外一种队列提供了这种机制</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#JoinableQueue([maxsize])：这就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。   #参数介绍：    maxsize是队列中允许最大项数，省略则无大小限制。    　 #方法介绍：    JoinableQueue的实例p除了与Queue对象相同的方法之外还具有：    q.task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常    q.join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止from multiprocessing import Process,JoinableQueueimport time,random,osdef consumer(q):    while True:        res&#x3D;q.get()        time.sleep(random.randint(1,3))        print(&#39;\033[45m%s 吃 %s\033[0m&#39; %(os.getpid(),res))        q.task_done() #向q.join()发送一次信号,证明一个数据已经被取走了def producer(name,q):    for i in range(10):        time.sleep(random.randint(1,3))        res&#x3D;&#39;%s%s&#39; %(name,i)        q.put(res)        print(&#39;\033[44m%s 生产了 %s\033[0m&#39; %(os.getpid(),res))    q.join()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    q&#x3D;JoinableQueue()    #生产者们:即厨师们    p1&#x3D;Process(target&#x3D;producer,args&#x3D;(&#39;包子&#39;,q))    p2&#x3D;Process(target&#x3D;producer,args&#x3D;(&#39;骨头&#39;,q))    p3&#x3D;Process(target&#x3D;producer,args&#x3D;(&#39;泔水&#39;,q))    #消费者们:即吃货们    c1&#x3D;Process(target&#x3D;consumer,args&#x3D;(q,))    c2&#x3D;Process(target&#x3D;consumer,args&#x3D;(q,))    c1.daemon&#x3D;True    c2.daemon&#x3D;True    #开始    p_l&#x3D;[p1,p2,p3,c1,c2]    for p in p_l:        p.start()    p1.join()    p2.join()    p3.join()    print(&#39;主&#39;)     #主进程等---&gt;p1,p2,p3等----&gt;c1,c2    #p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据    #因而c1,c2也没有存在的价值了,应该随着主进程的结束而结束,所以设置成守护进程</code></pre></div></figure><h3 id="七-管道"><a href="#七-管道" class="headerlink" title="七 管道"></a>七 管道</h3><p>进程间通信（IPC）方式二：管道（不推荐使用，了解即可）</p><p>介绍</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#创建管道的类：Pipe([duplex]):在进程之间创建一条管道，并返回元组（conn1,conn2）,其中conn1，conn2表示管道两端的连接对象，强调一点：必须在产生Process对象之前产生管道#参数介绍：dumplex:默认管道是全双工的，如果将duplex射成False，conn1只能用于接收，conn2只能用于发送。#主要方法：    conn1.recv():接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError。    conn1.send(obj):通过连接发送对象。obj是与序列化兼容的任意对象 #其他方法：conn1.close():关闭连接。如果conn1被垃圾回收，将自动调用此方法conn1.fileno():返回连接使用的整数文件描述符conn1.poll([timeout]):如果连接上的数据可用，返回True。timeout指定等待的最长时限。如果省略此参数，方法将立即返回结果。如果将timeout射成None，操作将无限期地等待数据到达。conn1.recv_bytes([maxlength]):接收c.send_bytes()方法发送的一条完整的字节消息。maxlength指定要接收的最大字节数。如果进入的消息，超过了这个最大值，将引发IOError异常，并且在连接上无法进行进一步读取。如果连接的另外一端已经关闭，再也不存在任何数据，将引发EOFError异常。conn.send_bytes(buffer [, offset [, size]])：通过连接发送字节数据缓冲区，buffer是支持缓冲区接口的任意对象，offset是缓冲区中的字节偏移量，而size是要发送字节数。结果数据以单条消息的形式发出，然后调用c.recv_bytes()函数进行接收    conn1.recv_bytes_into(buffer [, offset]):接收一条完整的字节消息，并把它保存在buffer对象中，该对象支持可写入的缓冲区接口（即bytearray对象或类似的对象）。offset指定缓冲区中放置消息处的字节位移。返回值是收到的字节数。如果消息长度大于可用的缓冲区空间，将引发BufferTooShort异常。</code></pre></div></figure><p>基于管道实现进程间通信（与队列的方式是类似的，队列就是管道加锁实现的）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Process,Pipeimport time,osdef consumer(p,name):    left,right&#x3D;p    left.close()    while True:        try:            baozi&#x3D;right.recv()            print(&#39;%s 收到包子:%s&#39; %(name,baozi))        except EOFError:            right.close()            breakdef producer(seq,p):    left,right&#x3D;p    right.close()    for i in seq:        left.send(i)        # time.sleep(1)    else:        left.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    left,right&#x3D;Pipe()    c1&#x3D;Process(target&#x3D;consumer,args&#x3D;((left,right),&#39;c1&#39;))    c1.start()    seq&#x3D;(i for i in range(10))    producer(seq,(left,right))    right.close()    left.close()    c1.join()    print(&#39;主进程&#39;)</code></pre></div></figure><p>*<em>注意：生产者和消费者都没有使用管道的某个端点，就应该将其关闭，如在生产者中关闭管道的右端，在消费者中关闭管道的左端。如果忘记执行这些步骤，程序可能再消费者中的recv*</em>()*<em>操作上挂起。管道是由操作系统进行引用计数的,必须在所有进程中关闭管道后才能生产EOFError异常。因此在生产者中关闭管道不会有任何效果，付费消费者中也关闭了相同的管道端点。</em>*</p><p>管道可以用于双向通信，利用通常在客户端&#x2F;服务器中使用的请求／响应模型或远程过程调用，就可以使用管道编写与进程交互的程序</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Process,Pipeimport time,osdef adder(p,name):    server,client&#x3D;p    client.close()    while True:        try:            x,y&#x3D;server.recv()        except EOFError:            server.close()            break        res&#x3D;x+y        server.send(res)    print(&#39;server done&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    server,client&#x3D;Pipe()    c1&#x3D;Process(target&#x3D;adder,args&#x3D;((server,client),&#39;c1&#39;))    c1.start()    server.close()    client.send((10,20))    print(client.recv())    client.close()    c1.join()    print(&#39;主进程&#39;)#注意：send()和recv()方法使用pickle模块对对象进行序列化。</code></pre></div></figure><h3 id="八-共享数据"><a href="#八-共享数据" class="headerlink" title="八 共享数据"></a>八 共享数据</h3><p>展望未来，基于消息传递的并发编程是大势所趋</p><p>即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合</p><p>通过消息队列交换数据。这样极大地减少了对使用锁定和其他同步手段的需求，</p><p>还可以扩展到分布式系统中</p><p><strong>进程间通信应该尽量避免使用本节所讲的共享数据的方式</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此A manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies.A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array. For example,</code></pre></div></figure><p>进程之间操作共享的数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Manager,Process,Lockimport osdef work(d,lock):    # with lock: #不加锁而操作共享的数据,肯定会出现数据错乱        d[&#39;count&#39;]-&#x3D;1if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    lock&#x3D;Lock()    with Manager() as m:        dic&#x3D;m.dict(&#123;&#39;count&#39;:100&#125;)        p_l&#x3D;[]        for i in range(100):            p&#x3D;Process(target&#x3D;work,args&#x3D;(dic,lock))            p_l.append(p)            p.start()        for p in p_l:            p.join()        print(dic)        #&#123;&#39;count&#39;: 94&#125;</code></pre></div></figure><h3 id="九-信号量-了解）"><a href="#九-信号量-了解）" class="headerlink" title="九 信号量(了解）"></a>九 信号量(了解）</h3><p>信号量Semahpore（同线程一样）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去，如果指定信号量为3，那么来一个人获得一把锁，计数加1，当计数等于3时，后面的人均需要等待。一旦释放，就有人可以获得一把锁    信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念from multiprocessing import Process,Semaphoreimport time,randomdef go_wc(sem,user):    sem.acquire()    print(&#39;%s 占到一个茅坑&#39; %user)    time.sleep(random.randint(0,3)) #模拟每个人拉屎速度不一样，0代表有的人蹲下就起来了    sem.release()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    sem&#x3D;Semaphore(5)    p_l&#x3D;[]    for i in range(13):        p&#x3D;Process(target&#x3D;go_wc,args&#x3D;(sem,&#39;user%s&#39; %i,))        p.start()        p_l.append(p)    for i in p_l:        i.join()    print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》&#39;)</code></pre></div></figure><h3 id="十-事件-了解"><a href="#十-事件-了解" class="headerlink" title="十 事件(了解)"></a>十 事件(了解)</h3><p>Event（同线程一样）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。    事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。clear：将“Flag”设置为Falseset：将“Flag”设置为True#_*_coding:utf-8_*_#!&#x2F;usr&#x2F;bin&#x2F;env pythonfrom multiprocessing import Process,Eventimport time,randomdef car(e,n):    while True:        if not e.is_set(): #Flase            print(&#39;\033[31m红灯亮\033[0m，car%s等着&#39; %n)            e.wait()            print(&#39;\033[32m车%s 看见绿灯亮了\033[0m&#39; %n)            time.sleep(random.randint(3,6))            if not e.is_set():                continue            print(&#39;走你,car&#39;, n)            breakdef police_car(e,n):    while True:        if not e.is_set():            print(&#39;\033[31m红灯亮\033[0m，car%s等着&#39; % n)            e.wait(1)            print(&#39;灯的是%s，警车走了,car %s&#39; %(e.is_set(),n))            breakdef traffic_lights(e,inverval):    while True:        time.sleep(inverval)        if e.is_set():            e.clear() #e.is_set() ----&gt;False        else:            e.set()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    e&#x3D;Event()    # for i in range(10):    #     p&#x3D;Process(target&#x3D;car,args&#x3D;(e,i,))    #     p.start()    for i in range(5):        p &#x3D; Process(target&#x3D;police_car, args&#x3D;(e, i,))        p.start()    t&#x3D;Process(target&#x3D;traffic_lights,args&#x3D;(e,10))    t.start()    print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》&#39;)</code></pre></div></figure><h3 id="十一-进程池"><a href="#十一-进程池" class="headerlink" title="十一 进程池"></a>十一 进程池</h3><p>在利用Python进行系统管理的时候，特别是同时操作多个文件目录，或者远程控制多台主机，并行操作可以节约大量的时间。多进程是实现并发的手段之一，需要注意的问题是：</p><ol><li>很明显需要并发执行的任务通常要远大于核数</li><li>一个操作系统不可能无限开启进程，通常有几个核就开几个进程</li><li>进程开启过多，效率反而会下降（开启进程是需要占用系统资源的，而且开启多余核数目的进程也无法做到并行）</li></ol><p>例如当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个。。。手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。</p><p>我们就可以通过维护一个进程池来控制进程数目，比如httpd的进程模式，规定最小进程数和最大进程数… <em>ps：对于远程过程调用的高级应用程序而言，应该使用进程池，Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，就重用进程池中的进程。</em></p><p><strong>创建进程池的类：如果指定numprocess为3，则进程池会从无到有创建三个进程，然后自始至终使用这三个进程去执行所有任务，不会开启其他进程</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 Pool([numprocess  [,initializer [, initargs]]]):创建进程池</code></pre></div></figure><p><strong>参数介绍：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值2 initializer：是每个工作进程启动时要执行的可调用对象，默认为None3 initargs：是要传给initializer的参数组</code></pre></div></figure><p><strong>方法介绍：</strong></p><p>主要方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()2 p.apply_async(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。3    4 p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成5 P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</code></pre></div></figure><p>其他方法（了解部分）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。obj.ready():如果调用完成，返回Trueobj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常obj.wait([timeout]):等待结果变为可用。obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</code></pre></div></figure><p><strong>应用：</strong></p><p>同步调用apply</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Poolimport os,timedef work(n):    print(&#39;%s run&#39; %os.getpid())    time.sleep(3)    return n**2if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    p&#x3D;Pool(3) #进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务    res_l&#x3D;[]    for i in range(10):        res&#x3D;p.apply(work,args&#x3D;(i,)) #同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞，但不管该任务是否存在阻塞，同步调用都会在原地等着，只是等的过程中若是任务发生了阻塞就会被夺走cpu的执行权限        res_l.append(res)    print(res_l)</code></pre></div></figure><p>异步调用apply_async</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Poolimport os,timedef work(n):    print(&#39;%s run&#39; %os.getpid())    time.sleep(3)    return n**2if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    p&#x3D;Pool(3) #进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务    res_l&#x3D;[]    for i in range(10):        res&#x3D;p.apply_async(work,args&#x3D;(i,)) #同步运行,阻塞、直到本次任务执行完毕拿到res        res_l.append(res)    #异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果，否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了    p.close()    p.join()    for res in res_l:        print(res.get()) #使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get</code></pre></div></figure><p>详解：apply_async与apply</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#一：使用进程池（异步调用,apply_async）#coding: utf-8from multiprocessing import Process,Poolimport timedef func(msg):    print( &quot;msg:&quot;, msg)    time.sleep(1)    return msgif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    pool &#x3D; Pool(processes &#x3D; 3)    res_l&#x3D;[]    for i in range(10):        msg &#x3D; &quot;hello %d&quot; %(i)        res&#x3D;pool.apply_async(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去        res_l.append(res)    print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;) #没有后面的join，或get，则程序整体结束，进程池中的任务还没来得及全部执行完也都跟着主进程一起结束了    pool.close() #关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成    pool.join()   #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束    print(res_l) #看到的是&lt;multiprocessing.pool.ApplyResult object at 0x10357c4e0&gt;对象组成的列表,而非最终的结果,但这一步是在join后执行的,证明结果已经计算完毕,剩下的事情就是调用每个对象下的get方法去获取结果    for i in res_l:        print(i.get()) #使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get#二：使用进程池（同步调用,apply）#coding: utf-8from multiprocessing import Process,Poolimport timedef func(msg):    print( &quot;msg:&quot;, msg)    time.sleep(0.1)    return msgif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    pool &#x3D; Pool(processes &#x3D; 3)    res_l&#x3D;[]    for i in range(10):        msg &#x3D; &quot;hello %d&quot; %(i)        res&#x3D;pool.apply(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去        res_l.append(res) #同步执行，即执行完一个拿到结果，再去执行另外一个    print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;)    pool.close()    pool.join()   #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束    print(res_l) #看到的就是最终的结果组成的列表    for i in res_l: #apply是同步的，所以直接得到结果，没有get()方法        print(i)</code></pre></div></figure><p><strong>练习2：使用进程池维护固定数目的进程（重写练习1）</strong></p><p>server端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#Pool内的进程数默认是cpu核数，假设为4（查看方法os.cpu_count()）#开启6个客户端，会发现2个客户端处于等待状态#在每个进程内查看pid，会发现pid使用为4个，即多个客户端公用4个进程from socket import *from multiprocessing import Poolimport osserver&#x3D;socket(AF_INET,SOCK_STREAM)server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)server.bind((&#39;127.0.0.1&#39;,8080))server.listen(5)def talk(conn,client_addr):    print(&#39;进程pid: %s&#39; %os.getpid())    while True:        try:            msg&#x3D;conn.recv(1024)            if not msg:break            conn.send(msg.upper())        except Exception:            breakif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    p&#x3D;Pool()    while True:        conn,client_addr&#x3D;server.accept()        p.apply_async(talk,args&#x3D;(conn,client_addr))        # p.apply(talk,args&#x3D;(conn,client_addr)) #同步的话，则同一时间只有一个客户端能访问</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from socket import *client&#x3D;socket(AF_INET,SOCK_STREAM)client.connect((&#39;127.0.0.1&#39;,8080))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if not msg:continue    client.send(msg.encode(&#39;utf-8&#39;))    msg&#x3D;client.recv(1024)    print(msg.decode(&#39;utf-8&#39;))</code></pre></div></figure><p>发现：并发开启多个客户端，服务端同一时间只有3个不同的pid，干掉一个客户端，另外一个客户端才会进来，被3个进程之一处理</p><p><strong>回掉函数：</strong></p><p><strong>需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数</strong></p><p><strong>我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I&#x2F;O的过程，直接拿到的是任务的结果。</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Poolimport requestsimport jsonimport osdef get_page(url):    print(&#39;&lt;进程%s&gt; get %s&#39; %(os.getpid(),url))    respone&#x3D;requests.get(url)    if respone.status_code &#x3D;&#x3D; 200:        return &#123;&#39;url&#39;:url,&#39;text&#39;:respone.text&#125;def pasrse_page(res):    print(&#39;&lt;进程%s&gt; parse %s&#39; %(os.getpid(),res[&#39;url&#39;]))    parse_res&#x3D;&#39;url:&lt;%s&gt; size:[%s]\n&#39; %(res[&#39;url&#39;],len(res[&#39;text&#39;]))    with open(&#39;db.txt&#39;,&#39;a&#39;) as f:        f.write(parse_res)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    urls&#x3D;[        &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,        &#39;https:&#x2F;&#x2F;www.python.org&#39;,        &#39;https:&#x2F;&#x2F;www.openstack.org&#39;,        &#39;https:&#x2F;&#x2F;help.github.com&#x2F;&#39;,        &#39;http:&#x2F;&#x2F;www.sina.com.cn&#x2F;&#39;    ]    p&#x3D;Pool(3)    res_l&#x3D;[]    for url in urls:        res&#x3D;p.apply_async(get_page,args&#x3D;(url,),callback&#x3D;pasrse_page)        res_l.append(res)    p.close()    p.join()    print([res.get() for res in res_l]) #拿到的是get_page的结果,其实完全没必要拿该结果,该结果已经传给回调函数处理了&#39;&#39;&#39;打印结果:&lt;进程3388&gt; get https:&#x2F;&#x2F;www.baidu.com&lt;进程3389&gt; get https:&#x2F;&#x2F;www.python.org&lt;进程3390&gt; get https:&#x2F;&#x2F;www.openstack.org&lt;进程3388&gt; get https:&#x2F;&#x2F;help.github.com&#x2F;&lt;进程3387&gt; parse https:&#x2F;&#x2F;www.baidu.com&lt;进程3389&gt; get http:&#x2F;&#x2F;www.sina.com.cn&#x2F;&lt;进程3387&gt; parse https:&#x2F;&#x2F;www.python.org&lt;进程3387&gt; parse https:&#x2F;&#x2F;help.github.com&#x2F;&lt;进程3387&gt; parse http:&#x2F;&#x2F;www.sina.com.cn&#x2F;&lt;进程3387&gt; parse https:&#x2F;&#x2F;www.openstack.org[&#123;&#39;url&#39;: &#39;https:&#x2F;&#x2F;www.baidu.com&#39;, &#39;text&#39;: &#39;&lt;!DOCTYPE html&gt;\r\n...&#39;,...&#125;]&#39;&#39;&#39;</code></pre></div></figure><p>爬虫案例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Poolimport time,randomimport requestsimport redef get_page(url,pattern):    response&#x3D;requests.get(url)    if response.status_code &#x3D;&#x3D; 200:        return (response.text,pattern)def parse_page(info):    page_content,pattern&#x3D;info    res&#x3D;re.findall(pattern,page_content)    for item in res:        dic&#x3D;&#123;            &#39;index&#39;:item[0],            &#39;title&#39;:item[1],            &#39;actor&#39;:item[2].strip()[3:],            &#39;time&#39;:item[3][5:],            &#39;score&#39;:item[4]+item[5]        &#125;        print(dic)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    pattern1&#x3D;re.compile(r&#39;&lt;dd&gt;.*?board-index.*?&gt;(\d+)&lt;.*?title&#x3D;&quot;(.*?)&quot;.*?star.*?&gt;(.*?)&lt;.*?releasetime.*?&gt;(.*?)&lt;.*?integer.*?&gt;(.*?)&lt;.*?fraction.*?&gt;(.*?)&lt;&#39;,re.S)    url_dic&#x3D;&#123;        &#39;http:&#x2F;&#x2F;maoyan.com&#x2F;board&#x2F;7&#39;:pattern1,    &#125;    p&#x3D;Pool()    res_l&#x3D;[]    for url,pattern in url_dic.items():        res&#x3D;p.apply_async(get_page,args&#x3D;(url,pattern),callback&#x3D;parse_page)        res_l.append(res)    for i in res_l:        i.get()    # res&#x3D;requests.get(&#39;http:&#x2F;&#x2F;maoyan.com&#x2F;board&#x2F;7&#39;)    # print(re.findall(pattern,res.text))</code></pre></div></figure><p><strong>如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Poolimport time,random,osdef work(n):    time.sleep(1)    return n**2if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    p&#x3D;Pool()    res_l&#x3D;[]    for i in range(10):        res&#x3D;p.apply_async(work,args&#x3D;(i,))        res_l.append(res)    p.close()    p.join() #等待进程池中所有进程执行完毕    nums&#x3D;[]    for res in res_l:        nums.append(res.get()) #拿到所有结果    print(nums) #主进程拿到所有的处理结果,可以在主进程中进行统一进行处理</code></pre></div></figure><p><a href="https://link.zhihu.com/?target=https://docs.python.org/dev/library/concurrent.futures.html">进程池的其他实现方式：https://docs.python.org/dev/library/concurrent.futures.htmldocs.python.org/dev/library/concurrent.futures.html</a></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=131">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=131<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>33-并发编程（二）</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/33_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/33_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一-什么是进程"><a href="#一-什么是进程" class="headerlink" title="一 什么是进程"></a>一 什么是进程</h3><p>进程：正在进行的一个过程或者说一个任务。而负责执行任务则是cpu。</p><p>举例（单核+多道，实现多个进程的并发执行）：</p><p>egon在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务，　　</p><p>但egon同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？</p><p>egon备一会课，再去跟李杰的女朋友聊聊天，再去打一会王者荣耀….这就保证了每个任务都在进行中.</p><h3 id="二-进程与程序的区别"><a href="#二-进程与程序的区别" class="headerlink" title="二 进程与程序的区别"></a>二 进程与程序的区别</h3><p>程序仅仅只是一堆代码而已，而进程指的是程序的运行过程。</p><p>举例：</p><p>想象一位有一手好厨艺的计算机科学家egon正在为他的女儿元昊烘制生日蛋糕。</p><p>他有做生日蛋糕的食谱，</p><p>厨房里有所需的原料:面粉、鸡蛋、韭菜，蒜泥等。</p><p>在这个比喻中：</p><p><strong>做蛋糕的食谱就是程序</strong>(即用适当形式描述的算法)</p><p><strong>计算机科学家就是处理器(cpu)</strong></p><p><strong>而做蛋糕的各种原料就是输入数据</strong>。</p><p><strong>进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和</strong>。</p><p>现在假设计算机科学家egon的儿子alex哭着跑了进来，说：<a href="https://link.zhihu.com/?target=http://fanyi.baidu.com/translate?aldtype=16047&query=%E5%98%BF%EF%BC%8C%E7%88%B8%E7%88%B8%EF%BC%8C%E6%88%91%E7%9A%84%E5%A4%B4%E8%A2%AB%E8%9C%9C%E8%9C%82%E8%9B%B0%E4%BA%86&keyfrom=baidu&smartresult=dict&lang=auto2zh%23zh/en/%E5%98%BF%EF%BC%8C%E7%88%B8%E7%88%B8%EF%BC%8C%E6%88%91%E7%9A%84%E5%A4%B4%E8%A2%AB%E8%9C%9C%E8%9C%82%E8%9B%B0%E4%BA%86">XXXXXXXXXXXXXX</a>。</p><p>科学家egon想了想，处理儿子alex蛰伤的任务比给女儿元昊做蛋糕的任务更重要，于是</p><p>计算机科学家就记录下他照着食谱做到哪儿了(保存进程的当前状态)，然后拿出一本急救手册，按照其中的指示处理蛰伤。这里，我们看到处理机从一个进程(做蛋糕)切换到另一个高优先级的进程(实施医疗救治)，每个进程拥有各自的程序(食谱和急救手册)。当蜜蜂蛰伤处理完之后，这位计算机科学家又回来做蛋糕，从他 离开时的那一步继续做下去。</p><p><strong>需要强调的是：同一个程序执行两次，那也是两个进程，比如打开暴风影音，虽然都是同一个软件，但是一个可以播放苍井空，一个可以播放饭岛爱。</strong></p><h3 id="三-并发与并行"><a href="#三-并发与并行" class="headerlink" title="三 并发与并行"></a>三 并发与并行</h3><p>无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务</p><p>一 并发：是伪并行，即看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发）</p><p>单cpu，多进程，并发举例一</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">你是一个cpu，你同时谈了三个女朋友，每一个都可以是一个恋爱任务，你被这三个任务共享要玩出并发恋爱的效果，应该是你先跟女友1去看电影，看了一会说：不好，我要拉肚子，然后跑去跟第二个女友吃饭，吃了一会说：那啥，我去趟洗手间，然后跑去跟女友3开了个房</code></pre></div></figure><p>单cpu，多进程，并发举例二</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">某天下午，egon，yuanhao，wupeiqi，alex约好了一起去嫖娼，但娼只有一个，cpu只有一个，但是却要‘同时’干四个任务(嫖出并发的效果)，那就必须是干一会egon，再干一会yuanhao，再干一会wupeiqi，再干一会alexegon：花了200块钱，因为人美活好yuanhao：500块钱wupeiqi：100块钱，可能是不太行alex：没要钱，为啥？？？因为大家刚刚嫖的是他女朋友</code></pre></div></figure><p>二 并行：同时运行，只有具备多个cpu才能实现并行</p><p> 单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（<strong>多道技术是针对单核而言的</strong>）</p><p> 有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4，</p><p> 一旦任务1遇到I&#x2F;O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术</p><p> 而一旦任务1的I&#x2F;O结束了，操作系统会重新调用它(<strong>需知进程的调度、分配给哪个cpu运行，由操作系统说了算</strong>)，可能被分配给四个cpu中的任意一个去执行</p><p><img src="https://pic2.zhimg.com/80/v2-7137159d323204d49821595cb18e4729_720w.jpg" alt="img"></p><p>所有现代计算机经常会在同一时间做很多件事，一个用户的PC（无论是单cpu还是多cpu），都可以同时运行多个任务（一个任务可以理解为一个进程）。</p><p>启动一个进程来杀毒（360软件）</p><p>启动一个进程来看电影（暴风影音）</p><p>启动一个进程来聊天（腾讯QQ）</p><p>所有的这些进程都需被管理，于是一个支持多进程的多道程序系统是至关重要的</p><p>多道技术概念回顾：内存中同时存入多道（多个）程序，cpu从一个进程快速切换到另外一个，使每个进程各自运行几十或几百毫秒，这样，虽然在某一个瞬间，一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并发，以此来区分多处理器操作系统的真正硬件并行（多个cpu共享同一个物理内存）</p><h3 id="四-同步-异步and阻塞-非阻塞（重点）"><a href="#四-同步-异步and阻塞-非阻塞（重点）" class="headerlink" title="四 同步\异步and阻塞\非阻塞（重点）"></a>四 同步\异步and阻塞\非阻塞（重点）</h3><p><strong>同步：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不会返回。按照这个定义，其实绝大多数函数都是同步调用。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。#举例：#1. multiprocessing.Pool下的apply #发起同步调用后，就在原地等着任务结束，根本不考虑任务是在计算还是在io阻塞，总之就是一股脑地等任务结束#2. concurrent.futures.ProcessPoolExecutor().submit(func,).result()#3. concurrent.futures.ThreadPoolExecutor().submit(func,).result()</code></pre></div></figure><p><strong>异步：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#异步的概念和同步相对。当一个异步功能调用发出后，调用者不能立刻得到结果。当该异步功能完成后，通过状态、通知或回调来通知调用者。如果异步功能用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一 种很严重的错误）。如果是使用通知的方式，效率则很高，因为异步功能几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。#举例：#1. multiprocessing.Pool().apply_async() #发起异步调用后，并不会等待任务结束才返回，相反，会立即获取一个临时结果（并不是最终的结果，可能是封装好的一个对象）。#2. concurrent.futures.ProcessPoolExecutor(3).submit(func,)#3. concurrent.futures.ThreadPoolExecutor(3).submit(func,)</code></pre></div></figure><p><strong>阻塞：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到io操作）。函数只有在得到结果之后才会将阻塞的线程激活。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。#举例：#1. 同步调用：apply一个累计1亿次的任务，该调用会一直等待，直到任务返回结果为止，但并未阻塞住（即便是被抢走cpu的执行权限，那也是处于就绪态）;#2. 阻塞调用：当socket工作在阻塞模式的时候，如果没有数据的情况下调用recv函数，则当前线程就会被挂起，直到有数据为止。</code></pre></div></figure><p><strong>非阻塞：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程。</code></pre></div></figure><p><strong>小结：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 同步与异步针对的是函数&#x2F;任务的调用方式：同步就是当一个进程发起一个函数（任务）调用的时候，一直等到函数（任务）完成，而进程继续处于激活状态。而异步情况下是当一个进程发起一个函数（任务）调用的时候，不会等函数返回，而是继续往下执行当，函数返回的时候通过状态、通知、事件等方式通知进程任务完成。#2. 阻塞与非阻塞针对的是进程或线程：阻塞是当请求不能满足的时候就将进程挂起，而非阻塞则不会阻塞当前进程</code></pre></div></figure><h3 id="五-进程的创建（了解）"><a href="#五-进程的创建（了解）" class="headerlink" title="五 进程的创建（了解）"></a>五 进程的创建（了解）</h3><p>但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p><p>而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程</p><p>\1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</p><p>\2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</p><p>\3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</p><p>\4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）</p><p>无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的：</p><p>\1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）</p><p>\2. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。　</p><p>关于创建的子进程，UNIX和windows</p><p>1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（<strong>多道技术要求物理层面实现进程之间内存的隔离</strong>），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。</p><p>2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。</p><h3 id="六-进程的终止（了解）"><a href="#六-进程的终止（了解）" class="headerlink" title="六 进程的终止（了解）"></a>六 进程的终止（了解）</h3><p>\1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）</p><p>\2. 出错退出（自愿，python a.py中a.py不存在）</p><p>\3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1&#x2F;0等，可以捕捉异常，try…except…）</p><p>\4. 被其他进程杀死（非自愿，如kill -9）</p><h3 id="七-进程的层次结构"><a href="#七-进程的层次结构" class="headerlink" title="七 进程的层次结构"></a>七 进程的层次结构</h3><p>无论UNIX还是windows，进程只有一个父进程，不同的是：</p><p>\1. 在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。</p><p>\2. 在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（<strong>称为句柄</strong>）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。</p><h3 id="八-进程的状态"><a href="#八-进程的状态" class="headerlink" title="八 进程的状态"></a>八 进程的状态</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">tail -f access.log |grep &#39;404&#39;</code></pre></div></figure><p>执行程序tail，开启一个子进程，执行程序grep，开启另外一个子进程，两个进程之间基于管道’|’通讯，将tail的结果作为grep的输入。</p><p>进程grep在等待输入（即I&#x2F;O）时的状态称为阻塞，此时grep命令都无法运行</p><p>其实在两种情况下会导致一个进程在逻辑上不能运行，</p><p>\1. 进程挂起是自身原因，遇到I&#x2F;O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作</p><p>\2. 与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。</p><p>因而一个进程由三种状态</p><p><img src="https://pic1.zhimg.com/80/v2-1b816bea5d7900ca5faad9abdee1cec4_720w.jpg" alt="img"></p><h3 id="九-进程并发的实现（了解）"><a href="#九-进程并发的实现（了解）" class="headerlink" title="九 进程并发的实现（了解）"></a>九 进程并发的实现（了解）</h3><p>进程并发的实现在于，硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来，为此，操作系统维护一张表格，即进程表（process table），每个进程占用一个进程表项（这些表项也称为进程控制块）</p><p><img src="https://pic1.zhimg.com/80/v2-c7e653f1793ccc5d2aeed7d128459698_720w.jpg" alt="img"></p><p>该表存放了进程状态的重要信息：程序计数器、堆栈指针、内存分配状况、所有打开文件的状态、帐号和调度信息，以及其他在进程由运行态转为就绪态或阻塞态时，必须保存的信息，从而保证该进程在再次启动时，就像从未被中断过一样。<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linhaifeng/articles/7430066.html">python并发编程之多进程理论部分</a></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=130">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=130<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>32-并发编程（一）</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/32_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/32_python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一-引子"><a href="#一-引子" class="headerlink" title="一 引子"></a>一 引子</h2><p>顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。</p><p>进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。</p><p>所以想要真正了解进程，必须事先了解操作系统</p><h2 id="二-为什么要有操作系统"><a href="#二-为什么要有操作系统" class="headerlink" title="二 为什么要有操作系统"></a>二 为什么要有操作系统</h2><p>现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。</p><p>一般而言，现代计算机系统是一个复杂的系统。</p><p>其一：如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年….）</p><p>其二：并且管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。</p><p><strong>总结：</strong></p><p><strong>程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。</strong></p><h2 id="三-什么是操作系统"><a href="#三-什么是操作系统" class="headerlink" title="三 什么是操作系统"></a>三 什么是操作系统</h2><p><strong>精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如图1</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#操作系统位于计算机硬件与应用软件之间，本质也是一个软件。操作系统由操作系统的内核（运行于内核态，管理硬件资源）以及系统调用（运行于用户态，为应用程序员写的应用程序提供系统调用接口）两部分组成，所以，单纯的说操作系统是运行于内核态的，是不准确的。</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-6ad1085ae57855ce665ca5b8692b6e67_720w.jpg" alt="img"></p><p> 图1</p><p><strong>细说的话，操作系统应该分成两部分功能：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#一：隐藏了丑陋的硬件调用接口，为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制（比如控制磁盘转动，移动磁头读写数据等细节），#二：将应用程序对硬件资源的竞态请求变得有序化例如：很多应用软件其实是共享一套计算机硬件，比方说有可能有三个应用程序同时需要申请打印机来输出内容，那么a程序竞争到了打印机资源就打印，然后可能是b竞争到打印机资源，也可能是c，这就导致了无序，打印机可能打印一段a的内容然后又去打印c...,操作系统的一个功能就是将这种无序变得有序。</code></pre></div></figure><p>详解</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">现代计算机或者网络都是多用户的，多个用户不仅共享硬件，而且共享文件，数据库等信息，共享意味着冲突和无序。操作系统主要使用来1.记录哪个程序使用什么资源2.对资源请求进行分配3.为不同的程序和用户调解互相冲突的资源请求。我们可将上述操作系统的功能总结为：处理来自多个程序发起的多个（多个即多路）共享（共享即复用）资源的请求，简称多路复用多路复用有两种实现方式1.时间上的复用当一个资源在时间上复用时，不同的程序或用户轮流使用它，第一个程序获取该资源使用结束后，在轮到第二个。。。第三个。。。例如：只有一个cpu，多个程序需要在该cpu上运行，操作系统先把cpu分给第一个程序，在这个程序运行的足够长的时间（时间长短由操作系统的算法说了算）或者遇到了I&#x2F;O阻塞，操作系统则把cpu分配给下一个程序，以此类推，直到第一个程序重新被分配到了cpu然后再次运行，由于cpu的切换速度很快，给用户的感觉就是这些程序是同时运行的，或者说是并发的，或者说是伪并行的。至于资源如何实现时间复用，或者说谁应该是下一个要运行的程序，以及一个任务需要运行多长时间，这些都是操作系统的工作。2.空间上的复用每个客户都获取了一个大的资源中的一小部分资源，从而减少了排队等待资源的时间。例如：多个运行的程序同时进入内存，硬件层面提供保护机制来确保各自的内存是分割开的，且由操作系统控制，这比一个程序独占内存一个一个排队进入内存效率要高的多。有关空间复用的其他资源还有磁盘，在许多系统中，一个磁盘同时为许多用户保存文件。分配磁盘空间并且记录谁正在使用哪个磁盘块是操作系统资源管理的典型任务。这两种方式合起来便是多道技术</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-fb67806e24ae5472d9f9cfbb19a01855_720w.jpg" alt="img"></p><p> 图 2</p><h2 id="四-操作系统与普通软件的区别"><a href="#四-操作系统与普通软件的区别" class="headerlink" title="四 操作系统与普通软件的区别"></a>四 操作系统与普通软件的区别</h2><p>1.主要区别是：你不想用暴风影音了你可以选择用迅雷播放器或者干脆自己写一个，但是你无法写一个属于操作系统一部分的程序（时钟中断处理程序），操作系统由硬件保护，不能被用户修改。</p><p>2.操作系统与用户程序的差异并不在于二者所处的地位。特别地，操作系统是一个大型、复杂、长寿的软件，</p><ul><li>大型：linux或windows的源代码有五百万行数量级。按照每页50行共1000行的书来算，五百万行要有100卷，要用一整个书架子来摆置，这还仅仅是内核部分。用户程序，如GUI，库以及基本应用软件（如windows Explorer等），很容易就能达到这个数量的10倍或者20倍之多。</li><li>长寿：操作系统很难编写，如此大的代码量，一旦完成，操作系统所有者便不会轻易扔掉，再写一个。而是在原有的基础上进行改进。（基本上可以把windows95&#x2F;98&#x2F;Me看出一个操作系统，而windows NT&#x2F;2000&#x2F;XP&#x2F;Vista则是两位一个操作系统，对于用户来说它们十分相似。还有UNIX以及它的变体和克隆版本也演化了多年，如System V版，Solaris以及FreeBSD等都是Unix的原始版，不过尽管linux非常依照UNIX模式而仿制，并且与UNIX高度兼容，但是linux具有全新的代码基础）</li></ul><h2 id="五-操作系统发展史"><a href="#五-操作系统发展史" class="headerlink" title="五 操作系统发展史"></a>五 操作系统发展史</h2><p><strong>第一代计算机（1940~1955）：真空管和穿孔卡片</strong></p><p>第一代计算机的产生背景：</p><p>第一代之前人类是想用机械取代人力，第一代计算机的产生是计算机由机械时代进入电子时代的标志，从Babbage失败之后一直到第二次世界大战，数字计算机的建造几乎没有什么进展，第二次世界大战刺激了有关计算机研究的爆炸性进展。</p><p>lowa州立大学的john Atanasoff教授和他的学生Clifford Berry建造了据认为是第一台可工作的数字计算机。该机器使用300个真空管。大约在同时，Konrad Zuse在柏林用继电器构建了Z3计算机，英格兰布莱切利园的一个小组在1944年构建了Colossus，Howard Aiken在哈佛大学建造了Mark 1，宾夕法尼亚大学的William Mauchley和他的学生J.Presper Eckert建造了ENIAC。这些机器有的是二进制的，有的使用真空管，有的是可编程的，但都非常原始，设置需要花费数秒钟时间才能完成最简单的运算。</p><p>在这个时期，同一个小组里的工程师们，设计、建造、编程、操作及维护同一台机器，所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过成千上万根电缆接到插件板上连成电路来控制机器的基本功能。没有程序设计语言（汇编也没有），操作系统则是从来都没听说过。使用机器的过程更加原始，详见下‘工作过程’</p><p>特点： 没有操作系统的概念 所有的程序设计都是直接操控硬件</p><p>工作过程： 程序员在墙上的机时表预约一段时间，然后程序员拿着他的插件版到机房里，将自己的插件板街道计算机里，这几个小时内他独享整个计算机资源，后面的一批人都得等着(两万多个真空管经常会有被烧坏的情况出现)。</p><p>后来出现了穿孔卡片，可以将程序写在卡片上，然后读入机而不用插件板</p><p>优点：</p><p>程序员在申请的时间段内独享整个资源，可以即时地调试自己的程序（有bug可以立刻处理）</p><p>缺点：</p><p>浪费计算机资源，一个时间段内只有一个人用。 注意：同一时刻只有一个程序在内存中，被cpu调用执行，比方说10个程序的执行，是串行的</p><p>**第二代计算机*<em>（1955~1965）*<em>：晶体管和批处理系统</em></em></p><p>第二代计算机的产生背景：</p><p>由于当时的计算机非常昂贵，自认很自然的想办法较少机时的浪费。通常采用的方法就是批处理系统。</p><p>特点： 设计人员、生产人员、操作人员、程序人员和维护人员直接有了明确的分工，计算机被锁在专用空调房间中，由专业操作人员运行，这便是‘大型机’。</p><p>有了操作系统的概念</p><p>有了程序设计语言：FORTRAN语言或汇编语言，写到纸上，然后穿孔打成卡片，再讲卡片盒带到输入室，交给操作员，然后喝着咖啡等待输出接口</p><p>工作过程：插图</p><p><img src="https://pic3.zhimg.com/80/v2-342367e551bb23a7f1bceedd8a3cdf36_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-7e573545a6efac95f8d52717d2c74ffc_720w.jpg" alt="img"></p><p>第二代如何解决第一代的问题&#x2F;缺点： 1.把一堆人的输入攒成一大波输入， 2.然后顺序计算（这是有问题的，但是第二代计算也没有解决） 3.把一堆人的输出攒成一大波输出</p><p>现代操作系统的前身:(见图）</p><p>优点：批处理，节省了机时</p><p>缺点： <em>1.整个流程需要人参与控制，将磁带搬来搬去（中间俩小人）</em></p><p>2.计算的过程仍然是顺序计算-》串行</p><p>3.程序员原来独享一段时间的计算机，现在必须被统一规划到一批作业中，等待结果和重新调试的过程都需要等同批次的其他程序都运作完才可以（这极大的影响了程序的开发效率，无法及时调试程序）</p><p>**第三代计算机*<em>（1965~1980）*<em>：集成电路芯片和多道程序设计</em></em></p><p>第三代计算机的产生背景：</p><p>20世纪60年代初期，大多数计算机厂商都有两条完全不兼容的生产线。</p><p>一条是面向字的：大型的科学计算机，如IBM 7094，见上图，主要用于科学计算和工程计算</p><p>另外一条是面向字符的：商用计算机，如IBM 1401，见上图，主要用于银行和保险公司从事磁带归档和打印服务</p><p>开发和维护完全不同的产品是昂贵的，同时不同的用户对计算机的用途不同。</p><p>IBM公司试图通过引入system&#x2F;360系列来同时满足科学计算和商业计算，360系列低档机与1401相当，高档机比7094功能强很多，不同的性能卖不同的价格</p><p>360是第一个采用了（小规模）芯片（集成电路）的主流机型，与采用晶体管的第二代计算机相比，性价比有了很大的提高。这些计算机的后代仍在大型的计算机中心里使用，<strong>此乃现在服务器的前身</strong>，这些服务器每秒处理不小于千次的请求。</p><p>如何解决第二代计算机的问题1： 卡片被拿到机房后能够很快的将作业从卡片读入磁盘，于是任何时刻当一个作业结束时，操作系统就能将一个作业从磁带读出，装进空出来的内存区域运行，这种技术叫做 同时的外部设备联机操作：SPOOLING，该技术同时用于输出。当采用了这种技术后，就不在需要IBM1401机了，也不必将磁带搬来搬去了（中间俩小人不再需要）</p><p>如何解决第二代计算机的问题2：</p><p>第三代计算机的操作系统广泛应用了第二代计算机的操作系统没有的关键技术：多道技术</p><p>*<strong>cpu在执行一个任务的过程中，若需要操作硬盘，则发送操作硬盘的指令，指令一旦发出，硬盘上的机械手臂滑动读取数据到内存中，这一段时间，cpu需要等待，时间可能很短，但对于cpu来说已经很长很长，长到可以让cpu做很多其他的任务，如果我们让cpu在这段时间内切换到去做其他的任务，这样cpu不就充分利用了吗。这正是多道技术产生的技术背景*</strong></p><p><strong>多道技术：</strong></p><p>多道技术中的多道指的是多个程序，多道技术的实现是为了解决多个程序竞争或者说共享同一个资源（比如cpu）的有序调度问题，解决方式即多路复用，多路复用分为时间上的复用和空间上的复用。</p><p><strong>空间上的复用</strong>：将内存分为几部分，每个部分放入一个程序，这样，同一时间内存中就有了多道程序。</p><p><img src="https://pic4.zhimg.com/80/v2-668294576c0e934be21f7aebeb1ed45f_720w.jpg" alt="img"></p><p><strong>时间上的复用</strong>：当一个程序在等待I&#x2F;O时，另一个程序可以使用cpu，如果内存中可以同时存放足够多的作业，则cpu的利用率可以接近100%，类似于我们小学数学所学的<strong>统筹方法</strong>。（操作系统采用了多道技术后，可以控制进程的切换，或者说进程之间去争抢cpu的执行权限。这种切换不仅会在一个进程遇到io时进行，一个进程占用cpu时间过长也会切换，或者说被操作系统夺走cpu的执行权限）</p><p><img src="https://pic3.zhimg.com/80/v2-1c53668bcee393edac0d7b3b3daff1ae_720w.jpg" alt="img"></p><p>详解</p><p>空间上的复用最大的问题是：程序之间的内存必须分割，这种分割需要在硬件层面实现，由操作系统控制。如果内存彼此不分割，则一个程序可以访问另外一个程序的内存，</p><p>首先丧失的是安全性，比如你的qq程序可以访问操作系统的内存，这意味着你的qq可以拿到操作系统的所有权限。</p><p>其次丧失的是稳定性，某个程序崩溃时有可能把别的程序的内存也给回收了，比方说把操作系统的内存给回收了，则操作系统崩溃。</p><p>第三代计算机的操作系统仍然是批处理</p><p>许多程序员怀念第一代独享的计算机，可以即时调试自己的程序。为了满足程序员们很快可以得到响应，出现了分时操作系统</p><p>如何解决第二代计算机的问题3：</p><p>分时操作系统： 多个联机终端+多道技术</p><p>20个客户端同时加载到内存，有17在思考，3个在运行，cpu就采用多道的方式处理内存中的这3个程序，由于客户提交的一般都是简短的指令而且很少有耗时长的，索引计算机能够为许多用户提供快速的交互式服务，所有的用户都以为自己独享了计算机资源</p><p>CTTS：麻省理工（MIT）在一台改装过的7094机上开发成功的，CTSS兼容分时系统，<strong>第三代计算机广泛采用了必须的保护硬件（程序之间的内存彼此隔离）之后，分时系统才开始流行</strong></p><p>MIT，贝尔实验室和通用电气在CTTS成功研制后决定开发能够同时支持上百终端的MULTICS（其设计者着眼于建造满足波士顿地区所有用户计算需求的一台机器），很明显真是要上天啊，最后摔死了。</p><p>后来一位参加过MULTICS研制的贝尔实验室计算机科学家Ken Thompson开发了一个简易的，单用户版本的MULTICS，<strong>这就是后来的UNIX系统</strong>。基于它衍生了很多其他的Unix版本，为了使程序能在任何版本的unix上运行，IEEE提出了一个unix标准，即<strong>posix（可移植的操作系统接口Portable Operating System Interface）</strong></p><p>后来，在1987年，出现了一个UNIX的小型克隆，即minix，用于教学使用。芬兰学生Linus Torvalds基于它编写了Linux</p><p><strong>第四代计算机*<em>（1980~至今）：个人计算机*</em></strong></p><p>PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p><strong>必备的理论基础：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#一 操作系统的作用：    1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口    2：管理、调度进程，并且将多个进程对硬件的竞争变得有序#二 多道技术：    1.产生背景：针对单核，实现并发    ps：    现在的主机一般是多核，那么每个核都会利用多道技术    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个    cpu中的任意一个，具体由操作系统调度算法决定。    2.空间上的复用：如内存中同时有多道程序    3.时间上的复用：复用一个cpu的时间片       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样            才能保证下次切换回来时，能基于上次切走的位置继续运行</code></pre></div></figure><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=129">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=129<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>31-网络编程</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/31_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/31_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-客户端-服务器架构"><a href="#一-客户端-服务器架构" class="headerlink" title="一 客户端&#x2F;服务器架构"></a>一 客户端&#x2F;服务器架构</h2><p>1.硬件C&#x2F;S架构(打印机)</p><p>2.软件C&#x2F;S架构</p><p><em>互联网中处处是C&#x2F;S架构</em></p><p><em>如黄色网站是服务端，你的浏览器是客户端（B&#x2F;S架构也是C&#x2F;S架构的一种）</em></p><p><em>腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频）</em></p><p>C&#x2F;S架构与socket的关系：</p><p><em>我们学习socket就是为了完成C&#x2F;S架构的开发</em></p><h3 id="二-osi七层"><a href="#二-osi七层" class="headerlink" title="二 osi七层"></a>二 osi七层</h3><p><strong>引子：</strong></p><p><em>须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）</em></p><p><em>如果你要跟别人一起玩，那你就需要上网了，什么是互联网？</em></p><p><em>互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语</em></p><p><em>如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。</em></p><p><em>人们按照分工不同把互联网协议从逻辑上划分了层级，</em></p><p><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/5937962.html">详见网络通信原理：http://www.cnblogs.com/linhaifeng/articles/5937962.html</a></p><p><strong>为何学习socket一定要先学习互联网协议：</strong></p><p><em>1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C&#x2F;S架构软件</em></p><p><em>2.其次：C&#x2F;S架构的软件（软件属于应用层）是基于网络进行通信的</em></p><p><em>3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。</em></p><p><em>4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅</em></p><p><img src="https://pic4.zhimg.com/80/v2-3f2ab5646d1bbca993e920c8ae27f40f_720w.jpg" alt="img"></p><p> 图1</p><h3 id="三-socket层"><a href="#三-socket层" class="headerlink" title="三 socket层"></a>三 socket层</h3><p>在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。</p><p><img src="https://pic3.zhimg.com/80/v2-a4a1fd105e5e7af5d7db820b303ad7e2_720w.jpg" alt="img"></p><p><strong>图2</strong></p><h3 id="四-socket是什么"><a href="#四-socket是什么" class="headerlink" title="四 socket是什么"></a>四 socket是什么</h3><p>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>所以，我们无需深入理解tcp&#x2F;udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp&#x2F;udp标准的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识</code></pre></div></figure><h3 id="五-套接字发展史及分类"><a href="#五-套接字发展史及分类" class="headerlink" title="五 套接字发展史及分类"></a>五 套接字发展史及分类</h3><p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。</p><p>*<strong>基于文件类型的套接字家族*</strong></p><p>套接字家族的名字：AF_UNIX</p><p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p><p>*<strong>基于网络类型的套接字家族*</strong></p><p>套接字家族的名字：AF_INET</p><p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p><h3 id="六-套接字工作流程"><a href="#六-套接字工作流程" class="headerlink" title="六 套接字工作流程"></a>六 套接字工作流程</h3><p> 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。</p><p><img src="https://pic1.zhimg.com/80/v2-7d4ff6c59a5201bac25926b792826a40_720w.jpg" alt="img"></p><p> 图3</p><p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p><p>socket()模块函数用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 import socket 2 socket.socket(socket_family,socket_type,protocal&#x3D;0) 3 socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0。 4  5 获取tcp&#x2F;ip套接字 6 tcpSock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) 7  8 获取udp&#x2F;ip套接字 9 udpSock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)10 11 由于 socket 模块中有太多的属性。我们在这里破例使用了&#39;from module import *&#39;语句。使用 &#39;from socket import *&#39;,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。12 例如tcpSock &#x3D; socket(AF_INET, SOCK_STREAM</code></pre></div></figure><p><em><strong>服务端套接字函数</strong></em><br>s.bind() 绑定(主机,端口号)到套接字<br>s.listen() 开始TCP监听<br>s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来</p><p><em><strong>客户端套接字函数</strong></em><br>s.connect() 主动初始化TCP服务器连接<br>s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</p><p><em><strong>公共用途的套接字函数</strong></em><br>s.recv() 接收TCP数据<br>s.send() 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)<br>s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)<br>s.recvfrom() 接收UDP数据<br>s.sendto() 发送UDP数据<br>s.getpeername() 连接到当前套接字的远端的地址<br>s.getsockname() 当前套接字的地址<br>s.getsockopt() 返回指定套接字的参数<br>s.setsockopt() 设置指定套接字的参数<br>s.close() 关闭套接字</p><p><em><strong>面向锁的套接字方法</strong></em><br>s.setblocking() 设置套接字的阻塞与非阻塞模式<br>s.settimeout() 设置阻塞套接字操作的超时时间<br>s.gettimeout() 得到阻塞套接字操作的超时时间</p><p><em><strong>面向文件的套接字的函数</strong></em><br>s.fileno() 套接字的文件描述符<br>s.makefile() 创建一个与该套接字相关的文件</p><h3 id="七-基于TCP的套接字"><a href="#七-基于TCP的套接字" class="headerlink" title="七 基于TCP的套接字"></a>七 基于TCP的套接字</h3><p>*<strong>tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端*</strong></p><p>*<strong>tcp服务端*</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 ss &#x3D; socket() #创建服务器套接字2 ss.bind()      #把地址绑定到套接字3 ss.listen()      #监听链接4 inf_loop:      #服务器无限循环5     cs &#x3D; ss.accept() #接受客户端链接6     comm_loop:         #通讯循环7         cs.recv()&#x2F;cs.send() #对话(接收与发送)8     cs.close()    #关闭客户端套接字9 ss.close()        #关闭服务器套接字(可选)</code></pre></div></figure><p>*<strong>tcp客户端*</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 cs &#x3D; socket()    # 创建客户套接字2 cs.connect()    # 尝试连接服务器3 comm_loop:        # 通讯循环4     cs.send()&#x2F;cs.recv()    # 对话(发送&#x2F;接收)5 cs.close()            # 关闭客户套接字</code></pre></div></figure><p>socket通信流程与打电话流程类似，我们就以打电话为例来实现一个low版的套接字通信</p><p>服务端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000)  #电话卡BUFSIZE&#x3D;1024                #收发消息的尺寸s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机s.bind(ip_port) #手机插卡s.listen(5)     #手机待机conn,addr&#x3D;s.accept()            #手机接电话# print(conn)# print(addr)print(&#39;接到来自%s的电话&#39; %addr[0])msg&#x3D;conn.recv(BUFSIZE)             #听消息,听话print(msg,type(msg))conn.send(msg.upper())          #发消息,说话conn.close()                    #挂电话s.close()                       #手机关机</code></pre></div></figure><p>客户端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000)BUFSIZE&#x3D;1024s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect_ex(ip_port)           #拨电话s.send(&#39;linhaifeng nb&#39;.encode(&#39;utf-8&#39;))         #发消息,说话(只能发送字节类型)feedback&#x3D;s.recv(BUFSIZE)                           #收消息,听话print(feedback.decode(&#39;utf-8&#39;))s.close()                                       #挂电话</code></pre></div></figure><p>加上链接循环与通信循环</p><p>服务端改进版:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,8081)#电话卡BUFSIZE&#x3D;1024s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机s.bind(ip_port) #手机插卡s.listen(5)     #手机待机while True:                         #新增接收链接循环,可以不停的接电话    conn,addr&#x3D;s.accept()            #手机接电话    # print(conn)    # print(addr)    print(&#39;接到来自%s的电话&#39; %addr[0])    while True:                         #新增通信循环,可以不断的通信,收发消息        msg&#x3D;conn.recv(BUFSIZE)             #听消息,听话        # if len(msg) &#x3D;&#x3D; 0:break        #如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生        print(msg,type(msg))        conn.send(msg.upper())          #发消息,说话    conn.close()                    #挂电话s.close()                       #手机关机</code></pre></div></figure><p>客户端改进版</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,8081)BUFSIZE&#x3D;1024s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect_ex(ip_port)           #拨电话while True:                             #新增通信循环,客户端可以不断发收消息    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if len(msg) &#x3D;&#x3D; 0:continue    s.send(msg.encode(&#39;utf-8&#39;))         #发消息,说话(只能发送字节类型)    feedback&#x3D;s.recv(BUFSIZE)                           #收消息,听话    print(feedback.decode(&#39;utf-8&#39;))s.close()                                       #挂电话</code></pre></div></figure><p>问题：</p><p>有的同学在重启服务端时可能会遇到</p><p><img src="https://pic2.zhimg.com/80/v2-aeeffa09a60bc1037ae69a2856cf8941_720w.jpg" alt="img"></p><p>这个是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法）</p><p>解决方法：</p><p>方法一</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#加入一条socket配置，重用ip和端口phone&#x3D;socket(AF_INET,SOCK_STREAM)phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#39;127.0.0.1&#39;,8080))</code></pre></div></figure><p>方法二</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决，vi &#x2F;etc&#x2F;sysctl.conf编辑文件，加入以下内容：net.ipv4.tcp_syncookies &#x3D; 1net.ipv4.tcp_tw_reuse &#x3D; 1net.ipv4.tcp_tw_recycle &#x3D; 1net.ipv4.tcp_fin_timeout &#x3D; 30然后执行 &#x2F;sbin&#x2F;sysctl -p 让参数生效。net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间</code></pre></div></figure><h3 id="八-基于UDP的套接字"><a href="#八-基于UDP的套接字" class="headerlink" title="八 基于UDP的套接字"></a>八 基于UDP的套接字</h3><p>*<strong>udp是无链接的，先启动哪一端都不会报错*</strong></p><p>udp服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 ss &#x3D; socket()   #创建一个服务器的套接字2 ss.bind()       #绑定服务器套接字3 inf_loop:       #服务器无限循环4     cs &#x3D; ss.recvfrom()&#x2F;ss.sendto() # 对话(接收与发送)5 ss.close()                         # 关闭服务器套接字</code></pre></div></figure><p>udp客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">cs &#x3D; socket()   # 创建客户套接字comm_loop:      # 通讯循环    cs.sendto()&#x2F;cs.recvfrom()   # 对话(发送&#x2F;接收)cs.close()                      # 关闭客户套接字</code></pre></div></figure><p>*<strong>udp套接字简单示例*</strong></p><p>udp服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000)BUFSIZE&#x3D;1024udp_server_client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)udp_server_client.bind(ip_port)while True:    msg,addr&#x3D;udp_server_client.recvfrom(BUFSIZE)    print(msg,addr)    udp_server_client.sendto(msg.upper(),addr)</code></pre></div></figure><p>udp客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000)BUFSIZE&#x3D;1024udp_server_client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if not msg:continue    udp_server_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port)    back_msg,addr&#x3D;udp_server_client.recvfrom(BUFSIZE)    print(back_msg.decode(&#39;utf-8&#39;),addr)</code></pre></div></figure><p>*<strong>qq聊天(由于udp无连接，所以可以同时多个客户端去跟服务端通信)*</strong></p><p>udp服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,8081)udp_server_sock&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #买手机udp_server_sock.bind(ip_port)while True:    qq_msg,addr&#x3D;udp_server_sock.recvfrom(1024)    print(&#39;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#39; %(addr[0],addr[1],qq_msg.decode(&#39;utf-8&#39;)))    back_msg&#x3D;input(&#39;回复消息: &#39;).strip()    udp_server_sock.sendto(back_msg.encode(&#39;utf-8&#39;),addr)</code></pre></div></figure><p>udp客户端1</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024udp_client_socket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)qq_name_dic&#x3D;&#123;    &#39;狗哥alex&#39;:(&#39;127.0.0.1&#39;,8081),    &#39;瞎驴&#39;:(&#39;127.0.0.1&#39;,8081),    &#39;一棵树&#39;:(&#39;127.0.0.1&#39;,8081),    &#39;武大郎&#39;:(&#39;127.0.0.1&#39;,8081),&#125;while True:    qq_name&#x3D;input(&#39;请选择聊天对象: &#39;).strip()    while True:        msg&#x3D;input(&#39;请输入消息,回车发送: &#39;).strip()        if msg &#x3D;&#x3D; &#39;quit&#39;:break        if not msg or not qq_name or qq_name not in qq_name_dic:continue        udp_client_socket.sendto(msg.encode(&#39;utf-8&#39;),qq_name_dic[qq_name])        back_msg,addr&#x3D;udp_client_socket.recvfrom(BUFSIZE)        print(&#39;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#39; %(addr[0],addr[1],back_msg.decode(&#39;utf-8&#39;)))udp_client_socket.close()</code></pre></div></figure><p>udp客户端2</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024udp_client_socket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)qq_name_dic&#x3D;&#123;    &#39;狗哥alex&#39;:(&#39;127.0.0.1&#39;,8081),    &#39;瞎驴&#39;:(&#39;127.0.0.1&#39;,8081),    &#39;一棵树&#39;:(&#39;127.0.0.1&#39;,8081),    &#39;武大郎&#39;:(&#39;127.0.0.1&#39;,8081),&#125;while True:    qq_name&#x3D;input(&#39;请选择聊天对象: &#39;).strip()    while True:        msg&#x3D;input(&#39;请输入消息,回车发送: &#39;).strip()        if msg &#x3D;&#x3D; &#39;quit&#39;:break        if not msg or not qq_name or qq_name not in qq_name_dic:continue        udp_client_socket.sendto(msg.encode(&#39;utf-8&#39;),qq_name_dic[qq_name])        back_msg,addr&#x3D;udp_client_socket.recvfrom(BUFSIZE)        print(&#39;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#39; %(addr[0],addr[1],back_msg.decode(&#39;utf-8&#39;)))udp_client_socket.close()</code></pre></div></figure><p>服务端运行结果</p><p><img src="https://pic3.zhimg.com/80/v2-b8475dd2de46da061d4f507bc2414206_720w.jpg" alt="img"></p><p>客户端1运行结果</p><p><img src="https://pic1.zhimg.com/80/v2-7fa4072d1b9ed772c81fe72b20497eec_720w.jpg" alt="img"></p><p>客户端2运行结果</p><p><img src="https://pic2.zhimg.com/80/v2-c70ea48a4774814cbc6d58657b811539_720w.jpg" alt="img"></p><p>*<strong>时间服务器*</strong></p><p>ntp服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *from time import strftimeip_port&#x3D;(&#39;127.0.0.1&#39;,9000)bufsize&#x3D;1024tcp_server&#x3D;socket(AF_INET,SOCK_DGRAM)tcp_server.bind(ip_port)while True:    msg,addr&#x3D;tcp_server.recvfrom(bufsize)    print(&#39;&#x3D;&#x3D;&#x3D;&gt;&#39;,msg)    if not msg:        time_fmt&#x3D;&#39;%Y-%m-%d %X&#39;    else:        time_fmt&#x3D;msg.decode(&#39;utf-8&#39;)    back_msg&#x3D;strftime(time_fmt)    tcp_server.sendto(back_msg.encode(&#39;utf-8&#39;),addr)tcp_server.close()</code></pre></div></figure><p>ntp客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)bufsize&#x3D;1024tcp_client&#x3D;socket(AF_INET,SOCK_DGRAM)while True:    msg&#x3D;input(&#39;请输入时间格式(例%Y %m %d)&gt;&gt;: &#39;).strip()    tcp_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port)    data&#x3D;tcp_client.recv(bufsize)    print(data.decode(&#39;utf-8&#39;))tcp_client.close()</code></pre></div></figure><h3 id="九-粘包现象"><a href="#九-粘包现象" class="headerlink" title="九 粘包现象"></a>九 粘包现象</h3><p>让我们基于tcp先制作一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig）</p><p><strong>注意注意注意：</strong></p><p>res&#x3D;subprocess.Popen(cmd.decode(‘utf-8’), shell&#x3D;True, stderr&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE)</p><p>的结果的编码是以当前所在的系统为准的，如果是windows，那么<strong>res.stdout.read()读出的就是GBK编码的</strong>，在接收端需<strong>要用GBK解码</strong></p><p><strong>且只能从管道里读一次结果</strong></p><p>注意：命令ls -l ; lllllll ; pwd 的结果是既有正确stdout结果，又有错误stderr结果</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import subprocessip_port&#x3D;(&#39;127.0.0.1&#39;,8080)BUFSIZE&#x3D;1024tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)while True:    conn,addr&#x3D;tcp_socket_server.accept()    print(&#39;客户端&#39;,addr)    while True:        cmd&#x3D;conn.recv(BUFSIZE)        if len(cmd) &#x3D;&#x3D; 0:break        res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),shell&#x3D;True,                         stdout&#x3D;subprocess.PIPE,                         stdin&#x3D;subprocess.PIPE,                         stderr&#x3D;subprocess.PIPE)        stderr&#x3D;act_res.stderr.read()        stdout&#x3D;act_res.stdout.read()        conn.send(stderr)        conn.send(stdout)</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex(ip_port)while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if len(msg) &#x3D;&#x3D; 0:continue    if msg &#x3D;&#x3D; &#39;quit&#39;:break    s.send(msg.encode(&#39;utf-8&#39;))    act_res&#x3D;s.recv(BUFSIZE)    print(act_res.decode(&#39;utf-8&#39;),end&#x3D;&#39;&#39;)</code></pre></div></figure><p>上述程序是基于tcp的socket，在运行时会发生粘包</p><p>让我们再基于udp制作一个远程执行命令的程序</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import subprocessip_port&#x3D;(&#39;127.0.0.1&#39;,9003)bufsize&#x3D;1024udp_server&#x3D;socket(AF_INET,SOCK_DGRAM)udp_server.bind(ip_port)while True:    #收消息    cmd,addr&#x3D;udp_server.recvfrom(bufsize)    print(&#39;用户命令-----&gt;&#39;,cmd)    #逻辑处理    res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),shell&#x3D;True,stderr&#x3D;subprocess.PIPE,stdin&#x3D;subprocess.PIPE,stdout&#x3D;subprocess.PIPE)    stderr&#x3D;res.stderr.read()    stdout&#x3D;res.stdout.read()    #发消息    udp_server.sendto(stderr,addr)    udp_server.sendto(stdout,addr)udp_server.close()</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,9003)bufsize&#x3D;1024udp_client&#x3D;socket(AF_INET,SOCK_DGRAM)while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    udp_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port)    data,addr&#x3D;udp_client.recvfrom(bufsize)    print(data.decode(&#39;utf-8&#39;),end&#x3D;&#39;&#39;)</code></pre></div></figure><p>上述程序是基于udp的socket，在运行时永远不会发生粘包</p><h3 id="十-什么是粘包"><a href="#十-什么是粘包" class="headerlink" title="十 什么是粘包"></a>十 什么是粘包</h3><p>须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来</p><p>首先需要掌握一个socket收发消息的原理</p><p><img src="https://pic4.zhimg.com/80/v2-5e9568f888a55cd273aca6f561cea2d7_720w.jpg" alt="img"></p><p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write&#x2F;send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。</p><p>例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</p><p>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。</p><p>此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/datastructure">算法</a>把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p><ol><li>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。</li><li>UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 <strong>即面向消息的通信是有消息保护边界的。</strong></li><li><strong>tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略</strong></li></ol><p>udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠</p><p>tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</p><p>*<strong>两种情况下会发生粘包。*</strong></p><p>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)conn,addr&#x3D;tcp_socket_server.accept()data1&#x3D;conn.recv(10)data2&#x3D;conn.recv(10)print(&#39;-----&gt;&#39;,data1.decode(&#39;utf-8&#39;))print(&#39;-----&gt;&#39;,data2.decode(&#39;utf-8&#39;))conn.close()</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex(ip_port)s.send(&#39;hello&#39;.encode(&#39;utf-8&#39;))s.send(&#39;feng&#39;.encode(&#39;utf-8&#39;))</code></pre></div></figure><p>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)conn,addr&#x3D;tcp_socket_server.accept()data1&#x3D;conn.recv(2) #一次没有收完整data2&#x3D;conn.recv(10)#下次收的时候,会先取旧的数据,然后取新的print(&#39;-----&gt;&#39;,data1.decode(&#39;utf-8&#39;))print(&#39;-----&gt;&#39;,data2.decode(&#39;utf-8&#39;))conn.close()</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex(ip_port)s.send(&#39;hello feng&#39;.encode(&#39;utf-8&#39;))</code></pre></div></figure><p>*<strong>拆包的发生情况*</strong></p><p>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。</p><p>*<strong>补充问题一：为何tcp是可靠传输，udp是不可靠传输*</strong></p><p>基于tcp的数据传输请参考我的另一篇文章<a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linhaifeng/articles/5937962.html">http://www.cnblogs.com/linhaifeng/articles/5937962.html</a>，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack&#x3D;1，发送端则清理缓存中的数据，对端返回ack&#x3D;0，则重新发送数据，所以tcp是可靠的</p><p>而udp发送数据，对端是不会返回确认信息的，因此不可靠</p><p>*<strong>补充问题二：send(字节流)和recv(1024)及sendall*</strong></p><p>recv里指定的1024意思是从缓存里一次拿出1024个字节的数据</p><p>send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失</p><h3 id="十一-解决粘包的low比处理方法"><a href="#十一-解决粘包的low比处理方法" class="headerlink" title="十一 解决粘包的low比处理方法"></a>十一 解决粘包的low比处理方法</h3><p>问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据</p><p>low版本的解决方法</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socket,subprocessip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)s.bind(ip_port)s.listen(5)while True:    conn,addr&#x3D;s.accept()    print(&#39;客户端&#39;,addr)    while True:        msg&#x3D;conn.recv(1024)        if not msg:break        res&#x3D;subprocess.Popen(msg.decode(&#39;utf-8&#39;),shell&#x3D;True,\                            stdin&#x3D;subprocess.PIPE,\                         stderr&#x3D;subprocess.PIPE,\                         stdout&#x3D;subprocess.PIPE)        err&#x3D;res.stderr.read()        if err:            ret&#x3D;err        else:            ret&#x3D;res.stdout.read()        data_length&#x3D;len(ret)        conn.send(str(data_length).encode(&#39;utf-8&#39;))        data&#x3D;conn.recv(1024).decode(&#39;utf-8&#39;)        if data &#x3D;&#x3D; &#39;recv_ready&#39;:            conn.sendall(ret)    conn.close()</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socket,times&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex((&#39;127.0.0.1&#39;,8080))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if len(msg) &#x3D;&#x3D; 0:continue    if msg &#x3D;&#x3D; &#39;quit&#39;:break    s.send(msg.encode(&#39;utf-8&#39;))    length&#x3D;int(s.recv(1024).decode(&#39;utf-8&#39;))    s.send(&#39;recv_ready&#39;.encode(&#39;utf-8&#39;))    send_size&#x3D;0    recv_size&#x3D;0    data&#x3D;b&#39;&#39;    while recv_size &lt; length:        data+&#x3D;s.recv(1024)        recv_size+&#x3D;len(data)    print(data.decode(&#39;utf-8&#39;))</code></pre></div></figure><p>为何low：</p><p>程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗</p><h3 id="十二-峰哥解决粘包的方法"><a href="#十二-峰哥解决粘包的方法" class="headerlink" title="十二 峰哥解决粘包的方法"></a>十二 峰哥解决粘包的方法</h3><p>为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据</p><p><strong>struct模块</strong></p><p>该模块可以把一个类型，如数字，转成固定长度的bytes</p><p>&gt;&gt;&gt; struct.pack(‘i’,1111111111111)</p><p>。。。。。。。。。</p><p>struct.error: ‘i’ format requires -2147483648 &lt;&#x3D; number &lt;&#x3D; 2147483647 #这个是范围</p><p><img src="https://pic2.zhimg.com/80/v2-d7c66c9a0abe12041ae948a553b908c9_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import json,struct#假设通过客户端上传1T:1073741824000的文件a.txt#为避免粘包,必须自定制报头header&#x3D;&#123;&#39;file_size&#39;:1073741824000,&#39;file_name&#39;:&#39;&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;a.txt&#39;,&#39;md5&#39;:&#39;8f6fbf8347faa4924a76856701edb0f3&#39;&#125; #1T数据,文件路径和md5值#为了该报头能传送,需要序列化并且转为byteshead_bytes&#x3D;bytes(json.dumps(header),encoding&#x3D;&#39;utf-8&#39;) #序列化并转成bytes,用于传输#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节head_len_bytes&#x3D;struct.pack(&#39;i&#39;,len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度#客户端开始发送conn.send(head_len_bytes) #先发报头的长度,4个bytesconn.send(head_bytes) #再发报头的字节格式conn.sendall(文件内容) #然后发真实内容的字节格式#服务端开始接收head_len_bytes&#x3D;s.recv(4) #先收报头4个bytes,得到报头长度的字节格式x&#x3D;struct.unpack(&#39;i&#39;,head_len_bytes)[0] #提取报头的长度head_bytes&#x3D;s.recv(x) #按照报头长度x,收取报头的bytes格式header&#x3D;json.loads(json.dumps(header)) #提取报头#最后根据报头的内容提取真实的数据,比如real_data_len&#x3D;s.recv(header[&#39;file_size&#39;])s.recv(real_data_len)</code></pre></div></figure><p>关于struct的详细用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*_#http:&#x2F;&#x2F;www.cnblogs.com&#x2F;coser&#x2F;archive&#x2F;2011&#x2F;12&#x2F;17&#x2F;2291160.html__author__ &#x3D; &#39;Linhaifeng&#39;import structimport binasciiimport ctypesvalues1 &#x3D; (1, &#39;abc&#39;.encode(&#39;utf-8&#39;), 2.7)values2 &#x3D; (&#39;defg&#39;.encode(&#39;utf-8&#39;),101)s1 &#x3D; struct.Struct(&#39;I3sf&#39;)s2 &#x3D; struct.Struct(&#39;4sI&#39;)print(s1.size,s2.size)prebuffer&#x3D;ctypes.create_string_buffer(s1.size+s2.size)print(&#39;Before : &#39;,binascii.hexlify(prebuffer))# t&#x3D;binascii.hexlify(&#39;asdfaf&#39;.encode(&#39;utf-8&#39;))# print(t)s1.pack_into(prebuffer,0,*values1)s2.pack_into(prebuffer,s1.size,*values2)print(&#39;After pack&#39;,binascii.hexlify(prebuffer))print(s1.unpack_from(prebuffer,0))print(s2.unpack_from(prebuffer,s1.size))s3&#x3D;struct.Struct(&#39;ii&#39;)s3.pack_into(prebuffer,0,123,123)print(&#39;After pack&#39;,binascii.hexlify(prebuffer))print(s3.unpack_from(prebuffer,0))</code></pre></div></figure><p>服务端（自定制报头）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socket,struct,jsonimport subprocessphone&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#39;127.0.0.1&#39;,8080))phone.listen(5)while True:    conn,addr&#x3D;phone.accept()    while True:        cmd&#x3D;conn.recv(1024)        if not cmd:break        print(&#39;cmd: %s&#39; %cmd)        res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),                             shell&#x3D;True,                             stdout&#x3D;subprocess.PIPE,                             stderr&#x3D;subprocess.PIPE)        err&#x3D;res.stderr.read()        print(err)        if err:            back_msg&#x3D;err        else:            back_msg&#x3D;res.stdout.read()        conn.send(struct.pack(&#39;i&#39;,len(back_msg))) #先发back_msg的长度        conn.sendall(back_msg) #在发真实的内容    conn.close()</code></pre></div></figure><p>客户端（自定制报头）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socket,time,structs&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex((&#39;127.0.0.1&#39;,8080))while True:    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()    if len(msg) &#x3D;&#x3D; 0:continue    if msg &#x3D;&#x3D; &#39;quit&#39;:break    s.send(msg.encode(&#39;utf-8&#39;))    l&#x3D;s.recv(4)    x&#x3D;struct.unpack(&#39;i&#39;,l)[0]    print(type(x),x)    # print(struct.unpack(&#39;I&#39;,l))    r_s&#x3D;0    data&#x3D;b&#39;&#39;    while r_s &lt; x:        r_d&#x3D;s.recv(1024)        data+&#x3D;r_d        r_s+&#x3D;len(r_d)    # print(data.decode(&#39;utf-8&#39;))    print(data.decode(&#39;gbk&#39;)) #windows默认gbk编码</code></pre></div></figure><p>我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）</p><p>发送时：</p><p>先发报头长度</p><p>再编码报头内容然后发送</p><p>最后发真实内容</p><p>接收时：</p><p>先手报头长度，用struct取出来</p><p>根据取出的长度收取报头内容，然后解码，反序列化</p><p>从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</p><p>服务端：定制稍微复杂一点的报头</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socket,struct,jsonimport subprocessphone&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#39;127.0.0.1&#39;,8080))phone.listen(5)while True:    conn,addr&#x3D;phone.accept()    while True:        cmd&#x3D;conn.recv(1024)        if not cmd:break        print(&#39;cmd: %s&#39; %cmd)        res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),                             shell&#x3D;True,                             stdout&#x3D;subprocess.PIPE,                             stderr&#x3D;subprocess.PIPE)        err&#x3D;res.stderr.read()        print(err)        if err:            back_msg&#x3D;err        else:            back_msg&#x3D;res.stdout.read()        headers&#x3D;&#123;&#39;data_size&#39;:len(back_msg)&#125;        head_json&#x3D;json.dumps(headers)        head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;&#39;utf-8&#39;)        conn.send(struct.pack(&#39;i&#39;,len(head_json_bytes))) #先发报头的长度        conn.send(head_json_bytes) #再发报头        conn.sendall(back_msg) #在发真实的内容    conn.close()</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from socket import *import struct,jsonip_port&#x3D;(&#39;127.0.0.1&#39;,8080)client&#x3D;socket(AF_INET,SOCK_STREAM)client.connect(ip_port)while True:    cmd&#x3D;input(&#39;&gt;&gt;: &#39;)    if not cmd:continue    client.send(bytes(cmd,encoding&#x3D;&#39;utf-8&#39;))    head&#x3D;client.recv(4)    head_json_len&#x3D;struct.unpack(&#39;i&#39;,head)[0]    head_json&#x3D;json.loads(client.recv(head_json_len).decode(&#39;utf-8&#39;))    data_len&#x3D;head_json[&#39;data_size&#39;]    recv_size&#x3D;0    recv_data&#x3D;b&#39;&#39;    while recv_size &lt; data_len:        recv_data+&#x3D;client.recv(1024)        recv_size+&#x3D;len(recv_data)    print(recv_data.decode(&#39;utf-8&#39;))    #print(recv_data.decode(&#39;gbk&#39;)) #windows默认gbk编码</code></pre></div></figure><p>FTP作业：上传下载文件</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socketimport structimport jsonimport subprocessimport osclass MYTCPServer:    address_family &#x3D; socket.AF_INET    socket_type &#x3D; socket.SOCK_STREAM    allow_reuse_address &#x3D; False    max_packet_size &#x3D; 8192    coding&#x3D;&#39;utf-8&#39;    request_queue_size &#x3D; 5    server_dir&#x3D;&#39;file_upload&#39;    def __init__(self, server_address, bind_and_activate&#x3D;True):        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;        self.server_address&#x3D;server_address        self.socket &#x3D; socket.socket(self.address_family,                                    self.socket_type)        if bind_and_activate:            try:                self.server_bind()                self.server_activate()            except:                self.server_close()                raise    def server_bind(self):        &quot;&quot;&quot;Called by constructor to bind the socket.        &quot;&quot;&quot;        if self.allow_reuse_address:            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        self.socket.bind(self.server_address)        self.server_address &#x3D; self.socket.getsockname()    def server_activate(self):        &quot;&quot;&quot;Called by constructor to activate the server.        &quot;&quot;&quot;        self.socket.listen(self.request_queue_size)    def server_close(self):        &quot;&quot;&quot;Called to clean-up the server.        &quot;&quot;&quot;        self.socket.close()    def get_request(self):        &quot;&quot;&quot;Get the request and client address from the socket.        &quot;&quot;&quot;        return self.socket.accept()    def close_request(self, request):        &quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;        request.close()    def run(self):        while True:            self.conn,self.client_addr&#x3D;self.get_request()            print(&#39;from client &#39;,self.client_addr)            while True:                try:                    head_struct &#x3D; self.conn.recv(4)                    if not head_struct:break                    head_len &#x3D; struct.unpack(&#39;i&#39;, head_struct)[0]                    head_json &#x3D; self.conn.recv(head_len).decode(self.coding)                    head_dic &#x3D; json.loads(head_json)                    print(head_dic)                    #head_dic&#x3D;&#123;&#39;cmd&#39;:&#39;put&#39;,&#39;filename&#39;:&#39;a.txt&#39;,&#39;filesize&#39;:123123&#125;                    cmd&#x3D;head_dic[&#39;cmd&#39;]                    if hasattr(self,cmd):                        func&#x3D;getattr(self,cmd)                        func(head_dic)                except Exception:                    break    def put(self,args):        file_path&#x3D;os.path.normpath(os.path.join(            self.server_dir,            args[&#39;filename&#39;]        ))        filesize&#x3D;args[&#39;filesize&#39;]        recv_size&#x3D;0        print(&#39;-----&gt;&#39;,file_path)        with open(file_path,&#39;wb&#39;) as f:            while recv_size &lt; filesize:                recv_data&#x3D;self.conn.recv(self.max_packet_size)                f.write(recv_data)                recv_size+&#x3D;len(recv_data)                print(&#39;recvsize:%s filesize:%s&#39; %(recv_size,filesize))tcpserver1&#x3D;MYTCPServer((&#39;127.0.0.1&#39;,8080))tcpserver1.run()</code></pre></div></figure><p>客户端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socketimport structimport jsonimport osclass MYTCPClient:    address_family &#x3D; socket.AF_INET    socket_type &#x3D; socket.SOCK_STREAM    allow_reuse_address &#x3D; False    max_packet_size &#x3D; 8192    coding&#x3D;&#39;utf-8&#39;    request_queue_size &#x3D; 5    def __init__(self, server_address, connect&#x3D;True):        self.server_address&#x3D;server_address        self.socket &#x3D; socket.socket(self.address_family,                                    self.socket_type)        if connect:            try:                self.client_connect()            except:                self.client_close()                raise    def client_connect(self):        self.socket.connect(self.server_address)    def client_close(self):        self.socket.close()    def run(self):        while True:            inp&#x3D;input(&quot;&gt;&gt;: &quot;).strip()            if not inp:continue            l&#x3D;inp.split()            cmd&#x3D;l[0]            if hasattr(self,cmd):                func&#x3D;getattr(self,cmd)                func(l)    def put(self,args):        cmd&#x3D;args[0]        filename&#x3D;args[1]        if not os.path.isfile(filename):            print(&#39;file:%s is not exists&#39; %filename)            return        else:            filesize&#x3D;os.path.getsize(filename)        head_dic&#x3D;&#123;&#39;cmd&#39;:cmd,&#39;filename&#39;:os.path.basename(filename),&#39;filesize&#39;:filesize&#125;        print(head_dic)        head_json&#x3D;json.dumps(head_dic)        head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;self.coding)        head_struct&#x3D;struct.pack(&#39;i&#39;,len(head_json_bytes))        self.socket.send(head_struct)        self.socket.send(head_json_bytes)        send_size&#x3D;0        with open(filename,&#39;rb&#39;) as f:            for line in f:                self.socket.send(line)                send_size+&#x3D;len(line)                print(send_size)            else:                print(&#39;upload successful&#39;)client&#x3D;MYTCPClient((&#39;127.0.0.1&#39;,8080))client.run()</code></pre></div></figure><h3 id="十三-认证客户端的链接合法性"><a href="#十三-认证客户端的链接合法性" class="headerlink" title="十三 认证客户端的链接合法性"></a>十三 认证客户端的链接合法性</h3><p>如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现</p><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import hmac,ossecret_key&#x3D;b&#39;linhaifeng bang bang bang&#39;def conn_auth(conn):    &#39;&#39;&#39;    认证客户端链接    :param conn:    :return:    &#39;&#39;&#39;    print(&#39;开始验证新链接的合法性&#39;)    msg&#x3D;os.urandom(32)    conn.sendall(msg)    h&#x3D;hmac.new(secret_key,msg)    digest&#x3D;h.digest()    respone&#x3D;conn.recv(len(digest))    return hmac.compare_digest(respone,digest)def data_handler(conn,bufsize&#x3D;1024):    if not conn_auth(conn):        print(&#39;该链接不合法,关闭&#39;)        conn.close()        return    print(&#39;链接合法,开始通信&#39;)    while True:        data&#x3D;conn.recv(bufsize)        if not data:break        conn.sendall(data.upper())def server_handler(ip_port,bufsize,backlog&#x3D;5):    &#39;&#39;&#39;    只处理链接    :param ip_port:    :return:    &#39;&#39;&#39;    tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)    tcp_socket_server.bind(ip_port)    tcp_socket_server.listen(backlog)    while True:        conn,addr&#x3D;tcp_socket_server.accept()        print(&#39;新连接[%s:%s]&#39; %(addr[0],addr[1]))        data_handler(conn,bufsize)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)    bufsize&#x3D;1024    server_handler(ip_port,bufsize)</code></pre></div></figure><p>客户端(合法)</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import hmac,ossecret_key&#x3D;b&#39;linhaifeng bang bang bang&#39;def conn_auth(conn):    &#39;&#39;&#39;    验证客户端到服务器的链接    :param conn:    :return:    &#39;&#39;&#39;    msg&#x3D;conn.recv(32)    h&#x3D;hmac.new(secret_key,msg)    digest&#x3D;h.digest()    conn.sendall(digest)def client_handler(ip_port,bufsize&#x3D;1024):    tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM)    tcp_socket_client.connect(ip_port)    conn_auth(tcp_socket_client)    while True:        data&#x3D;input(&#39;&gt;&gt;: &#39;).strip()        if not data:continue        if data &#x3D;&#x3D; &#39;quit&#39;:break        tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;))        respone&#x3D;tcp_socket_client.recv(bufsize)        print(respone.decode(&#39;utf-8&#39;))    tcp_socket_client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)    bufsize&#x3D;1024    client_handler(ip_port,bufsize)</code></pre></div></figure><p>客户端(非法:不知道加密方式)</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *def client_handler(ip_port,bufsize&#x3D;1024):    tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM)    tcp_socket_client.connect(ip_port)    while True:        data&#x3D;input(&#39;&gt;&gt;: &#39;).strip()        if not data:continue        if data &#x3D;&#x3D; &#39;quit&#39;:break        tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;))        respone&#x3D;tcp_socket_client.recv(bufsize)        print(respone.decode(&#39;utf-8&#39;))    tcp_socket_client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)    bufsize&#x3D;1024    client_handler(ip_port,bufsize)</code></pre></div></figure><p>客户端(非法:不知道secret_key)</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import hmac,ossecret_key&#x3D;b&#39;linhaifeng bang bang bang1111&#39;def conn_auth(conn):    &#39;&#39;&#39;    验证客户端到服务器的链接    :param conn:    :return:    &#39;&#39;&#39;    msg&#x3D;conn.recv(32)    h&#x3D;hmac.new(secret_key,msg)    digest&#x3D;h.digest()    conn.sendall(digest)def client_handler(ip_port,bufsize&#x3D;1024):    tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM)    tcp_socket_client.connect(ip_port)    conn_auth(tcp_socket_client)    while True:        data&#x3D;input(&#39;&gt;&gt;: &#39;).strip()        if not data:continue        if data &#x3D;&#x3D; &#39;quit&#39;:break        tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;))        respone&#x3D;tcp_socket_client.recv(bufsize)        print(respone.decode(&#39;utf-8&#39;))    tcp_socket_client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)    bufsize&#x3D;1024    client_handler(ip_port,bufsize)</code></pre></div></figure><h3 id="十四-socketserver实现并发"><a href="#十四-socketserver实现并发" class="headerlink" title="十四 socketserver实现并发"></a>十四 socketserver实现并发</h3><p>基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环</p><p>socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）</p><p>server类：</p><p><img src="https://pic1.zhimg.com/80/v2-8888d725cb767594afe03b558814ba28_720w.jpg" alt="img"></p><p>request类：</p><p><img src="https://pic2.zhimg.com/80/v2-d39565c190e7edc28f8cf8be1bf981f9_720w.jpg" alt="img"></p><p>继承关系:</p><p><img src="https://pic1.zhimg.com/80/v2-16fcc2d93beebe3f1739951dc5d80114_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-154c5cb9cc464fac3e81703938479446_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-43cec3a3b133fd33c4d4db33af86807a_720w.jpg" alt="img"></p><p>以下述代码为例，分析socketserver源码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">ftpserver&#x3D;socketserver.ThreadingTCPServer((&#39;127.0.0.1&#39;,8080),FtpServer)ftpserver.serve_forever()</code></pre></div></figure><p>查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer</p><ol><li>实例化得到ftpserver，先找类ThreadingTCPServer的<strong>init</strong>,在TCPServer中找到，进而执行server_bind,server_active</li><li>找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中</li><li>执行self._handle_request_noblock()进而执行request, client_address &#x3D; self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)</li><li>在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)</li><li>上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找<strong>init</strong>方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找….</li></ol><p>源码分析总结：</p><p>基于tcp的socketserver我们自己定义的类中的</p><ol><li>self.server即套接字对象</li><li>self.request即一个链接</li><li>self.client_address即客户端地址</li></ol><p>基于udp的socketserver我们自己定义的类中的</p><ol><li>self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, )</li><li>self.client_address即客户端地址</li></ol><p>FtpServer</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socketserverimport structimport jsonimport osclass FtpServer(socketserver.BaseRequestHandler):    coding&#x3D;&#39;utf-8&#39;    server_dir&#x3D;&#39;file_upload&#39;    max_packet_size&#x3D;1024    BASE_DIR&#x3D;os.path.dirname(os.path.abspath(__file__))    def handle(self):        print(self.request)        while True:            data&#x3D;self.request.recv(4)            data_len&#x3D;struct.unpack(&#39;i&#39;,data)[0]            head_json&#x3D;self.request.recv(data_len).decode(self.coding)            head_dic&#x3D;json.loads(head_json)            # print(head_dic)            cmd&#x3D;head_dic[&#39;cmd&#39;]            if hasattr(self,cmd):                func&#x3D;getattr(self,cmd)                func(head_dic)    def put(self,args):        file_path &#x3D; os.path.normpath(os.path.join(            self.BASE_DIR,            self.server_dir,            args[&#39;filename&#39;]        ))        filesize &#x3D; args[&#39;filesize&#39;]        recv_size &#x3D; 0        print(&#39;-----&gt;&#39;, file_path)        with open(file_path, &#39;wb&#39;) as f:            while recv_size &lt; filesize:                recv_data &#x3D; self.request.recv(self.max_packet_size)                f.write(recv_data)                recv_size +&#x3D; len(recv_data)                print(&#39;recvsize:%s filesize:%s&#39; % (recv_size, filesize))ftpserver&#x3D;socketserver.ThreadingTCPServer((&#39;127.0.0.1&#39;,8080),FtpServer)ftpserver.serve_forever()</code></pre></div></figure><p>FtpClient</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socketimport structimport jsonimport osclass MYTCPClient:    address_family &#x3D; socket.AF_INET    socket_type &#x3D; socket.SOCK_STREAM    allow_reuse_address &#x3D; False    max_packet_size &#x3D; 8192    coding&#x3D;&#39;utf-8&#39;    request_queue_size &#x3D; 5    def __init__(self, server_address, connect&#x3D;True):        self.server_address&#x3D;server_address        self.socket &#x3D; socket.socket(self.address_family,                                    self.socket_type)        if connect:            try:                self.client_connect()            except:                self.client_close()                raise    def client_connect(self):        self.socket.connect(self.server_address)    def client_close(self):        self.socket.close()    def run(self):        while True:            inp&#x3D;input(&quot;&gt;&gt;: &quot;).strip()            if not inp:continue            l&#x3D;inp.split()            cmd&#x3D;l[0]            if hasattr(self,cmd):                func&#x3D;getattr(self,cmd)                func(l)    def put(self,args):        cmd&#x3D;args[0]        filename&#x3D;args[1]        if not os.path.isfile(filename):            print(&#39;file:%s is not exists&#39; %filename)            return        else:            filesize&#x3D;os.path.getsize(filename)        head_dic&#x3D;&#123;&#39;cmd&#39;:cmd,&#39;filename&#39;:os.path.basename(filename),&#39;filesize&#39;:filesize&#125;        print(head_dic)        head_json&#x3D;json.dumps(head_dic)        head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;self.coding)        head_struct&#x3D;struct.pack(&#39;i&#39;,len(head_json_bytes))        self.socket.send(head_struct)        self.socket.send(head_json_bytes)        send_size&#x3D;0        with open(filename,&#39;rb&#39;) as f:            for line in f:                self.socket.send(line)                send_size+&#x3D;len(line)                print(send_size)            else:                print(&#39;upload successful&#39;)client&#x3D;MYTCPClient((&#39;127.0.0.1&#39;,8080))client.run()</code></pre></div></figure><h3 id="十五-作业"><a href="#十五-作业" class="headerlink" title="十五 作业"></a>十五 作业</h3><p><img src="https://pic3.zhimg.com/80/v2-37d4aec9c5fe06d298f0d35258c0a222_720w.jpg" alt="img"></p><h2 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接"></a>视频链接</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=119">  </a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>30-异常处理</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/30_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/30_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一-什么是异常"><a href="#一-什么是异常" class="headerlink" title="一 什么是异常"></a>一 什么是异常</h2><p>异常是程序发生错误的信号。程序一旦出现错误，便会产生一个异常，若程序中没有处理它，就会抛出该异常，程序的运行也随之终止。在Python中,错误触发的异常如下</p><p><img src="https://pic3.zhimg.com/80/v2-4653ca6dbe955793d1e4ed1fb750ce86_720w.jpg" alt="img"></p><p>而错误分成两种，一种是语法上的错误SyntaxError，这种错误应该在程序运行前就修改正确</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; if    File &quot;&lt;stdin&gt;&quot;, line 1    if     ^SyntaxError: invalid syntax</code></pre></div></figure><p>另一类就是逻辑错误，常见的逻辑错误如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># TypeError：数字类型无法与字符串类型相加1+’2’# ValueError：当字符串包含有非数字的值时，无法转成int类型num&#x3D;input(&quot;&gt;&gt;: &quot;) #输入helloint(num)# NameError：引用了一个不存在的名字xx# IndexError：索引超出列表的限制l&#x3D;[&#39;egon&#39;,&#39;aa&#39;]l[3]# KeyError：引用了一个不存在的keydic&#x3D;&#123;&#39;name&#39;:&#39;egon&#39;&#125;dic[&#39;age&#39;]# AttributeError：引用的属性不存在class Foo:    passFoo.x# ZeroDivisionError：除数不能为01&#x2F;0</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-c568557e9385e17985dca3108dd58981_720w.jpg" alt="img"></p><h2 id="二-异常处理"><a href="#二-异常处理" class="headerlink" title="二 异常处理"></a>二 异常处理</h2><p>为了保证程序的容错性与可靠性，即在遇到错误时有相应的处理机制不会任由程序崩溃掉，我们需要对异常进行处理，处理的基本形式为</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    被检测的代码块except 异常类型：    检测到异常，就执行这个位置的逻辑</code></pre></div></figure><p>举例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    print(&#39;start...&#39;)    print(x) # 引用了一个不存在的名字，触发异常NameError    print(&#39;end...&#39;)except NameError as e: # as语法将异常类型的值赋值给变量e，这样我们通过打印e便可以知道错误的原因    print(&#39;异常值为：%s&#39; %e)print(&#39;run other code...&#39;)#执行结果为start...异常值为：name &#39;x&#39; is not definedrun other code...</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-eb6851dbe7f64728348b5abb9b54934e_720w.jpg" alt="img"></p><p>本来程序一旦出现异常就整体结束掉了，有了异常处理以后，在被检测的代码块出现异常时，被检测的代码块中异常发生位置之后的代码将不会执行，取而代之的是执行匹配异常的except子代码块，其余代码均正常运行。</p><p> 当被检测的代码块中有可能触发不同类型的异常时，针对不同类型的异常：</p><p> 如果我们想分别用不同的逻辑处理，需要用到多分支的except（类似于多分支的elif，从上到下依次匹配，匹配成功一次便不再匹配其他）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    被检测的代码块except NameError:    触发NameError时对应的处理逻辑except IndexError:    触发IndexError时对应的处理逻辑except KeyError:    触发KeyError时对应的处理逻辑</code></pre></div></figure><p>举例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def convert_int(obj):    try:        res&#x3D;int(obj)    except ValueError as e:        print(&#39;ValueError: %s&#39; %e)        res&#x3D;None    except TypeError as e:        print(&#39;TypeError: %s&#39; %e)        res&#x3D;None    return resconvert_int(&#39;egon&#39;) # ValueError: invalid literal for int() with base 10: &#39;egon&#39;convert_int(&#123;&#39;n&#39;:1&#125;) # TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;dict&#39;</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-350521efd08746dac4bde9049f1e6cee_720w.jpg" alt="img"></p><p>如果我们想多种类型的异常统一用一种逻辑处理，可以将多个异常放到一个元组内，用一个except匹配</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    被检测的代码块except (NameError,IndexError,TypeError):    触发NameError或IndexError或TypeError时对应的处理逻辑</code></pre></div></figure><p>举例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def convert_int(obj):    try:        res&#x3D;int(obj)    except (ValueError,TypeError):        print(&#39;argument must be number or numeric string&#39;)        res&#x3D;None    return resconvert_int(&#39;egon&#39;) # argument must be number or numeric stringconvert_int(&#123;&#39;n&#39;:1&#125;) # argument must be number or numeric string</code></pre></div></figure><p>如果我们想捕获所有异常并用一种逻辑处理，Python提供了一个万能异常类型Exception</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    被检测的代码块except NameError:    触发NameError时对应的处理逻辑except IndexError:    触发IndexError时对应的处理逻辑except Exception:    其他类型的异常统一用此处的逻辑处理</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-3bcb24c9b610fc49cf8a5c65d81ca81e_720w.jpg" alt="img"></p><p>在多分支except之后还可以跟一个else（else必须跟在except之后，不能单独存在），只有在被检测的代码块没有触发任何异常的情况下才会执行else的子代码块</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    被检测的代码块except 异常类型1:    passexcept 异常类型2:    pass......else:    没有异常发生时执行的代码块</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-0f32aec0c63c6943040c3b6affdabc3d_720w.jpg" alt="img"></p><p>此外try还可以与finally连用，从语法上讲finally必须放到else之后，但可以使用try-except-finally的形式，也可以直接使用try-finally的形式。无论被检测的代码块是否触发异常，都会执行finally的子代码块，因此通常在finally的子代码块做一些回收资源的操作，比如关闭打开的文件、关闭数据库连接等</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">python try: 被检测的代码块 except 异常类型1: pass except 异常类型2: pass ...... else: 没有异常发生时执行的代码块 finally: 无论有无异常发生都会执行的代码块</code></pre></div></figure><p>举例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">f&#x3D;Nonetry:    f&#x3D;open(‘db.txt’,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;)    s&#x3D;f.read().strip()    int(s)  # 若字符串s中包含非数字时则会触发异常ValueError    # f.close() # 若上面的代码触发异常，则根本不可能执行到此处的代码，应该将关闭文件的操作放到finally中finally:    if f: # 文件存在则f的值不为None        f.close()</code></pre></div></figure><p>在不符合Python解释器的语法或逻辑规则时，是由Python解释器主动触发的各种类型的异常，而对于违反程序员自定制的各类规则，则需要由程序员自己来明确地触发异常，这就用到了raise语句，raise后必须是一个异常的类或者是异常的实例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Student:    def __init__(self,name,age):        if not isinstance(name,str):            raise TypeError(&#39;name must be str&#39;)        if not isinstance(age,int):            raise TypeError(&#39;age must be int&#39;)        self.name&#x3D;name        self.age&#x3D;agestu1&#x3D;Student(4573,18) # TypeError: name must be strstu2&#x3D;Student(&#39;egon&#39;,&#39;18&#39;) # TypeError: age must be int</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-844dd17bef29d8cd13a459d3c28a9053_720w.jpg" alt="img"></p><p>在内置异常不够用的情况下，我们可以通过继承内置的异常类来自定义异常类</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class PoolEmptyError(Exception): # 可以通过继承Exception来定义一个全新的异常    def __init__(self,value&#x3D;&#39;The proxy source is exhausted&#39;): # 可以定制初始化方法        super(PoolEmptyError,self).__init__()        self.value&#x3D;value    def __str__(self): # 可以定义该方法用来定制触发异常时打印异常值的格式        return &#39;&lt; %s &gt;&#39; %self.valueclass NetworkIOError(IOError): # 也可以在特定异常的基础上扩展一个相关的异常    passraise PoolEmptyError # __main__.PoolEmptyError: &lt; The proxy source is exhausted &gt;raise NetworkIOError(&#39;连接被拒绝&#39;) # __main__.NetworkIOError: 连接被拒绝</code></pre></div></figure><p>最后，Python还提供了一个断言语句assert expression，断定表达式expression成立，否则触发异常AssertionError，与raise-if-not的语义相同，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age&#x3D;&#39;18&#39;# 若表达式isinstance(age,int)返回值为False则触发异常AssertionErrorassert isinstance(age,int)# 等同于if not isinstance(age,int):    raise AssertionError</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-b4c672c234ecd697537f7cfcaac1a828_720w.jpg" alt="img"></p><h2 id="三-何时使用异常处理"><a href="#三-何时使用异常处理" class="headerlink" title="三 何时使用异常处理"></a>三 何时使用异常处理</h2><p>在了解了异常处理机制后，本着提高程序容错性和可靠性的目的，读者可能会错误地认为应该尽可能多地为程序加上try…except…，这其是在过度消费程序的可读性，因为try…except本来就是你附加给程序的一种额外的逻辑，与你的主要工作是没有多大关系的。</p><p> 如果错误发生的条件是“可预知的”，我们应该用if来进行”预防”，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age&#x3D;input(&#39;input your age&gt;&gt;: &#39;).strip()if age.isdigit(): # 可预知只有满足字符串age是数字的条件，int(age)才不会触发异常，    age&#x3D;int(age)else:    print(&#39;You must enter the number&#39;)</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-93ad4d4a063406cea18caa3d056519a0_720w.jpg" alt="img"></p><p>如果错误发生的条件“不可预知”，即异常一定会触发，那么我们才应该使用try…except语句来处理。例如我们编写一个下载网页内容的功能，网络发生延迟之类的异常是很正常的事，而我们根本无法预知在满足什么条件的情况下才会出现延迟，因而只能用异常处理机制了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsfrom requests.exceptions import ConnectTimeout # 导入requests模块内自定义的异常def get(url):    try:        response&#x3D;requests.get(url,timeout&#x3D;3)#超过3秒未下载成功则触发ConnectTimeout异常        res&#x3D;response.text    except ConnectTimeout:        print(&#39;连接请求超时&#39;)        res&#x3D;None    except Exception:        print(&#39;网络出现其他异常&#39;)        res&#x3D;None    return resget(&#39;https:&#x2F;&#x2F;www.python.org&#39;)</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-7f0323790a39e9352c1a1a6671fb9623_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73346821?p=6">python快速入门补充_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73346821?p=6<img src="https://pic4.zhimg.com/v2-2e36f1807728ea385dcbcf702a634e37_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>29-元类</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/29_%E5%85%83%E7%B1%BB/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/29_%E5%85%83%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-元类介绍"><a href="#一-元类介绍" class="headerlink" title="一 元类介绍"></a>一 元类介绍</h2><p><img src="https://pic1.zhimg.com/80/v2-29cebafe1389b48a2773171be4c65688_720w.jpg" alt="img"></p><p>什么是元类呢？一切源自于一句话：python中一切皆为对象。让我们先定义一个类，然后逐步分析</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class StanfordTeacher(object):    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)</code></pre></div></figure><p>所有的对象都是实例化或者说调用类而得到的（调用类的过程称为类的实例化），比如对象t1是调用类StanfordTeacher得到的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">t1&#x3D;StanfordTeacher(&#39;lili&#39;,18)print(type(t1)) #查看对象t1的类是&lt;class &#39;__main__.StanfordTeacher&#39;&gt;</code></pre></div></figure><p>如果一切皆为对象，那么类StanfordTeacher本质也是一个对象，既然所有的对象都是调用类得到的，那么StanfordTeacher必然也是调用了一个类得到的，这个类称为元类</p><p><strong>于是我们可以推导出&#x3D;&#x3D;&#x3D;&gt;产生StanfordTeacher的过程一定发生了：StanfordTeacher&#x3D;元类(…)</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(type(StanfordTeacher)) # 结果为&lt;class &#39;type&#39;&gt;，证明是调用了type这个元类而产生的StanfordTeacher，即默认的元类为type</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-0c3a9e7d4555f2ad236b5b2952ccfc0f_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-51512d73604c757d83751fb2a486cad6_720w.jpg" alt="img"></p><h2 id="二-class关键字创建类的流程分析"><a href="#二-class关键字创建类的流程分析" class="headerlink" title="二 class关键字创建类的流程分析"></a>二 class关键字创建类的流程分析</h2><p>上文我们基于python中一切皆为对象的概念分析出：我们用class关键字定义的类本身也是一个对象，负责产生该对象的类称之为元类（元类可以简称为类的类），内置的元类为type</p><p>class关键字在帮我们创建类时，必然帮我们调用了元类StanfordTeacher&#x3D;type(…)，那调用type时传入的参数是什么呢？必然是类的关键组成部分，一个类有三大组成部分，分别是</p><p>1、类名class_name&#x3D;’StanfordTeacher’</p><p>2、基类们class_bases&#x3D;(object,)</p><p>3、类的名称空间class_dic，类的名称空间是执行类体代码而得到的</p><p>调用type时会依次传入以上三个参数</p><p>综上，class关键字帮我们创建一个类应该细分为以下四个过程</p><p><img src="https://pic3.zhimg.com/80/v2-434226f9a3a7c464e73981972ab666a6_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-6b9d3aedf59408e10a7e6d17ce5f834a_720w.jpg" alt="img"></p><p>补充：exec的用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#exec：三个参数#参数一：包含一系列python代码的字符串#参数二：全局作用域（字典形式），如果不指定，默认为globals()#参数三：局部作用域（字典形式），如果不指定，默认为locals()#可以把exec命令的执行当成是一个函数的执行，会将执行期间产生的名字存放于局部名称空间中g&#x3D;&#123;    &#39;x&#39;:1,    &#39;y&#39;:2&#125;l&#x3D;&#123;&#125;exec(&#39;&#39;&#39;global x,zx&#x3D;100z&#x3D;200m&#x3D;300&#39;&#39;&#39;,g,l)print(g) #&#123;&#39;x&#39;: 100, &#39;y&#39;: 2,&#39;z&#39;:200,......&#125;print(l) #&#123;&#39;m&#39;: 300&#125;</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-1c83a64a4831811981dd5db4aafb3e6a_720w.jpg" alt="img"></p><h2 id="四-自定义元类控制类StanfordTeacher的创建"><a href="#四-自定义元类控制类StanfordTeacher的创建" class="headerlink" title="四 自定义元类控制类StanfordTeacher的创建"></a>四 自定义元类控制类StanfordTeacher的创建</h2><p>一个类没有声明自己的元类，默认他的元类就是type，除了使用内置元类type，我们也可以通过继承type来自定义元类，然后使用metaclass关键字参数为一个类指定元类</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类    pass# StanfordTeacher&#x3D;Mymeta(&#39;StanfordTeacher&#39;,(object),&#123;...&#125;)class StanfordTeacher(object,metaclass&#x3D;Mymeta):     school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-8efe701a4c33c45178b9ecbf8de2c5de_720w.jpg" alt="img"></p><p>自定义元类可以控制类的产生过程，类的产生过程其实就是元类的调用过程,即StanfordTeacher&#x3D;Mymeta(‘StanfordTeacher’,(object),{…})，调用Mymeta会先产生一个空对象StanfordTeacher，然后连同调用Mymeta括号内的参数一同传给Mymeta下的__init__方法，完成初始化，于是我们可以</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类    def __init__(self,class_name,class_bases,class_dic):        # print(self) #&lt;class &#39;__main__.StanfordTeacher&#39;&gt;        # print(class_bases) #(&lt;class &#39;object&#39;&gt;,)        # print(class_dic) #&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;StanfordTeacher&#39;, &#39;school&#39;: &#39;Stanford&#39;, &#39;__init__&#39;: &lt;function StanfordTeacher.__init__ at 0x102b95ae8&gt;, &#39;say&#39;: &lt;function StanfordTeacher.say at 0x10621c6a8&gt;&#125;        super(Mymeta, self).__init__(class_name, class_bases, class_dic)  # 重用父类的功能        if class_name.islower():            raise TypeError(&#39;类名%s请修改为驼峰体&#39; %class_name)        if &#39;__doc__&#39; not in class_dic or len(class_dic[&#39;__doc__&#39;].strip(&#39; \n&#39;)) &#x3D;&#x3D; 0:            raise TypeError(&#39;类中必须有文档注释，并且文档注释不能为空&#39;)# StanfordTeacher&#x3D;Mymeta(&#39;StanfordTeacher&#39;,(object),&#123;...&#125;)class StanfordTeacher(object,metaclass&#x3D;Mymeta):     &quot;&quot;&quot;    类StanfordTeacher的文档注释    &quot;&quot;&quot;    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-cb7c3e73b09fc81f61bde2d076aeb605_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-ac1e4d27769d13173968120e88ae3954_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-583d76e816de5247564f2452a3050fc8_720w.jpg" alt="img"></p><h2 id="五-自定义元类控制类StanfordTeacher的调用"><a href="#五-自定义元类控制类StanfordTeacher的调用" class="headerlink" title="五 自定义元类控制类StanfordTeacher的调用"></a>五 自定义元类控制类StanfordTeacher的调用</h2><p>储备知识：<strong>call</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Foo:    def __call__(self, *args, **kwargs):        print(self)        print(args)        print(kwargs)obj&#x3D;Foo()#1、要想让obj这个对象变成一个可调用的对象，需要在该对象的类中定义一个方法__call__方法，该方法会在调用对象时自动触发#2、调用obj的返回值就是__call__方法的返回值res&#x3D;obj(1,2,3,x&#x3D;1,y&#x3D;2)</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-69fee84a115c801a72c489b2047a11ab_720w.jpg" alt="img"></p><p>由上例得知，调用一个对象，就是触发对象所在类中的__call__方法的执行，如果把StanfordTeacher也当做一个对象，那么在StanfordTeacher这个对象的类中也必然存在一个__call__方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类    def __call__(self, *args, **kwargs):        print(self) #&lt;class &#39;__main__.StanfordTeacher&#39;&gt;        print(args) #(&#39;lili&#39;, 18)        print(kwargs) #&#123;&#125;        return 123class StanfordTeacher(object,metaclass&#x3D;Mymeta):    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)# 调用StanfordTeacher就是在调用StanfordTeacher类中的__call__方法# 然后将StanfordTeacher传给self,溢出的位置参数传给*，溢出的关键字参数传给**# 调用StanfordTeacher的返回值就是调用__call__的返回值t1&#x3D;StanfordTeacher(&#39;lili&#39;,18)print(t1) #123</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-138ef01613092ea6cdfce93a4fca1133_720w.jpg" alt="img"></p><p>默认地，调用t1&#x3D;StanfordTeacher(‘lili’,18)会做三件事</p><p>1、产生一个空对象obj</p><p>2、调用__init__方法初始化对象obj</p><p>3、返回初始化好的obj</p><p>对应着，StanfordTeacher类中的__call__方法也应该做这三件事</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.StanfordTeacher&#39;&gt;        #1、调用__new__产生一个空对象obj        obj&#x3D;self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个StanfordTeacher的对象obj        #2、调用__init__初始化空对象obj        self.__init__(obj,*args,**kwargs)        #3、返回初始化好的对象obj        return objclass StanfordTeacher(object,metaclass&#x3D;Mymeta):    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)t1&#x3D;StanfordTeacher(&#39;lili&#39;,18)print(t1.__dict__) #&#123;&#39;name&#39;: &#39;lili&#39;, &#39;age&#39;: 18&#125;</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-9869aa7ace53374e834e800453c2b911_720w.jpg" alt="img"></p><p>上例的__call__相当于一个模板，我们可以在该基础上改写__call__的逻辑从而控制调用StanfordTeacher的过程，比如将StanfordTeacher的对象的所有属性都变成私有的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.StanfordTeacher&#39;&gt;        #1、调用__new__产生一个空对象obj        obj&#x3D;self.__new__(self) # 此处的self是类StanfordTeacher，必须传参，代表创建一个StanfordTeacher的对象obj        #2、调用__init__初始化空对象obj        self.__init__(obj,*args,**kwargs)        # 在初始化之后，obj.__dict__里就有值了        obj.__dict__&#x3D;&#123;&#39;_%s__%s&#39; %(self.__name__,k):v for k,v in obj.__dict__.items()&#125;        #3、返回初始化好的对象obj        return objclass StanfordTeacher(object,metaclass&#x3D;Mymeta):    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)t1&#x3D;StanfordTeacher(&#39;lili&#39;,18)print(t1.__dict__) #&#123;&#39;_StanfordTeacher__name&#39;: &#39;lili&#39;, &#39;_StanfordTeacher__age&#39;: 18&#125;</code></pre></div></figure><p>上例中涉及到查找属性的问题，比如self.__new__，请看下一小节</p><p><img src="https://pic2.zhimg.com/80/v2-9869aa7ace53374e834e800453c2b911_720w.jpg" alt="img"></p><h2 id="五-再看属性查找"><a href="#五-再看属性查找" class="headerlink" title="五 再看属性查找"></a>五 再看属性查找</h2><p>结合python继承的实现原理+元类重新看属性的查找应该是什么样子呢？？？</p><p><img src="https://pic4.zhimg.com/80/v2-771f5846e57b1e89944a7135f9f307a7_720w.jpg" alt="img"></p><p>在学习完元类后，其实我们用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看），我们学习过继承的实现原理，如果把类当成对象去看，将下述继承应该说成是：对象StanfordTeacher继承对象Foo，对象Foo继承对象Bar，对象Bar继承对象object</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类    n&#x3D;444    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.StanfordTeacher&#39;&gt;        obj&#x3D;self.__new__(self)        self.__init__(obj,*args,**kwargs)        return objclass Bar(object):    n&#x3D;333class Foo(Bar):    n&#x3D;222class StanfordTeacher(Foo,metaclass&#x3D;Mymeta):    n&#x3D;111    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)print(StanfordTeacher.n) #自下而上依次注释各个类中的n&#x3D;xxx，然后重新运行程序，发现n的查找顺序为StanfordTeacher-&gt;Foo-&gt;Bar-&gt;object-&gt;Mymeta-&gt;type</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-1c83a64a4831811981dd5db4aafb3e6a_720w.jpg" alt="img"></p><p>于是属性查找应该分成两层，一层是对象层（基于c3算法的MRO）的查找，另外一个层则是类层（即元类层）的查找</p><p><img src="https://pic4.zhimg.com/80/v2-ddf630cf4b846c88c1ab506ba573521b_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#查找顺序：#1、先对象层：StanfordTeacher-&gt;Foo-&gt;Bar-&gt;object#2、然后元类层：Mymeta-&gt;type</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-1f4193a21056eeed75d3e4f9bbba57b3_720w.jpg" alt="img"></p><p>依据上述总结，我们来分析下元类Mymeta中__call__里的self.__new__的查找</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type):     n&#x3D;444    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.StanfordTeacher&#39;&gt;        obj&#x3D;self.__new__(self)        print(self.__new__ is object.__new__) #Trueclass Bar(object):    n&#x3D;333    # def __new__(cls, *args, **kwargs):    #     print(&#39;Bar.__new__&#39;)class Foo(Bar):    n&#x3D;222    # def __new__(cls, *args, **kwargs):    #     print(&#39;Foo.__new__&#39;)class StanfordTeacher(Foo,metaclass&#x3D;Mymeta):    n&#x3D;111    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)    # def __new__(cls, *args, **kwargs):    #     print(&#39;StanfordTeacher.__new__&#39;)StanfordTeacher(&#39;lili&#39;,18) #触发StanfordTeacher的类中的__call__方法的执行，进而执行self.__new__开始查找</code></pre></div></figure><p>总结，Mymeta下的__call__里的self.<strong>new__在StanfordTeacher、Foo、Bar里都没有找到__new__的情况下，会去找object里的__new__，而object下默认就有一个__new__，所以即便是之前的类均未实现__new</strong>,也一定会在object中找到一个，根本不会、也根本没必要再去找元类Mymeta-&gt;type中查找__new__</p><p><img src="https://pic3.zhimg.com/80/v2-cdbf64639b7652fb9698c52e856ecbbe_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-0efee7de2aeae470f383336f50f4f2a1_720w.jpg" alt="img"></p><p>我们在元类的__call__中也可以用object.<strong>new</strong>(self)去造对象</p><p><img src="https://pic4.zhimg.com/80/v2-657eafd32c29b05e69777e671975d867_720w.jpg" alt="img"></p><p><strong>但我们还是推荐在__call__中使用self.<strong>new</strong>(self)去创造空对象，因为这种方式会检索三个类StanfordTeacher-&gt;Foo-&gt;Bar,而object.__new__则是直接跨过了他们三个</strong></p><p>最后说明一点</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类    n&#x3D;444    def __new__(cls, *args, **kwargs):        obj&#x3D;type.__new__(cls,*args,**kwargs) # 必须按照这种传值方式        print(obj.__dict__)        # return obj # 只有在返回值是type的对象时，才会触发下面的__init__        return 123    def __init__(self,class_name,class_bases,class_dic):        print(&#39;run。。。&#39;)class StanfordTeacher(object,metaclass&#x3D;Mymeta): #StanfordTeacher&#x3D;Mymeta(&#39;StanfordTeacher&#39;,(object),&#123;...&#125;)    n&#x3D;111    school&#x3D;&#39;Stanford&#39;    def __init__(self,name,age):        self.name&#x3D;name        self.age&#x3D;age    def say(self):        print(&#39;%s says welcome to the Stanford to learn Python&#39; %self.name)print(type(Mymeta)) #&lt;class &#39;type&#39;&gt;# 产生类StanfordTeacher的过程就是在调用Mymeta，而Mymeta也是type类的一个对象，那么Mymeta之所以可以调用，一定是在元类type中有一个__call__方法# 该方法中同样需要做至少三件事：# class type:#     def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.Mymeta&#39;&gt;#         obj&#x3D;self.__new__(self,*args,**kwargs) # 产生Mymeta的一个对象#         self.__init__(obj,*args,**kwargs) #         return obj</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-f3490b306ed20138970d52fac3f665c0_720w.jpg" alt="img"></p><h2 id="六-作业"><a href="#六-作业" class="headerlink" title="六 作业"></a>六 作业</h2><p><img src="https://pic2.zhimg.com/80/v2-d550ffee42388e25d9edb134f3b958a1_720w.jpg" alt="img"></p><p><strong>1、在元类中控制把自定义类的数据属性都变成大写</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymetaclass(type):    def __new__(cls,name,bases,attrs):        update_attrs&#x3D;&#123;&#125;        for k,v in attrs.items():            if not callable(v) and not k.startswith(&#39;__&#39;):                update_attrs[k.upper()]&#x3D;v            else:                update_attrs[k]&#x3D;v        return type.__new__(cls,name,bases,update_attrs)class Chinese(metaclass&#x3D;Mymetaclass):    country&#x3D;&#39;China&#39;    tag&#x3D;&#39;Legend of the Dragon&#39; #龙的传人    def walk(self):        print(&#39;%s is walking&#39; %self.name)print(Chinese.__dict__)&#39;&#39;&#39;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;COUNTRY&#39;: &#39;China&#39;,  &#39;TAG&#39;: &#39;Legend of the Dragon&#39;, &#39;walk&#39;: &lt;function Chinese.walk at 0x0000000001E7B950&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Chinese&#39; objects&gt;,                                          &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Chinese&#39; objects&gt;, &#39;__doc__&#39;: None&#125;&#39;&#39;&#39;</code></pre></div></figure><p><strong>2、在元类中控制自定义的类无需__init__方法</strong></p><p> 1.元类帮其完成创建对象，以及初始化操作；</p><p>2.要求实例化时传参必须为关键字形式，否则抛出异常TypeError: must use keyword argument</p><p>3.key作为用户自定义类产生对象的属性，且所有属性变成大写</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymetaclass(type):    # def __new__(cls,name,bases,attrs):    #     update_attrs&#x3D;&#123;&#125;    #     for k,v in attrs.items():    #         if not callable(v) and not k.startswith(&#39;__&#39;):    #             update_attrs[k.upper()]&#x3D;v    #         else:    #             update_attrs[k]&#x3D;v    #     return type.__new__(cls,name,bases,update_attrs)    def __call__(self, *args, **kwargs):        if args:            raise TypeError(&#39;must use keyword argument for key function&#39;)        obj &#x3D; object.__new__(self) #创建对象，self为类Foo        for k,v in kwargs.items():            obj.__dict__[k.upper()]&#x3D;v        return objclass Chinese(metaclass&#x3D;Mymetaclass):    country&#x3D;&#39;China&#39;    tag&#x3D;&#39;Legend of the Dragon&#39; #龙的传人    def walk(self):        print(&#39;%s is walking&#39; %self.name)p&#x3D;Chinese(name&#x3D;&#39;lili&#39;,age&#x3D;18,sex&#x3D;&#39;male&#39;)print(p.__dict__)</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-63bab846a06315171b4c8ac24c4cf44c_720w.jpg" alt="img"></p><p><strong>3、在元类中控制自定义的类产生的对象相关的属性全部为隐藏属性</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Mymeta(type):    def __init__(self,class_name,class_bases,class_dic):        #控制类Foo的创建        super(Mymeta,self).__init__(class_name,class_bases,class_dic)    def __call__(self, *args, **kwargs):        #控制Foo的调用过程，即Foo对象的产生过程        obj &#x3D; self.__new__(self)        self.__init__(obj, *args, **kwargs)        obj.__dict__&#x3D;&#123;&#39;_%s__%s&#39; %(self.__name__,k):v for k,v in obj.__dict__.items()&#125;        return objclass Foo(object,metaclass&#x3D;Mymeta):  # Foo&#x3D;Mymeta(...)    def __init__(self, name, age,sex):        self.name&#x3D;name        self.age&#x3D;age        self.sex&#x3D;sexobj&#x3D;Foo(&#39;lili&#39;,18,&#39;male&#39;)print(obj.__dict__)</code></pre></div></figure><p><strong>4、基于元类实现单例模式</strong></p><p><img src="https://pic3.zhimg.com/80/v2-b80f116811d7948d519390f4021f160a_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#步骤五：基于元类实现单例模式# 单例：即单个实例，指的是同一个类实例化多次的结果指向同一个对象，用于节省内存空间# 如果我们从配置文件中读取配置来进行实例化，在配置相同的情况下，就没必要重复产生对象浪费内存了#settings.py文件内容如下HOST&#x3D;&#39;1.1.1.1&#39;PORT&#x3D;3306#方式一:定义一个类方法实现单例模式import settingsclass Mysql:    __instance&#x3D;None    def __init__(self,host,port):        self.host&#x3D;host        self.port&#x3D;port    @classmethod    def singleton(cls):        if not cls.__instance:            cls.__instance&#x3D;cls(settings.HOST,settings.PORT)        return cls.__instanceobj1&#x3D;Mysql(&#39;1.1.1.2&#39;,3306)obj2&#x3D;Mysql(&#39;1.1.1.3&#39;,3307)print(obj1 is obj2) #Falseobj3&#x3D;Mysql.singleton()obj4&#x3D;Mysql.singleton()print(obj3 is obj4) #True#方式二：定制元类实现单例模式import settingsclass Mymeta(type):    def __init__(self,name,bases,dic): #定义类Mysql时就触发        # 事先先从配置文件中取配置来造一个Mysql的实例出来        self.__instance &#x3D; object.__new__(self)  # 产生对象        self.__init__(self.__instance, settings.HOST, settings.PORT)  # 初始化对象        # 上述两步可以合成下面一步        # self.__instance&#x3D;super().__call__(*args,**kwargs)        super().__init__(name,bases,dic)    def __call__(self, *args, **kwargs): #Mysql(...)时触发        if args or kwargs: # args或kwargs内有值            obj&#x3D;object.__new__(self)            self.__init__(obj,*args,**kwargs)            return obj        return self.__instanceclass Mysql(metaclass&#x3D;Mymeta):    def __init__(self,host,port):        self.host&#x3D;host        self.port&#x3D;portobj1&#x3D;Mysql() # 没有传值则默认从配置文件中读配置来实例化，所有的实例应该指向一个内存地址obj2&#x3D;Mysql()obj3&#x3D;Mysql()print(obj1 is obj2 is obj3)obj4&#x3D;Mysql(&#39;1.1.1.4&#39;,3307)#方式三:定义一个装饰器实现单例模式import settingsdef singleton(cls): #cls&#x3D;Mysql    _instance&#x3D;cls(settings.HOST,settings.PORT)    def wrapper(*args,**kwargs):        if args or kwargs:            obj&#x3D;cls(*args,**kwargs)            return obj        return _instance    return wrapper@singleton # Mysql&#x3D;singleton(Mysql)class Mysql:    def __init__(self,host,port):        self.host&#x3D;host        self.port&#x3D;portobj1&#x3D;Mysql()obj2&#x3D;Mysql()obj3&#x3D;Mysql()print(obj1 is obj2 is obj3) #Trueobj4&#x3D;Mysql(&#39;1.1.1.3&#39;,3307)obj5&#x3D;Mysql(&#39;1.1.1.4&#39;,3308)print(obj3 is obj4) #False</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-9751369a2d4179f20d716d81f5cbbd19_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73346821?p=1">python快速入门补充_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73346821?p=1  </a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28-反射和内置方法</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/28_%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/28_%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一-反射"><a href="#一-反射" class="headerlink" title="一 反射"></a>一 反射</h2><p><img src="https://pic2.zhimg.com/80/v2-3d1d85b30d01da04b681d316cb460975_720w.jpg" alt="img"></p><p>python是动态语言，而反射(reflection)机制被视为动态语言的关键。</p><p>反射机制指的是在程序的运行状态中</p><p>对于任意一个类，都可以知道这个类的所有属性和方法；</p><p>对于任意一个对象，都能够调用他的任意方法和属性。</p><p>这种动态获取程序信息以及动态调用对象的功能称为反射机制。</p><p>在python中实现反射非常简单，在程序运行过程中，如果我们获取一个不知道存有何种属性的对象，若想操作其内部属性，可以先通过内置函数dir来获取任意一个类或者对象的属性列表，列表中全为字符串格式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class People:...     def __init__(self,name,age,gender):...         self.name&#x3D;name...         self.age&#x3D;age...         self.gender&#x3D;gender... &gt;&gt;&gt; obj&#x3D;People(&#39;egon&#39;,18,&#39;male&#39;)&gt;&gt;&gt; dir(obj) # 列表中查看到的属性全为字符串[......,&#39;age&#39;, &#39;gender&#39;, &#39;name&#39;]</code></pre></div></figure><p>接下来就是想办法通过字符串来操作对象的属性了，这就涉及到内置函数hasattr、getattr、setattr、delattr的使用了（Python中一切皆对象，类和对象都可以被这四个函数操作，用法一样）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Teacher:    def __init__(self,full_name):        self.full_name &#x3D;full_namet&#x3D;Teacher(&#39;Egon Lin&#39;)# hasattr(object,&#39;name&#39;)hasattr(t,&#39;full_name&#39;) # 按字符串&#39;full_name&#39;判断有无属性t.full_name# getattr(object, &#39;name&#39;, default&#x3D;None)getattr(t,&#39;full_name&#39;,None) # 等同于t.full_name,不存在该属性则返回默认值None# setattr(x, &#39;y&#39;, v)setattr(t,&#39;age&#39;,18) # 等同于t.age&#x3D;18# delattr(x, &#39;y&#39;)delattr(t,&#39;age&#39;) # 等同于del t.age</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-9bc82da339b0bf1fab4fa4c5da110592_720w.jpg" alt="img"></p><p>基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class FtpServer:...     def serve_forever(self):...         while True:...             inp&#x3D;input(&#39;input your cmd&gt;&gt;: &#39;).strip()...             cmd,file&#x3D;inp.split()...             if hasattr(self,cmd): # 根据用户输入的cmd，判断对象self有无对应的方法属性...                 func&#x3D;getattr(self,cmd) # 根据字符串cmd，获取对象self对应的方法属性...                 func(file)...     def get(self,file):...         print(&#39;Downloading %s...&#39; %file)...     def put(self,file):...         print(&#39;Uploading %s...&#39; %file)... &gt;&gt;&gt; server&#x3D;FtpServer()&gt;&gt;&gt; server.serve_forever()input your cmd&gt;&gt;: get a.txtDownloading a.txt...input your cmd&gt;&gt;: put a.txtUploading a.txt...</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-97d87ec7c2fe74480aad298b224565a0_720w.jpg" alt="img"></p><h2 id="二-内置方法"><a href="#二-内置方法" class="headerlink" title="二 内置方法"></a>二 内置方法</h2><p>Python的Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发，我们以常用的__str__和__del__为例来简单介绍它们的使用。</p><p><img src="https://pic4.zhimg.com/80/v2-6e4601a804f239a1f7f9a2aa14d8879f_720w.jpg" alt="img"></p><p>__str__方法会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class People:...     def __init__(self,name,age):...         self.name&#x3D;name...         self.age&#x3D;age...     def __str__(self):...         return &#39;&lt;Name:%s Age:%s&gt;&#39; %(self.name,self.age) #返回类型必须是字符串... &gt;&gt;&gt; p&#x3D;People(&#39;lili&#39;,18)&gt;&gt;&gt; print(p) #触发p.__str__()，拿到返回值后进行打印&lt;Name:lili Age:18&gt;</code></pre></div></figure><p>__del__会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制__del__方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MySQL:    def __init__(self,ip,port):        self.conn&#x3D;connect(ip,port) # 伪代码，发起网络连接，需要占用系统资源    def __del__(self):        self.conn.close() # 关闭网络连接，回收系统资源obj&#x3D;MySQL(&#39;127.0.0.1&#39;,3306) # 在对象obj被删除时，自动触发obj.__del__()</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-d760c34985ac2f1797ea5c3e718e28be_720w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26-绑定方法和非绑定方法</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/27_%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/27_%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一-绑定方法与非绑定方法"><a href="#一-绑定方法与非绑定方法" class="headerlink" title="一 绑定方法与非绑定方法"></a>一 绑定方法与非绑定方法</h2><p> 类中定义的函数分为两大类：绑定方法和非绑定方法</p><p> 其中绑定方法又分为绑定到对象的对象方法和绑定到类的类方法。</p><p> 在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器@classmethod后，该函数就绑定到了类。</p><p><img src="https://pic1.zhimg.com/80/v2-a60b7d2829a72bfcca8dd8d0c74fb028_720w.jpg" alt="img"></p><p> 我们在之前的章节中已经介绍过对象方法了，本节我们主要介绍类方法。类方法通常用来在__init__的基础上提供额外的初始化实例的方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 配置文件settings.py的内容HOST&#x3D;&#39;127.0.0.1&#39;PORT&#x3D;3306# 类方法的应用import settingsclass MySQL:    def __init__(self,host,port):        self.host&#x3D;host        self.port&#x3D;port    @classmethod    def from_conf(cls): # 从配置文件中读取配置进行初始化        return cls(settings.HOST,settings.PORT)&gt;&gt;&gt; MySQL.from_conf # 绑定到类的方法&lt;bound method MySQL.from_conf of &lt;class ‘__main__.MySQL&#39;&gt;&gt;&gt;&gt;&gt; conn&#x3D;MySQL.from_conf() # 调用类方法，自动将类MySQL当作第一个参数传给cls</code></pre></div></figure><p>绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用是没有意义的，并且容易引起混淆，这也是Python的对象系统与其他面向对象语言对象系统的区别之一，比如Smalltalk和Ruby中，绑定到类的方法与绑定到对象的方法是严格区分开的。</p><p><img src="https://pic1.zhimg.com/80/v2-ac3327054b536d6be35c9664c05cf4ac_720w.jpg" alt="img"></p><h2 id="二-非绑定方法"><a href="#二-非绑定方法" class="headerlink" title="二 非绑定方法"></a>二 非绑定方法</h2><p>为类中某个函数加上装饰器@staticmethod后，该函数就变成了非绑定方法，也称为静态方法。该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，因而没有自动传值那么一说</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import uuidclass MySQL:    def __init__(self,host,port):        self.id&#x3D;self.create_id()        self.host&#x3D;host        self.port&#x3D;port    @staticmethod    def create_id():        return uuid.uuid1()&gt;&gt;&gt; conn&#x3D;MySQL(‘127.0.0.1&#39;,3306)&gt;&gt;&gt; print(conn.id) #100365f6-8ae0-11e7-a51e-0088653ea1ec# 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法&gt;&gt;&gt; MySQL.create_id&lt;function MySQL.create_id at 0x1025c16a8&gt;&gt;&gt;&gt; conn.create_id&lt;function MySQL.create_id at 0x1025c16a8&gt;</code></pre></div></figure><p>总结绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法。</p><p><img src="https://pic4.zhimg.com/80/v2-66b5c969960fb21cd5d0f69ea6364e1f_720w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26-多态与鸭子类型</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/26_%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/26_%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="多态与多态性"><a href="#多态与多态性" class="headerlink" title="多态与多态性"></a>多态与多态性</h2><p>多态指的是一类事物有多种形态，比如动物有多种形态：猫、狗、猪</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Animal: #同一类事物:动物    def talk(self):        passclass Cat(Animal): #动物的形态之一:猫    def talk(self):        print(&#39;喵喵喵&#39;)class Dog(Animal): #动物的形态之二:狗    def talk(self):        print(&#39;汪汪汪&#39;)class Pig(Animal): #动物的形态之三:猪    def talk(self):        print(&#39;哼哼哼&#39;)#实例化得到三个对象&gt;&gt;&gt; cat&#x3D;Cat()&gt;&gt;&gt; dog&#x3D;Dog()&gt;&gt;&gt; pig&#x3D;Pig()</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-422b662cd3ea9bc9566bccae2e2a6a5e_720w.jpg" alt="img"></p><p>多态性指的是可以在不用考虑对象具体类型的情况下而直接使用对象，这就需要在设计时，把对象的使用方法统一成一种：例如cat、dog、pig都是动物,但凡是动物肯定有talk方法，于是我们可以不用考虑它们三者的具体是什么类型的动物,而直接使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; cat.talk()喵喵喵&gt;&gt;&gt; dog.talk()汪汪汪&gt;&gt;&gt; pig.talk()哼哼哼</code></pre></div></figure><p>更进一步,我们可以定义一个统一的接口来使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def Talk(animal):...     animal.talk()... &gt;&gt;&gt; Talk(cat)喵喵喵&gt;&gt;&gt; Talk(dog)汪汪汪&gt;&gt;&gt; Talk(pig)哼哼哼</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-382e86f07927121108888dea757b1a9a_720w.jpg" alt="img"></p><p>Python中一切皆对象，本身就支持多态性</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 我们可以在不考虑三者类型的情况下直接使用统计三个对象的长度s.__len__()l.__len__()t.__len__()# Python内置了一个统一的接口len(s)len(l)len(t)</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-3d3cdbecfc5d47a2ac2f3143e1abd205_720w.jpg" alt="img"></p><p>多态性的好处在于增强了程序的灵活性和可扩展性，比如通过继承Animal类创建了一个新的类，实例化得到的对象obj，可以使用相同的方式使用obj.talk()</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Wolf(Animal): #动物的另外一种形态：狼...     def talk(self):...         print(&#39;嗷...&#39;)... &gt;&gt;&gt; wolf&#x3D;Wolf() # 实例出一头狼&gt;&gt;&gt; wolf.talk() # 使用者根本无需关心wolf是什么类型而调用talk嗷...</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-b091d792728d28043c60245f801b1d80_720w.jpg" alt="img"></p><p>综上我们得知，多态性的本质在于不同的类中定义有相同的方法名，这样我们就可以不考虑类而统一用一种方式去使用对象，可以通过在父类引入抽象类的概念来硬性限制子类必须有某些方法名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import abc# 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，不能被实例化class Animal(metaclass&#x3D;abc.ABCMeta):    @abc.abstractmethod # 该装饰器限制子类必须定义有一个名为talk的方法    def talk(self): # 抽象方法中无需实现具体的功能        passclass Cat(Animal): # 但凡继承Animal的子类都必须遵循Animal规定的标准    def talk(self):        passcat&#x3D;Cat() # 若子类中没有一个名为talk的方法则会抛出异常TypeError，无法实例化</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-9835c439fe40447cec2e8c0417181828_720w.jpg" alt="img"></p><p>但其实我们完全可以不依赖于继承，只需要制造出外观和行为相同对象，同样可以实现不考虑对象类型而使用对象，这正是Python崇尚的“鸭子类型”（duck typing）：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子”。比起继承的方式，鸭子类型在某种程度上实现了程序的松耦合度，如下</p><p><img src="https://pic3.zhimg.com/80/v2-703589a4b0d56594a97612979289495e_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#二者看起来都像文件,因而就可以当文件一样去用，然而它们并没有直接的关系class Txt: #Txt类有两个与文件类型同名的方法，即read和write    def read(self):        pass    def write(self):        passclass Disk: #Disk类也有两个与文件类型同名的方法：read和write    def read(self):        pass    def write(self):        pass</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-97aafbff736a6fa0f2cf945a4a47dca9_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=110">https://www.bilibili.com/video/av73342471?p=110www.bilibili.com/video/av73342471?p=110</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23-面向对象编程</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/23_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/23_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-对象的概念"><a href="#一-对象的概念" class="headerlink" title="一 对象的概念"></a>一 对象的概念</h2><p><img src="https://pic2.zhimg.com/80/v2-9e0fb874291cdb93dc680387fb4b6895_720w.jpg" alt="img"></p><p>”面向对象“的核心是“对象”二字，而对象的精髓在于“整合“，什么意思？</p><p><img src="https://pic3.zhimg.com/80/v2-35fa66297dc63ecf396e6cbdbdf55e82_720w.jpg" alt="img"></p><p>所有的程序都是由”数据”与“功能“组成，因而编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。在学习”对象“之前，程序中的数据与功能是分离开的，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 数据：name、age、sexname&#x3D;&#39;lili&#39;age&#x3D;18sex&#x3D;&#39;female&#39;# 功能：tell_infodef tell_info(name,age,sex):     print(&#39;&lt;%s:%s:%s&gt;&#39; %(name,age,sex))# 此时若想执行查看个人信息的功能，需要同时拿来两样东西，一类是功能tell_info，另外一类则是多个数据name、age、sex，然后才能执行，非常麻烦tell_info(name,age,sex)</code></pre></div></figure><p>在学习了“对象”之后，我们就有了一个容器，该容器可以盛放数据与功能，所以我们可以说：对象是把数据与功能整合到一起的产物，或者说”对象“就是一个盛放数据与功能的容器&#x2F;箱子&#x2F;盒子。</p><p>如果把”数据“比喻为”睫毛膏“、”眼影“、”唇彩“等化妆所需要的原材料；把”功能“比喻为眼线笔、眉笔等化妆所需要的工具，那么”对象“就是一个彩妆盒，彩妆盒可以把”原材料“与”工具“都装到一起</p><p><img src="https://pic2.zhimg.com/80/v2-0e2848da85da660b62cd804505d52095_720w.jpg" alt="img"></p><p>如果我们把”化妆“比喻为要执行的业务逻辑，此时只需要拿来一样东西即可，那就是彩妆盒，因为彩妆盒里整合了化妆所需的所有原材料与功能，这比起你分别拿来原材料与功能才能执行，要方便的多。</p><p><img src="https://pic2.zhimg.com/80/v2-4cb7055278382e36149f1ebc48d995e5_720w.jpg" alt="img"></p><p> 在了解了对象的基本概念之后，理解面向对象的编程方式就相对简单很多了，面向对象编程就是要造出一个个的对象，把原本分散开的相关数据与功能整合到一个个的对象里，这么做既方便使用，也可以提高程序的解耦合程度，进而提升了程序的可扩展性（需要强调的是，软件质量属性包含很多方面，面向对象解决的仅仅只是扩展性问题）</p><p><img src="https://pic1.zhimg.com/80/v2-be68cd9e27b83c937cf44dbe7a2cf56c_720w.jpg" alt="img"></p><h2 id="二-类与对象"><a href="#二-类与对象" class="headerlink" title="二 类与对象"></a>二 类与对象</h2><p>类即类别&#x2F;种类，是面向对象分析和设计的基石，如果多个对象有相似的数据与功能，那么该多个对象就属于同一种类。有了类的好处是：我们可以把同一类对象相同的数据与功能存放到类里，而无需每个对象都重复存一份，这样每个对象里只需存自己独有的数据即可，极大地节省了空间。所以，如果说对象是用来存放数据与功能的容器，那么类则是用来存放多个对象相同的数据与功能的容器。</p><p><img src="https://pic2.zhimg.com/80/v2-0b1c2138d316307c0c830aa1df3aa1e1_720w.jpg" alt="img"></p><p> 综上所述，虽然我们是先介绍对象后介绍类，但是需要强调的是：在程序中，必须要事先定义类，然后再调用类产生对象（调用类拿到的返回值就是对象）。产生对象的类与对象之间存在关联，这种关联指的是：对象可以访问到类中共有的数据与功能，所以类中的内容仍然是属于对象的，类只不过是一种节省空间、减少代码冗余的机制，面向对象编程最终的核心仍然是去使用对象。</p><p> 在了解了类与对象这两大核心概念之后，我们就可以来介绍一下面向对象编程啦。</p><p><img src="https://pic3.zhimg.com/80/v2-dad32bbb5927e33abfc0003c07c6edd2_720w.jpg" alt="img"></p><h2 id="三-面向对象编程"><a href="#三-面向对象编程" class="headerlink" title="三 面向对象编程"></a>三 面向对象编程</h2><h2 id="3-1-类的定义与实例化"><a href="#3-1-类的定义与实例化" class="headerlink" title="3.1 类的定义与实例化"></a>3.1 类的定义与实例化</h2><p>我们以开发一个清华大学的选课系统为例，来简单介绍基于面向对象的思想如何编写程序</p><p><img src="https://pic3.zhimg.com/80/v2-39114d379b38da06b6a6b9923573e30a_720w.jpg" alt="img"></p><p>面向对象的基本思路就是把程序中要用到的、相关联的数据与功能整合到对象里，然后再去使用，但程序中要用到的数据以及功能那么多，如何找到相关连的呢？我需要先提取选课系统里的角色：学生、老师、课程等，然后显而易见的是：学生有学生相关的数据于功能，老师有老师相关的数据与功能，我们单以学生为例，</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 学生的数据有学校名字年龄性别# 学生的功能有选课</code></pre></div></figure><p>详细的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 学生1：    数据:        学校&#x3D;清华大学        姓名&#x3D;李建刚        性别&#x3D;男        年龄&#x3D;28    功能：        选课# 学生2：    数据:        学校&#x3D;清华大学        姓名&#x3D;王大力        性别&#x3D;女        年龄&#x3D;18    功能：        选课# 学生3：    数据:        学校&#x3D;清华大学        姓名&#x3D;牛嗷嗷        性别&#x3D;男        年龄&#x3D;38    功能：        选课</code></pre></div></figure><p>我们可以总结出一个学生类，用来存放学生们相同的数据与功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 学生类    相同的特征:        学校&#x3D;清华大学    相同的功能：        选课</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-953b7365b40efb7c36560df09c4ec93d_720w.jpg" alt="img"></p><p>基于上述分析的结果，我们接下来需要做的就是在程序中定义出类，然后调用类产生对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Student: # 类的命名应该使用“驼峰体”    school&#x3D;&#39;清华大学&#39; # 数据    def choose(self): # 功能        print(&#39;%s is choosing a course&#39; %self.name)</code></pre></div></figure><p>类体最常见的是变量的定义和函数的定义，但其实类体可以包含任意Python代码，类体的代码在类定义阶段就会执行，因而会产生新的名称空间用来存放类中定义的名字，可以打印Student.__dict__来查看类这个容器内盛放的东西</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; print(Student.__dict__)&#123;..., &#39;school&#39;: &#39;清华大学&#39;, &#39;choose&#39;: &lt;function Student.choose at 0x1018a2950&gt;, ...&#125;</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-ba4f6b43742c2eb0d1d2be4395948ba4_720w.jpg" alt="img"></p><p>调用类的过程称为将类实例化，拿到的返回值就是程序中的对象，或称为一个实例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; stu1&#x3D;Student() # 每实例化一次Student类就得到一个学生对象&gt;&gt;&gt; stu2&#x3D;Student()&gt;&gt;&gt; stu3&#x3D;Student()</code></pre></div></figure><p>如此stu1、stu2、stu3全都一样了（只有类中共有的内容，而没有各自独有的数据），想在实例化的过程中就为三位学生定制各自独有的数据：姓名，性别，年龄，需要我们在类内部新增一个__init__方法,如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Student:    school&#x3D;&#39;清华大学&#39;    #该方法会在对象产生之后自动执行，专门为对象进行初始化操作，可以有任意代码，但一定不能返回非None的值    def __init__(self,name,sex,age):        self.name&#x3D;name        self.sex&#x3D;sex        self.age&#x3D;age    def choose(self):         print(&#39;%s is choosing a course&#39; %self.name)</code></pre></div></figure><p>然后我们重新实例出三位学生</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; stu1&#x3D;Student(&#39;李建刚&#39;,&#39;男&#39;,28)&gt;&gt;&gt; stu2&#x3D;Student(&#39;王大力&#39;,&#39;女&#39;,18)&gt;&gt;&gt; stu3&#x3D;Student(&#39;牛嗷嗷&#39;,&#39;男&#39;,38)</code></pre></div></figure><p>单拿stu1的产生过程来分析，调用类会先产生一个空对象stu1，然后将stu1连同调用类时括号内的参数一起传给Student.<strong>init</strong>(stu1,’李建刚’,’男’,28)</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def __init__(self, name, sex, age):    self.name &#x3D; name  # stu1.name &#x3D; &#39;李建刚&#39;    self.sex &#x3D; sex    # stu1.sex &#x3D; &#39;男&#39;    self.age &#x3D; age    # stu1.age &#x3D; 28</code></pre></div></figure><p>会产生对象的名称空间，同样可以用__dict__查看</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; stu1.__dict__&#123;&#39;name&#39;: &#39;李建刚&#39;, &#39;sex&#39;: &#39;男&#39;, &#39;age&#39;: 28&#125;</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-83db32155675e830580cb17e6c767a4f_720w.jpg" alt="img"></p><p>至此，我们造出了三个对象与一个类，对象存放各自独有的数据，类中存放对象们共有的内容</p><p><img src="https://pic2.zhimg.com/80/v2-c3bb7aefce6ffee1029b1ae5dee72689_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-1c37ec375b8bcc6f734df307b13f978a_720w.jpg" alt="img"></p><p>存的目的是为了用，那么如何访问对象或者类中存放的内容呢？</p><p><img src="https://pic4.zhimg.com/80/v2-990cc37a6f39fc36193ba32a6a3c722f_720w.jpg" alt="img"></p><h2 id="3-2-属性访问"><a href="#3-2-属性访问" class="headerlink" title="3.2 属性访问"></a>3.2 属性访问</h2><h3 id="3-2-1-类属性与对象属性"><a href="#3-2-1-类属性与对象属性" class="headerlink" title="3.2.1 类属性与对象属性"></a>3.2.1 类属性与对象属性</h3><p><img src="https://pic4.zhimg.com/80/v2-ebbce58a25058d9ee08eba3272cba03f_720w.jpg" alt="img"></p><p>在类中定义的名字，都是类的属性，细说的话，类有两种属性：数据属性和函数属性，可以通过__dict__访问属性的值，比如Student.<strong>dict</strong>[‘school’]，但Python提供了专门的属性访问语法</p><p>插图：恶搞图</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; Student.school # 访问数据属性，等同于Student.__dict__[&#39;school&#39;]&#39;清华大学&#39;&gt;&gt;&gt; Student.choose # 访问函数属性，等同于Student.__dict__[&#39;choose&#39;]&lt;function Student.choose at 0x1018a2950&gt;# 除了查看属性外，我们还可以使用Student.attrib&#x3D;value(修改或新增属性),用del Student.attrib删除属性。</code></pre></div></figure><p>操作对象的属性也是一样</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; stu1.name # 查看，等同于obj1.__dict__[‘name&#39;]&#39;李建刚&#39;&gt;&gt;&gt; stu1.course&#x3D;’python’ # 新增，等同于obj1.__dict__[‘course&#39;]&#x3D;&#39;python&#39;&gt;&gt;&gt; stu1.age&#x3D;38 # 修改，等同于obj1.__dict__[‘age&#39;]&#x3D;38&gt;&gt;&gt; del obj1.course # 删除，等同于del obj1.__dict__[&#39;course&#39;]</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-1c37ec375b8bcc6f734df307b13f978a_720w.jpg" alt="img"></p><h3 id="3-2-2-属性查找顺序与绑定方法"><a href="#3-2-2-属性查找顺序与绑定方法" class="headerlink" title="3.2.2 属性查找顺序与绑定方法"></a>3.2.2 属性查找顺序与绑定方法</h3><p>对象的名称空间里只存放着对象独有的属性，而对象们相似的属性是存放于类中的。对象在访问属性时，会优先从对象本身的__dict__中查找，未找到，则去类的__dict__中查找</p><p><img src="https://pic4.zhimg.com/80/v2-990cc37a6f39fc36193ba32a6a3c722f_720w.jpg" alt="img"></p><p>1、类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># id都一样print(id(Student.school)) # 4301108704print(id(stu1.school)) # 4301108704print(id(stu2.school)) # 4301108704print(id(stu3.school)) # 4301108704</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-b636757ed106dde009623bd44a59f95e_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-15142b4a30e324fec709b506e2ecc518_720w.jpg" alt="img"></p><p>2、类中定义的函数是类的函数属性，类可以使用，但必须遵循函数的参数规则，有几个参数需要传几个参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Student.choose(stu1) # 李建刚 is choosing a courseStudent.choose(stu2) # 王大力 is choosing a courseStudent.choose(stu3) # 牛嗷嗷 is choosing a course</code></pre></div></figure><p>但其实类中定义的函数主要是给对象使用的，而且是绑定给对象的，虽然所有对象指向的都是相同的功能，但是绑定到不同的对象就是不同的绑定方法，内存地址各不相同</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(id(Student.choose)) # 4335426280print(id(stu1.choose)) # 4300433608print(id(stu2.choose)) # 4300433608print(id(stu3.choose)) # 4300433608</code></pre></div></figure><p>绑定到对象的方法特殊之处在于，绑定给谁就应该由谁来调用，谁来调用，就会将’谁’本身当做第一个参数自动传入（方法__init__也是一样的道理）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">stu1.choose()  # 等同于Student.choose(stu1)stu2.choose()  # 等同于Student.choose(stu2)stu3.choose()  # 等同于Student.choose(stu3)</code></pre></div></figure><p>绑定到不同对象的choose技能，虽然都是选课，但李建刚选的课，不会选给王大力，这正是”绑定“二字的精髓所在。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#注意：绑定到对象方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但命名为self是约定俗成的。</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-e54a102e09cb18b8deebc1bfee58c0ed_720w.jpg" alt="img"></p><p>Python中一切皆为对象，且Python3中类与类型是一个概念，因而绑定方法我们早就接触过</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#类型list就是类&gt;&gt;&gt; list&lt;class &#39;list&#39;&gt;#实例化的到3个对象l1,l2,l3&gt;&gt;&gt; l1&#x3D;list([1,2,3])&gt;&gt;&gt; l2&#x3D;list([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])&gt;&gt;&gt; l3&#x3D;list([&#39;x&#39;,&#39;y&#39;])#三个对象都有绑定方法append,是相同的功能,但内存地址不同&gt;&gt;&gt; l1.append&lt;built-in method append of list object at 0x10b482b48&gt;&gt;&gt;&gt; l2.append&lt;built-in method append of list object at 0x10b482b88&gt;&gt;&gt;&gt; l3.append&lt;built-in method append of list object at 0x10b482bc8&gt;#操作绑定方法l1.append(4),就是在往l1添加4,绝对不会将4添加到l2或l3&gt;&gt;&gt; l1.append(4) #等同于list.append(l1,4)&gt;&gt;&gt; l1[1,2,3,4]&gt;&gt;&gt; l2[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]&gt;&gt;&gt; l3[&#39;x&#39;,&#39;y&#39;]</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-b636757ed106dde009623bd44a59f95e_720w.jpg" alt="img"></p><h3 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h3><p>在上述介绍类与对象的使用过程中，我们更多的是站在底层原理的角度去介绍类与对象之间的关联关系，如果只是站在使用的角度，我们无需考虑语法“对象.属性”中”属性“到底源自于哪里，只需要知道是通过对象获取到的就可以了，所以说，对象是一个高度整合的产物，有了对象，我们只需要使用”对象.xxx“的语法就可以得到跟这个对象相关的所有数据与功能，十分方便且解耦合程度极高。</p><p><img src="https://pic4.zhimg.com/80/v2-990cc37a6f39fc36193ba32a6a3c722f_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-b6a8d20895c9d6c58cdb2be667a03774_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=91">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=91<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>25-继承与派生</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/25_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/25_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一-继承介绍"><a href="#一-继承介绍" class="headerlink" title="一 继承介绍"></a>一 继承介绍</h2><p><img src="https://pic3.zhimg.com/80/v2-e3ac39ed0476bd4ad372e51bea210c72_720w.jpg" alt="img"></p><p>继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class ParentClass1: #定义父类    passclass ParentClass2: #定义父类    passclass SubClass1(ParentClass1): #单继承    passclass SubClass2(ParentClass1,ParentClass2): #多继承    pass</code></pre></div></figure><p>通过类的内置属性__bases__可以查看类继承的所有父类</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; SubClass2.__bases__(&lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;__main__.ParentClass2&#39;&gt;)</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-b61fc012e7821e82ed7a57bf446f238c_720w.jpg" alt="img"></p><p>在Python2中有经典类与新式类之分，没有显式地继承object类的类，以及该类的子类，都是经典类，显式地继承object的类，以及该类的子类，都是新式类。而在Python3中，即使没有显式地继承object，也会默认继承该类，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; ParentClass1.__bases__(&lt;class ‘object&#39;&gt;,)&gt;&gt;&gt; ParentClass2.__bases__(&lt;class &#39;object&#39;&gt;,)</code></pre></div></figure><p>因而在Python3中统一都是新式类，关于经典类与新式类的区别，我们稍后讨论</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">提示：object类提供了一些常用内置方法的实现，如用来在打印对象时返回字符串的内置方法__str__</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-7c9d1a5d2778f92a7327f8733dcb419a_720w.jpg" alt="img"></p><h2 id="二-继承与抽象"><a href="#二-继承与抽象" class="headerlink" title="二 继承与抽象"></a>二 继承与抽象</h2><p>要找出类与类之间的继承关系，需要先抽象，再继承。抽象即总结相似之处，总结对象之间的相似之处得到类，总结类与类之间的相似之处就可以得到父类，如下图所示</p><p><img src="https://pic1.zhimg.com/80/v2-10df80634dbda00e4dcb4113c2a75b3c_720w.jpg" alt="img"></p><p>基于抽象的结果，我们就找到了继承关系</p><p><img src="https://pic1.zhimg.com/80/v2-d22528a722bfbb1765b99d1d75d8f1a4_720w.jpg" alt="img"></p><p>基于上图我们可以看出类与类之间的继承指的是什么’是’什么的关系（比如人类，猪类，猴类都是动物类）。子类可以继承／遗传父类所有的属性，因而继承可以用来解决类与类之间的代码重用性问题。比如我们按照定义Student类的方式再定义一个Teacher类</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Teacher:    school&#x3D;&#39;清华大学&#39;    def __init__(self,name,sex,age):        self.name&#x3D;name        self.sex&#x3D;sex        self.age&#x3D;age    def teach(self):        print(&#39;%s is teaching&#39; %self.name)</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-a17f608a24f6f7dfc8d72c1394a8057f_720w.jpg" alt="img"></p><p>类Teacher与Student之间存在重复的代码，老师与学生都是人类，所以我们可以得出如下继承关系，实现代码重用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class People:    school&#x3D;&#39;清华大学&#39;    def __init__(self,name,sex,age):        self.name&#x3D;name        self.sex&#x3D;sex        self.age&#x3D;ageclass Student(People):    def choose(self):        print(&#39;%s is choosing a course&#39; %self.name)class Teacher(People):    def teach(self):        print(&#39;%s is teaching&#39; %self.name)</code></pre></div></figure><p>Teacher类内并没有定义__init__方法，但是会从父类中找到__init__,因而仍然可以正常实例化，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; teacher1&#x3D;Teacher(&#39;lili&#39;,&#39;male&#39;,18)&gt;&gt;&gt; teacher1.school,teacher1.name,teacher1.sex,teacher1.age(&#39;清华大学&#39;, &#39;lili&#39;, &#39;male&#39;, 18)</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-b933b0de334a6cad2b227b53f3ae170a_720w.jpg" alt="img"></p><h2 id="三-属性查找"><a href="#三-属性查找" class="headerlink" title="三 属性查找"></a>三 属性查找</h2><p>有了继承关系，对象在查找属性时，先从对象自己的__dict__中找，如果没有则去子类中找，然后再去父类中找……</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Foo:...     def f1(self):...         print(&#39;Foo.f1&#39;)...     def f2(self):...         print(&#39;Foo.f2&#39;)...         self.f1()... &gt;&gt;&gt; class Bar(Foo):...     def f1(self):...         print(&#39;Foo.f1&#39;)... &gt;&gt;&gt; b&#x3D;Bar()&gt;&gt;&gt; b.f2()Foo.f2Foo.f1</code></pre></div></figure><p>b.f2()会在父类Foo中找到f2，先打印Foo.f2,然后执行到self.f1(),即b.f1()，仍会按照：对象本身-&gt;类Bar-&gt;父类Foo的顺序依次找下去，在类Bar中找到f1，因而打印结果为Foo.f1</p><p><img src="https://pic2.zhimg.com/80/v2-3b3119b9824bc80de6d1c7cb11219a6d_720w.jpg" alt="img"></p><p>父类如果不想让子类覆盖自己的方法，可以采用双下划线开头的方式将方法设置为私有的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Foo:...     def __f1(self): # 变形为_Foo__fa...         print(&#39;Foo.f1&#39;) ...     def f2(self):...         print(&#39;Foo.f2&#39;)...         self.__f1() # 变形为self._Foo__fa,因而只会调用自己所在的类中的方法... &gt;&gt;&gt; class Bar(Foo):...     def __f1(self): # 变形为_Bar__f1...         print(&#39;Foo.f1&#39;)... &gt;&gt;&gt; &gt;&gt;&gt; b&#x3D;Bar()&gt;&gt;&gt; b.f2() #在父类中找到f2方法，进而调用b._Foo__f1()方法，同样是在父类中找到该方法Foo.f2Foo.f1</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-80a1043173e8f968576b1efd57e857e9_720w.jpg" alt="img"></p><h2 id="四-继承的实现原理"><a href="#四-继承的实现原理" class="headerlink" title="四 继承的实现原理"></a>四 继承的实现原理</h2><h3 id="4-1-菱形问题"><a href="#4-1-菱形问题" class="headerlink" title="4.1 菱形问题"></a>4.1 菱形问题</h3><p> 大多数面向对象语言都不支持多继承，而在Python中，一个子类是可以同时继承多个父类的，这固然可以带来一个子类可以对多个不同父类加以重用的好处，但也有可能引发著名的 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Diamond_problem">Diamond problem</a>菱形问题(或称钻石问题，有时候也被称为“死亡钻石”)，菱形其实就是对下面这种继承结构的形象比喻</p><p><img src="https://pic4.zhimg.com/80/v2-7c6088a106bbf1fc46de0cca9c03a037_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">A类在顶部，B类和C类分别位于其下方，D类在底部将两者连接在一起形成菱形。</code></pre></div></figure><p>这种继承结构下导致的问题称之为菱形问题：如果A中有一个方法，B和&#x2F;或C都重写了该方法，而D没有重写它，那么D继承的是哪个版本的方法：B的还是C的？如下所示</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A(object):    def test(self):        print(&#39;from A&#39;)class B(A):    def test(self):        print(&#39;from B&#39;)class C(A):    def test(self):        print(&#39;from C&#39;)class D(B,C):    passobj &#x3D; D()obj.test() # 结果为：from B</code></pre></div></figure><p>要想搞明白obj.test()是如何找到方法test的，需要了解python的继承实现原理</p><h3 id="4-2-继承原理"><a href="#4-2-继承原理" class="headerlink" title="4.2 继承原理"></a>4.2 继承原理</h3><p>python到底是如何实现继承的呢？ 对于你定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; D.mro() # 新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法[&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre></div></figure><p>python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.子类会先于父类被检查2.多个父类会根据它们在列表中的顺序被检查3.如果对下一个类存在两个合法的选择,选择第一个父类</code></pre></div></figure><p>所以obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，则参照属性查找的发起者(即obj)所处类D的MRO列表来依次检索，首先在类D中未找到，然后再B中找到方法test</p><p>ps：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去，2.由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去，</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-e75f3e5658ec15a3d5e964d32dce7d19_720w.jpg" alt="img"></p><h3 id="4-3-深度优先和广度优先"><a href="#4-3-深度优先和广度优先" class="headerlink" title="4.3 深度优先和广度优先"></a>4.3 深度优先和广度优先</h3><p>参照下述代码，多继承结构为非菱形结构，此时，会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性</p><p><img src="https://pic4.zhimg.com/80/v2-64faa1a6e825277233fe2bf40401b99b_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class E:    def test(self):        print(&#39;from E&#39;)class F:    def test(self):        print(&#39;from F&#39;)class B(E):    def test(self):        print(&#39;from B&#39;)class C(F):    def test(self):        print(&#39;from C&#39;)class D:    def test(self):        print(&#39;from D&#39;)class A(B, C, D):    # def test(self):    #     print(&#39;from A&#39;)    passprint(A.mro())&#39;&#39;&#39;[&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.F&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;object&#39;&gt;]&#39;&#39;&#39;obj &#x3D; A()obj.test() # 结果为：from B# 可依次注释上述类中的方法test来进行验证</code></pre></div></figure><p>如果继承关系为菱形结构，那么经典类与新式类会有不同MRO，分别对应属性的两种查找方式：深度优先和广度优先</p><p><img src="https://pic4.zhimg.com/80/v2-e95d9f13b01af6eb7da3b5043442f697_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class G: # 在python2中，未继承object的类及其子类，都是经典类    def test(self):        print(&#39;from G&#39;)class E(G):    def test(self):        print(&#39;from E&#39;)class F(G):    def test(self):        print(&#39;from F&#39;)class B(E):    def test(self):        print(&#39;from B&#39;)class C(F):    def test(self):        print(&#39;from C&#39;)class D(G):    def test(self):        print(&#39;from D&#39;)class A(B,C,D):    # def test(self):    #     print(&#39;from A&#39;)    passobj &#x3D; A()obj.test() # 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;G-&gt;C-&gt;F-&gt;D-&gt;object# 可依次注释上述类中的方法test来进行验证,注意请在python2.x中进行测试</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-08eb8fd2226110ae845da74805cb98fb_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class G(object):    def test(self):        print(&#39;from G&#39;)class E(G):    def test(self):        print(&#39;from E&#39;)class F(G):    def test(self):        print(&#39;from F&#39;)class B(E):    def test(self):        print(&#39;from B&#39;)class C(F):    def test(self):        print(&#39;from C&#39;)class D(G):    def test(self):        print(&#39;from D&#39;)class A(B,C,D):    # def test(self):    #     print(&#39;from A&#39;)    passobj &#x3D; A()obj.test() # 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D-&gt;G-&gt;object# 可依次注释上述类中的方法test来进行验证</code></pre></div></figure><h3 id="4-4-Pyton-Mixins机制"><a href="#4-4-Pyton-Mixins机制" class="headerlink" title="4.4 Pyton Mixins机制"></a>4.4 Pyton Mixins机制</h3><p> 一个子类可以同时继承多个父类，这样的设计常被人诟病，一来它有可能导致可恶的菱形问题，二来在人的世界观里继承应该是个”is-a”关系。 比如轿车类之所以可以继承交通工具类，是因为基于人的世界观，我们可以说：轿车是一个(“is-a”)交通工具，而在人的世界观里，一个物品不可能是多种不同的东西，因此多重继承在人的世界观里是说不通的，它仅仅只是代码层面的逻辑。不过有没有这种情况，一个类的确是需要继承多个类呢？</p><p> 答案是有，我们还是拿交通工具来举例子:</p><p> 民航飞机、直升飞机、轿车都是一个（is-a）交通工具，前两者都有一个功能是飞行fly，但是轿车没有，所以如下所示我们把飞行功能放到交通工具这个父类中是不合理的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Vehicle:  # 交通工具    def fly(self):        &#39;&#39;&#39;        飞行功能相应的代码                &#39;&#39;&#39;        print(&quot;I am flying&quot;)class CivilAircraft(Vehicle):  # 民航飞机    passclass Helicopter(Vehicle):  # 直升飞机    passclass Car(Vehicle):  # 汽车并不会飞，但按照上述继承关系，汽车也能飞了    pass</code></pre></div></figure><p> 但是如果民航飞机和直升机都各自写自己的飞行fly方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会重复代码将会越来越多）。</p><p> 怎么办？？？为了尽可能地重用代码，那就只好在定义出一个飞行器的类，然后让民航飞机和直升飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系。这个难题该怎么解决？</p><p> 不同的语言给出了不同的方法，让我们先来了解Java的处理方法。Java提供了接口interface功能，来实现多重继承：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象基类：交通工具类public abstract class Vehicle &#123;&#125;&#x2F;&#x2F; 接口：飞行器public interface Flyable &#123;    public void fly();&#125;&#x2F;&#x2F; 类：实现了飞行器接口的类，在该类中实现具体的fly方法，这样下面民航飞机与直升飞机在实现fly时直接重用即可public class FlyableImpl implements Flyable &#123;    public void fly() &#123;        System.out.println(&quot;I am flying&quot;);    &#125;&#125;&#x2F;&#x2F; 民航飞机，继承自交通工具类，并实现了飞行器接口public class CivilAircraft extends Vehicle implements Flyable &#123;    private Flyable flyable;    public CivilAircraft() &#123;        flyable &#x3D; new FlyableImpl();    &#125;    public void fly() &#123;        flyable.fly();    &#125;&#125;&#x2F;&#x2F; 直升飞机，继承自交通工具类，并实现了飞行器接口public class Helicopter extends Vehicle implements Flyable &#123;    private Flyable flyable;    public Helicopter() &#123;        flyable &#x3D; new FlyableImpl();    &#125;    public void fly() &#123;        flyable.fly();    &#125;&#125;&#x2F;&#x2F; 汽车，继承自交通工具类，public class Car extends Vehicle &#123;&#125;</code></pre></div></figure><p>现在我们的飞机同时具有了交通工具及飞行器两种属性，而且我们不需要重写飞行器中的飞行方法，同时我们没有破坏单一继承的原则。飞机就是一种交通工具，可飞行的能力是飞机的属性，通过继承接口来获取。</p><p>回到主题，Python语言可没有接口功能，但Python提供了Mixins机制，简单来说Mixins机制指的是子类混合(mixin)不同类的功能，而这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的，并不是用来标识子类的从属”is-a”关系的，所以Mixins机制本质仍是多继承，但同样遵守”is-a”关系，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Vehicle:  # 交通工具    passclass FlyableMixin:    def fly(self):        &#39;&#39;&#39;        飞行功能相应的代码                &#39;&#39;&#39;        print(&quot;I am flying&quot;)class CivilAircraft(FlyableMixin, Vehicle):  # 民航飞机    passclass Helicopter(FlyableMixin, Vehicle):  # 直升飞机    passclass Car(Vehicle):  # 汽车    pass# ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路</code></pre></div></figure><p>可以看到，上面的CivilAircraft、Helicopter类实现了多继承，不过它继承的第一个类我们起名为FlyableMixin，而不是Flyable，这个并不影响功能，但是会告诉后来读代码的人，这个类是一个Mixin类，表示混入(mix-in)，这种命名方式就是用来明确地告诉别人（python语言惯用的手法），这个类是作为功能添加到子类中，而不是作为父类，它的作用同Java中的接口。所以从含义上理解，CivilAircraft、Helicopter类都只是一个Vehicle，而不是一个飞行器。</p><p>使用Mixin类实现多重继承要非常小心</p><ul><li>首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀</li><li>其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类</li><li>然后，它不依赖于子类的实现</li><li>最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）</li></ul><p> Mixins是从多个类中重用代码的好方法，但是需要付出相应的代价，我们定义的Minx类越多，子类的代码可读性就会越差，并且更恶心的是，在继承的层级变多时，代码阅读者在定位某一个方法到底在何处调用时会晕头转向，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Displayer:    def display(self, message):        print(message)class LoggerMixin:    def log(self, message, filename&#x3D;&#39;logfile.txt&#39;):        with open(filename, &#39;a&#39;) as fh:            fh.write(message)    def display(self, message):        super().display(message) # super的用法请参考下一小节        self.log(message)class MySubClass(LoggerMixin, Displayer):    def log(self, message):        super().log(message, filename&#x3D;&#39;subclasslog.txt&#39;) obj &#x3D; MySubClass()obj.display(&quot;This string will be shown and logged in subclasslog.txt&quot;)# 属性查找的发起者是obj,所以会参照类MySubClass的MRO来检索属性#[&lt;class &#39;__main__.MySubClass&#39;&gt;, &lt;class &#39;__main__.LoggerMixin&#39;&gt;, &lt;class &#39;__main__.Displayer&#39;&gt;, &lt;class &#39;object&#39;&gt;]# 1、首先会去对象obj的类MySubClass找方法display，没有则去类LoggerMixin中找，找到开始执行代码# 2、执行LoggerMixin的第一行代码：执行super().display(message)，参照MySubClass.mro(),super会去下一个类即类Displayer中找，找到display，开始执行代码，打印消息&quot;This string will be shown and logged in subclasslog.txt&quot;# 3、执行LoggerMixin的第二行代码：self.log(message)，self是对象obj，即obj.log(message)，属性查找的发起者为obj，所以会按照其类MySubClass.mro(),即MySubClass-&gt;LoggerMixin-&gt;Displayer-&gt;object的顺序查找，在MySubClass中找到方法log，开始执行super().log(message, filename&#x3D;&#39;subclasslog.txt&#39;)，super会按照MySubClass.mro()查找下一个类，在类LoggerMixin中找到log方法开始执行，最终将日志写入文件subclasslog.txt</code></pre></div></figure><p>ps：课外了解小知识</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Java只允许接口的多重继承。接口本质上是抽象基类，具有所有抽象方法，没有数据成员。与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化，继承的子类必须实现抽象基类规定的方法，这样便可保证始终只有一个特定方法或属性的实现，并且不会产生歧义，因而也可以起到避免菱形问题的作用java的interface：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;linhaifeng&#x2F;articles&#x2F;7340153.html#_label6python的抽象基类：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;linhaifeng&#x2F;articles&#x2F;7340153.html#_label7</code></pre></div></figure><h2 id="五-派生与方法重用"><a href="#五-派生与方法重用" class="headerlink" title="五 派生与方法重用"></a>五 派生与方法重用</h2><p>子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找，例如每个老师还有职称这一属性，我们就需要在Teacher类中定义该类自己的__init__覆盖父类的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class People:...     school&#x3D;&#39;清华大学&#39;...     ...     def __init__(self,name,sex,age):...         self.name&#x3D;name...         self.sex&#x3D;sex...         self.age&#x3D;age... &gt;&gt;&gt; class Teacher(People):...     def __init__(self,name,sex,age,title): # 派生...         self.name&#x3D;name...         self.sex&#x3D;sex...         self.age&#x3D;age...         self.title&#x3D;title...     def teach(self):...         print(&#39;%s is teaching&#39; %self.name)... &gt;&gt;&gt; obj&#x3D;Teacher(&#39;lili&#39;,&#39;female&#39;,28,&#39;高级讲师&#39;) #只会找自己类中的__init__，并不会自动调用父类的&gt;&gt;&gt; obj.name,obj.sex,obj.age,obj.title(&#39;lili&#39;, &#39;female&#39;, 28, &#39;高级讲师&#39;)</code></pre></div></figure><p>很明显子类Teacher中__init__内的前三行又是在写重复代码，若想在子类派生出的方法内重用父类的功能，有两种实现方式</p><p>方法一：“指名道姓”地调用某一个类的函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Teacher(People):...     def __init__(self,name,sex,age,title):...         People.__init__(self,name,age,sex) #调用的是函数,因而需要传入self...         self.title&#x3D;title...     def teach(self):...         print(&#39;%s is teaching&#39; %self.name)...</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-d21ae6052b43be565f551fc1fcabe5c3_720w.jpg" alt="img"></p><p>方法二：super()</p><p>调用super()会得到一个特殊的对象，该对象专门用来引用父类的属性，且严格按照MRO规定的顺序向后查找</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Teacher(People):...     def __init__(self,name,sex,age,title):...         super().__init__(name,age,sex) #调用的是绑定方法，自动传入self...         self.title&#x3D;title...     def teach(self):...         print(&#39;%s is teaching&#39; %self.name)...</code></pre></div></figure><p>提示：在Python2中super的使用需要完整地写成super(自己的类名,self) ,而在python3中可以简写为super()。</p><p><img src="https://pic3.zhimg.com/80/v2-908bf3b15e8a66ce55d1dc41155639ea_720w.jpg" alt="img"></p><p>这两种方式的区别是：方式一是跟继承没有关系的，而方式二的super()是依赖于继承的，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; #A没有继承B... class A:...     def test(self):...         super().test()... &gt;&gt;&gt; class B:...     def test(self):...         print(&#39;from B&#39;)... &gt;&gt;&gt; class C(A,B):...     pass... &gt;&gt;&gt; C.mro() # 在代码层面A并不是B的子类，但从MRO列表来看，属性查找时，就是按照顺序C-&gt;A-&gt;B-&gt;object，B就相当于A的“父类”[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;,&lt;class ‘object&#39;&gt;]&gt;&gt;&gt; obj&#x3D;C()&gt;&gt;&gt; obj.test() # 属性查找的发起者是类C的对象obj，所以中途发生的属性查找都是参照C.mro()from B</code></pre></div></figure><p>obj.test()首先找到A下的test方法，执行super().test()会基于MRO列表(以C.mro()为准)当前所处的位置继续往后查找()，然后在B中找到了test方法并执行。</p><p>关于在子类中重用父类功能的这两种方式，使用任何一种都可以，但是在最新的代码中还是推荐使用super()</p><p><img src="https://pic1.zhimg.com/80/v2-ad4967402d87e33226ff03f96801f350_720w.jpg" alt="img"></p><h2 id="六-组合"><a href="#六-组合" class="headerlink" title="六 组合"></a>六 组合</h2><p>在一个类中以另外一个类的对象作为数据属性，称为类的组合。组合与继承都是用来解决代码的重用性问题。不同的是：继承是一种“是”的关系，比如老师是人、学生是人，当类之间有很多相同的之处，应该使用继承；而组合则是一种“有”的关系，比如老师有生日，老师有多门课程，当类之间有显著不同，并且较小的类是较大的类所需要的组件时，应该使用组合，如下示例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Course:    def __init__(self,name,period,price):        self.name&#x3D;name        self.period&#x3D;period        self.price&#x3D;price    def tell_info(self):        print(&#39;&lt;%s %s %s&gt;&#39; %(self.name,self.period,self.price))class Date:    def __init__(self,year,mon,day):        self.year&#x3D;year        self.mon&#x3D;mon        self.day&#x3D;day    def tell_birth(self):       print(&#39;&lt;%s-%s-%s&gt;&#39; %(self.year,self.mon,self.day))class People:    school&#x3D;&#39;清华大学&#39;    def __init__(self,name,sex,age):        self.name&#x3D;name        self.sex&#x3D;sex        self.age&#x3D;age#Teacher类基于继承来重用People的代码，基于组合来重用Date类和Course类的代码class Teacher(People): #老师是人    def __init__(self,name,sex,age,title,year,mon,day):        super().__init__(name,age,sex)        self.birth&#x3D;Date(year,mon,day) #老师有生日        self.courses&#x3D;[] #老师有课程，可以在实例化后，往该列表中添加Course类的对象    def teach(self):        print(&#39;%s is teaching&#39; %self.name)python&#x3D;Course(&#39;python&#39;,&#39;3mons&#39;,3000.0)linux&#x3D;Course(&#39;linux&#39;,&#39;5mons&#39;,5000.0)teacher1&#x3D;Teacher(&#39;lili&#39;,&#39;female&#39;,28,&#39;博士生导师&#39;,1990,3,23)# teacher1有两门课程teacher1.courses.append(python)teacher1.courses.append(linux)# 重用Date类的功能teacher1.birth.tell_birth()# 重用Course类的功能for obj in teacher1.courses:     obj.tell_info()</code></pre></div></figure><p>此时对象teacher1集对象独有的属性、Teacher类中的内容、Course类中的内容于一身（都可以访问到），是一个高度整合的产物</p><p><img src="https://pic2.zhimg.com/80/v2-80420dc0b3ecd5676e7b9d9f02f41aad_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>继承与派生</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=100">https://www.bilibili.com/video/av73342471?p=100www.bilibili.com/video/av73342471?p=100</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24-封装</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/24_%E5%B0%81%E8%A3%85/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/24_%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="24、封装"><a href="#24、封装" class="headerlink" title="24、封装"></a>24、封装</h1><p><a href="https://www.zhihu.com/people/xiaoyuanqujing"><img src="https://pic3.zhimg.com/v2-c71f12bc82a46fa2c0ad1268aa249d7e_xs.jpg?source=172ae18b" alt="Egon林海峰"></a></p><p><a href="https://www.zhihu.com/people/xiaoyuanqujing">Egon林海峰</a></p><p>Egon的知识星球：<a href="https://egonlin.com/">https://egonlin.com</a></p><p>关注他</p><p>65 人赞同了该文章</p><p>目录：</p><ul><li><p>引入</p></li><li><p>隐藏属性</p></li><li><p>开放接口</p></li><li><ul><li>隐藏数据接口</li><li>隐藏函数接口</li></ul></li><li><p>property</p></li><li><p>视频链接</p></li></ul><p>强烈推荐配套资料：<a href="https://link.zhihu.com/?target=https://egonlin.com/book.html">egon新书来袭干货满满 - linhaifeng</a></p><h2 id="一-引入"><a href="#一-引入" class="headerlink" title="一 引入"></a>一 引入</h2><p> 面向对象编程有三大特性：封装、继承、多态，其中最重要的一个特性就是封装。封装指的就是把数据与功能都整合到一起，听起来是不是很熟悉，没错，我们之前所说的”整合“二字其实就是封装的通俗说法。除此之外，针对封装到对象或者类中的属性，我们还可以严格控制对它们的访问，分两步实现：隐藏与开放接口</p><p><img src="https://pic4.zhimg.com/80/v2-6a32e315fdeb5e7de1452455ee287933_720w.jpg" alt="img"></p><h2 id="二-隐藏属性"><a href="#二-隐藏属性" class="headerlink" title="二 隐藏属性"></a>二 隐藏属性</h2><p>Python的Class机制采用双下划线开头的方式将属性隐藏起来（设置成私有的），但其实这仅仅只是一种变形操作，类中所有双下滑线开头的属性都会在类定义阶段、检测语法时自动变成“_类名__属性名”的形式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Foo:    __N&#x3D;0 # 变形为_Foo__N    def __init__(self): # 定义函数时，会检测函数语法，所以__开头的属性也会变形        self.__x&#x3D;10 # 变形为self._Foo__x    def __f1(self): # 变形为_Foo__f1        print(&#39;__f1 run&#39;)    def f2(self):  # 定义函数时，会检测函数语法，所以__开头的属性也会变形        self.__f1() #变形为self._Foo__f1()print(Foo.__N) # 报错AttributeError:类Foo没有属性__Nobj &#x3D; Foo()print(obbj.__x) # 报错AttributeError:对象obj没有属性__x</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-805e04f3fd093604e61c6fa286d1658a_720w.jpg" alt="img"></p><p>这种变形需要注意的问题是：</p><p>1、在类外部无法直接访问双下滑线开头的属性，但知道了类名和属性名就可以拼出名字：_类名__属性，然后就可以访问了，如Foo._A__N，所以说这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; Foo.__dict__mappingproxy(&#123;..., &#39;_Foo__N&#39;: 0, ...&#125;)&gt;&gt;&gt; obj.__dict__&#123;&#39;_Foo__x&#39;: 10&#125;&gt;&gt;&gt; Foo._Foo__N0&gt;&gt;&gt; obj._Foo__x10&gt;&gt;&gt; obj._Foo__N0</code></pre></div></figure><p>2、在类内部是可以直接访问双下滑线开头的属性的，比如self.__f1()，因为在类定义阶段类内部双下滑线开头的属性统一发生了变形。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; obj.f2()__f1 run</code></pre></div></figure><p>3、变形操作只在类定义阶段发生一次,在类定义之后的赋值操作，不会变形。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; Foo.__M&#x3D;100&gt;&gt;&gt; Foo.__dict__mappingproxy(&#123;..., &#39;__M&#39;: 100,...&#125;)&gt;&gt;&gt; Foo.__M100&gt;&gt;&gt; obj.__y&#x3D;20&gt;&gt;&gt; obj.__dict__&#123;&#39;__y&#39;: 20, &#39;_Foo__x&#39;: 10&#125;&gt;&gt;&gt; obj.__y20</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-8832156adebe2467bff885f22728411f_720w.jpg" alt="img"></p><h2 id="三-开放接口"><a href="#三-开放接口" class="headerlink" title="三 开放接口"></a>三 开放接口</h2><p>定义属性就是为了使用，所以隐藏并不是目的</p><h2 id="3-1-隐藏数据属性"><a href="#3-1-隐藏数据属性" class="headerlink" title="3.1 隐藏数据属性"></a>3.1 隐藏数据属性</h2><p>将数据隐藏起来就限制了类外部对数据的直接操作，然后类内应该提供相应的接口来允许类外部间接地操作数据，接口之上可以附加额外的逻辑来对数据的操作进行严格地控制</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Teacher:...     def __init__(self,name,age): #将名字和年纪都隐藏起来...         self.__name&#x3D;name...         self.__age&#x3D;age...     def tell_info(self): #对外提供访问老师信息的接口...         print(&#39;姓名:%s,年龄:%s&#39; %(self.__name,self.__age))...     def set_info(self,name,age): #对外提供设置老师信息的接口，并附加类型检查的逻辑...         if not isinstance(name,str):...             raise TypeError(&#39;姓名必须是字符串类型&#39;)...         if not isinstance(age,int):...             raise TypeError(&#39;年龄必须是整型&#39;)...         self.__name&#x3D;name...         self.__age&#x3D;age... &gt;&gt;&gt;&gt;&gt;&gt; t&#x3D;Teacher(&#39;lili&#39;,18)&gt;&gt;&gt; t.set_info(‘LiLi&#39;,&#39;19&#39;) # 年龄不为整型，抛出异常Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;&lt;stdin&gt;&quot;, line 11, in set_infoTypeError: 年龄必须是整型&gt;&gt;&gt; t.set_info(&#39;LiLi&#39;,19) # 名字为字符串类型，年龄为整形，可以正常设置&gt;&gt;&gt; t.tell_info() # 查看老师的信息姓名:LiLi,年龄:19</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-8ee414d1292c42e754f32fa3887c77eb_720w.jpg" alt="img"></p><h2 id="3-2-隐藏函数属性"><a href="#3-2-隐藏函数属性" class="headerlink" title="3.2 隐藏函数属性"></a>3.2 隐藏函数属性</h2><p>目的的是为了隔离复杂度，例如ATM程序的取款功能,该功能有很多其他功能组成，比如插卡、身份认证、输入金额、打印小票、取钱等，而对使用者来说,只需要开发取款这个功能接口即可,其余功能我们都可以隐藏起来</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class ATM:...     def __card(self): #插卡...         print(&#39;插卡&#39;)...     def __auth(self): #身份认证...         print(&#39;用户认证&#39;)...     def __input(self): #输入金额...         print(&#39;输入取款金额&#39;)...     def __print_bill(self): #打印小票...         print(&#39;打印账单&#39;)...     def __take_money(self): #取钱...         print(&#39;取款&#39;)...     def withdraw(self): #取款功能...         self.__card()...         self.__auth()...         self.__input()...         self.__print_bill()...         self.__take_money()...&gt;&gt;&gt; obj&#x3D;ATM()&gt;&gt;&gt; obj.withdraw()</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-3a8cbf5b04077b88e85f6c075b37b94d_720w.jpg" alt="img"></p><p>总结隐藏属性与开放接口，本质就是为了明确地区分内外，类内部可以修改封装内的东西而不影响外部调用者的代码；而类外部只需拿到一个接口，只要接口名、参数不变，则无论设计者如何改变内部实现代码，使用者均无需改变代码。这就提供一个良好的合作基础，只要接口这个基础约定不变，则代码的修改不足为虑。</p><h2 id="四-property"><a href="#四-property" class="headerlink" title="四 property"></a>四 property</h2><p>BMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为</p><p><img src="https://pic3.zhimg.com/80/v2-43498605399e4a86e295e67ddd75962e_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">体质指数（BMI）&#x3D;体重（kg）÷身高^2（m）EX：70kg÷（1.75×1.75）&#x3D;22.86</code></pre></div></figure><p>身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能，为此Python专门提供了一个装饰器property，可以将类中的函数“伪装成”对象的数据属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果，例如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class People:...     def __init__(self,name,weight,height):...         self.name&#x3D;name...         self.weight&#x3D;weight...         self.height&#x3D;height...     @property...     def bmi(self):...         return self.weight &#x2F; (self.height**2)...&gt;&gt;&gt; obj&#x3D;People(&#39;lili&#39;,75,1.85)&gt;&gt;&gt; obj.bmi #触发方法bmi的执行，将obj自动传给self，执行后返回值作为本次引用的结果21.913805697589478</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-6efd0b831d73e828f7c644df0d8d996f_720w.jpg" alt="img"></p><p>使用property有效地保证了属性访问的一致性。另外property还提供设置和删除属性的功能，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Foo:...     def __init__(self,val):...         self.__NAME&#x3D;val #将属性隐藏起来...     @property...     def name(self):...         return self.__NAME...     @name.setter...     def name(self,value):...         if not isinstance(value,str):  #在设定值之前进行类型检查...             raise TypeError(&#39;%s must be str&#39; %value)...         self.__NAME&#x3D;value #通过类型检查后,将值value存放到真实的位置self.__NAME...     @name.deleter...     def name(self):...         raise PermissionError(&#39;Can not delete&#39;)...&gt;&gt;&gt; f&#x3D;Foo(&#39;lili&#39;)&gt;&gt;&gt; f.namelili&gt;&gt;&gt; f.name&#x3D;&#39;LiLi&#39; #触发name.setter装饰器对应的函数name(f,’Egon&#39;)&gt;&gt;&gt; f.name&#x3D;123 #触发name.setter对应的的函数name(f,123),抛出异常TypeError&gt;&gt;&gt; del f.name #触发name.deleter对应的函数name(f),抛出异常PermissionError</code></pre></div></figure><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>封装之隐藏属性</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=111">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=111<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>封装真正的意义</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=112">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=112<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>property</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=113">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=113<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22-软件开发的目录规范</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/22_%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/22_%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="软件开发目录规范"><a href="#软件开发目录规范" class="headerlink" title="软件开发目录规范"></a>软件开发目录规范</h2><p><img src="https://pic2.zhimg.com/80/v2-0cda8e5e376f38fcc2d7c5dac518c0b9_720w.jpg" alt="img"></p><p>强烈推荐配套资料：<a href="https://link.zhihu.com/?target=https://egonlin.com/book.html">egon新书来袭干货满满 - linhaifeng</a></p><p>为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。软件的目录规范并无硬性标准，只要清晰可读即可，假设你的软件名为foo，笔者推荐目录结构如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Foo&#x2F;|-- core&#x2F;|   |-- core.py||-- api&#x2F;|   |-- api.py||-- db&#x2F;|   |-- db_handle.py||-- lib&#x2F;|   |-- common.py||-- conf&#x2F;|   |-- settings.py||-- run.py|-- setup.py|-- requirements.txt|-- README</code></pre></div></figure><p>简要解释一下:</p><p> • core&#x2F;: 存放业务逻辑相关代码</p><p> • api&#x2F;: 存放接口文件，接口主要用于为业务逻辑提供数据操作。</p><p> • db&#x2F;: 存放操作数据库相关文件，主要用于与数据库交互</p><p> • lib&#x2F;: 存放程序中常用的自定义模块</p><p> • conf&#x2F;: 存放配置文件</p><p> • run.py: 程序的启动文件，一般放在项目的根目录下，因为在运行时会默认将运行文件所在的文件夹作为sys.path的第一个路径，这样就省去了处理环境变量的步骤</p><p> • setup.py: 安装、部署、打包的脚本。</p><p> • requirements.txt: 存放软件依赖的外部Python包列表。</p><p> • README: 项目说明文件。</p><p>除此之外，有一些方案给出了更加多的内容，比如LICENSE.txt,ChangeLog.txt文件等，主要是在项目需要开源时才会用到，请读者自行查阅。</p><p>关于README的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1、软件定位，软件的基本功能；2、运行代码的方法: 安装环境、启动命令等；3、简要的使用说明；4、代码目录结构说明，更详细点可以说明软件的基本原理；5、常见问题说明。</code></pre></div></figure><p>关于setup.py和requirements.txt：</p><p><img src="https://pic3.zhimg.com/80/v2-6e2c485cb45f4d50dd8d98f091fe062a_720w.jpg" alt="img"></p><p>一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p><p>requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。</p><p>这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;&#x3D;0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python依赖库都装好了，具体格式参照<a href="https://link.zhihu.com/?target=https://pip.readthedocs.io/en/1.1/requirements.html">https://pip.readthedocs.io/en/1.1/requirements.html</a></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=71">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=71<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-包</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/21_%E5%8C%85/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/21_%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="一-包介绍"><a href="#一-包介绍" class="headerlink" title="一 包介绍"></a>一 包介绍</h2><p>随着模块数目的增多，把所有模块不加区分地放到一起也是极不合理的，于是Python为我们提供了一种把模块组织到一起的方法，即创建一个包。包就是一个含有__init__.py文件的文件夹，文件夹内可以组织子模块或子包，例如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">pool&#x2F;                #顶级包├── __init__.py     ├── futures          #子包│   ├── __init__.py│   ├── process.py│   └── thread.py└── versions.py      #子模块</code></pre></div></figure><p>需要强调的是</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错#2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包的本质就是一种模</code></pre></div></figure><p>接下来我们就以包pool为例来介绍包的使用，包内各文件内容如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># process.pyclass ProcessPoolExecutor:    def __init__(self,max_workers):        self.max_workers&#x3D;max_workers    def submit(self):        print(&#39;ProcessPool submit&#39;)# thread.pyclass ThreadPoolExecutor:    def __init__(self, max_workers):        self.max_workers &#x3D; max_workers    def submit(self):        print(&#39;ThreadPool submit&#39;)# versions.pydef check():    print(&#39;check versions’)# __init__.py文件内容均为空</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-5dd50856f36ac71d32e384a0c9cb514f_720w.jpg" alt="img"></p><h2 id="二-包的使用"><a href="#二-包的使用" class="headerlink" title="二 包的使用"></a>二 包的使用</h2><h2 id="2-1-导入包与-init-py"><a href="#2-1-导入包与-init-py" class="headerlink" title="2.1 导入包与__init__.py"></a>2.1 导入包与__init__.py</h2><p>包属于模块的一种，因而包以及包内的模块均是用来被导入使用的，而绝非被直接执行，首次导入包（如import pool）同样会做三件事：</p><p>1、执行包下的__init__.py文件</p><p>2、产生一个新的名称空间用于存放__init__.py执行过程中产生的名字</p><p>3、在当前执行文件所在的名称空间中得到一个名字pool，该名字指向__init__.py的名称空间，例如<a href="https://link.zhihu.com/?target=http://pool.xxx">http://pool.xxx</a>和pool.yyy中的xxx和yyy都是来自于pool下的__init__.py，也就是说导入包时并不会导入包下所有的子模块与子包</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import poolpool.versions.check() #抛出异常AttributeErrorpool.futures.process.ProcessPoolExecutor(3) #抛出异常AttributeError</code></pre></div></figure><p>pool.versions.check()要求pool下有名字versions，进而pool.versions下有名字check。pool.versions下已经有名字check了，所以问题出在pool下没有名字versions，这就需要在pool下的__init__.py中导入模块versions</p><p><img src="https://pic3.zhimg.com/80/v2-08c7810c490572e8aed0d3dccfb2eb26_720w.jpg" alt="img"></p><p><strong>强调</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.关于包相关的导入语句也分为import和from ... import ...两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如import 顶级包.子包.子模块,但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。2、包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间3、import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件</code></pre></div></figure><h2 id="2-2-绝对导入与相对导入"><a href="#2-2-绝对导入与相对导入" class="headerlink" title="2.2 绝对导入与相对导入"></a>2.2 绝对导入与相对导入</h2><p>针对包内的模块之间互相导入，导入的方式有两种</p><p>1、绝对导入：以顶级包为起始</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#pool下的__init__.pyfrom pool import versions</code></pre></div></figure><p>2、相对导入：.代表当前文件所在的目录，..代表当前目录的上一级目录，依此类推</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#pool下的__init__.pyfrom . import versions</code></pre></div></figure><p>同理，针对pool.futures.process.ProcessPoolExecutor(3)，则需要</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#操作pool下的__init__.py，保证pool.futuresfrom . import futures #或from pool import futures#操作futrues下的__init__.py，保证pool.futures.processfrom . import process #或from pool.futures import process</code></pre></div></figure><p>在包内使用相对导入还可以跨目录导入模块，比如thread.py中想引用versions.py的名字check</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import也能使用绝对导入，导入过程中同样会依次执行包下的__init__.py,只是基于import导入的结果，使用时必须加上该前缀</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-0d72cc18ba9ff316c955509c82222653_720w.jpg" alt="img"></p><p>例1：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pool.futures #拿到名字pool.futures指向futures下的__init__.pypool.futures.xxx #要求futures下的__init__.py中必须有名字xxx</code></pre></div></figure><p>例2：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pool.futures.thread #拿到名字pool.futures.thread指向thread.pythread_pool&#x3D;pool.futures.thread.ThreadPoolExecutor(3)thread_pool.submit()</code></pre></div></figure><p>相对导入只能用from module import symbol的形式,import ..versions语法是不对的，且symbol只能是一个明确的名字</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pool import futures.process #语法错误from pool.futures import process #语法正确</code></pre></div></figure><p>针对包内部模块之间的相互导入推荐使用相对导入，需要特别强调：</p><p>1、相对导入只能在包内部使用，用相对导入不同目录下的模块是非法的</p><p>2、无论是import还是from-import，但凡是在导入时带点的，点的左边必须是包,否则语法错误</p><p><img src="https://pic4.zhimg.com/80/v2-833bff5bca842734b92acebb8d524e03_720w.jpg" alt="img"></p><p>总结包的使用需要牢记三点<br>1、导包就是在导包下__init__.py文件<br>2、包内部的导入应该使用相对导入，相对导入也只能在包内部使用，而且…取上一级不能出包<br>3、<br>使用语句中的点代表的是访问属性<br>m.n.x —-&gt; 向m要n，向n要x<br>而导入语句中的点代表的是路径分隔符<br>import a.b.c –&gt; a&#x2F;b&#x2F;c，文件夹下a下有子文件夹b，文件夹b下有子文件或文件夹c<br>所以导入语句中点的左边必须是一个包</p><h2 id="2-3-from-包-import"><a href="#2-3-from-包-import" class="headerlink" title="2.3 from 包 import *"></a>2.3 from 包 import *</h2><p> 在使用包时同样支持from pool.futures import * ，毫无疑问<em>代表的是futures下__init__.py中所有的名字，通用是用变量__all__来控制</em>代表的意思</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#futures下的__init__.py__all__&#x3D;[&#39;process&#39;,&#39;thread&#39;]</code></pre></div></figure><p> 最后说明一点，包内部的目录结构通常是包的开发者为了方便自己管理和维护代码而创建的，这种目录结构对包的使用者往往是无用的，此时通过操作__init__.py可以“隐藏”包内部的目录结构，降低使用难度，比如想要让使用者直接使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import poolpool.check()pool.ProcessPoolExecutor(3)pool.ThreadPoolExecutor(3)</code></pre></div></figure><p>需要操作pool下的__init__.py</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from .versions import checkfrom .futures.process import ProcessPoolExecutorfrom .futures.thread import ThreadPoolExecutor</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-6c06f350e2f63e5e46e0fc59062dc6ac_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>包的定义：</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=69">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=69<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>包的使用：</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=70">https://www.bilibili.com/video/av73342471?p=70www.bilibili.com/video/av73342471?p=70</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20-模块</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/20_%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/20_%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一-模块介绍"><a href="#一-模块介绍" class="headerlink" title="一 模块介绍"></a>一 模块介绍</h2><p>在Python中，一个py文件就是一个模块，文件名为xxx.py模块名则是xxx,导入模块可以引用模块中已经写好的功能。如果把开发程序比喻成制造一台电脑，编写模块就像是在制造电脑的零部件，准备好零部件后，剩下的工作就是按照逻辑把它们组装到一起。</p><p>将程序模块化会使得程序的组织结构清晰，维护起来更加方便。比起直接开发一个完整的程序，单独开发一个小的模块也会更加简单，并且程序中的模块与电脑中的零部件稍微不同的是：程序中的模块可以被重复使用。所以总结下来，使用模块既保证了代码的重用性，又增强了程序的结构性和可维护性。另外除了自定义模块外，我们还可以导入使用内置或第三方模块提供的现成功能，这种“拿来主义”极大地提高了程序员的开发效率。</p><h2 id="二-模块的使用"><a href="#二-模块的使用" class="headerlink" title="二 模块的使用"></a>二 模块的使用</h2><h2 id="2-1-import语句"><a href="#2-1-import语句" class="headerlink" title="2.1 import语句"></a>2.1 import语句</h2><p>有如下示范文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#文件名：foo.pyx&#x3D;1def get():    print(x)def change():    global x    x&#x3D;0class Foo:    def func(self):       print(&#39;from the func&#39;)</code></pre></div></figure><p>要想在另外一个py文件中引用foo.py中的功能，需要使用import foo，首次导入模块会做三件事：</p><p>1、执行源文件代码</p><p>2、产生一个新的名称空间用于存放源文件执行过程中产生的名字</p><p>3、在当前执行文件所在的名称空间中得到一个名字foo，该名字指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import foo #导入模块fooa&#x3D;foo.x #引用模块foo中变量x的值赋值给当前名称空间中的名字afoo.get() #调用模块foo的get函数foo.change() #调用模块foo中的change函数obj&#x3D;foo.Foo() #使用模块foo的类Foo来实例化，进一步可以执行obj.func()</code></pre></div></figure><p>加上foo.作为前缀就相当于指名道姓地说明要引用foo名称空间中的名字，所以肯定不会与当前执行文件所在名称空间中的名字相冲突，并且若当前执行文件的名称空间中存在x，执行foo.get()或foo.change()操作的都是源文件中的全局变量x。</p><p><img src="https://pic4.zhimg.com/80/v2-884e2868bde505c7fb7232f576bbcfdb_720w.jpg" alt="img"></p><p>需要强调一点是，第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名。</p><p>提示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、在Python中模块也属于第一类对象，可以进行赋值、以数据形式传递以及作为容器类型的元素等操作。#2、模块名应该遵循小写形式，标准库从python2过渡到python3做出了很多这类调整，比如ConfigParser、Queue、SocketServer全更新为纯小写形式。</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-d0708c002191a57754895d0ed4d05262_720w.jpg" alt="img"></p><p>用import语句导入多个模块，可以写多行import语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import module1import module2    ...import moduleN</code></pre></div></figure><p>还可以在一行导入，用逗号分隔开不同的模块</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import module1,module2,...,moduleN</code></pre></div></figure><p>但其实第一种形式更为规范，可读性更强，推荐使用，而且我们导入的模块中可能包含有python内置的模块、第三方的模块、自定义的模块，为了便于明显地区分它们，我们通常在文件的开头导入模块，并且分类导入，一类模块的导入与另外一类的导入用空行隔开，不同类别的导入顺序如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. python内置模块#2. 第三方模块#3. 程序员自定义模块</code></pre></div></figure><p> 当然，我们也可以在函数内导入模块，对比在文件开头导入模块属于全局作用域，在函数内导入的模块则属于局部的作用域。</p><p><img src="https://pic1.zhimg.com/80/v2-506cce5c2b597bfe50f9644086cb2258_720w.jpg" alt="img"></p><h2 id="2-2-from-import-语句"><a href="#2-2-from-import-语句" class="headerlink" title="2.2 from-import 语句"></a>2.2 from-import 语句</h2><p>from…import…与import语句基本一致，唯一不同的是：使用import foo导入模块后，引用模块中的名字都需要加上foo.作为前缀，而使用from foo import x,get,change,Foo则可以在当前执行文件中直接引用模块foo中的名字，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from foo import x,get,change #将模块foo中的x和get导入到当前名称空间a&#x3D;x #直接使用模块foo中的x赋值给aget() #直接执行foo中的get函数change() #即便是当前有重名的x，修改的仍然是源文件中的x</code></pre></div></figure><p>无需加前缀的好处是使得我们的代码更加简洁，坏处则是容易与当前名称空间中的名字冲突，如果当前名称空间存在相同的名字，则后定义的名字会覆盖之前定义的名字。</p><p><img src="https://pic3.zhimg.com/80/v2-13b67a1601f0ad7ca5f461fb17a631ce_720w.jpg" alt="img"></p><p>另外from语句支持from foo import <em>语法，</em>代表将foo中所有的名字都导入到当前位置</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from foo import * #把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字a&#x3D;xget()change()obj&#x3D;Foo()</code></pre></div></figure><p>如果我们需要引用模块中的名字过多的话，可以采用上述的导入形式来达到节省代码量的效果，但是需要强调的一点是：只能在模块最顶层使用<em>的方式导入，在函数内则非法，并且</em>的方式会带来一种副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突。模块的编写者可以在自己的文件中定义__all__变量用来控制*代表的意思</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#foo.py__all__&#x3D;[&#39;x&#39;,&#39;get&#39;] #该列表中所有的元素必须是字符串类型，每个元素对应foo.py中的一个名字x&#x3D;1def get():    print(x)def change():    global x    x&#x3D;0class Foo:    def func(self):       print(&#39;from the func&#39;)</code></pre></div></figure><p>这样我们在另外一个文件中使用*导入时，就只能导入__all__定义的名字了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from foo import * #此时的*只代表x和getx #可用get() #可用change() #不可用Foo() #不可用</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-a7d712d021543c75a8f4be75999cee1e_720w.jpg" alt="img"></p><h2 id="2-3-其他导入语法-as"><a href="#2-3-其他导入语法-as" class="headerlink" title="2.3 其他导入语法(as)"></a>2.3 其他导入语法(as)</h2><p>我们还可以在当前位置为导入的模块起一个别名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import foo as f #为导入的模块foo在当前位置起别名f，以后再使用时就用这个别名ff.xf.get()</code></pre></div></figure><p>还可以为导入的一个名字起别名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from foo import get as get_xget_x()</code></pre></div></figure><p>通常在被导入的名字过长时采用起别名的方式来精简代码，另外为被导入的名字起别名可以很好地避免与当前名字发生冲突，还有很重要的一点就是：可以保持调用方式的一致性，例如我们有两个模块json和pickle同时实现了load方法，作用是从一个打开的文件中解析出结构化的数据，但解析的格式不同，可以用下述代码有选择性地加载不同的模块</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">if data_format &#x3D;&#x3D; &#39;json&#39;:    import json as serialize #如果数据格式是json，那么导入json模块并命名为serializeelif data_format &#x3D;&#x3D; &#39;pickle&#39;:    import pickle as serialize #如果数据格式是pickle，那么导入pickle模块并命名为serializedata&#x3D;serialize.load(fn) #最终调用的方式是一致的</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-46fbc37fa93302dfacd0803f7d78715d_720w.jpg" alt="img"></p><h2 id="2-4-循环导入问题"><a href="#2-4-循环导入问题" class="headerlink" title="2.4 循环导入问题"></a>2.4 循环导入问题</h2><p><img src="https://pic1.zhimg.com/80/v2-415ea58d416900ea166573cb65543080_720w.jpg" alt="img"></p><p>循环导入问题指的是在一个模块加载&#x2F;导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码</p><p><strong>我们以下述文件为例，来详细分析循环&#x2F;嵌套导入出现异常的原因以及解决的方案</strong></p><p>m1.py</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&#39;正在导入m1&#39;)from m2 import yx&#x3D;&#39;m1&#39;</code></pre></div></figure><p>m2.py</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&#39;正在导入m2&#39;)from m1 import xy&#x3D;&#39;m2&#39;</code></pre></div></figure><p>run.py</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import m1</code></pre></div></figure><p><strong>测试一</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、执行run.py会抛出异常正在导入m1正在导入m2Traceback (most recent call last):  File &quot;&#x2F;Users&#x2F;linhaifeng&#x2F;PycharmProjects&#x2F;pro01&#x2F;1 aaaa练习目录&#x2F;aa.py&quot;, line 1, in &lt;module&gt;    import m1  File &quot;&#x2F;Users&#x2F;linhaifeng&#x2F;PycharmProjects&#x2F;pro01&#x2F;1 aaaa练习目录&#x2F;m1.py&quot;, line 2, in &lt;module&gt;    from m2 import y  File &quot;&#x2F;Users&#x2F;linhaifeng&#x2F;PycharmProjects&#x2F;pro01&#x2F;1 aaaa练习目录&#x2F;m2.py&quot;, line 2, in &lt;module&gt;    from m1 import xImportError: cannot import name &#39;x&#39;#2、分析先执行run.py---&gt;执行import m1，开始导入m1并运行其内部代码---&gt;打印内容&quot;正在导入m1&quot;---&gt;执行from m2 import y 开始导入m2并运行其内部代码---&gt;打印内容“正在导入m2”---&gt;执行from m1 import x,由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿x，然而x此时并没有存在于m1中，所以报错</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-991b007f2b930863c768b479e0f303eb_720w.jpg" alt="img"></p><p><strong>测试二</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、执行文件不等于导入文件，比如执行m1.py不等于导入了m1直接执行m1.py抛出异常正在导入m1正在导入m2正在导入m1Traceback (most recent call last):  File &quot;&#x2F;Users&#x2F;linhaifeng&#x2F;PycharmProjects&#x2F;pro01&#x2F;1 aaaa练习目录&#x2F;m1.py&quot;, line 2, in &lt;module&gt;    from m2 import y  File &quot;&#x2F;Users&#x2F;linhaifeng&#x2F;PycharmProjects&#x2F;pro01&#x2F;1 aaaa练习目录&#x2F;m2.py&quot;, line 2, in &lt;module&gt;    from m1 import x  File &quot;&#x2F;Users&#x2F;linhaifeng&#x2F;PycharmProjects&#x2F;pro01&#x2F;1 aaaa练习目录&#x2F;m1.py&quot;, line 2, in &lt;module&gt;    from m2 import yImportError: cannot import name &#39;y&#39;#2、分析执行m1.py，打印“正在导入m1”，执行from m2 import y ，导入m2进而执行m2.py内部代码---&gt;打印&quot;正在导入m2&quot;，执行from m1 import x，此时m1是第一次被导入，执行m1.py并不等于导入了m1，于是开始导入m1并执行其内部代码---&gt;打印&quot;正在导入m1&quot;，执行from m1 import y，由于m1已经被导入过了，所以无需继续导入而直接问m2要y，然而y此时并没有存在于m2中所以报错</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-99a7e78c8f88bf5e443c03d3b94183ca_720w.jpg" alt="img"></p><p><strong>解决方案</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方案一：导入语句放到最后，保证在导入时，所有名字都已经加载过# 文件：m1.pyprint(&#39;正在导入m1&#39;)x&#x3D;&#39;m1&#39;from m2 import y# 文件：m2.pyprint(&#39;正在导入m2&#39;)y&#x3D;&#39;m2&#39;from m1 import x# 文件：run.py内容如下，执行该文件，可以正常使用import m1print(m1.x)print(m1.y)# 方案二：导入语句放到函数中，只有在调用函数时才会执行其内部代码# 文件：m1.pyprint(&#39;正在导入m1&#39;)def f1():    from m2 import y    print(x,y)x &#x3D; &#39;m1&#39;# 文件：m2.pyprint(&#39;正在导入m2&#39;)def f2():    from m1 import x    print(x,y)y &#x3D; &#39;m2&#39;# 文件：run.py内容如下，执行该文件，可以正常使用import m1m1.f1()</code></pre></div></figure><p><strong>注意：循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环&#x2F;嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入</strong></p><p><img src="https://pic2.zhimg.com/80/v2-ba9d3d04398d89655c579c67cbe9f9f1_720w.jpg" alt="img"></p><h2 id="2-5-搜索模块的路径与优先级"><a href="#2-5-搜索模块的路径与优先级" class="headerlink" title="2.5 搜索模块的路径与优先级"></a>2.5 搜索模块的路径与优先级</h2><p>模块其实分为四个通用类别，分别是：</p><p>1、使用纯Python代码编写的py文件</p><p>2、包含一系列模块的包</p><p>3、使用C编写并链接到Python解释器中的内置模块</p><p>4、使用C或C++编译的扩展模块</p><p>在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。sys.path也被称为模块的搜索路径，它是一个列表类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; sys.path[&#39;&#39;,&#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.5&#x2F;lib&#x2F;python35.zip&#39;,&#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.5&#x2F;lib&#x2F;python3.5&#39;,...,&#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.5&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#39;</code></pre></div></figure><p>列表中的每个元素其实都可以当作一个目录来看：在列表中会发现有.zip或.egg结尾的文件，二者是不同形式的压缩文件，事实上Python确实支持从一个压缩文件中导入模块，我们也只需要把它们都当成目录去看即可。</p><p><img src="https://pic3.zhimg.com/80/v2-b380918dbff3c80f06c3e47d778b913e_720w.jpg" alt="img"></p><p>sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为&#x2F;pythoner&#x2F;projects&#x2F;</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import syssys.path.append(r&#39;&#x2F;pythoner&#x2F;projects&#x2F;&#39;) #也可以使用sys.path.insert(……)import foo #无论foo.py在何处,我们都可以导入它了</code></pre></div></figure><h2 id="2-6-区分py文件的两种用途"><a href="#2-6-区分py文件的两种用途" class="headerlink" title="2.6 区分py文件的两种用途"></a>2.6 区分py文件的两种用途</h2><p>一个Python文件有两种用途，一种被当主程序&#x2F;脚本执行，另一种被当模块导入，为了区别同一个文件的不同用途，每个py文件都内置了__name__变量，该变量在py文件被当做脚本执行时赋值为“__main__”,在py文件被当做模块导入时赋值为模块名</p><p><img src="https://pic4.zhimg.com/80/v2-d10449104b8d634196b784b31ab1f0e3_720w.jpg" alt="img"></p><p>作为模块foo.py的开发者，可以在文件末尾基于__name__在不同应用场景下值的不同来控制文件执行不同的逻辑</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#foo.py...if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    foo.py被当做脚本执行时运行的代码else:    foo.py被当做模块导入时运行的代码</code></pre></div></figure><p>通常我们会在if的子代码块中编写针对模块功能的测试代码，这样foo.py在被当做脚本运行时，就会执行测试代码，而被当做模块导入时则不用执行测试代码。</p><h2 id="2-7-编写一个规范的模块"><a href="#2-7-编写一个规范的模块" class="headerlink" title="2.7 编写一个规范的模块"></a>2.7 编写一个规范的模块</h2><p><img src="https://pic2.zhimg.com/80/v2-c8e40baa1976d8e26f75f0fa2ceb5cd5_720w.jpg" alt="img"></p><p>我们在编写py文件时，需要时刻提醒自己，该文件既是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时最好按照统一的规范去编写，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python #通常只在类unix环境有效,作用是可以使用脚本名来执行，而无需直接调用解释器。&quot;The module is used to...&quot; #模块的文档描述import sys #导入模块x&#x3D;1 #定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能class Foo: #定义类,并写好类的注释    &#39;Class Foo is used to...&#39;    passdef test(): #定义函数,并写好函数的注释    &#39;Function test is used to…&#39;    passif __name__ &#x3D;&#x3D; &#39;__main__&#39;: #主程序    test() #在被当做脚本执行时,执行此处的代码</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-0aa2d5e22f88e3b8b8f4b6f2fdfb76b1_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>模块的使用之import</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=65">https://www.bilibili.com/video/av73342471?p=65www.bilibili.com/video/av73342471?p=65</a></p><p>模块的使用之from…import…</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=66">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=66<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>区分python文件的两种用途</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=67">https://www.bilibili.com/video/av73342471?p=67www.bilibili.com/video/av73342471?p=67</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19-面向过程和函数式</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/19_%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/19_%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一-编程范式"><a href="#一-编程范式" class="headerlink" title="一 编程范式"></a>一 编程范式</h2><p> 很多初学者在了解了一门编程语言的基本语法和使用之后，面对一个’开发需求‘时仍然会觉得无从下手、没有思路&#x2F;套路，本节主题“编程范式”正是为了解决该问题，那到底什么是编程范式呢？</p><p>编程范式指的就是编程的套路，打个比方，如果把编程的过程比喻为练习武功，那编程范式指的就是武林中的各种流派，而在编程的世界里常见的流派有：面向过程、函数式、面向对象等，本节我们主要介绍前两者。</p><p> 在正式介绍前，我们需要强调：“功夫的流派没有高低之分，只有习武的人才有高低之分“，在编程世界里更是这样，各种编程范式在不同的场景下都各有优劣，谁好谁坏不能一概而论，下面就让我们来一一解读它们。</p><p><img src="https://pic3.zhimg.com/80/v2-320a4e510709df1dd29361212ca7617e_720w.jpg" alt="img"></p><h2 id="二-面向过程"><a href="#二-面向过程" class="headerlink" title="二 面向过程"></a>二 面向过程</h2><p> ”面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤，即先干什么再干什么……，基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行，即无论采用什么语言、无论依据何种编程范式设计出的程序，最终的执行都是过程式的。</p><p><img src="https://pic1.zhimg.com/80/v2-84ee41725a5dbbd4e8c6cbcf9c7a28f8_720w.jpg" alt="img"></p><p> 详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。举例如下：</p><p> 写一个数据远程备份程序，分三步：本地数据打包，上传至云服务器，检测备份文件可用性</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import os,time# 一：基于本章所学，我们可以用函数去实现这一个个的步骤# 1、本地数据打包def data_backup(folder):    print(&quot;找到备份目录: %s&quot; %folder)    print(&#39;正在备份...&#39;)    zip_file&#x3D;&#39;&#x2F;tmp&#x2F;backup_%s.zip&#39; %time.strftime(&#39;%Y%m%d&#39;)    print(&#39;备份成功，备份文件为: %s&#39; %zip_file)    return zip_file#2、上传至云服务器def cloud_upload(file):    print(&quot;\nconnecting cloud storage center...&quot;)    print(&quot;cloud storage connected&quot;)    print(&quot;upload [%s] to cloud...&quot; %file)    link&#x3D;&#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;bak&#x2F;%s&#39; %os.path.basename(file)    print(&#39;close connection&#39;)    return link#3、检测备份文件可用性def data_backup_check(link):    print(&quot;\n下载文件: %s , 验证文件是否无损...&quot; %link)#二：依次调用# 步骤一：本地数据打包zip_file &#x3D; data_backup(r&quot;&#x2F;Users&#x2F;egon&#x2F;欧美100G高清无码&quot;)# 步骤二：上传至云服务器link&#x3D;cloud_upload(zip_file)# 步骤三：检测备份文件的可用性data_backup_check(link)</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-d7abc4f23679ef40d74b5ab5a5d01e95_720w.jpg" alt="img"></p><p>面向过程总结：</p><p>1、优点</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">将复杂的问题流程化，进而简单化</code></pre></div></figure><p>2、缺点</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;程序的可扩展性极差，因为一套流水线或者流程就是用来解决一个问题，就好比生产汽水的流水线无法生产汽车一样，即便是能，也得是大改，而且改一个组件，与其相关的组件可能都需要修改，比如我们修改了cloud_upload的逻辑，那么依赖其结果才能正常执行的data_backup_check也需要修改，这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕。&#39;&#39;&#39;def cloud_upload(file): # 加上异常处理，在出现异常的情况下，没有link返回    try:        print(&quot;\nconnecting cloud storage center...&quot;)        print(&quot;cloud storage connected&quot;)        print(&quot;upload [%s] to cloud...&quot; %file)        link&#x3D;&#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;bak&#x2F;%s&#39; %os.path.basename(file)        print(&#39;close connection&#39;)        return link    except Exception:        print(&#39;upload error&#39;)    finally:        print(&#39;close connection.....&#39;)def data_backup_check(link): # 加上对参数link的判断    if link:        print(&quot;\n下载文件: %s , 验证文件是否无损...&quot; %link)    else:        print(&#39;\n链接不存在&#39;)</code></pre></div></figure><p>3、应用场景</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">面向过程的程序设计一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-7ef6c56d758201f1262fce11e4b52cc6_720w.jpg" alt="img"></p><h2 id="三-函数式"><a href="#三-函数式" class="headerlink" title="三 函数式"></a>三 函数式</h2><p>函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提供了很多函数式编程好的特性，如lambda，map，reduce，filter</p><p><img src="https://pic1.zhimg.com/80/v2-fcd96db9b6524e583f4483121d7fe160_720w.jpg" alt="img"></p><h2 id="3-1-匿名函数与lambda"><a href="#3-1-匿名函数与lambda" class="headerlink" title="3.1 匿名函数与lambda"></a>3.1 匿名函数与lambda</h2><p> 对比使用def关键字创建的是有名字的函数，使用lambda关键字创建则是没有名字的函数，即匿名函数，语法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">lambda 参数1,参数2,...: expression</code></pre></div></figure><p>举例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、定义lambda x,y,z:x+y+z#等同于def func(x,y,z):    return x+y+z# 2、调用# 方式一：res&#x3D;(lambda x,y,z:x+y+z)(1,2,3)# 方式二：func&#x3D;lambda x,y,z:x+y+z # “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的res&#x3D;func(1,2,3)</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-51fa4a8780bba6ac0b31a882bedfd92d_720w.jpg" alt="img"></p><p>匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用，我们以下述字典为例来介绍它</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">salaries&#x3D;&#123;    &#39;siry&#39;:3000,    &#39;tom&#39;:7000,    &#39;lili&#39;:10000,    &#39;jack&#39;:2000&#125;</code></pre></div></figure><p>要想取得薪水的最大值和最小值，我们可以使用内置函数max和min（为了方便开发，python解释器已经为我们定义好了一系列常用的功能，称之为内置的函数，我们只需要拿来使用即可）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; max(salaries)&#39;tom&#39;&gt;&gt;&gt; min(salaries)&#39;jack&#39;</code></pre></div></figure><p>内置max和min都支持迭代器协议，工作原理都是迭代字典，取得是字典的键，因而比较的是键的最大和最小值，而我们想要的是比较值的最大值与最小值，于是做出如下改动</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 函数max会迭代字典salaries，每取出一个“人名”就会当做参数传给指定的匿名函数，然后将匿名函数的返回值当做比较依据，最终返回薪资最高的那个人的名字&gt;&gt;&gt; max(salaries,key&#x3D;lambda k:salaries[k]) &#39;lili&#39;# 原理同上&gt;&gt;&gt; min(salaries,key&#x3D;lambda k:salaries[k])&#39;jack&#39;</code></pre></div></figure><p>同理，我们直接对字典进行排序，默认也是按照字典的键去排序的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; sorted(salaries)[&#39;jack&#39;, &#39;lili&#39;, &#39;siry&#39;, &#39;tom&#39;]</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-73a826d95d6e8a03bf2db2c8e3bfd84e_720w.jpg" alt="img"></p><h2 id="3-2-map、reduce、filter"><a href="#3-2-map、reduce、filter" class="headerlink" title="3.2 map、reduce、filter"></a>3.2 map、reduce、filter</h2><p>函数map、reduce、filter都支持迭代器协议，用来处理可迭代对象，我们以一个可迭代对象array为例来介绍它们三个的用法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">array&#x3D;[1,2,3,4,5]</code></pre></div></figure><p>要求一：对array的每个元素做平方处理，可以使用map函数</p><p>map函数可以接收两个参数，一个是函数，另外一个是可迭代对象，具体用法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; res&#x3D;map(lambda x:x**2,array)&gt;&gt;&gt; res&lt;map object at 0x1033f45f8&gt;&gt;&gt;&gt;</code></pre></div></figure><p>解析：map会依次迭代array，得到的值依次传给匿名函数（也可以是有名函数），而map函数得到的结果仍然是迭代器。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; list(res) #使用list可以依次迭代res，取得的值作为列表元素[1, 4, 9, 16, 25]</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-585046858a6b78be30ccd4a4b1ef2da3_720w.jpg" alt="img"></p><p>要求二：对array进行合并操作，比如求和运算，这就用到了reduce函数</p><p>reduce函数可以接收三个参数，一个是函数，第二个是可迭代对象，第三个是初始值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># reduce在python2中是内置函数，在python3中则被集成到模块functools中，需要导入才能使用&gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; res&#x3D;reduce(lambda x,y:x+y,array)&gt;&gt;&gt; res15</code></pre></div></figure><p>解析：</p><p>1 没有初始值，reduce函数会先迭代一次array得到的值作为初始值，作为第一个值数传给x，然后继续迭代一次array得到的值作为第二个值传给y，运算的结果为3</p><p>2 将上一次reduce运算的结果作为第一个值传给x，然后迭代一次array得到的结果作为第二个值传给y，依次类推，知道迭代完array的所有元素，得到最终的结果15</p><p>也可以为reduce指定初始值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; res&#x3D;reduce(lambda x,y:x+y,array,100) &gt;&gt;&gt; res115</code></pre></div></figure><p>要求三：对array进行过滤操作，这就用到了filter函数，比如过滤出大于3的元素</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; res&#x3D;filter(lambda x:x&gt;3,array)</code></pre></div></figure><p>解析：filter函数会依次迭代array，得到的值依次传给匿名函数，如果匿名函数的返回值为真，则过滤出该元素，而filter函数得到的结果仍然是迭代器。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; list(res) [4, 5]</code></pre></div></figure><p>提示：我们介绍map、filter、reduce只是为了带大家了解函数式编程的大致思想，在实际开发中，我们完全可以用列表生成式或者生成器表达式来实现三者的功能。</p><p><img src="https://pic3.zhimg.com/80/v2-8ce8d9f5f81621b10d67231fd1c60f86_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=55">https://www.bilibili.com/video/av73342471?p=55www.bilibili.com/video/av73342471?p=55</a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=56">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=56<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18-函数递归</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/18_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/18_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h2 id="一-函数递归调用介绍"><a href="#一-函数递归调用介绍" class="headerlink" title="一 函数递归调用介绍"></a>一 函数递归调用介绍</h2><p><img src="https://pic2.zhimg.com/80/v2-41fbf2d09891b34e4150056188af9201_720w.jpg" alt="img"></p><p>函数不仅可以嵌套定义，还可以嵌套调用，即在调用一个函数的过程中，函数内部又调用另一个函数，而函数的递归调用指的是在调用一个函数的过程中又直接或间接地调用该函数本身</p><p><img src="https://pic3.zhimg.com/80/v2-3b052e2e8d0b3e8db1e7c7230478bd8a_720w.jpg" alt="img"></p><p>例如</p><p>在调用f1的过程中，又调用f1，这就是直接调用函数f1本身</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def f1():    print(&#39;from f1&#39;)    f1()f1()</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-e409210099ed20bf4b6a01fc4f1a7c9e_720w.jpg" alt="img"></p><p>在调用f1的过程中，又调用f2，而在调用f2的过程中又调用f1，这就是间接调用函数f1本身</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def f1():    print(&#39;from f1&#39;)    f2()def f2():    print(&#39;from f2&#39;)    f1()f1()</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-3190338dfab02a5e59a1f6d099801667_720w.jpg" alt="img"></p><p>从上图可以看出，两种情况下的递归调用都是一个无限循环的过程，但在python对函数的递归调用的深度做了限制，因而并不会像大家所想的那样进入无限循环，会抛出异常，要避免出现这种情况，就必须让递归调用在满足某个特定条件下终止。</p><p>提示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 可以使用sys.getrecursionlimit()去查看递归深度，默认值为1000，虽然可以使用sys.setrecursionlimit()去设定该值，但仍受限于主机操作系统栈大小的限制#2. python不是一门函数式编程语言，无法对递归进行尾递归优化。</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-d949d426fb903f274b5fa4126516b9d8_720w.jpg" alt="img"></p><h2 id="二-回溯与递推"><a href="#二-回溯与递推" class="headerlink" title="二 回溯与递推"></a>二 回溯与递推</h2><p>下面我们用一个浅显的例子，为了让读者阐释递归的原理和使用：</p><p>例4.5</p><p>某公司四个员工坐在一起，问第四个人薪水，他说比第三个人多1000，问第三个人薪水，第他说比第二个人多1000，问第二个人薪水，他说比第一个人多1000，最后第一人说自己每月5000，请问第四个人的薪水是多少？</p><p>思路解析：</p><p>要知道第四个人的月薪，就必须知道第三个人的，第三个人的又取决于第二个人的，第二个人的又取决于第一个人的，而且每一个员工都比前一个多一千，数学表达式即：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">salary(4)&#x3D;salary(3)+1000 salary(3)&#x3D;salary(2)+1000 salary(2)&#x3D;salary(1)+1000 salary(1)&#x3D;5000总结为： salary(n)&#x3D;salary(n-1)+1000 (n&gt;1) salary(1)&#x3D;5000 (n&#x3D;1) </code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-56aac40500c7f687bf181640f4c36eee_720w.jpg" alt="img"></p><p>很明显这是一个递归的过程，可以将该过程分为两个阶段：回溯和递推。</p><p> 在回溯阶段，要求第n个员工的薪水，需要回溯得到(n-1)个员工的薪水，以此类推，直到得到第一个员工的薪水，此时，salary(1)已知，因而不必再向前回溯了。然后进入递推阶段：从第一个员工的薪水可以推算出第二个员工的薪水(6000)，从第二个员工的薪水可以推算出第三个员工的薪水(7000)，以此类推，一直推算出第第四个员工的薪水(8000)为止，递归结束。需要注意的一点是，递归一定要有一个结束条件，这里n&#x3D;1就是结束条件。</p><p><img src="https://pic3.zhimg.com/80/v2-b8756ae5141d371f4594408e3df84e56_720w.jpg" alt="img"></p><p>代码实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def salary(n):    if n&#x3D;&#x3D;1:        return 5000    return salary(n-1)+1000s&#x3D;salary(4)print(s)</code></pre></div></figure><p>执行结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">8000</code></pre></div></figure><p>程序分析：</p><p>在未满足n==1的条件时，一直进行递归调用，即一直回溯，见图4.3的左半部分。而在满足n==1的条件时，终止递归调用，即结束回溯，从而进入递推阶段，依次推导直到得到最终的结果。</p><p>递归本质就是在做重复的事情，所以理论上递归可以解决的问题循环也都可以解决，只不过在某些情况下，使用递归会更容易实现，比如有一个嵌套多层的列表，要求打印出所有的元素，代码实现如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">items&#x3D;[[1,2],3,[4,[5,[6,7]]]]def foo(items):    for i in items:        if isinstance(i,list): #满足未遍历完items以及if判断成立的条件时，一直进行递归调用            foo(i)         else:            print(i,end&#x3D;&#39; &#39;)foo(items) #打印结果1 2 3 4 5 6 7</code></pre></div></figure><p>使用递归，我们只需要分析出要重复执行的代码逻辑，然后提取进入下一次递归调用的条件或者说递归结束的条件即可，代码实现起来简洁清晰</p><p><img src="https://pic4.zhimg.com/80/v2-73c8b40fe24179104a712dcb49be1153_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=59">https://www.bilibili.com/video/av73342471?p=59www.bilibili.com/video/av73342471?p=59</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-生成器</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/17_%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/17_%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-生成器与yield"><a href="#一-生成器与yield" class="headerlink" title="一 生成器与yield"></a>一 生成器与yield</h2><p><img src="https://pic2.zhimg.com/80/v2-2c92ed3ae0da1fd192339be9abc973a1_720w.jpg" alt="img"></p><p>若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def my_range(start,stop,step&#x3D;1):...     print(&#39;start...&#39;)...     while start &lt; stop:...         yield start...         start+&#x3D;step...     print(&#39;end...&#39;)... &gt;&gt;&gt; g&#x3D;my_range(0,3)&gt;&gt;&gt; g&lt;generator object my_range at 0x104105678&gt;</code></pre></div></figure><p>生成器内置有__iter__和__next__方法，所以生成器本身就是一个迭代器</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; g.__iter__&lt;method-wrapper &#39;__iter__&#39; of generator object at 0x1037d2af0&gt;&gt;&gt;&gt; g.__next__&lt;method-wrapper &#39;__next__&#39; of generator object at 0x1037d2af0&gt;</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-31590362f23201814f45879db5dd6a51_720w.jpg" alt="img"></p><p>因而我们可以用next(生成器)触发生成器所对应函数的执行，</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; next(g) # 触发函数执行直到遇到yield则停止,将yield后的值返回，并在当前位置挂起函数start...0&gt;&gt;&gt; next(g) # 再次调用next(g)，函数从上次暂停的位置继续执行，直到重新遇到yield...1&gt;&gt;&gt; next(g) # 周而复始...2&gt;&gt;&gt; next(g) # 触发函数执行没有遇到yield则无值返回，即取值完毕抛出异常结束迭代end...Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-fa04ec0eaa5bd7bb8804908ad7b88369_720w.jpg" alt="img"></p><p>既然生成器对象属于迭代器，那么必然可以使用for循环迭代，如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for i in countdown(3):...     print(i)... countdown start321Done!</code></pre></div></figure><p>有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值</p><p><img src="https://pic4.zhimg.com/80/v2-024f3ac36393f784226497828d53eebf_720w.jpg" alt="img"></p><h2 id="二-yield表达式应用"><a href="#二-yield表达式应用" class="headerlink" title="二 yield表达式应用"></a>二 yield表达式应用</h2><p>在函数内可以采用表达式形式的yield</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def eater():...     print(&#39;Ready to eat&#39;)...     while True:...         food&#x3D;yield...         print(&#39;get the food: %s, and start to eat&#39; %food)...</code></pre></div></figure><p>可以拿到函数的生成器对象持续为函数体send值，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; g&#x3D;eater() # 得到生成器对象&gt;&gt;&gt; g&lt;generator object eater at 0x101b6e2b0&gt;&gt;&gt;&gt; next(e) # 需要事先”初始化”一次，让函数挂起在food&#x3D;yield，等待调用g.send()方法为其传值Ready to eat&gt;&gt;&gt; g.send(&#39;包子&#39;)get the food: 包子, and start to eat&gt;&gt;&gt; g.send(&#39;鸡腿&#39;)get the food: 鸡腿, and start to eat</code></pre></div></figure><p>针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food&#x3D;yield的位置，等待调用g.send()方法为函数体传值，g.send(None)等同于next(g)。</p><p><img src="https://pic1.zhimg.com/80/v2-277c3fe7374520dba8973dea02474790_720w.jpg" alt="img"></p><p> 我们可以编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def init(func):    def wrapper(*args,**kwargs):        g&#x3D;func(*args,**kwargs)        next(g)        return g    return wrapper@initdef eater():    print(&#39;Ready to eat&#39;)    while True:        food&#x3D;yield        print(&#39;get the food: %s, and start to eat&#39; %food)</code></pre></div></figure><p>表达式形式的yield也可以用于返回多次值，即<code>变量名=yield 值</code>的形式，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def eater():...     print(&#39;Ready to eat&#39;)...     food_list&#x3D;[]...     while True:...         food&#x3D;yield food_list...         food_list.append(food)... &gt;&gt;&gt; e&#x3D;eater()&gt;&gt;&gt; next(e)Ready to eat[]&gt;&gt;&gt; e.send(&#39;蒸羊羔&#39;)[&#39;蒸羊羔&#39;]&gt;&gt;&gt; e.send(&#39;蒸熊掌&#39;)[&#39;蒸羊羔&#39;, &#39;蒸熊掌&#39;]&gt;&gt;&gt; e.send(&#39;蒸鹿尾儿&#39;)[&#39;蒸羊羔&#39;, &#39;蒸熊掌&#39;, &#39;蒸鹿尾儿&#39;]</code></pre></div></figure><h2 id="三-三元表达式、列表生成式、生成器表达式"><a href="#三-三元表达式、列表生成式、生成器表达式" class="headerlink" title="三 三元表达式、列表生成式、生成器表达式"></a>三 三元表达式、列表生成式、生成器表达式</h2><h2 id="3-1-三元表达式"><a href="#3-1-三元表达式" class="headerlink" title="3.1 三元表达式"></a>3.1 三元表达式</h2><p>三元表达式是python为我们提供的一种简化代码的解决方案，语法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; 条件成立时返回的值 if 条件 else 条件不成立时返回的值</code></pre></div></figure><p>针对下述场景</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def max2(x,y):    if x &gt; y:        return x    else:        return yres &#x3D; max2(1,2)</code></pre></div></figure><p>用三元表达式可以一行解决</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;1y&#x3D;2res &#x3D; x if x &gt; y else y # 三元表达式</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-6b5e335f9c2baca1a9d076721c672b19_720w.jpg" alt="img"></p><h2 id="3-2-列表生成式"><a href="#3-2-列表生成式" class="headerlink" title="3.2 列表生成式"></a>3.2 列表生成式</h2><p>列表生成式是python为我们提供的一种简化代码的解决方案，用来快速生成列表，语法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">[expression for item1 in iterable1 if condition1for item2 in iterable2 if condition2...for itemN in iterableN if conditionN]#类似于res&#x3D;[]for item1 in iterable1:    if condition1:        for item2 in iterable2:            if condition2                ...                for itemN in iterableN:                    if conditionN:                        res.append(expression)</code></pre></div></figure><p>针对下述场景</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">egg_list&#x3D;[]for i in range(10):    egg_list.append(&#39;鸡蛋%s&#39; %i)</code></pre></div></figure><p>用列表生成式可以一行解决</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">egg_list&#x3D;[&#39;鸡蛋%s&#39; %i for i in range(10)]</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-d9640f4c3f1c13bbd78e7cf6de6dc316_720w.jpg" alt="img"></p><h2 id="3-3-生成器表达式"><a href="#3-3-生成器表达式" class="headerlink" title="3.3 生成器表达式"></a>3.3 生成器表达式</h2><p>创建一个生成器对象有两种方式，一种是调用带yield关键字的函数，另一种就是生成器表达式，与列表生成式的语法格式相同，只需要将[]换成()，即：</p><p><img src="https://pic3.zhimg.com/80/v2-70257d333a3e9a49704c10982ce48856_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">（expression for item in iterable if condition）</code></pre></div></figure><p>对比列表生成式返回的是一个列表，生成器表达式返回的是一个生成器对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; [x*x for x in range(3)][0, 1, 4]&gt;&gt;&gt; g&#x3D;(x*x for x in range(3))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x101be0ba0&gt;</code></pre></div></figure><p>对比列表生成式，生成器表达式的优点自然是节省内存（一次只产生一个值在内存中）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g) #抛出异常StopIteration</code></pre></div></figure><p>如果我们要读取一个大文件的字节数，应该基于生成器表达式的方式完成</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">with open(&#39;db.txt&#39;,&#39;rb&#39;) as f:    nums&#x3D;(len(line) for line in f)    total_size&#x3D;sum(nums) # 依次执行next(nums)，然后累加到一起得到结果&#x3D;</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-f0a061871b663d857e13ada7c10b31ac_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=52">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=52<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=53">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=53<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=54">https://www.bilibili.com/video/av73342471?p=54www.bilibili.com/video/av73342471?p=54</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16-迭代器</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/16_%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/16_%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-迭代器介绍"><a href="#一-迭代器介绍" class="headerlink" title="一 迭代器介绍"></a>一 迭代器介绍</h2><p>迭代器即用来迭代取值的工具，而迭代是重复反馈过程的活动，其目的通常是为了逼近所需的目标或结果，每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值,单纯的重复并不是迭代</p><p><img src="https://pic4.zhimg.com/80/v2-565373773a847faa7a97a79b8851d2db_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">while True:    msg &#x3D; input(&#39;&gt;&gt;: &#39;).strip()    print(msg)</code></pre></div></figure><p>下述while循环才是一个迭代过程，不仅满足重复，而且以每次重新赋值后的index值作为下一次循环中新的索引进行取值，反复迭代，最终可以取尽列表中的值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">goods&#x3D;[&#39;mac&#39;,&#39;lenovo&#39;,&#39;acer&#39;,&#39;dell&#39;,&#39;sony&#39;]index&#x3D;0while index &lt; len(goods):    print(goods[index])    index+&#x3D;1</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-70866f67008dbbd32b1db9a0122e5a85_720w.jpg" alt="img"></p><h2 id="1-1-可迭代对象"><a href="#1-1-可迭代对象" class="headerlink" title="1.1 可迭代对象"></a>1.1 可迭代对象</h2><p>通过索引的方式进行迭代取值，实现简单，但仅适用于序列类型：字符串，列表，元组。对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了迭代器。</p><p>要想了解迭代器为何物，必须事先搞清楚一个很重要的概念：可迭代对象(Iterable)。从语法形式上讲，内置有__iter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123;&#39;name&#39;:&#39;egon&#39;&#125;.__iter__&#123;7,8,9&#125;.__iter__……</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-2d426dd7229747e25b7342c4bba5be50_720w.jpg" alt="img"></p><h3 id="1-2-迭代器对象"><a href="#1-2-迭代器对象" class="headerlink" title="1.2 迭代器对象"></a>1.2 迭代器对象</h3><p>调用obj.<strong>iter</strong>()方法返回的结果就是一个迭代器对象(Iterator)。迭代器对象是内置有<strong>iter</strong>和<strong>next</strong>方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.<strong>iter</strong>()方法得到的仍然是迭代器本身，而执行迭代器.<strong>next</strong>()方法就会计算出迭代器中的下一个值。 迭代器是Python提供的一种统一的、不依赖于索引的迭代取值方式，只要存在多个“值”，无论序列类型还是非序列类型都可以按照迭代器的方式取值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; s&#x3D;&#123;1,2,3&#125; # 可迭代对象s&gt;&gt;&gt; i&#x3D;iter(s)  # 本质就是在调用s.__iter__(),返回s的迭代器对象i，&gt;&gt;&gt; next(i) # 本质就是在调用i.__next__()1&gt;&gt;&gt; next(i)2&gt;&gt;&gt; next(i)3&gt;&gt;&gt; next(i)  #抛出StopIteration的异常，代表无值可取，迭代结束</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-737e0d369eb76a990b772d9666e25a4f_720w.jpg" alt="img"></p><h2 id="二-for循环原理"><a href="#二-for循环原理" class="headerlink" title="二 for循环原理"></a>二 for循环原理</h2><p>有了迭代器后，我们便可以不依赖索引迭代取值了，使用while循环的实现方式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">goods&#x3D;[&#39;mac&#39;,&#39;lenovo&#39;,&#39;acer&#39;,&#39;dell&#39;,&#39;sony&#39;]i&#x3D;iter(goods) #每次都需要重新获取一个迭代器对象while True:    try:        print(next(i))    except StopIteration: #捕捉异常终止循环        break</code></pre></div></figure><p>for循环又称为迭代循环，in后可以跟任意可迭代对象，上述while循环可以简写为</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">goods&#x3D;[&#39;mac&#39;,&#39;lenovo&#39;,&#39;acer&#39;,&#39;dell&#39;,&#39;sony&#39;]for item in goods:       print(item)</code></pre></div></figure><p>for 循环在工作时，首先会调用可迭代对象goods内置的<strong>iter</strong>方法拿到一个迭代器对象，然后再调用该迭代器对象的<strong>next</strong>方法将取到的值赋给item,执行循环体完成一次循环，周而复始，直到捕捉StopIteration异常，结束迭代。</p><p><img src="https://pic2.zhimg.com/80/v2-c64b3c28a2b8977bfce7621078da63b9_720w.jpg" alt="img"></p><h2 id="三-迭代器的优缺点"><a href="#三-迭代器的优缺点" class="headerlink" title="三 迭代器的优缺点"></a>三 迭代器的优缺点</h2><p>基于索引的迭代取值，所有迭代的状态都保存在了索引中，而基于迭代器实现迭代的方式不再需要索引，所有迭代的状态就保存在迭代器中，然而这种处理方式优点与缺点并存：</p><h2 id="3-1-优点："><a href="#3-1-优点：" class="headerlink" title="3.1 优点："></a>3.1 优点：</h2><p>1、为序列和非序列类型提供了一种统一的迭代取值方式。</p><p>2、惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用<strong>next</strong>来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。</p><p><img src="https://pic2.zhimg.com/80/v2-c91b05bd30f1abae45ec6867bb5e9625_720w.jpg" alt="img"></p><h2 id="3-2-缺点："><a href="#3-2-缺点：" class="headerlink" title="3.2 缺点："></a>3.2 缺点：</h2><p>1、除非取尽，否则无法获取迭代器的长度</p><p>2、只能取下一个值，不能回到开始，更像是‘一次性的’，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值。</p><p><img src="https://pic2.zhimg.com/80/v2-8e0f71376333332d0411bb2199131c6d_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=51">https://www.bilibili.com/video/av73342471?p=51www.bilibili.com/video/av73342471?p=51</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15-装饰器</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/15_%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/15_%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-装饰器介绍"><a href="#一-装饰器介绍" class="headerlink" title="一 装饰器介绍"></a>一 装饰器介绍</h2><h2 id="1-1-为何要用装饰器"><a href="#1-1-为何要用装饰器" class="headerlink" title="1.1 为何要用装饰器"></a>1.1 为何要用装饰器</h2><p><img src="https://pic3.zhimg.com/80/v2-5f0bd90a1428a4b373be52c22f7d871a_720w.jpg" alt="img"></p><p>软件的设计应该遵循开放封闭原则，即对扩展是开放的，而对修改是封闭的。对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改。</p><p>软件包含的所有功能的源代码以及调用方式，都应该避免修改，否则一旦改错，则极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器。</p><h2 id="1-2-什么是装饰器"><a href="#1-2-什么是装饰器" class="headerlink" title="1.2 什么是装饰器"></a>1.2 什么是装饰器</h2><p><img src="https://pic2.zhimg.com/80/v2-b43bfaa7c4abf2a53d535ce272d937b9_720w.jpg" alt="img"></p><p>’装饰’代指为被装饰对象添加新的功能，’器’代指器具&#x2F;工具，装饰器与被装饰的对象均可以是任意可调用对象。概括地讲，装饰器的作用就是在不修改被装饰对象源代码和调用方式的前提下为被装饰对象添加额外的功能。装饰器经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等应用场景，装饰器是解决这类问题的绝佳设计，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p><p>提示：可调用对象有函数，方法或者类，此处我们单以本章主题函数为例，来介绍函数装饰器，并且被装饰的对象也是函数。</p><h2 id="二-装饰器的实现"><a href="#二-装饰器的实现" class="headerlink" title="二 装饰器的实现"></a>二 装饰器的实现</h2><p>函数装饰器分为：无参装饰器和有参装饰两种，二者的实现原理一样，都是’函数嵌套+闭包+函数对象’的组合使用的产物。</p><p><img src="https://pic2.zhimg.com/80/v2-21b3488ea792ad818b3eea81740f6945_720w.jpg" alt="img"></p><h2 id="2-1-无参装饰器的实现"><a href="#2-1-无参装饰器的实现" class="headerlink" title="2.1 无参装饰器的实现"></a>2.1 无参装饰器的实现</h2><p>如果想为下述函数添加统计其执行时间的功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timedef index():    time.sleep(3)    print(&#39;Welcome to the index page’)    return 200index() #函数执行</code></pre></div></figure><p>遵循不修改被装饰对象源代码的原则，我们想到的解决方法可能是这样</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">start_time&#x3D;time.time()index() #函数执行stop_time&#x3D;time.time()print(&#39;run time is %s&#39; %(stop_time-start_time))</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-2e3af8429a3c2606c4cfbedb0b196e89_720w.jpg" alt="img"></p><p>考虑到还有可能要统计其他函数的执行时间，于是我们将其做成一个单独的工具，函数体需要外部传入被装饰的函数从而进行调用，我们可以使用参数的形式传入</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def wrapper(func): # 通过参数接收外部的值    start_time&#x3D;time.time()    res&#x3D;func()    stop_time&#x3D;time.time()    print(&#39;run time is %s&#39; %(stop_time-start_time))    return res</code></pre></div></figure><p>但之后函数的调用方式都需要统一改成</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">wrapper(index)wrapper(其他函数)</code></pre></div></figure><p>这便违反了不能修改被装饰对象调用方式的原则，于是我们换一种为函数体传值的方式，即将值包给函数，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def timer(func):    def wrapper(): # 引用外部作用域的变量func        start_time&#x3D;time.time()        res&#x3D;func()        stop_time&#x3D;time.time()        print(&#39;run time is %s&#39; %(stop_time-start_time))        return res    return wrapper</code></pre></div></figure><p>这样我们便可以在不修改被装饰函数源代码和调用方式的前提下为其加上统计时间的功能，只不过需要事先执行一次timer将被装饰的函数传入，返回一个闭包函数wrapper重新赋值给变量名 &#x2F;函数名index，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">index&#x3D;timer(index)  #得到index&#x3D;wrapper，wrapper携带对外作用域的引用：func&#x3D;原始的indexindex() # 执行的是wrapper()，在wrapper的函数体内再执行最原始的index</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-6c1260375fb70d489df20b676c5cac51_720w.jpg" alt="img"></p><p>至此我们便实现了一个无参装饰器timer，可以在不修改被装饰对象index源代码和调用方式的前提下为其加上新功能。但我们忽略了若被装饰的函数是一个有参函数，便会抛出异常</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def home(name):    time.sleep(5)    print(&#39;Welcome to the home page&#39;,name)home&#x3D;timer(home)home(&#39;egon&#39;)#抛出异常TypeError: wrapper() takes 0 positional arguments but 1 was given</code></pre></div></figure><p>之所以会抛出异常，是因为home(‘egon’)调用的其实是wrapper(‘egon’)，而函数wrapper没有参数。wrapper函数接收的参数其实是给最原始的func用的，为了能满足被装饰函数参数的所有情况，便用上*args+**kwargs组合（见4.3小节）,于是修正装饰器timer如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def timer(func):    def wrapper(*args,**kwargs):        start_time&#x3D;time.time()        res&#x3D;func(*args,**kwargs)        stop_time&#x3D;time.time()        print(&#39;run time is %s&#39; %(stop_time-start_time))        return res    return wrapper</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-da8d9c6733f96b2a897c986e3515ffe3_720w.jpg" alt="img"></p><p>此时我们就可以用timer来装饰带参数或不带参数的函数了，但是为了简洁而优雅地使用装饰器，Python提供了专门的装饰器语法来取代index&#x3D;timer(index)的形式，需要在被装饰对象的正上方单独一行添加@timer,当解释器解释到@timer时就会调用timer函数，且把它正下方的函数名当做实参传入，然后将返回的结果重新赋值给原函数名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">@timer # index&#x3D;timer(index)def index():    time.sleep(3)    print(&#39;Welcome to the index page&#39;)    return 200@timer # index&#x3D;timer(home)           def home(name):    time.sleep(5)    print(&#39;Welcome to the home page’,name)</code></pre></div></figure><p>如果我们有多个装饰器，可以叠加多个</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">@deco3@deco2@deco1def index():    pass</code></pre></div></figure><p>叠加多个装饰器也无特殊之处，上述代码语义如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">index&#x3D;deco3(deco2(deco1(index)))</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-c6e67404ac0e4319ce3cd89af56ead5d_720w.jpg" alt="img"></p><h2 id="2-2-有参装饰器的实现"><a href="#2-2-有参装饰器的实现" class="headerlink" title="2.2 有参装饰器的实现"></a>2.2 有参装饰器的实现</h2><p>了解无参装饰器的实现原理后，我们可以再实现一个用来为被装饰对象添加认证功能的装饰器，实现的基本形式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def deco(func):    def wrapper(*args,**kwargs):        编写基于文件的认证,认证通过则执行res&#x3D;func(*args,**kwargs),并返回res    return wrapper</code></pre></div></figure><p>如果我们想提供多种不同的认证方式以供选择，单从wrapper函数的实现角度改写如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def deco(func):        def wrapper(*args,**kwargs):            if driver &#x3D;&#x3D; &#39;file&#39;:                编写基于文件的认证,认证通过则执行res&#x3D;func(*args,**kwargs),并返回res            elif driver &#x3D;&#x3D; &#39;mysql&#39;:                编写基于mysql认证,认证通过则执行res&#x3D;func(*args,**kwargs),并返回res        return wrapper</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-82fb584a53b2277048a09561b3e19b58_720w.jpg" alt="img"></p><p>函数wrapper需要一个driver参数，而函数deco与wrapper的参数都有其特定的功能，不能用来接受其他类别的参数，可以在deco的外部再包一层函数auth，用来专门接受额外的参数，这样便保证了在auth函数内无论多少层都可以引用到</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def auth(driver):    def deco(func):        ……    return deco</code></pre></div></figure><p>此时我们就实现了一个有参装饰器，使用方式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">先调用auth_type(driver&#x3D;&#39;file&#39;)，得到@deco，deco是一个闭包函数，包含了对外部作用域名字driver的引用，@deco的语法意义与无参装饰器一样@auth(driver&#x3D;&#39;file&#39;) def index():         pass@auth(driver&#x3D;&#39;mysql&#39;) def home():    pass  </code></pre></div></figure><p>可以使用help(函数名)来查看函数的文档注释，本质就是查看函数的<strong>doc</strong>属性，但对于被装饰之后的函数，查看文档注释</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">@timerdef home(name):    &#39;&#39;&#39;    home page function    :param name: str    :return: None    &#39;&#39;&#39;    time.sleep(5)    print(&#39;Welcome to the home page&#39;,name)print(help(home))&#39;&#39;&#39;打印结果：Help on function wrapper in module __main__:wrapper(*args, **kwargs)None</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-3380e05c82d8501f9ac1c2681311a062_720w.jpg" alt="img"></p><p>在被装饰之后home&#x3D;wrapper,查看home.<strong>name</strong>也可以发现home的函数名确实是wrapper，想要保留原函数的文档和函数名属性，需要修正装饰器</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def timer(func):    def wrapper(*args,**kwargs):        start_time&#x3D;time.time()        res&#x3D;func(*args,**kwargs)        stop_time&#x3D;time.time()        print(&#39;run time is %s&#39; %(stop_time-start_time))        return res    wrapper.__doc__&#x3D;func.__doc__    wrapper.__name__&#x3D;func.__name__    return wrapper</code></pre></div></figure><p>按照上述方式来实现保留原函数属性过于麻烦，functools模块下提供一个装饰器wraps专门用来帮我们实现这件事，用法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from functools import wrapsdef timer(func):    @wraps(func)    def wrapper(*args,**kwargs):        start_time&#x3D;time.time()        res&#x3D;func(*args,**kwargs)        stop_time&#x3D;time.time()        print(&#39;run time is %s&#39; %(stop_time-start_time))        return res    return wrapper</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-091acff94160bf2b8258553158168f79_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>简单装饰器的实现</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=47">https://www.bilibili.com/video/av73342471?p=47www.bilibili.com/video/av73342471?p=47</a></p><p>装饰器修订</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=48">https://www.bilibili.com/video/av73342471?p=48www.bilibili.com/video/av73342471?p=48</a></p><p>wraps补充</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=49">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=49<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-函数对象和闭包</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/14_%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/14_%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="一-函数对象"><a href="#一-函数对象" class="headerlink" title="一 函数对象"></a>一 函数对象</h2><p>函数对象指的是函数可以被当做’数据’来处理，具体可以分为四个方面的使用，我们如下</p><p><img src="https://pic2.zhimg.com/80/v2-610f07da055d449976326f5e234075d9_720w.jpg" alt="img"></p><h2 id="1-1-函数可以被引用"><a href="#1-1-函数可以被引用" class="headerlink" title="1.1 函数可以被引用"></a>1.1 函数可以被引用</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def add(x,y):...     return x+y... &gt;&gt;&gt; func&#x3D;add&gt;&gt;&gt; func(1,2)3</code></pre></div></figure><h2 id="1-2-函数可以作为容器类型的元素"><a href="#1-2-函数可以作为容器类型的元素" class="headerlink" title="1.2 函数可以作为容器类型的元素"></a>1.2 函数可以作为容器类型的元素</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; dic&#x3D;&#123;&#39;add&#39;:add,&#39;max&#39;:max&#125;&gt;&gt;&gt; dic&#123;&#39;add&#39;: &lt;function add at 0x100661e18&gt;, &#39;max&#39;: &lt;built-in function max&gt;&#125;&gt;&gt;&gt; dic[&#39;add&#39;](1,2)3</code></pre></div></figure><h2 id="1-3-函数可以作为参数传入另外一个函数"><a href="#1-3-函数可以作为参数传入另外一个函数" class="headerlink" title="1.3 函数可以作为参数传入另外一个函数"></a>1.3 函数可以作为参数传入另外一个函数</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def foo(x,y,func):...     return func(x,y)...&gt;&gt;&gt; foo(1,2,add)3</code></pre></div></figure><h2 id="1-4-函数的返回值可以是一个函数"><a href="#1-4-函数的返回值可以是一个函数" class="headerlink" title="1.4 函数的返回值可以是一个函数"></a>1.4 函数的返回值可以是一个函数</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def bar():      return add func&#x3D;bar() func(1,2)3 </code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-3a92b83b2c4ab23b0e237f071b6bcd7e_720w.jpg" alt="img"></p><h2 id="二-闭包函数"><a href="#二-闭包函数" class="headerlink" title="二 闭包函数"></a>二 闭包函数</h2><h2 id="2-1-闭与包"><a href="#2-1-闭与包" class="headerlink" title="2.1 闭与包"></a>2.1 闭与包</h2><p>基于函数对象的概念，可以将函数返回到任意位置去调用，但作用域的关系是在定义完函数时就已经被确定了的，与函数的调用位置无关。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;1def f1():    def f2():        print(x)    return f2def f3():    x&#x3D;3    f2&#x3D;f1() #调用f1()返回函数f2    f2() #需要按照函数定义时的作用关系去执行，与调用位置无关f3() #结果为1</code></pre></div></figure><p>也就是说函数被当做数据处理时，始终以自带的作用域为准。若内嵌函数包含对外部函数作用域（而非全局作用域）中变量的引用，那么该’内嵌函数’就是闭包函数，简称闭包(Closures)</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;1def outer():    x&#x3D;2    def inner():        print(x)    return innerfunc&#x3D;outer()func() # 结果为2</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-f8b3a3ff993a95277b4ec5b1514cb103_720w.jpg" alt="img"></p><p>可以通过函数的<strong>closure</strong>属性，查看到闭包函数所包裹的外部变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; func.__closure__(&lt;cell at 0x10212af78: int object at 0x10028cca0&gt;,)&gt;&gt;&gt; func.__closure__[0].cell_contents2</code></pre></div></figure><p>“闭”代表函数是内部的，“包”代表函数外’包裹’着对外层作用域的引用。因而无论在何处调用闭包函数，使用的仍然是包裹在其外层的变量。</p><p><img src="https://pic4.zhimg.com/80/v2-c6e623206aa2c60c1036f30656ffbbaf_720w.jpg" alt="img"></p><h2 id="2-2-闭包的用途"><a href="#2-2-闭包的用途" class="headerlink" title="2.2 闭包的用途"></a>2.2 闭包的用途</h2><p>目前为止，我们得到了两种为函数体传值的方式，一种是直接将值以参数的形式传入，另外一种就是将值包给函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests#方式一：def get(url):    return requests.get(url).text#方式二：def page(url):    def get():        return requests.get(url).text    return get</code></pre></div></figure><p>提示：requests模块是用来模拟浏览器向网站发送请求并将页面内容下载到本地，需要事先安装：pip3 install requests</p><p><img src="https://pic1.zhimg.com/80/v2-25aba810eb15ef9e3d59241516b05358_720w.jpg" alt="img"></p><p>对比两种方式，方式一在下载同一页面时需要重复传入url，而方式二只需要传一次值，就会得到一个包含指定url的闭包函数，以后调用该闭包函数无需再传url</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方式一下载同一页面get(&#39;https:&#x2F;&#x2F;www.python.org&#39;)get(&#39;https:&#x2F;&#x2F;www.python.org&#39;)get(&#39;https:&#x2F;&#x2F;www.python.org&#39;)……# 方式二下载同一页面python&#x3D;page(&#39;https:&#x2F;&#x2F;www.python.org&#39;)python()python()python()……</code></pre></div></figure><p>闭包函数的这种特性有时又称为惰性计算。使用将值包给函数的方式，在接下来的装饰器中也将大有用处</p><p><img src="https://pic3.zhimg.com/80/v2-fbcde5e64980428d3864f2c389ce3f3e_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>函数对象：</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=43">https://www.bilibili.com/video/av73342471?p=43www.bilibili.com/video/av73342471?p=43</a></p><p>闭包函数：</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=46">https://www.bilibili.com/video/av73342471?p=46www.bilibili.com/video/av73342471?p=46</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-名称空间和作用域</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/13_%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/13_%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一-名称空间"><a href="#一-名称空间" class="headerlink" title="一 名称空间"></a>一 名称空间</h2><p>名称空间即存放名字与对象映射&#x2F;绑定关系的地方。对于x&#x3D;3，Python会申请内存空间存放对象3，然后将名字x与3的绑定关系存放于名称空间中，del x表示清除该绑定关系。</p><p> 在程序执行期间最多会存在三种名称空间</p><p><img src="https://pic2.zhimg.com/80/v2-596e030156bc539213fb080d356ca1d9_720w.jpg" alt="img"></p><h2 id="1-1-内建名称空间"><a href="#1-1-内建名称空间" class="headerlink" title="1.1 内建名称空间"></a>1.1 内建名称空间</h2><p>伴随python解释器的启动&#x2F;关闭而产生&#x2F;回收，因而是第一个被加载的名称空间，用来存放一些内置的名字，比如内建函数名</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; max&lt;built-in function max&gt; #built-in内建</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-6b1e7070c484f0d266dcfdc04ebf265a_720w.jpg" alt="img"></p><h2 id="1-2-全局名称空间"><a href="#1-2-全局名称空间" class="headerlink" title="1.2 全局名称空间"></a>1.2 全局名称空间</h2><p>伴随python文件的开始执行&#x2F;执行完毕而产生&#x2F;回收，是第二个被加载的名称空间，文件执行过程中产生的名字都会存放于该名称空间中，如下名字</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sys #模块名sysx&#x3D;1 #变量名xif x &#x3D;&#x3D; 1:    y&#x3D;2 #变量名ydef foo(x): #函数名foo    y&#x3D;1    def bar():        passClass Bar: #类名Bar    pass</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-2def7f8d2d87802b200813e691a5acfd_720w.jpg" alt="img"></p><h2 id="1-3-局部名称空间"><a href="#1-3-局部名称空间" class="headerlink" title="1.3 局部名称空间"></a>1.3 局部名称空间</h2><p>伴随函数的调用&#x2F;结束而临时产生&#x2F;回收，函数的形参、函数内定义的名字都会被存放于该名称空间中</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def foo(x):    y&#x3D;3 #调用函数时，才会执行函数代码，名字x和y都存放于该函数的局部名称空间中</code></pre></div></figure><p>名称空间的加载顺序是：内置名称空间-&gt;全局名称空间-&gt;局部名称空间，而查找一个名字，必须从三个名称空间之一找到，查找顺序为：局部名称空间-&gt;全局名称空间-&gt;内置名称空间。</p><p><img src="https://pic1.zhimg.com/80/v2-521d2bf3131371f8d2656b184ad17798_720w.jpg" alt="img"></p><h2 id="二-作用域"><a href="#二-作用域" class="headerlink" title="二 作用域"></a>二 作用域</h2><h2 id="2-1-全局作用域与局部作用域"><a href="#2-1-全局作用域与局部作用域" class="headerlink" title="2.1 全局作用域与局部作用域"></a>2.1 全局作用域与局部作用域</h2><p>按照名字作用范围的不同可以将三个名称空间划分为两个区域：</p><ol><li>全局作用域:位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）；</li><li>局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）。</li></ol><p><img src="https://pic4.zhimg.com/80/v2-c7c952d4554d6db0cf46305be525bafb_720w.jpg" alt="img"></p><h2 id="2-2-作用域与名字查找的优先级"><a href="#2-2-作用域与名字查找的优先级" class="headerlink" title="2.2 作用域与名字查找的优先级"></a>2.2 作用域与名字查找的优先级</h2><p> 在局部作用域查找名字时，起始位置是局部作用域，所以先查找局部名称空间，没有找到，再去全局作用域查找：先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;100 #全局作用域的名字xdef foo():    x&#x3D;300 #局部作用域的名字x    print(x) #在局部找xfoo()#结果为300</code></pre></div></figure><p>在全局作用域查找名字时，起始位置便是全局作用域，所以先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;100def foo():    x&#x3D;300 #在函数调用时产生局部作用域的名字xfoo()print(x) #在全局找x,结果为100</code></pre></div></figure><p>提示：可以调用内建函数locals()和globals()来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals()的结果等于globals()</p><p><img src="https://pic3.zhimg.com/80/v2-7adbbd64e5216724e7933789054d0f1e_720w.jpg" alt="img"></p><p>Python支持函数的嵌套定义，在内嵌的函数内查找名字时，会优先查找自己局部作用域的名字，然后由内而外一层层查找外部嵌套函数定义的作用域，没有找到，则查找全局作用域</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;1def outer():    x&#x3D;2    def inner(): # 函数名inner属于outer这一层作用域的名字        x&#x3D;3        print(&#39;inner x:%s&#39; %x)    inner()    print(&#39;outer x:%s&#39; %x)outer() #结果为inner x:3outer x:2</code></pre></div></figure><p>在函数内，无论嵌套多少层，都可以查看到全局作用域的名字，若要在函数内修改全局名称空间中名字的值，当值为不可变类型时，则需要用到global关键字</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;1def foo():    global x #声明x为全局名称空间的名字    x&#x3D;2foo()print(x) #结果为2</code></pre></div></figure><p>当实参的值为可变类型时，函数体内对该值的修改将直接反应到原值，</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">num_list&#x3D;[1,2,3]def foo(nums):    nums.append(5)foo(num_list)print(num_list)#结果为[1, 2, 3, 5]</code></pre></div></figure><p>对于嵌套多层的函数，使用nonlocal关键字可以将名字声明为来自外部嵌套函数定义的作用域（非全局）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def  f1():    x&#x3D;2    def f2():        nonlocal x        x&#x3D;3    f2() #调用f2(),修改f1作用域中名字x的值    print(x) #在f1作用域查看xf1()#结果3</code></pre></div></figure><p>nonlocal x会从当前函数的外层函数开始一层层去查找名字x，若是一直到最外层函数都找不到，则会抛出异常。</p><p><img src="https://pic2.zhimg.com/80/v2-632ec1c5586b42b1b603268097360c35_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471/?p=45">https://www.bilibili.com/video/av73342471/?p=45www.bilibili.com/video/av73342471/?p=45</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-函数基本使用</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/11_%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/11_%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-引入"><a href="#一-引入" class="headerlink" title="一 引入"></a>一 引入</h2><p> 基于前一部分的学习，我们已经能开发一些功能简单的小程序了，但随着程序功能的增多，代码量随之增大，此时仍不加区分地把所有功能的实现代码放到一起，将会使得程序的组织结构不清晰，可读性变差，且程序中需要频繁使用同一功能时，只能重复编写该功能的实现代码，日积月累，程序将变得冗长，并且当某一功能需要修改时，又不得不找出所有定义及使用这段功能的地方修改之，管理维护的难度极大，好吧，装了半天逼，到底该如何解决提出的这些问题呢？</p><p><img src="https://pic1.zhimg.com/80/v2-9c9953bf70a721520e78add4ceeeb340_720w.jpg" alt="img"></p><p>我们完全可以从现实生活中找到简化程序设计的方案：比如一个修理工会事先准备好螺丝刀、锤子等工具，这样在进行修理的过程中，需要用到拧螺丝的功能时就直接拿来螺丝刀使用，需要用到锤击物体的功能时就直接拿来锤子使用，而无需临时制造。这个例子的核心在于’事先准备好工具’，遇到应用场景时’拿来就用’，。</p><p>在程序中，具备某一功能的‘工具’指的就是函数，‘事先准备工具’的过程即函数的定义，‘拿来就用’即函数的调用。</p><h2 id="二-定义函数"><a href="#二-定义函数" class="headerlink" title="二 定义函数"></a>二 定义函数</h2><p>函数的使用必须遵循’先定义，后调用’的原则。函数的定义就相当于事先将函数体代码保存起来，然后将内存地址赋值给函数名，函数名就是对这段代码的引用，这和变量的定义是相似的。没有事先定义函数而直接调用，就相当于在引用一个不存在的’变量名’。</p><p>定义函数的语法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def 函数名(参数1,参数2,...):    &quot;&quot;&quot;文档描述&quot;&quot;&quot;    函数体    return 值</code></pre></div></figure><ol><li>def: 定义函数的关键字；</li><li>函数名：函数名指向函数内存地址，是对函数体代码的引用。函数的命名应该反映出函数的功能；</li><li>括号：括号内定义参数，参数是可有可无的，且无需指定参数的类型；</li><li>冒号：括号后要加冒号，然后在下一行开始缩进编写函数体的代码；</li><li>“””文档描述”””: 描述函数功能，参数介绍等信息的文档，非必要，但是建议加上，从而增强函数的可读性；</li><li>函数体：由语句和表达式组成；</li><li>return 值：定义函数的返回值，return是可有可无的。</li></ol><p><img src="https://pic1.zhimg.com/80/v2-b6820acb8b8135a298d22c46d88dc078_720w.jpg" alt="img"></p><p>参数是函数的调用者向函数体传值的媒介，若函数体代码逻辑依赖外部传来的参数时则需要定义为参函数，</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def my_min(x,y):    res&#x3D;x if x &lt; y else y    return res</code></pre></div></figure><p>否则定义为无参函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def interactive():    user&#x3D;input(&#39;user&gt;&gt;: &#39;).strip()    pwd&#x3D;input(&#39;password&gt;&gt;: &#39;).strip()    return (user,pwd)</code></pre></div></figure><p> 函数体为pass代表什么都不做，称之为空函数。定义空函数通常是有用的，因为在程序设计的开始，往往是先想好程序都需要完成什么功能，然后把所有功能都列举出来用pass充当函数体“占位符”，这将使得程序的体系结构立见，清晰且可读性强。例如要编写一个ftp程序，我们可能想到的功能有用户认证，下载，上传，浏览，切换目录等功能，可以先做出如下定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def auth_user():    &quot;&quot;&quot;user authentication function&quot;&quot;&quot;    passdef download_file():    &quot;&quot;&quot;download file function&quot;&quot;&quot;    passdef upload_file():    &quot;&quot;&quot;upload file function&quot;&quot;&quot;    passdef ls():    &quot;&quot;&quot;list contents function&quot;&quot;&quot;    passdef cd():    &quot;&quot;&quot;change directory&quot;&quot;&quot;    pass</code></pre></div></figure><p>之后我们便可以统筹安排编程任务，有选择性的去实现上述功能来替换掉pass，从而提高开发效率。</p><p><img src="https://pic3.zhimg.com/80/v2-7eec3d29ee04903367255ddf4ba56fa2_720w.jpg" alt="img"></p><h2 id="三-调用函数与函数返回值"><a href="#三-调用函数与函数返回值" class="headerlink" title="三 调用函数与函数返回值"></a>三 调用函数与函数返回值</h2><p> 函数的使用分为定义阶段与调用阶段，定义函数时只检测语法，不执行函数体代码，函数名加括号即函数调用，只有调用函数时才会执行函数体代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#定义阶段def foo():    print(&#39;in the foo&#39;)    bar()def bar():    print(&#39;in the bar&#39;)#调用阶段foo()</code></pre></div></figure><p>执行结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">in the fooin the bar</code></pre></div></figure><p>定义阶段函数foo与bar均无语法错误，而在调用阶段调用foo()时，函数foo与bar都早已经存在于内存中了，所以不会有任何问题。</p><p><img src="https://pic4.zhimg.com/80/v2-49571392a08c9cb0980b37d25890cf57_720w.jpg" alt="img"></p><p>按照在程序出现的形式和位置，可将函数的调用形式分为三种：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、语句形式：foo()#2、表达式形式：m&#x3D;my_min(1,2) #将调用函数的返回值赋值给xn&#x3D;10*my_min(1,2) #将调用函数的返回值乘以10的结果赋值给n#3、函数调用作为参数的形式：# my_min（2，3）作为函数my_min的第二个参数，实现了取1,2,3中的较小者赋值给mm&#x3D;my_min(1，my_min（2，3）)</code></pre></div></figure><p>若需要将函数体代码执行的结果返回给调用者，则需要用到return。return后无值或直接省略return，则默认返回None，return的返回值无类型限制，且可以将多个返回值放到一个元组内。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def test(x,y,z):...     return x,y,z #等同于return (x,y,z)... &gt;&gt;&gt; res&#x3D;test(1,2,3)&gt;&gt;&gt; print(res)(1, 2, 3)</code></pre></div></figure><p>return是一个函数结束的标志,函数内可以有多个return，但只执行一次函数就结束了，并把return后定义的值作为本次调用的结果返回。</p><p><img src="https://pic3.zhimg.com/80/v2-46449ad493f48f4863cefab55f8da196_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>函数基础</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=38">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=38<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>函数返回值</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=39">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=39<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-函数的参数</title>
    <link href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/12_%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <url>/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/12_%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一-形参与实参介绍"><a href="#一-形参与实参介绍" class="headerlink" title="一 形参与实参介绍"></a>一 形参与实参介绍</h2><p><img src="https://pic2.zhimg.com/80/v2-3be956bc3ace8da945af47995ea41b19_720w.jpg" alt="img"></p><p>函数的参数分为形式参数和实际参数，简称形参和实参：</p><p>形参即在定义函数时，括号内声明的参数。形参本质就是一个变量名，用来接收外部传来的值。</p><p>实参即在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1：实参是常量res&#x3D;my_min(1,2)#2：实参是变量a&#x3D;1b&#x3D;2res&#x3D;my_min(a,b)#3：实参是表达式res&#x3D;my_min(10*2,10*my_min(3,4))#4：实参可以是常量、变量、表达式的任意组合a&#x3D;2my_min(1,a,10*my_min(3,4))</code></pre></div></figure><p>在调用有参函数时，实参（值）会赋值给形参（变量名）。在Python中，变量名与值只是单纯的绑定关系，而对于函数来说，这种绑定关系只在函数调用时生效，在调用结束后解除。</p><p><img src="https://pic2.zhimg.com/80/v2-b0036c8f8942a558d95a3200f38338d1_720w.jpg" alt="img"></p><h2 id="二-形参与实参的具体使用"><a href="#二-形参与实参的具体使用" class="headerlink" title="二 形参与实参的具体使用"></a>二 形参与实参的具体使用</h2><h2 id="2-1-位置参数"><a href="#2-1-位置参数" class="headerlink" title="2.1 位置参数"></a>2.1 位置参数</h2><p>位置即顺序，位置参数指的是按顺序定义的参数，需要从两个角度去看：</p><ol><li>在定义函数时，按照从左到右的顺序依次定义形参,称为位置形参，凡是按照这种形式定义的形参都必须被传值</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def register(name,age,sex): #定义位置形参：name，age，sex，三者都必须被传值    print(&#39;Name:%s Age:%s Sex:%s&#39; %(name,age,sex))register() #TypeError：缺少3个位置参数 </code></pre></div></figure><ol><li>在调用函数时，按照从左到右的顺序依次定义实参，称为位置实参，凡是按照这种形式定义的实参会按照从左到右的顺序与形参一一对应</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def register(name,age,sex): #定义位置形参：name，age，sex，三者都必须被传值    print(&#39;Name:%s Age:%s Sex:%s&#39; %(name,age,sex))register() #TypeError：缺少3个位置参数</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-1152d1943f7d6b217981965ad5d2b8be_720w.jpg" alt="img"></p><h2 id="2-2-关键字参数"><a href="#2-2-关键字参数" class="headerlink" title="2.2 关键字参数"></a>2.2 关键字参数</h2><p>在调用函数时，实参可以是key&#x3D;value的形式，称为关键字参数，凡是按照这种形式定义的实参，可以完全不按照从左到右的顺序定义，但仍能为指定的形参赋值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; register(sex&#x3D;&#39;male&#39;,name&#x3D;&#39;lili&#39;,age&#x3D;18)Name:lili Age:18 Sex:male</code></pre></div></figure><p>需要注意在调用函数时，实参也可以是按位置或按关键字的混合使用，但必须保证关键字参数在位置参数后面，且不可以对一个形参重复赋值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; register(&#39;lili&#39;,sex&#x3D;&#39;male&#39;,age&#x3D;18) #正确使用&gt;&gt;&gt; register(name&#x3D;&#39;lili&#39;,18,sex&#x3D;&#39;male&#39;) #SyntaxError：关键字参数name&#x3D;‘lili’在位置参数18之前&gt;&gt;&gt; register(&#39;lili&#39;,sex&#x3D;&#39;male&#39;,age&#x3D;18,name&#x3D;&#39;jack&#39;) #TypeError：形参name被重复赋值</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-751903e8073067049e6c42c5196754fe_720w.jpg" alt="img"></p><h2 id="2-3-默认参数"><a href="#2-3-默认参数" class="headerlink" title="2.3 默认参数"></a>2.3 默认参数</h2><p>在定义函数时，就已经为形参赋值，这类形参称之为默认参数，当函数有多个参数时，需要将值经常改变的参数定义成位置参数，而将值改变较少的参数定义成默认参数。例如编写一个注册学生信息的函数，如果大多数学生的性别都为男，那完全可以将形参sex定义成默认参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def register(name,age,sex&#x3D;&#39;male&#39;): #默认sex的值为male...     print(&#39;Name:%s Age:%s Sex:%s&#39; %(name,age,sex))...</code></pre></div></figure><p>定义时就已经为参数sex赋值，意味着调用时可以不对sex赋值，这降低了函数调用的复杂度</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; register(&#39;tom&#39;,17) #大多数情况,无需为sex传值,默认为maleName:tom Age:17 Sex:male&gt;&gt;&gt; register(&#39;Lili&#39;,18,&#39;female&#39;) #少数情况,可以为sex传值femaleName:Lili Age:18 Sex:female</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-85c49040b5ca19b0a6cd236d6a335d21_720w.jpg" alt="img"></p><p>需要注意：</p><ol><li>默认参数必须在位置参数之后</li><li>默认参数的值仅在函数定义阶段被赋值一次</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x&#x3D;1&gt;&gt;&gt; def foo(arg&#x3D;x):...     print(arg)... &gt;&gt;&gt; x&#x3D;5 #定义阶段arg已被赋值为1，此处的修改与默认参数arg无任何关系&gt;&gt;&gt; foo()1</code></pre></div></figure><ol><li>默认参数的值通常应设为不可变类型</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def foo(n,arg&#x3D;[]):         arg.append(n)         return arg    foo(1)    [1] foo(2)    [1, 2] foo(3)    [1, 2, 3]</code></pre></div></figure><p>每次调用是在上一次的基础上向同一列表增加值，修改如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def foo(n,arg&#x3D;None):         if arg is None:             arg&#x3D;[]         arg.append(n)         return arg    foo(1)    [1] foo(2)    [2] foo(3)    [3]</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-c48b74c4968b946d68531c2ef2c1b40e_720w.jpg" alt="img"></p><h2 id="2-4-可变长度的参数（-与-的用法）"><a href="#2-4-可变长度的参数（-与-的用法）" class="headerlink" title="2.4 可变长度的参数（*与**的用法）"></a>2.4 可变长度的参数（*与**的用法）</h2><p><img src="https://pic2.zhimg.com/80/v2-ac1ed3f13dbd9fea9e3c5cfbb1047611_720w.jpg" alt="img"></p><p>参数的长度可变指的是在调用函数时，实参的个数可以不固定，而在调用函数时，实参的定义无非是按位置或者按关键字两种形式，这就要求形参提供两种解决方案来分别处理两种形式的可变长度的参数</p><h3 id="2-4-1-可变长度的位置参数"><a href="#2-4-1-可变长度的位置参数" class="headerlink" title="2.4.1 可变长度的位置参数"></a>2.4.1 可变长度的位置参数</h3><p>如果在最后一个形参名前加<em>号,那么在调用函数时，溢出的位置实参，都会被</em>接收，以元组的形式保存下来赋值给该形参</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def foo(x,y,z&#x3D;1,*args): #在最后一个形参名args前加*号...     print(x)...     print(y)...     print(z)...     print(args)... &gt;&gt;&gt; foo(1,2,3,4,5,6,7)  #实参1、2、3按位置为形参x、y、z赋值，多余的位置实参4、5、6、7都被*接收，以元组的形式保存下来，赋值给args，即args&#x3D;(4, 5, 6,7)123(4, 5, 6, 7)</code></pre></div></figure><p>如果我们事先生成了一个列表,仍然是可以传值给*args的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def foo(x,y,*args):...     print(x)...     print(y)...     print(args)... &gt;&gt;&gt; L&#x3D;[3,4,5]&gt;&gt;&gt; foo(1,2,*L) # *L就相当于位置参数3，4，5, foo(1,2,*L)就等同于foo(1,2,3,4,5)12(3, 4, 5)</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-e73cc42b02d988741717036dab3ef3d8_720w.jpg" alt="img"></p><p>注意：如果在传入L时没有加*,那L就只是一个普通的位置参数了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; foo(1,2,L) #仅多出一个位置实参L12([1, 2, 3],)</code></pre></div></figure><p>如果形参为常规的参数（位置或默认），实参仍可以是*的形式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def foo(x,y,z&#x3D;3):...     print(x)...     print(y)...     print(z)... &gt;&gt;&gt; foo(*[1,2]) #等同于foo(1,2)123</code></pre></div></figure><p>如果我们想要求多个值的和，*args就派上用场了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def add(*args):...     res&#x3D;0...     for i in args:...         res+&#x3D;i...     return res... &gt;&gt;&gt; add(1,2,3,4,5)15</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-8996656ee55ad76ec5b15628a8044140_720w.jpg" alt="img"></p><h3 id="2-4-2-可变长度的关键字参数"><a href="#2-4-2-可变长度的关键字参数" class="headerlink" title="2.4.2 可变长度的关键字参数"></a>2.4.2 可变长度的关键字参数</h3><p>如果在最后一个形参名前加<strong>号,那么在调用函数时，溢出的关键字参数，都会被</strong>接收，以字典的形式保存下来赋值给该形参</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def foo(x,**kwargs): #在最后一个参数kwargs前加**...     print(x)        ...     print(kwargs)   ... &gt;&gt;&gt; foo(y&#x3D;2,x&#x3D;1,z&#x3D;3) #溢出的关键字实参y&#x3D;2，z&#x3D;3都被**接收，以字典的形式保存下来，赋值给kwargs1&#123;&#39;z&#39;: 3, &#39;y&#39;: 2&#125;</code></pre></div></figure><p>如果我们事先生成了一个字典,仍然是可以传值给**kwargs的</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def foo(x,y,**kwargs):...     print(x)...     print(y)...     print(kwargs)... &gt;&gt;&gt; dic&#x3D;&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125; &gt;&gt;&gt; foo(1,2,**dic) #**dic就相当于关键字参数a&#x3D;1，b&#x3D;2，foo(1,2,**dic)等同foo(1,2,a&#x3D;1,b&#x3D;2)12&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-b4374327737ac837551b67f7813666e8_720w.jpg" alt="img"></p><p>注意：如果在传入dic时没有加**,那dic就只是一个普通的位置参数了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; foo(1,2,dic) #TypeError:函数foo只需要2个位置参数，但是传了3个</code></pre></div></figure><p>如果形参为常规参数（位置或默认），实参仍可以是**的形式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def foo(x,y,z&#x3D;3):...     print(x)...     print(y)...     print(z)... &gt;&gt;&gt; foo(**&#123;&#39;x&#39;:1,&#39;y&#39;:2&#125;) #等同于foo(y&#x3D;2,x&#x3D;1)123</code></pre></div></figure><p>如果我们要编写一个用户认证的函数，起初可能只基于用户名密码的验证就可以了，可以使用**kwargs为日后的扩展供良好的环境，同时保持了函数的简洁性。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def auth(user,password,**kwargs): ...     pass ...</code></pre></div></figure><h2 id="2-5-命名关键字参数"><a href="#2-5-命名关键字参数" class="headerlink" title="2.5 命名关键字参数"></a>2.5 命名关键字参数</h2><p>在定义了**kwargs参数后，函数调用者就可以传入任意的关键字参数key&#x3D;value，如果函数体代码的执行需要依赖某个key，必须在函数内进行判断</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def register(name,age,**kwargs):...     if &#39;sex&#39; in kwargs:...         #有sex参数...         pass...     if &#39;height&#39; in kwargs:...         #有height参数...         pass...</code></pre></div></figure><p>想要限定函数的调用者必须以key&#x3D;value的形式传值，Python3提供了专门的语法：需要在定义形参时，用<em>作为一个分隔符号，</em>号之后的形参称为命名关键字参数。对于这类参数，在函数调用时，必须按照key&#x3D;value的形式为其传值，且必须被传值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def register(name,age,*,sex,height): #sex,height为命名关键字参数...     pass... &gt;&gt;&gt; register(&#39;lili&#39;,18,sex&#x3D;&#39;male&#39;,height&#x3D;&#39;1.8m&#39;) #正确使用&gt;&gt;&gt; register(&#39;lili&#39;,18,&#39;male&#39;,&#39;1.8m&#39;) # TypeError:未使用关键字的形式为sex和height传值&gt;&gt;&gt; register(&#39;lili&#39;,18,height&#x3D;&#39;1.8m&#39;) # TypeError没有为命名关键字参数height传值。</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-536b4db7a18e1f39795a152f4c6249bb_720w.jpg" alt="img"></p><p>命名关键字参数也可以有默认值，从而简化调用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def register(name,age,*,sex&#x3D;&#39;male&#39;,height):...     print(&#39;Name:%s,Age:%s,Sex:%s,Height:%s&#39; %(name,age,sex,height))... &gt;&gt;&gt; register(&#39;lili&#39;,18,height&#x3D;&#39;1.8m&#39;)Name:lili,Age:18,Sex:male,Height:1.8m</code></pre></div></figure><p>需要强调的是：sex不是默认参数，height也不是位置参数，因为二者均在<em>后，所以都是命名关键字参数，形参sex&#x3D;’male’属于命名关键字参数的默认值，因而即便是放到形参height之前也不会有问题。另外，如果形参中已经有一个</em>args了，命名关键字参数就不再需要一个单独的*作为分隔符号了</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def register(name,age,*args,sex&#x3D;&#39;male&#39;,height):...   print(&#39;Name:%s,Age:%s,Args:%s,Sex:%s,Height:%s&#39; %(name,age,args,sex,height))... &gt;&gt;&gt; register(&#39;lili&#39;,18,1,2,3,height&#x3D;&#39;1.8m&#39;) #sex与height仍为命名关键字参数Name:lili,Age:18,Args:(1, 2, 3),Sex:male,Height:1.8m</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-daa2f3a7038bc4603a334da19e216dcf_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-f69da71d076e7119fd2ec2e84817dd6c_720w.jpg" alt="img"></p><h2 id="2-6-组合使用"><a href="#2-6-组合使用" class="headerlink" title="2.6 组合使用"></a>2.6 组合使用</h2><p>综上所述所有参数可任意组合使用，但定义顺序必须是：位置参数、默认参数、*args、命名关键字参数、**kwargs</p><p>可变参数*args与关键字参数<strong>kwargs通常是组合在一起使用的，如果一个函数的形参为*args与</strong>kwargs，那么代表该函数可以接收任何形式、任意长度的参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def wrapper(*args,**kwargs):...     pass...</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-8a33c0e3ae4f314dc75eca6250b66fe7_720w.jpg" alt="img"></p><p>在该函数内部还可以把接收到的参数传给另外一个函数（这在4.6小节装饰器的实现中大有用处）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def func(x,y,z):...     print(x,y,z)... &gt;&gt;&gt; def wrapper(*args,**kwargs):...     func(*args,**kwargs)...&gt;&gt;&gt; wrapper(1,z&#x3D;3,y&#x3D;2)1 2 3</code></pre></div></figure><p>按照上述写法，在为函数wrapper传参时，其实遵循的是函数func的参数规则，调用函数wrapper的过程分析如下：</p><ol><li>位置实参1被*接收，以元组的形式保存下来，赋值给args，即args&#x3D;(1,),关键字实参z&#x3D;3，y&#x3D;2被**接收，以字典的形式保存下来，赋值给kwargs，即kwargs&#x3D;{‘y’: 2, ‘z’: 3}</li><li>执行func(<em>args,<em>kwargs),即func(</em>(1,),</em>* {‘y’: 2, ‘z’: 3}),等同于func(1,z&#x3D;3,y&#x3D;2)</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">提示： *args、**kwargs中的args和kwargs被替换成其他名字并无语法错误，但使用args、kwargs是约定俗成的。</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-0064bdc3b1e3fd19d4240f375fecce8a_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471/?p=40">https://www.bilibili.com/video/av73342471/?p=40www.bilibili.com/video/av73342471/?p=40</a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=41">https://www.bilibili.com/video/av73342471?p=41www.bilibili.com/video/av73342471?p=41</a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=42">https://www.bilibili.com/video/av73342471?p=42www.bilibili.com/video/av73342471?p=42</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>02_Python进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-文件处理</title>
    <link href="/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/10_%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <url>/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/10_%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一-引入"><a href="#一-引入" class="headerlink" title="一 引入"></a>一 引入</h2><p> 应用程序运行过程中产生的数据最先都是存放于内存中的，若想永久保存下来，必须要保存于硬盘中。应用程序若想操作硬件必须通过操作系统，而文件就是操作系统提供给应用程序来操作硬盘的虚拟概念，用户或应用程序对文件的操作，就是向操作系统发起调用，然后由操作系统完成对硬盘的具体操作。</p><p><img src="https://pic2.zhimg.com/80/v2-e1c5ac2494f15c2d7a1ee4732fbb9289_720w.jpg" alt="img"></p><h2 id="二-文件操作的基本流程"><a href="#二-文件操作的基本流程" class="headerlink" title="二 文件操作的基本流程"></a>二 文件操作的基本流程</h2><h2 id="2-1-基本流程"><a href="#2-1-基本流程" class="headerlink" title="2.1 基本流程"></a>2.1 基本流程</h2><p><img src="https://pic3.zhimg.com/80/v2-5f2bdccc6b9d407c733fe1c4315a050a_720w.jpg" alt="img"></p><p>有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1. 打开文件，由应用程序向操作系统发起系统调用open(...)，操作系统打开该文件，对应一块硬盘空间，并返回一个文件对象赋值给一个变量ff&#x3D;open(&#39;a.txt&#39;,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) #默认打开模式就为r# 2. 调用文件对象下的读&#x2F;写方法，会被操作系统转换为读&#x2F;写硬盘的操作data&#x3D;f.read()# 3. 向操作系统发起关闭文件的请求，回收系统资源f.close()</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-df5334d72003b1b12e88bdf983af6b5d_720w.jpg" alt="img"></p><h2 id="2-2-资源回收与with上下文管理"><a href="#2-2-资源回收与with上下文管理" class="headerlink" title="2.2 资源回收与with上下文管理"></a>2.2 资源回收与with上下文管理</h2><p>打开一个文件包含两部分资源：应用程序的变量f和操作系统打开的文件。在操作完毕一个文件时，必须把与该文件的这两部分资源全部回收，回收方法为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1、f.close() #回收操作系统打开的文件资源2、del f #回收应用程序级的变量</code></pre></div></figure><p>其中del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件无法关闭，白白占用资源， 而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()，虽然我们如此强调，但是大多数读者还是会不由自主地忘记f.close()，考虑到这一点，python提供了with关键字来帮我们管理上下文</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、在执行完子代码块后，with 会自动执行f.close()with open(&#39;a.txt&#39;,&#39;w&#39;) as f:    pass # 2、可用用with同时打开多个文件，用逗号分隔开即可with open(&#39;a.txt&#39;,&#39;r&#39;) as read_f,open(&#39;b.txt&#39;,&#39;w&#39;) as write_f:      data &#x3D; read_f.read()    write_f.write(data)</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-d5d2e9ba1e1584d711be9141313c9a55_720w.jpg" alt="img"></p><h2 id="2-3-指定操作文本文件的字符编码"><a href="#2-3-指定操作文本文件的字符编码" class="headerlink" title="2.3 指定操作文本文件的字符编码"></a>2.3 指定操作文本文件的字符编码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">f &#x3D; open(...)是由操作系统打开文件，如果打开的是文本文件，会涉及到字符编码问题，如果没有为open指定编码，那么打开文本文件的默认编码很明显是操作系统说了算了，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。这就用到了上节课讲的字符编码的知识：若要保证不乱码，文件以什么方式存的，就要以什么方式打开。f &#x3D; open(&#39;a.txt&#39;,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;)</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-fc61df44636a5f14346f24fae99f1b67_720w.jpg" alt="img"></p><h2 id="三-文件的操作模式"><a href="#三-文件的操作模式" class="headerlink" title="三 文件的操作模式"></a>三 文件的操作模式</h2><h2 id="3-1-控制文件读写操作的模式"><a href="#3-1-控制文件读写操作的模式" class="headerlink" title="3.1 控制文件读写操作的模式"></a>3.1 控制文件读写操作的模式</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">r(默认的)：只读w：只写a：只追加写</code></pre></div></figure><h3 id="3-1-1-案例一：r-模式的使用"><a href="#3-1-1-案例一：r-模式的使用" class="headerlink" title="3.1.1 案例一：r 模式的使用"></a>3.1.1 案例一：r 模式的使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># r只读模式: 在文件不存在时则报错,文件存在文件内指针直接跳到文件开头 with open(&#39;a.txt&#39;,mode&#x3D;&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:     res&#x3D;f.read() # 会将文件的内容由硬盘全部读入内存，赋值给res# 小练习：实现用户认证功能 inp_name&#x3D;input(&#39;请输入你的名字: &#39;).strip() inp_pwd&#x3D;input(&#39;请输入你的密码: &#39;).strip() with open(r&#39;db.txt&#39;,mode&#x3D;&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:     for line in f:         # 把用户输入的名字与密码与读出内容做比对         u,p&#x3D;line.strip(&#39;\n&#39;).split(&#39;:&#39;)         if inp_name &#x3D;&#x3D; u and inp_pwd &#x3D;&#x3D; p:             print(&#39;登录成功&#39;)             break     else:         print(&#39;账号名或者密码错误&#39;)</code></pre></div></figure><h3 id="3-1-2-案例二：w-模式的使用"><a href="#3-1-2-案例二：w-模式的使用" class="headerlink" title="3.1.2 案例二：w 模式的使用"></a>3.1.2 案例二：w 模式的使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># w只写模式: 在文件不存在时会创建空文档,文件存在会清空文件,文件指针跑到文件开头with open(&#39;b.txt&#39;,mode&#x3D;&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:    f.write(&#39;你好\n&#39;)    f.write(&#39;我好\n&#39;)     f.write(&#39;大家好\n&#39;)    f.write(&#39;111\n222\n333\n&#39;)#强调：# 1 在文件不关闭的情况下,连续的写入，后写的内容一定跟在前写内容的后面# 2 如果重新以w模式打开文件，则会清空文件内容</code></pre></div></figure><h3 id="3-1-3-案例三：a-模式的使用"><a href="#3-1-3-案例三：a-模式的使用" class="headerlink" title="3.1.3 案例三：a 模式的使用"></a>3.1.3 案例三：a 模式的使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># a只追加写模式: 在文件不存在时会创建空文档,文件存在会将文件指针直接移动到文件末尾 with open(&#39;c.txt&#39;,mode&#x3D;&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:     f.write(&#39;44444\n&#39;)     f.write(&#39;55555\n&#39;)#强调 w 模式与 a 模式的异同：# 1 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后# 2 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后# 小练习：实现注册功能: name&#x3D;input(&#39;username&gt;&gt;&gt;: &#39;).strip() pwd&#x3D;input(&#39;password&gt;&gt;&gt;: &#39;).strip() with open(&#39;db1.txt&#39;,mode&#x3D;&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:     info&#x3D;&#39;%s:%s\n&#39; %(name,pwd)     f.write(info)</code></pre></div></figure><h3 id="3-1-4-案例四：-模式的使用-了解"><a href="#3-1-4-案例四：-模式的使用-了解" class="headerlink" title="3.1.4 案例四：+ 模式的使用(了解)"></a>3.1.4 案例四：+ 模式的使用(了解)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># r+ w+ a+ :可读可写#在平时工作中，我们只单纯使用r&#x2F;w&#x2F;a，要么只读，要么只写，一般不用可读可写的模式</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-bea42b94950b49f8be785289904e17b7_720w.jpg" alt="img"></p><h2 id="3-2-控制文件读写内容的模式"><a href="#3-2-控制文件读写内容的模式" class="headerlink" title="3.2 控制文件读写内容的模式"></a>3.2 控制文件读写内容的模式</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">大前提: tb模式均不能单独使用,必须与r&#x2F;w&#x2F;a之一结合使用t（默认的）：文本模式    1. 读写文件都是以字符串为单位的    2. 只能针对文本文件    3. 必须指定encoding参数b：二进制模式:   1.读写文件都是以bytes&#x2F;二进制为单位的   2. 可以针对所有文件   3. 一定不能指定encoding参数</code></pre></div></figure><h3 id="3-2-1-案例一：t-模式的使用"><a href="#3-2-1-案例一：t-模式的使用" class="headerlink" title="3.2.1 案例一：t 模式的使用"></a>3.2.1 案例一：t 模式的使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># t 模式：如果我们指定的文件打开模式为r&#x2F;w&#x2F;a，其实默认就是rt&#x2F;wt&#x2F;at with open(&#39;a.txt&#39;,mode&#x3D;&#39;rt&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:     res&#x3D;f.read()      print(type(res)) # 输出结果为：&lt;class &#39;str&#39;&gt; with open(&#39;a.txt&#39;,mode&#x3D;&#39;wt&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:     s&#x3D;&#39;abc&#39;     f.write(s) # 写入的也必须是字符串类型 #强调：t 模式只能用于操作文本文件,无论读写，都应该以字符串为单位，而存取硬盘本质都是二进制的形式，当指定 t 模式时，内部帮我们做了编码与解码</code></pre></div></figure><h3 id="3-2-2-案例二：-b-模式的使用"><a href="#3-2-2-案例二：-b-模式的使用" class="headerlink" title="3.2.2 案例二： b 模式的使用"></a>3.2.2 案例二： b 模式的使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># b: 读写都是以二进制位单位 with open(&#39;1.mp4&#39;,mode&#x3D;&#39;rb&#39;) as f:     data&#x3D;f.read()     print(type(data)) # 输出结果为：&lt;class &#39;bytes&#39;&gt; with open(&#39;a.txt&#39;,mode&#x3D;&#39;wb&#39;) as f:     msg&#x3D;&quot;你好&quot;     res&#x3D;msg.encode(&#39;utf-8&#39;) # res为bytes类型     f.write(res) # 在b模式下写入文件的只能是bytes类型#强调：b模式对比t模式1、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节，b模式则需要手动编码与解码，所以此时t模式更为方便2、针对非文本文件（如图片、视频、音频等）只能使用b模式# 小练习： 编写拷贝工具src_file&#x3D;input(&#39;源文件路径: &#39;).strip()dst_file&#x3D;input(&#39;目标文件路径: &#39;).strip()with open(r&#39;%s&#39; %src_file,mode&#x3D;&#39;rb&#39;) as read_f,open(r&#39;%s&#39; %dst_file,mode&#x3D;&#39;wb&#39;) as write_f:    for line in read_f:        # print(line)        write_f.write(line)</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-4af94c11c6a45976fca8c53a0794c3a2_720w.jpg" alt="img"></p><h2 id="四-操作文件的方法"><a href="#四-操作文件的方法" class="headerlink" title="四 操作文件的方法"></a>四 操作文件的方法</h2><h2 id="4-1-重点"><a href="#4-1-重点" class="headerlink" title="4.1 重点"></a>4.1 重点</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 读操作f.read()  # 读取所有内容,执行完该操作后，文件指针会移动到文件末尾f.readline()  # 读取一行内容,光标移动到第二行首部f.readlines()  # 读取每一行内容,存放于列表中# 强调：# f.read()与f.readlines()都是将内容一次性读入内容，如果内容过大会导致内存溢出，若还想将内容全读入内存，则必须分多次读入，有两种实现方式：# 方式一with open(&#39;a.txt&#39;,mode&#x3D;&#39;rt&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:    for line in f:        print(line) # 同一时刻只读入一行内容到内存中# 方式二with open(&#39;1.mp4&#39;,mode&#x3D;&#39;rb&#39;) as f:    while True:        data&#x3D;f.read(1024) # 同一时刻只读入1024个Bytes到内存中        if len(data) &#x3D;&#x3D; 0:            break        print(data)# 写操作f.write(&#39;1111\n222\n&#39;)  # 针对文本模式的写,需要自己写换行符f.write(&#39;1111\n222\n&#39;.encode(&#39;utf-8&#39;))  # 针对b模式的写,需要自己写换行符f.writelines([&#39;333\n&#39;,&#39;444\n&#39;])  # 文件模式f.writelines([bytes(&#39;333\n&#39;,encoding&#x3D;&#39;utf-8&#39;),&#39;444\n&#39;.encode(&#39;utf-8&#39;)]) #b模式</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-30d5763461db05414c3ac2cc944a8f6e_720w.jpg" alt="img"></p><h2 id="4-2-了解"><a href="#4-2-了解" class="headerlink" title="4.2 了解"></a>4.2 了解</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">f.readable()  # 文件是否可读f.writable()  # 文件是否可读f.closed  # 文件是否关闭f.encoding  # 如果文件打开模式为b,则没有该属性f.flush()  # 立刻将文件内容从内存刷到硬盘f.name</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-3474d487b3fb518ce9b511c73153ce78_720w.jpg" alt="img"></p><h2 id="五-主动控制文件内指针移动"><a href="#五-主动控制文件内指针移动" class="headerlink" title="五 主动控制文件内指针移动"></a>五 主动控制文件内指针移动</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#大前提:文件内指针的移动都是Bytes为单位的,唯一例外的是t模式下的read(n),n以字符为单位with open(&#39;a.txt&#39;,mode&#x3D;&#39;rt&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:     data&#x3D;f.read(3) # 读取3个字符with open(&#39;a.txt&#39;,mode&#x3D;&#39;rb&#39;) as f:     data&#x3D;f.read(3) # 读取3个Bytes# 之前文件内指针的移动都是由读&#x2F;写操作而被动触发的，若想读取文件某一特定位置的数据，则则需要用f.seek方法主动控制文件内指针的移动，详细用法如下：# f.seek(指针移动的字节数,模式控制): # 模式控制:# 0: 默认的模式,该模式代表指针移动的字节数是以文件开头为参照的# 1: 该模式代表指针移动的字节数是以当前所在的位置为参照的# 2: 该模式代表指针移动的字节数是以文件末尾的位置为参照的# 强调:其中0模式可以在t或者b模式使用,而1跟2模式只能在b模式下用</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-2b5a0f6ecedec41601c52959b34d7f5a_720w.jpg" alt="img"></p><h2 id="5-1-案例一：-0模式详解"><a href="#5-1-案例一：-0模式详解" class="headerlink" title="5.1 案例一： 0模式详解"></a>5.1 案例一： 0模式详解</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># a.txt用utf-8编码，内容如下（abc各占1个字节，中文“你好”各占3个字节）abc你好# 0模式的使用with open(&#39;a.txt&#39;,mode&#x3D;&#39;rt&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:    f.seek(3,0)     # 参照文件开头移动了3个字节    print(f.tell()) # 查看当前文件指针距离文件开头的位置，输出结果为3    print(f.read()) # 从第3个字节的位置读到文件末尾，输出结果为：你好    # 注意：由于在t模式下，会将读取的内容自动解码，所以必须保证读取的内容是一个完整中文数据，否则解码失败with open(&#39;a.txt&#39;,mode&#x3D;&#39;rb&#39;) as f:    f.seek(6,0)    print(f.read().decode(&#39;utf-8&#39;)) #输出结果为: 好</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-9a9115785268e099152bbed9d0bc7e97_720w.jpg" alt="img"></p><h2 id="5-2-案例二：-1模式详解"><a href="#5-2-案例二：-1模式详解" class="headerlink" title="5.2 案例二： 1模式详解"></a>5.2 案例二： 1模式详解</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1模式的使用with open(&#39;a.txt&#39;,mode&#x3D;&#39;rb&#39;) as f:    f.seek(3,1) # 从当前位置往后移动3个字节，而此时的当前位置就是文件开头    print(f.tell()) # 输出结果为：3    f.seek(4,1)     # 从当前位置往后移动4个字节，而此时的当前位置为3    print(f.tell()) # 输出结果为：7</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-2122d50b6c97ed1c5fe27a13126266d0_720w.jpg" alt="img"></p><h2 id="5-3-案例三：-2模式详解"><a href="#5-3-案例三：-2模式详解" class="headerlink" title="5.3 案例三： 2模式详解"></a>5.3 案例三： 2模式详解</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># a.txt用utf-8编码，内容如下（abc各占1个字节，中文“你好”各占3个字节）abc你好# 2模式的使用with open(&#39;a.txt&#39;,mode&#x3D;&#39;rb&#39;) as f:    f.seek(0,2)     # 参照文件末尾移动0个字节， 即直接跳到文件末尾    print(f.tell()) # 输出结果为：9    f.seek(-3,2)     # 参照文件末尾往前移动了3个字节    print(f.read().decode(&#39;utf-8&#39;)) # 输出结果为：好# 小练习：实现动态查看最新一条日志的效果import timewith open(&#39;access.log&#39;,mode&#x3D;&#39;rb&#39;) as f:    f.seek(0,2)    while True:        line&#x3D;f.readline()        if len(line) &#x3D;&#x3D; 0:            # 没有内容            time.sleep(0.5)        else:            print(line.decode(&#39;utf-8&#39;),end&#x3D;&#39;&#39;)</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-009f54e4493921a84480b80a4fa5aa90_720w.jpg" alt="img"></p><h2 id="六-文件的修改"><a href="#六-文件的修改" class="headerlink" title="六 文件的修改"></a>六 文件的修改</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 文件a.txt内容如下张一蛋     山东    179    49    12344234523李二蛋     河北    163    57    13913453521王全蛋     山西    153    62    18651433422# 执行操作with open(&#39;a.txt&#39;,mode&#x3D;&#39;r+t&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:    f.seek(9)    f.write(&#39;&lt;妇女主任&gt;&#39;)# 文件修改后的内容如下张一蛋&lt;妇女主任&gt; 179    49    12344234523李二蛋     河北    163    57    13913453521王全蛋     山西    153    62    18651433422# 强调：# 1、硬盘空间是无法修改的,硬盘中数据的更新都是用新内容覆盖旧内容# 2、内存中的数据是可以修改的</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-138c4c7000b5db3a37d691ea0aa09fb0_720w.jpg" alt="img"></p><p>文件对应的是硬盘空间,硬盘不能修改对应着文件本质也不能修改, 那我们看到文件的内容可以修改,是如何实现的呢? 大致的思路是将硬盘中文件内容读入内存,然后在内存中修改完毕后再覆盖回硬盘 具体的实现方式分为两种:</p><h2 id="6-1-文件修改方式一"><a href="#6-1-文件修改方式一" class="headerlink" title="6.1 文件修改方式一"></a>6.1 文件修改方式一</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 实现思路：将文件内容发一次性全部读入内存,然后在内存中修改完毕后再覆盖写回原文件# 优点: 在文件修改过程中同一份数据只有一份# 缺点: 会过多地占用内存with open(&#39;db.txt&#39;,mode&#x3D;&#39;rt&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:    data&#x3D;f.read()with open(&#39;db.txt&#39;,mode&#x3D;&#39;wt&#39;,encoding&#x3D;&#39;utf-8&#39;) as f:    f.write(data.replace(&#39;kevin&#39;,&#39;SB&#39;))</code></pre></div></figure><h2 id="6-1-文件修改方式二"><a href="#6-1-文件修改方式二" class="headerlink" title="6.1 文件修改方式二"></a>6.1 文件修改方式二</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 实现思路：以读的方式打开原文件,以写的方式打开一个临时文件,一行行读取原文件内容,修改完后写入临时文件...,删掉原文件,将临时文件重命名原文件名# 优点: 不会占用过多的内存# 缺点: 在文件修改过程中同一份数据存了两份import oswith open(&#39;db.txt&#39;,mode&#x3D;&#39;rt&#39;,encoding&#x3D;&#39;utf-8&#39;) as read_f,\        open(&#39;.db.txt.swap&#39;,mode&#x3D;&#39;wt&#39;,encoding&#x3D;&#39;utf-8&#39;) as wrife_f:    for line in read_f:        wrife_f.write(line.replace(&#39;SB&#39;,&#39;kevin&#39;))os.remove(&#39;db.txt&#39;)os.rename(&#39;.db.txt.swap&#39;,&#39;db.txt&#39;)</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-d45f4a423f5dd6e9880e4dbcdb1bdaf7_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>文件处理</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=31">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=31<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=32">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=32<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=33">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=33<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=34">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=34<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=35">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=35<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=36">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=36<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=37">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=37<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>01_Python入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-字符编码</title>
    <link href="/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/09_%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <url>/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/09_%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一-引入"><a href="#一-引入" class="headerlink" title="一 引入"></a>一 引入</h2><p> 字符串类型、文本文件的内容都是由字符组成的，但凡涉及到字符的存取，都需要考虑字符编码的问题。</p><p> 字符编码这个知识点的典型特征就是理论多、结论少，但对于开发而言只需要记住结论即可，下面让我们来一点点介绍它</p><p><img src="https://pic1.zhimg.com/80/v2-621d28181cc40a235414a49fc9d14738_720w.jpg" alt="img"></p><h2 id="二-知识储备"><a href="#二-知识储备" class="headerlink" title="二 知识储备"></a>二 知识储备</h2><h2 id="2-1-三大核心硬件"><a href="#2-1-三大核心硬件" class="headerlink" title="2.1 三大核心硬件"></a>2.1 三大核心硬件</h2><p>所有软件都是运行硬件之上的，与运行软件相关的三大核心硬件为cpu、内存、硬盘，我们需要明确三点</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、软件运行前，软件的代码及其相关数据都是存放于硬盘中的#2、任何软件的启动都是将数据从硬盘中读入内存，然后cpu从内存中取出指令并执行#3、软件运行过程中产生的数据最先都是存放于内存中的，若想永久保存软件产生的数据，则需要将数据由内存写入硬盘</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-48e25e7f03030e066f8fcaf4750cc892_720w.jpg" alt="img"></p><h2 id="2-2-文本编辑器读取文件内容的流程"><a href="#2-2-文本编辑器读取文件内容的流程" class="headerlink" title="2.2 文本编辑器读取文件内容的流程"></a>2.2 文本编辑器读取文件内容的流程</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#阶段1、启动一个文件编辑器（文本编辑器如nodepad++，pycharm，word）#阶段2、文件编辑器会将文件内容从硬盘读入内存#阶段3、文本编辑器会将刚刚读入内存中的内容显示到屏幕上</code></pre></div></figure><h2 id="2-3-python解释器执行文件的流程"><a href="#2-3-python解释器执行文件的流程" class="headerlink" title="2.3 python解释器执行文件的流程"></a>2.3 python解释器执行文件的流程</h2><p>以python test.py为例，执行流程如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#阶段1、启动python解释器，此时就相当于启动了一个文本编辑器#阶段2、python解释器相当于文本编辑器，从硬盘上将test.py的内容读入到内存中#阶段3、python解释器解释执行刚刚读入的内存的内容，开始识别python语法</code></pre></div></figure><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>python解释器与文件本编辑的异同如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、相同点：前两个阶段二者完全一致，都是将硬盘中文件的内容读入内存，详解如下python解释器是解释执行文件内容的，因而python解释器具备读py文件的功能，这一点与文本编辑器一样#2、不同点：在阶段3时，针对内存中读入的内容处理方式不同，详解如下文本编辑器将文件内容读入内存后，是为了显示或者编辑，根本不去理会python的语法，而python解释器将文件内容读入内存后，可不是为了给你瞅一眼python代码写的啥，而是为了执行python代码、会识别python语法）</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-c80921c5d7ede2fd94262892c7e0a733_720w.jpg" alt="img"></p><h2 id="三、字符编码介绍"><a href="#三、字符编码介绍" class="headerlink" title="三、字符编码介绍"></a>三、字符编码介绍</h2><h2 id="3-1-什么是字符编码？"><a href="#3-1-什么是字符编码？" class="headerlink" title="3.1 什么是字符编码？"></a>3.1 什么是字符编码？</h2><p>人类在与计算机交互时，用的都是人类能读懂的字符，如中文字符、英文字符、日文字符等</p><p>而计算机只能识别二进制数,详解如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#二进制数即由0和1组成的数字，例如010010101010。计算机是基于电工作的，电的特性即高低电平，人类从逻辑层面将高电平对应为数字1,低电平对应为数字0，这直接决定了计算机可以识别的是由0和1组成的数字</code></pre></div></figure><p>毫无疑问，由人类的字符到计算机中的数字，必须经历一个过程，如下</p><p><img src="https://pic1.zhimg.com/80/v2-80b925e192579faa59dcffbb046535a4_720w.jpg" alt="img"></p><p>翻译的过程必须参照一个特定的标准，该标准称之为字符编码表，该表上存放的就是字符与数字一一对应的关系。</p><p>字符编码中的编码指的是翻译或者转换的意思，即将人能理解的字符翻译成计算机能识别的数字</p><h2 id="3-2-字符编码表的发展史-了解"><a href="#3-2-字符编码表的发展史-了解" class="headerlink" title="3.2 字符编码表的发展史 (了解)"></a>3.2 字符编码表的发展史 (了解)</h2><p>字符编码的发展经历了三个重要的阶段，如下</p><h3 id="3-2-1-阶段一：一家独大"><a href="#3-2-1-阶段一：一家独大" class="headerlink" title="3.2.1 阶段一：一家独大"></a>3.2.1 阶段一：一家独大</h3><p>现代计算机起源于美国，所以最先考虑仅仅是让计算机识别英文字符，于是诞生了ASCII表</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># ASCII表的特点:    1、只有英文字符与数字的一一对应关系    2、一个英文字符对应1Bytes，1Bytes&#x3D;8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-c4a210efb1a57b869288eb7e89bf6fc9_720w.jpg" alt="img"></p><h3 id="3-2-2-阶段二：诸侯割据、天下大乱"><a href="#3-2-2-阶段二：诸侯割据、天下大乱" class="headerlink" title="3.2.2 阶段二：诸侯割据、天下大乱"></a>3.2.2 阶段二：诸侯割据、天下大乱</h3><p><img src="https://pic2.zhimg.com/80/v2-114700ee2814bcf3de172a4b673001e1_720w.jpg" alt="img"></p><p>为了让计算机能够识别中文和英文，中国人定制了GBK</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># GBK表的特点：    1、只有中文字符、英文字符与数字的一一对应关系    2、一个英文字符对应1Bytes       一个中文字符对应2Bytes          补充说明：       1Bytes&#x3D;8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符       2Bytes&#x3D;16bit，16bit最多包含65536个数字，可以对应65536个字符，足够表示所有中文字符</code></pre></div></figure><p>每个国家都各自的字符，为让计算机能够识别自己国家的字符外加英文字符，各个国家都制定了自己的字符编码表</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Shift_JIS表的特点：    1、只有日文字符、英文字符与数字的一一对应关系# Euc-kr表的特点：    1、只有韩文字符、英文字符与数字的一一对应关系</code></pre></div></figure><p>此时,美国人用的计算机里使用字符编码标准是ASCII、中国人用的计算机里使用字符编码标准是GBK、日本人用的计算机里使用字符编码标准是Shift_JIS,如下图所示，</p><p><img src="https://pic3.zhimg.com/80/v2-19bac7b0910652bbd1f7e026683a28be_720w.jpg" alt="img"></p><p>字符编码发展到了这个阶段，可以用一句话概括：诸侯割据、天下大乱，详解如下</p><p><img src="https://pic3.zhimg.com/80/v2-b6ac2031b2082daa422c8dc233be95ee_720w.jpg" alt="img"></p><p>图1中，文本编辑存取文件的原理如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">文本文件内容全都为字符，无论存取都是涉及到字符编码问题#1、存文本文件人类通过文本编辑器输入的字符会被转化成ASCII格式的二进制存放于内存中，如果需要永久保存，则直接将内存中的ASCII格式的二进制写入硬盘#2、读文本文件直接将硬盘中的ASCII格式的二进制读入内存，然后通过ASCII表反解成英文字符</code></pre></div></figure><p>图2图3都是相同的过程，此时无论是存还是取由于采用的字符编码表一样，所以肯定不会出现乱码问题，但问题是在美国人用的计算机里只能输入英文字符，而在中国人用的计算机里只能输入中文字符和英文字符….,毫无疑问我们希望计算机允许我们输入万国字符均可识别、不乱码，而现阶段计算机采用的字符编码ASCII、GBK、Shift_JIS都无法识别万国字符，所以我们必须定制一个兼容万国字符的编码表，请看阶段三</p><p><img src="https://pic3.zhimg.com/80/v2-aeb16d83abab152e00e7e2f99eaeb102_720w.jpg" alt="img"></p><h3 id="3-2-3-阶段三：分久必合"><a href="#3-2-3-阶段三：分久必合" class="headerlink" title="3.2.3 阶段三：分久必合"></a>3.2.3 阶段三：分久必合</h3><p><img src="https://pic1.zhimg.com/80/v2-f405404cd434f2280b4586c4f95ce760_720w.jpg" alt="img"></p><p>unicode于1990年开始研发，1994年正式公布，具备两大特点：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 存在所有语言中的所有字符与数字的一一对应关系,即兼容万国字符#2. 与传统的字符编码的二进制数都有对应关系，详解如下</code></pre></div></figure><p>很多地方或老的系统、应用软件仍会采用各种各样传统的编码，这是历史遗留问题。此处需要强调：软件是存放于硬盘的，而运行软件是要将软件加载到内存的，面对硬盘中存放的各种传统编码的软件，想让我们的计算机能够将它们全都正常运行而不出现乱码，内存中必须有一种兼容万国的编码，并且该编码需要与其他编码有相对应的映射&#x2F;转换关系，这就是unicode的第二大特点产生的缘由</p><p><img src="https://pic1.zhimg.com/80/v2-484a43054d2217ed11c7d5d9170675f8_720w.jpg" alt="img"></p><p>文本编辑器输入任何字符都是最新存在于内存中，是unicode编码的，存放于硬盘中，则可以转换成任意其他编码，只要该编码可以支持相应的字符</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 英文字符可以被ASCII识别英文字符---&gt;unciode格式的数字---&gt;ASCII格式的数字# 中文字符、英文字符可以被GBK识别中文字符、英文字符---&gt;unicode格式的数字---&gt;gbk格式的数字# 日文字符、英文字符可以被shift-JIS识别日文字符、英文字符---&gt;unicode格式的数字---&gt;shift-JIS格式的数字</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-77be4ea6e528d6ed700fd08b2096566f_720w.jpg" alt="img"></p><h2 id="3-3-编码与解码"><a href="#3-3-编码与解码" class="headerlink" title="3.3 编码与解码"></a>3.3 编码与解码</h2><p>由字符转换成内存中的unicode，以及由unicode转换成其他编码的过程，都称为编码encode</p><p><img src="https://pic3.zhimg.com/80/v2-08a12814397a5a6d3e530a66cf2dbc02_720w.jpg" alt="img"></p><p>由内存中的unicode转换成字符，以及由其他编码转换成unicode的过程，都称为解码decode</p><p><img src="https://pic4.zhimg.com/80/v2-5f7b25aaeb4ccc913f0c23d586acdbab_720w.jpg" alt="img"></p><p>在诸多文件类型中，只有文本文件的内存是由字符组成的，因而文本文件的存取也涉及到字符编码的问题</p><h2 id="3-4-utf-8的由来"><a href="#3-4-utf-8的由来" class="headerlink" title="3.4 utf-8的由来"></a>3.4 utf-8的由来</h2><p>注意：如果保存到硬盘的是GBK格式二进制，当初用户输入的字符只能是中文或英文，同理如果保存到硬盘的是Shift_JIS格式二进制，当初用户输入的字符只能是日文或英文……如果我们输入的字符中包含多国字符，那么该如何处理？</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#多国字符—√—》内存（unicode格式的二进制）——X—》硬盘（GBK格式的二进制）#多国字符—√—》内存（unicode格式的二进制）——X—》硬盘（Shift_JIS格式的二进制）#多国字符—√—》内存（unicode格式的二进制）——√—》硬盘（???格式的二进制）</code></pre></div></figure><p>理论上是可以将内存中unicode格式的二进制直接存放于硬盘中的，但由于unicode固定使用两个字节来存储一个字符，如果多国字符中包含大量的英文字符时，使用unicode格式存放会额外占用一倍空间（英文字符其实只需要用一个字节存放即可），然而空间占用并不是最致命的问题，最致命地是当我们由内存写入硬盘时会额外耗费一倍的时间，所以将内存中的unicode二进制写入硬盘或者基于网络传输时必须将其转换成一种精简的格式，这种格式即utf-8（全称Unicode Transformation Format，即unicode的转换格式）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 多国字符—√—》内存（unicode格式的二进制）——√—》硬盘（utf-8格式的二进制）</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-c2a4ec82d946e4e35645f9782dbc798a_720w.jpg" alt="img"></p><p>那为何在内存中不直接使用utf-8呢？</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">utf-8是针对Unicode的可变长度字符编码：一个英文字符占1Bytes，一个中文字符占3Bytes，生僻字用更多的Bytes存储unicode更像是一个过渡版本，我们新开发的软件或文件存入硬盘都采用utf-8格式，等过去几十年，所有老编码的文件都淘汰掉之后，会出现一个令人开心的场景，即硬盘里放的都是utf-8格式，此时unicode便可以退出历史舞台，内存里也改用utf-8，天下重新归于统一</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-183090ce203c9e1b6edab8aff77460cb_720w.jpg" alt="img"></p><h2 id="四-字符编码的应用"><a href="#四-字符编码的应用" class="headerlink" title="四 字符编码的应用"></a>四 字符编码的应用</h2><p>我们学习字符编码就是为了存取字符时不发生乱码问题：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、内存中固定使用unicode无论输入任何字符都不会发生乱码#2、我们能够修改的是存&#x2F;取硬盘的编码方式，如果编码设置不正确将会出现乱码问题。乱码问题分为两种：存乱了，读乱了#2.1 存乱了：如果用户输入的内容中包含中文和日文字符，如果单纯以shift_JIS存，日文可以正常写入硬盘，而由于中文字符在shift_jis中没有找到对应关系而导致存乱了#2.2 读乱了：如果硬盘中的数据是shift_JIS格式存储的，采GBK格式读入内存就读乱了</code></pre></div></figure><p>总结：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. 保证存的时候不乱：在由内存写入硬盘时，必须将编码格式设置为支持所输入字符的编码格式#2. 保证存的时候不乱：在由硬盘读入内存时，必须采用与写入硬盘时相同的编码格式</code></pre></div></figure><h2 id="4-1-文本编辑器nodpad-存取文本文件"><a href="#4-1-文本编辑器nodpad-存取文本文件" class="headerlink" title="4.1 文本编辑器nodpad++存取文本文件"></a>4.1 文本编辑器nodpad++存取文本文件</h2><p>文本编辑器存取的都是文本文件，而文本文件中包含的内容全为字符，所以存取文本文件都涉及到字符编码的问题。</p><p><img src="https://pic4.zhimg.com/80/v2-80d179cdb9262eced650c8574bc74d33_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-75e2cb4b6932bc76c6161a086ad1a5a3_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-3d3b0ae681354751c1a85d75b27ee1d0_720w.jpg" alt="img"></p><h2 id="4-2-python解释器执行文件的前两个阶段"><a href="#4-2-python解释器执行文件的前两个阶段" class="headerlink" title="4.2 python解释器执行文件的前两个阶段"></a>4.2 python解释器执行文件的前两个阶段</h2><p>执行py文件的前两个阶段就是python解释器读文本文件的过程，与文本编辑读文本文件的前两个阶段没人任何区别，要保证读不乱码，则必须将python解释器读文件时采用的编码方式设置为文件当初写入硬盘时的编码格式，如果没有设置，python解释器则才用默认的编码方式，在python3中默认为utf-8，在python2中默认为ASCII，我们可以通过指定文件头来修改默认的编码</p><ul><li>在文件首行写入包含#号在内的以下内容</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># coding: 当初文件写入硬盘时采用的编码格式</code></pre></div></figure><p>解释器会先用默认的编码方式读取文件的首行内容，由于首行是纯英文组成，而任何编码方式都可以识别英文字符。</p><p><img src="https://pic4.zhimg.com/80/v2-b39022bd9969bcba565b7cfe6c067b13_720w.jpg" alt="img"></p><h2 id="4-3-python解释器执行文件的第三个阶段"><a href="#4-3-python解释器执行文件的第三个阶段" class="headerlink" title="4.3 python解释器执行文件的第三个阶段"></a>4.3 python解释器执行文件的第三个阶段</h2><p>设置文件头的作用是保证运行python程序的前两个阶段不乱码，经过前两个阶段后py文件的内容都会以unicode格式存放于内存中。</p><p>在经历第三个阶段时开始识别python语法，当遇到特定的语法name &#x3D; ‘上’（代码本身也都全都是unicode格式存的）时，需要申请内存空间来存储字符串’上’，这就又涉及到应该以什么编码存储‘上’的问题了。</p><p>在Python3中，字符串类的值都是使用unicode格式来存储</p><p>由于Python2的盛行是早于unicode的，因此在Python2中是按照文件头指定的编码来存储字符串类型的值的（如果文件头中没有指定编码，那么解释器会按照它自己默认的编码方式来存储‘上’），所以，这就有可能导致乱码问题</p><p><img src="https://pic2.zhimg.com/80/v2-d27cfdaa0659c34c85fcff4a48a4e2f9_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># coding:utf-8x &#x3D; &#39;上&#39; # x的值为untf-8格式的二进制print(x) # 打印操作是将x的值，即utf-8格式的二进制交给终端，当终端收到后发现并不是unicode（只有unicode才与字符有对应关系），所以终端会执行操作：utf-8二进制---解码--&gt;unicode格式的二进制，解码的过程终端会采用自己默认的编码，而在pycharm的终端默认编码为utf-8、windows下的cmd终端的默认编码为gbk，所以该打印操作在pycharm中显示正常，而在windows下的cmd中则乱码# 在windows下的cmd中运行效果如下C:\Users\Administrator&gt;python2 E:\aaa.py涓</code></pre></div></figure><p>python2后推出了一种补救措施，就是在字符串类型前加u，则会将字符串类型强制存储unicode，这就与python3保持一致了，对于unicode格式无论丢给任何终端进行打印，都可以直接对应字符不会出现乱码问题</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># coding:utf-8x &#x3D; u&#39;上&#39; # 即便文件头为utf-8，x的值依然存成unicode</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-1ef12a426d5d928e8ce10eafef489616_720w.jpg" alt="img"></p><h2 id="4-4-字符串encode编码与decode解码的使用"><a href="#4-4-字符串encode编码与decode解码的使用" class="headerlink" title="4.4 字符串encode编码与decode解码的使用"></a>4.4 字符串encode编码与decode解码的使用</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、unicode格式------编码encode--------&gt;其它编码格式&gt;&gt;&gt; x&#x3D;&#39;上&#39; # 在python3在&#39;上&#39;被存成unicode&gt;&gt;&gt; res&#x3D;x.encode(&#39;utf-8&#39;)&gt;&gt;&gt; res,type(res) # unicode编码成了utf-8格式，而编码的结果为bytes类型，可以当作直接当作二进制去使用(b&#39;\xe4\xb8\x8a&#39;, &lt;class &#39;bytes&#39;&gt;)# 2、其它编码格式------解码decode--------&gt;unicode格式&gt;&gt;&gt; res.decode(&#39;utf-8&#39;) &#39;上&#39;</code></pre></div></figure><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=27">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=27<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=28">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=28<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=29">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=29<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=30">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=30<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>01_Python入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-基本数据类型及内置方法</title>
    <link href="/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/08_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/08_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一-引子"><a href="#一-引子" class="headerlink" title="一 引子"></a>一 引子</h2><p> 数据类型是用来记录事物状态的，而事物的状态是不断变化的(如:一个人年龄的增长（操作int类型） ，单个人名的修改（操作str类型），学生列表中增加学生（操作list类型）等)，这意味着我们在开发程序时需要频繁对数据进行操作，为了提升我们的开发效率， python针对这些常用的操作，为每一种数据类型内置了一系列方法。本章的主题就是带大家详细了解下它们，以及每种数据类型的详细定义、类型转换。</p><p><img src="https://pic1.zhimg.com/80/v2-10e28bbd95c783f2266fea32400e48d0_720w.jpg" alt="img"></p><h2 id="二-数字类型int与float"><a href="#二-数字类型int与float" class="headerlink" title="二 数字类型int与float"></a>二 数字类型int与float</h2><p><img src="https://pic3.zhimg.com/80/v2-c2179471827cd00d18d8a286eb708fd6_720w.jpg" alt="img"></p><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、定义：# 1.1 整型int的定义age&#x3D;10  # 本质age &#x3D; int(10)# 1.2 浮点型float的定义salary&#x3D;3000.3  # 本质salary&#x3D;float(3000.3)# 注意：名字+括号的意思就是调用某个功能，比如# print(...)调用打印功能# int(...)调用创建整型数据的功能# float(...)调用创建浮点型数据的功能</code></pre></div></figure><h2 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、数据类型转换# 1.1 int可以将由纯整数构成的字符串直接转换成整型，若包含其他任意非整数符号，则会报错&gt;&gt;&gt; s &#x3D; &#39;123&#39;&gt;&gt;&gt; res &#x3D; int(s)&gt;&gt;&gt; res,type(res)(123, &lt;class &#39;int&#39;&gt;)&gt;&gt;&gt; int(&#39;12.3&#39;) # 错误演示：字符串内包含了非整数符号.Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &#39;12.3&#39;# 1.2 进制转换# 十进制转其他进制&gt;&gt;&gt; bin(3)&#39;0b11&#39;&gt;&gt;&gt; oct(9)&#39;0o11&#39;&gt;&gt;&gt; hex(17)&#39;0x11&#39;# 其他进制转十进制&gt;&gt;&gt; int(&#39;0b11&#39;,2)3&gt;&gt;&gt; int(&#39;0o11&#39;,8)9&gt;&gt;&gt; int(&#39;0x11&#39;,16)17# 1.3 float同样可以用来做数据类型的转换&gt;&gt;&gt; s &#x3D; &#39;12.3&#39;&gt;&gt;&gt; res&#x3D;float(s)&gt;&gt;&gt; res,type(res)(12.3, &lt;class &#39;float&#39;&gt;)</code></pre></div></figure><h2 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h2><p>数字类型主要就是用来做数学运算与比较运算，因此数字类型除了与运算符结合使用之外，并无需要掌握的内置方法</p><p><img src="https://pic3.zhimg.com/80/v2-45110f0279c9d352ab9c17dca57c140e_720w.jpg" alt="img"></p><h2 id="三-字符串"><a href="#三-字符串" class="headerlink" title="三 字符串"></a>三 字符串</h2><p><img src="https://pic4.zhimg.com/80/v2-15b3e5110d3102e523299c53ddadf663_720w.jpg" alt="img"></p><h2 id="3-1-定义："><a href="#3-1-定义：" class="headerlink" title="3.1 定义："></a>3.1 定义：</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义：在单引号\双引号\三引号内包含一串字符name1 &#x3D; &#39;jason&#39;  # 本质:name &#x3D; str(&#39;任意形式内容&#39;)name2 &#x3D; &quot;lili&quot;  # 本质:name &#x3D; str(&quot;任意形式内容&quot;)name3 &#x3D; &quot;&quot;&quot;ricky&quot;&quot;&quot;  # 本质:name &#x3D; str(&quot;&quot;&quot;任意形式内容&quot;&quot;&quot;)</code></pre></div></figure><h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3.2 类型转换"></a>3.2 类型转换</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 数据类型转换：str()可以将任意数据类型转换成字符串类型，例如 &gt;&gt;&gt; type(str([1,2,3])) # list-&gt;str&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(str(&#123;&quot;name&quot;:&quot;jason&quot;,&quot;age&quot;:18&#125;)) # dict-&gt;str&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(str((1,2,3)))  # tuple-&gt;str&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(str(&#123;1,2,3,4&#125;)) # set-&gt;str&lt;class &#39;str&#39;&gt;</code></pre></div></figure><h2 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h2><h3 id="3-3-1-优先掌握的操作"><a href="#3-3-1-优先掌握的操作" class="headerlink" title="3.3.1 优先掌握的操作"></a>3.3.1 优先掌握的操作</h3><p><img src="https://pic4.zhimg.com/80/v2-fefd043609f271fb50a01020cea03f73_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; str1 &#x3D; &#39;hello python!&#39;# 1.按索引取值(正向取，反向取)：# 1.1 正向取(从左往右)&gt;&gt;&gt; str1[6]p# 1.2 反向取(负号表示从右往左)&gt;&gt;&gt; str1[-4]h# 1.3 对于str来说，只能按照索引取值，不能改&gt;&gt;&gt; str1[0]&#x3D;&#39;H&#39; # 报错TypeError# 2.切片(顾头不顾尾，步长)# 2.1 顾头不顾尾：取出索引为0到8的所有字符&gt;&gt;&gt; str1[0:9]  hello pyt# 2.2 步长：0:9:2,第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0、2、4、6、8的字符&gt;&gt;&gt; str1[0:9:2]  hlopt # 2.3 反向切片&gt;&gt;&gt; str1[::-1]  # -1表示从右往左依次取值!nohtyp olleh# 3.长度len# 3.1 获取字符串的长度，即字符的个数，但凡存在于引号内的都算作字符)&gt;&gt;&gt; len(str1) # 空格也算字符13# 4.成员运算 in 和 not in    # 4.1 int:判断hello 是否在 str1里面&gt;&gt;&gt; &#39;hello&#39; in str1  True# 4.2 not in:判断tony 是否不在 str1里面&gt;&gt;&gt; &#39;tony&#39; not in str1 True# 5.strip移除字符串首尾指定的字符(默认移除空格)# 5.1 括号内不指定字符，默认移除首尾空白字符(空格、\n、\t)&gt;&gt;&gt; str1 &#x3D; &#39;  life is short!  &#39;&gt;&gt;&gt; str1.strip()  life is short!# 5.2 括号内指定字符，移除首尾指定的字符&gt;&gt;&gt; str2 &#x3D; &#39;**tony**&#39;  &gt;&gt;&gt; str2.strip(&#39;*&#39;)  tony# 6.切分split# 6.1 括号内不指定字符，默认以空格作为切分符号&gt;&gt;&gt; str3&#x3D;&#39;hello world&#39;&gt;&gt;&gt; str3.split()[&#39;hello&#39;, &#39;world&#39;]# 6.2 括号内指定分隔字符，则按照括号内指定的字符切割字符串&gt;&gt;&gt; str4 &#x3D; &#39;127.0.0.1&#39;&gt;&gt;&gt; str4.split(&#39;.&#39;)  [&#39;127&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;]  # 注意:split切割得到的结果是列表数据类型# 7.循环&gt;&gt;&gt; str5 &#x3D; &#39;今天你好吗？&#39;&gt;&gt;&gt; for line in str5:  # 依次取出字符串中每一个字符...     print(line)...今天你好吗？</code></pre></div></figure><h3 id="3-3-2-需要掌握的操作"><a href="#3-3-2-需要掌握的操作" class="headerlink" title="3.3.2 需要掌握的操作"></a>3.3.2 需要掌握的操作</h3><p><img src="https://pic4.zhimg.com/80/v2-3870f73c837fd6488da8a24bec358a6f_720w.jpg" alt="img"></p><p><strong>1.strip, lstrip, rstrip</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; str1 &#x3D; &#39;**tony***&#39;&gt;&gt;&gt; str1.strip(&#39;*&#39;)  # 移除左右两边的指定字符&#39;tony&#39;&gt;&gt;&gt; str1.lstrip(&#39;*&#39;)  # 只移除左边的指定字符tony***&gt;&gt;&gt; str1.rstrip(&#39;*&#39;)  # 只移除右边的指定字符**tony</code></pre></div></figure><p><strong>2.lower(),upper()</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; str2 &#x3D; &#39;My nAme is tonY！&#39;&gt;&gt;&gt; str2.lower()  # 将英文字符串全部变小写my name is tony！&gt;&gt;&gt; str2.upper()  # 将英文字符串全部变大写MY NAME IS TONY！</code></pre></div></figure><p><strong>3.startswith,endswith</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; str3 &#x3D; &#39;tony jam&#39;# startswith()判断字符串是否以括号内指定的字符开头，结果为布尔值True或False&gt;&gt;&gt; str3.startswith(&#39;t&#39;) True&gt;&gt;&gt; str3.startswith(&#39;j&#39;)False# endswith()判断字符串是否以括号内指定的字符结尾，结果为布尔值True或False&gt;&gt;&gt; str3.endswith(&#39;jam&#39;)True&gt;&gt;&gt; str3.endswith(&#39;tony&#39;)  False</code></pre></div></figure><p><strong>4.格式化输出之format</strong></p><p>之前我们使用%s来做字符串的格式化输出操作，在传值时，必须严格按照位置与%s一一对应，而字符串的内置方法format则提供了一种不依赖位置的传值方式</p><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># format括号内在传参数时完全可以打乱顺序，但仍然能指名道姓地为指定的参数传值，name&#x3D;‘tony’就是传给&#123;name&#125;&gt;&gt;&gt; str4 &#x3D; &#39;my name is &#123;name&#125;, my age is &#123;age&#125;!&#39;.format(age&#x3D;18,name&#x3D;&#39;tony&#39;)&gt;&gt;&gt; str4  &#39;my name is tony, my age is 18!&#39;&gt;&gt;&gt; str4 &#x3D; &#39;my name is &#123;name&#125;&#123;name&#125;&#123;name&#125;, my age is &#123;name&#125;!&#39;.format(name&#x3D;&#39;tony&#39;, age&#x3D;18)&gt;&gt;&gt; str4  &#39;my name is tonytonytony, my age is tony!&#39;</code></pre></div></figure><p>format的其他使用方式（了解）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 类似于%s的用法，传入的值会按照位置与&#123;&#125;一一对应&gt;&gt;&gt; str4 &#x3D; &#39;my name is &#123;&#125;, my age is &#123;&#125;!&#39;.format(&#39;tony&#39;, 18)&gt;&gt;&gt; str4 my name is tony, my age is 18!# 把format传入的多个值当作一个列表，然后用&#123;索引&#125;取值&gt;&gt;&gt; str4 &#x3D; &#39;my name is &#123;0&#125;, my age is &#123;1&#125;!&#39;.format(&#39;tony&#39;, 18)&gt;&gt;&gt; str4my name is tony, my age is 18!&gt;&gt;&gt; str4 &#x3D; &#39;my name is &#123;1&#125;, my age is &#123;0&#125;!&#39;.format(&#39;tony&#39;, 18)&gt;&gt;&gt; str4  my name is 18, my age is tony!&gt;&gt;&gt; str4 &#x3D; &#39;my name is &#123;1&#125;, my age is &#123;1&#125;!&#39;.format(&#39;tony&#39;, 18)&gt;&gt;&gt; str4  my name is 18, my age is 18!</code></pre></div></figure><p><strong>5.split,rsplit</strong></p><p><img src="https://pic4.zhimg.com/80/v2-56cf164d7e6dc3467c228bf141f1585b_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># split会按照从左到右的顺序对字符串进行切分，可以指定切割次数&gt;&gt;&gt; str5&#x3D;&#39;C:&#x2F;a&#x2F;b&#x2F;c&#x2F;d.txt&#39;&gt;&gt;&gt; str5.split(&#39;&#x2F;&#39;,1)[&#39;C:&#39;, &#39;a&#x2F;b&#x2F;c&#x2F;d.txt&#39;]  # rsplit刚好与split相反，从右往左切割，可以指定切割次数&gt;&gt;&gt; str5&#x3D;&#39;a|b|c&#39;&gt;&gt;&gt; str5.rsplit(&#39;|&#39;,1)[&#39;a|b&#39;, &#39;c&#39;]</code></pre></div></figure><p><strong>6.join</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 从可迭代对象中取出多个字符串，然后按照指定的分隔符进行拼接，拼接的结果为字符串&gt;&gt;&gt; &#39;%&#39;.join(&#39;hello&#39;) # 从字符串&#39;hello&#39;中取出多个字符串，然后按照%作为分隔符号进行拼接&#39;h%e%l%l%o&#39;&gt;&gt;&gt; &#39;|&#39;.join([&#39;tony&#39;,&#39;18&#39;,&#39;read&#39;])  # 从列表中取出多个字符串，然后按照*作为分隔符号进行拼接&#39;tony|18|read&#39;</code></pre></div></figure><p><strong>7.replace</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 用新的字符替换字符串中旧的字符&gt;&gt;&gt; str7 &#x3D; &#39;my name is tony, my age is 18!&#39;  # 将tony的年龄由18岁改成73岁&gt;&gt;&gt; str7 &#x3D; str7.replace(&#39;18&#39;, &#39;73&#39;)  # 语法:replace(&#39;旧内容&#39;, &#39;新内容&#39;)&gt;&gt;&gt; str7my name is tony, my age is 73!# 可以指定修改的个数&gt;&gt;&gt; str7 &#x3D; &#39;my name is tony, my age is 18!&#39;&gt;&gt;&gt; str7 &#x3D; str7.replace(&#39;my&#39;, &#39;MY&#39;,1) # 只把一个my改为MY&gt;&gt;&gt; str7&#39;MY name is tony, my age is 18!&#39;</code></pre></div></figure><p><strong>8.isdigit</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 判断字符串是否是纯数字组成，返回结果为True或False&gt;&gt;&gt; str8 &#x3D; &#39;5201314&#39;&gt;&gt;&gt; str8.isdigit()True&gt;&gt;&gt; str8 &#x3D; &#39;123g123&#39;&gt;&gt;&gt; str8.isdigit()False</code></pre></div></figure><h3 id="3-3-3-了解操作"><a href="#3-3-3-了解操作" class="headerlink" title="3.3.3 了解操作"></a>3.3.3 了解操作</h3><p><img src="https://pic1.zhimg.com/80/v2-44989c1a59822b2480dc44ed07e1987c_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.find,rfind,index,rindex,count# 1.1 find：从指定范围内查找子字符串的起始索引，找得到则返回数字1，找不到则返回-1&gt;&gt;&gt; msg&#x3D;&#39;tony say hello&#39;&gt;&gt;&gt; msg.find(&#39;o&#39;,1,3)  # 在索引为1和2(顾头不顾尾)的字符中查找字符o的索引1  # 1.2 index:同find,但在找不到时会报错&gt;&gt;&gt; msg.index(&#39;e&#39;,2,4) # 报错ValueError# 1.3 rfind与rindex：略# 1.4 count:统计字符串在大字符串中出现的次数&gt;&gt;&gt; msg &#x3D; &quot;hello everyone&quot;&gt;&gt;&gt; msg.count(&#39;e&#39;)  # 统计字符串e出现的次数4&gt;&gt;&gt; msg.count(&#39;e&#39;,1,6)  # 字符串e在索引1~5范围内出现的次数1# 2.center,ljust,rjust,zfill&gt;&gt;&gt; name&#x3D;&#39;tony&#39;&gt;&gt;&gt; name.center(30,&#39;-&#39;)  # 总宽度为30，字符串居中显示，不够用-填充-------------tony-------------&gt;&gt;&gt; name.ljust(30,&#39;*&#39;)  # 总宽度为30，字符串左对齐显示，不够用*填充tony**************************&gt;&gt;&gt; name.rjust(30,&#39;*&#39;)  # 总宽度为30，字符串右对齐显示，不够用*填充**************************tony&gt;&gt;&gt; name.zfill(50)  # 总宽度为50，字符串右对齐显示，不够用0填充0000000000000000000000000000000000000000000000tony# 3.expandtabs&gt;&gt;&gt; name &#x3D; &#39;tony\thello&#39;  # \t表示制表符(tab键)&gt;&gt;&gt; nametony    hello&gt;&gt;&gt; name.expandtabs(1)  # 修改\t制表符代表的空格数tony hello# 4.captalize,swapcase,title# 4.1 captalize：首字母大写&gt;&gt;&gt; message &#x3D; &#39;hello everyone nice to meet you!&#39;&gt;&gt;&gt; message.capitalize()Hello everyone nice to meet you!  # 4.2 swapcase：大小写翻转&gt;&gt;&gt; message1 &#x3D; &#39;Hi girl, I want make friends with you!&#39;&gt;&gt;&gt; message1.swapcase()  hI GIRL, i WANT MAKE FRIENDS WITH YOU!  #4.3 title：每个单词的首字母大写&gt;&gt;&gt; msg &#x3D; &#39;dear my friend i miss you very much&#39;&gt;&gt;&gt; msg.title()Dear My Friend I Miss You Very Much # 5.is数字系列#在python3中num1 &#x3D; b&#39;4&#39; #bytesnum2 &#x3D; u&#39;4&#39; #unicode,python3中无需加u就是unicodenum3 &#x3D; &#39;四&#39; #中文数字num4 &#x3D; &#39;Ⅳ&#39; #罗马数字#isdigt:bytes,unicode&gt;&gt;&gt; num1.isdigit()True&gt;&gt;&gt; num2.isdigit()True&gt;&gt;&gt; num3.isdigit()False&gt;&gt;&gt; num4.isdigit() False#isdecimal:uncicode(bytes类型无isdecimal方法)&gt;&gt;&gt; num2.isdecimal() True&gt;&gt;&gt; num3.isdecimal() False&gt;&gt;&gt; num4.isdecimal() False#isnumberic:unicode,中文数字,罗马数字(bytes类型无isnumberic方法)&gt;&gt;&gt; num2.isnumeric() True&gt;&gt;&gt; num3.isnumeric() True&gt;&gt;&gt; num4.isnumeric() True# 三者不能判断浮点数&gt;&gt;&gt; num5 &#x3D; &#39;4.3&#39;&gt;&gt;&gt; num5.isdigit()False&gt;&gt;&gt; num5.isdecimal()False&gt;&gt;&gt; num5.isnumeric()False&#39;&#39;&#39;总结:    最常用的是isdigit,可以判断bytes和unicode类型,这也是最常见的数字应用场景    如果要判断中文数字或罗马数字,则需要用到isnumeric。&#39;&#39;&#39;# 6.is其他&gt;&gt;&gt; name &#x3D; &#39;tony123&#39;&gt;&gt;&gt; name.isalnum() #字符串中既可以包含数字也可以包含字母True&gt;&gt;&gt; name.isalpha() #字符串中只包含字母False&gt;&gt;&gt; name.isidentifier()True&gt;&gt;&gt; name.islower()  # 字符串是否是纯小写True&gt;&gt;&gt; name.isupper()  # 字符串是否是纯大写False&gt;&gt;&gt; name.isspace()  # 字符串是否全是空格False&gt;&gt;&gt; name.istitle()  # 字符串中的单词首字母是否都是大写False</code></pre></div></figure><h2 id="四-列表"><a href="#四-列表" class="headerlink" title="四 列表"></a>四 列表</h2><p><img src="https://pic4.zhimg.com/80/v2-c388190efab0d91f2604988622f3fd37_720w.jpg" alt="img"></p><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义：在[]内,用逗号分隔开多个任意数据类型的值l1 &#x3D; [1,&#39;a&#39;,[1,2]]  # 本质:l1 &#x3D; list([1,&#39;a&#39;,[1,2]])</code></pre></div></figure><h2 id="4-2-类型转换"><a href="#4-2-类型转换" class="headerlink" title="4.2 类型转换"></a>4.2 类型转换</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 但凡能被for循环遍历的数据类型都可以传给list()转换成列表类型，list()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到列表中&gt;&gt;&gt; list(&#39;wdad&#39;) # 结果：[&#39;w&#39;, &#39;d&#39;, &#39;a&#39;, &#39;d&#39;] &gt;&gt;&gt; list([1,2,3]) # 结果：[1, 2, 3]&gt;&gt;&gt; list(&#123;&quot;name&quot;:&quot;jason&quot;,&quot;age&quot;:18&#125;) #结果：[&#39;name&#39;, &#39;age&#39;]&gt;&gt;&gt; list((1,2,3)) # 结果：[1, 2, 3] &gt;&gt;&gt; list(&#123;1,2,3,4&#125;) # 结果：[1, 2, 3, 4]</code></pre></div></figure><h2 id="4-3-使用"><a href="#4-3-使用" class="headerlink" title="4.3 使用"></a>4.3 使用</h2><h3 id="4-3-1-优先掌握的操作"><a href="#4-3-1-优先掌握的操作" class="headerlink" title="4.3.1 优先掌握的操作"></a>4.3.1 优先掌握的操作</h3><p><img src="https://pic3.zhimg.com/80/v2-17400abd279a6fb484ecc78c5d8d3b8e_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.按索引存取值(正向存取+反向存取)：即可存也可以取  # 1.1 正向取(从左往右)&gt;&gt;&gt; my_friends&#x3D;[&#39;tony&#39;,&#39;jason&#39;,&#39;tom&#39;,4,5]&gt;&gt;&gt; my_friends[0]  tony# 1.2 反向取(负号表示从右往左)&gt;&gt;&gt; my_friends[-1]  5# 1.3 对于list来说，既可以按照索引取值，又可以按照索引修改指定位置的值，但如果索引不存在则报错&gt;&gt;&gt; my_friends &#x3D; [&#39;tony&#39;,&#39;jack&#39;,&#39;jason&#39;,4,5]&gt;&gt;&gt; my_friends[1] &#x3D; &#39;martthow&#39;&gt;&gt;&gt; my_friends[&#39;tony&#39;, &#39;martthow&#39;, &#39;jason&#39;, 4, 5]# 2.切片(顾头不顾尾，步长)# 2.1 顾头不顾尾：取出索引为0到3的元素&gt;&gt;&gt; my_friends[0:4] [&#39;tony&#39;, &#39;jason&#39;, &#39;tom&#39;, 4]# 2.2 步长：0:4:2,第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0、2的元素&gt;&gt;&gt; my_friends[0:4:2]  [&#39;tony&#39;, &#39;tom&#39;]# 3.长度&gt;&gt;&gt; len(my_friends)5# 4.成员运算in和not in&gt;&gt;&gt; &#39;tony&#39; in my_friendsTrue&gt;&gt;&gt; &#39;xxx&#39; not in my_friendsTrue# 5.添加# 5.1 append()列表尾部追加元素&gt;&gt;&gt; l1 &#x3D; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]&gt;&gt;&gt; l1.append(&#39;d&#39;)&gt;&gt;&gt; l1[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]# 5.2 extend()一次性在列表尾部添加多个元素&gt;&gt;&gt; l1.extend([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])&gt;&gt;&gt; l1[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]# 5.3 insert()在指定位置插入元素&gt;&gt;&gt; l1.insert(0,&quot;first&quot;)  # 0表示按索引位置插值&gt;&gt;&gt; l1[&#39;first&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;alisa&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]# 6.删除# 6.1 del&gt;&gt;&gt; l &#x3D; [11,22,33,44]&gt;&gt;&gt; del l[2]  # 删除索引为2的元素&gt;&gt;&gt; l[11,22,44]# 6.2 pop()默认删除列表最后一个元素，并将删除的值返回，括号内可以通过加索引值来指定删除元素&gt;&gt;&gt; l &#x3D; [11,22,33,22,44]&gt;&gt;&gt; res&#x3D;l.pop()&gt;&gt;&gt; res44&gt;&gt;&gt; res&#x3D;l.pop(1)&gt;&gt;&gt; res22# 6.3 remove()括号内指名道姓表示要删除哪个元素，没有返回值&gt;&gt;&gt; l &#x3D; [11,22,33,22,44]&gt;&gt;&gt; res&#x3D;l.remove(22) # 从左往右查找第一个括号内需要删除的元素&gt;&gt;&gt; print(res)None# 7.reverse()颠倒列表内元素顺序&gt;&gt;&gt; l &#x3D; [11,22,33,44]&gt;&gt;&gt; l.reverse() &gt;&gt;&gt; l[44,33,22,11]# 8.sort()给列表内所有元素排序# 8.1 排序时列表元素之间必须是相同数据类型，不可混搭，否则报错&gt;&gt;&gt; l &#x3D; [11,22,3,42,7,55]&gt;&gt;&gt; l.sort()&gt;&gt;&gt; l [3, 7, 11, 22, 42, 55]  # 默认从小到大排序&gt;&gt;&gt; l &#x3D; [11,22,3,42,7,55]&gt;&gt;&gt; l.sort(reverse&#x3D;True)  # reverse用来指定是否跌倒排序，默认为False&gt;&gt;&gt; l [55, 42, 22, 11, 7, 3]# 8.2 了解知识：# 我们常用的数字类型直接比较大小，但其实，字符串、列表等都可以比较大小，原理相同：都是依次比较对应位置的元素的大小，如果分出大小，则无需比较下一个元素，比如&gt;&gt;&gt; l1&#x3D;[1,2,3]&gt;&gt;&gt; l2&#x3D;[2,]&gt;&gt;&gt; l2 &gt; l1True# 字符之间的大小取决于它们在ASCII表中的先后顺序，越往后越大&gt;&gt;&gt; s1&#x3D;&#39;abc&#39;&gt;&gt;&gt; s2&#x3D;&#39;az&#39;&gt;&gt;&gt; s2 &gt; s1 # s1与s2的第一个字符没有分出胜负，但第二个字符&#39;z&#39;&gt;&#39;b&#39;,所以s2&gt;s1成立True# 所以我们也可以对下面这个列表排序&gt;&gt;&gt; l &#x3D; [&#39;A&#39;,&#39;z&#39;,&#39;adjk&#39;,&#39;hello&#39;,&#39;hea&#39;]&gt;&gt;&gt; l.sort()&gt;&gt;&gt; l[&#39;A&#39;, &#39;adjk&#39;, &#39;hea&#39;, &#39;hello&#39;,&#39;z&#39;]# 9.循环# 循环遍历my_friends列表里面的值for line in my_friends:    print(line) &#39;tony&#39;&#39;jack&#39;&#39;jason&#39;45</code></pre></div></figure><h3 id="4-3-2-了解操作"><a href="#4-3-2-了解操作" class="headerlink" title="4.3.2 了解操作"></a>4.3.2 了解操作</h3><p><img src="https://pic3.zhimg.com/80/v2-7c242fdec61e16c79e06f9181bb71a1a_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; l&#x3D;[1,2,3,4,5,6]&gt;&gt;&gt; l[0:3:1] [1, 2, 3]  # 正向步长&gt;&gt;&gt; l[2::-1] [3, 2, 1]  # 反向步长# 通过索引取值实现列表翻转&gt;&gt;&gt; l[::-1][6, 5, 4, 3, 2, 1]</code></pre></div></figure><h2 id="五-元组"><a href="#五-元组" class="headerlink" title="五 元组"></a>五 元组</h2><p><img src="https://pic1.zhimg.com/80/v2-c2d1b8f652b5290b197d97c45f115830_720w.jpg" alt="img"></p><h2 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a>5.1 作用</h2><p>元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改，即元组相当于不可变的列表，用于记录多个固定不允许修改的值，单纯用于取</p><p><img src="https://pic1.zhimg.com/80/v2-66e37151e39efc17ad3473a1ccadafc4_720w.jpg" alt="img"></p><h2 id="5-2-定义方式"><a href="#5-2-定义方式" class="headerlink" title="5.2 定义方式"></a>5.2 定义方式</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在()内用逗号分隔开多个任意类型的值&gt;&gt;&gt; countries &#x3D; (&quot;中国&quot;，&quot;美国&quot;，&quot;英国&quot;)  # 本质:countries &#x3D; tuple(&quot;中国&quot;，&quot;美国&quot;，&quot;英国&quot;)# 强调：如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组&gt;&gt;&gt; countries &#x3D; (&quot;中国&quot;，)  # 本质:countries &#x3D; tuple(&quot;中国&quot;)</code></pre></div></figure><h2 id="5-3-类型转换"><a href="#5-3-类型转换" class="headerlink" title="5.3 类型转换"></a>5.3 类型转换</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 但凡能被for循环的遍历的数据类型都可以传给tuple()转换成元组类型&gt;&gt;&gt; tuple(&#39;wdad&#39;) # 结果：(&#39;w&#39;, &#39;d&#39;, &#39;a&#39;, &#39;d&#39;) &gt;&gt;&gt; tuple([1,2,3]) # 结果：(1, 2, 3)&gt;&gt;&gt; tuple(&#123;&quot;name&quot;:&quot;jason&quot;,&quot;age&quot;:18&#125;) # 结果：(&#39;name&#39;, &#39;age&#39;)&gt;&gt;&gt; tuple((1,2,3)) # 结果：(1, 2, 3)&gt;&gt;&gt; tuple(&#123;1,2,3,4&#125;) # 结果：(1, 2, 3, 4)# tuple()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到元组中</code></pre></div></figure><h2 id="5-4-使用"><a href="#5-4-使用" class="headerlink" title="5.4 使用"></a>5.4 使用</h2><p><img src="https://pic3.zhimg.com/80/v2-4ece19ae4a48f1677deb018019fe2c2a_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; tuple1 &#x3D; (1, &#39;hhaha&#39;, 15000.00, 11, 22, 33) # 1、按索引取值(正向取+反向取)：只能取，不能改否则报错！  &gt;&gt;&gt; tuple1[0]1&gt;&gt;&gt; tuple1[-2]22&gt;&gt;&gt; tuple1[0] &#x3D; &#39;hehe&#39;  # 报错：TypeError:# 2、切片(顾头不顾尾，步长)&gt;&gt;&gt; tuple1[0:6:2] (1, 15000.0, 22)# 3、长度&gt;&gt;&gt; len(tuple1)  6# 4、成员运算 in 和 not in&gt;&gt;&gt; &#39;hhaha&#39; in tuple1 True&gt;&gt;&gt; &#39;hhaha&#39; not in tuple1  False # 5、循环&gt;&gt;&gt; for line in tuple1:...     print(line)1hhaha15000.0112233</code></pre></div></figure><h2 id="六-字典"><a href="#六-字典" class="headerlink" title="六 字典"></a>六 字典</h2><p><img src="https://pic4.zhimg.com/80/v2-d1303c9f61b67e515d181e47ea284163_720w.jpg" alt="img"></p><h2 id="6-1-定义方式"><a href="#6-1-定义方式" class="headerlink" title="6.1 定义方式"></a>6.1 定义方式</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义：在&#123;&#125;内用逗号分隔开多元素，每一个元素都是key:value的形式，其中value可以是任意类型，而key则必须是不可变类型，详见第八小节，通常key应该是str类型，因为str类型会对value有描述性的功能info&#x3D;&#123;&#39;name&#39;:&#39;tony&#39;,&#39;age&#39;:18,&#39;sex&#39;:&#39;male&#39;&#125; #本质info&#x3D;dict(&#123;....&#125;)# 也可以这么定义字典info&#x3D;dict(name&#x3D;&#39;tony&#39;,age&#x3D;18,sex&#x3D;&#39;male&#39;) # info&#x3D;&#123;&#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;, &#39;name&#39;: &#39;tony&#39;&#125;</code></pre></div></figure><h2 id="6-2-类型转换"><a href="#6-2-类型转换" class="headerlink" title="6.2 类型转换"></a>6.2 类型转换</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 转换1: &gt;&gt;&gt; info&#x3D;dict([[&#39;name&#39;,&#39;tony&#39;],(&#39;age&#39;,18)])&gt;&gt;&gt; info&#123;&#39;age&#39;: 18, &#39;name&#39;: &#39;tony&#39;&#125;# 转换2：fromkeys会从元组中取出每个值当做key，然后与None组成key:value放到字典中&gt;&gt;&gt; &#123;&#125;.fromkeys((&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;),None)  &#123;&#39;age&#39;: None, &#39;sex&#39;: None, &#39;name&#39;: None&#125;</code></pre></div></figure><h2 id="6-3-使用"><a href="#6-3-使用" class="headerlink" title="6.3 使用"></a>6.3 使用</h2><h3 id="6-3-1-优先掌握的操作"><a href="#6-3-1-优先掌握的操作" class="headerlink" title="6.3.1 优先掌握的操作"></a>6.3.1 优先掌握的操作</h3><p><img src="https://pic3.zhimg.com/80/v2-f9177137b88b9fc3f31c88d91ff854ee_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、按key存取值：可存可取# 1.1 取&gt;&gt;&gt; dic &#x3D; &#123;...     &#39;name&#39;: &#39;xxx&#39;,...     &#39;age&#39;: 18,...     &#39;hobbies&#39;: [&#39;play game&#39;, &#39;basketball&#39;]... &#125;&gt;&gt;&gt; dic[&#39;name&#39;]&#39;xxx&#39;&gt;&gt;&gt; dic[&#39;hobbies&#39;][1]&#39;basketball&#39;# 1.2 对于赋值操作，如果key原先不存在于字典，则会新增key:value&gt;&gt;&gt; dic[&#39;gender&#39;] &#x3D; &#39;male&#39;  &gt;&gt;&gt; dic&#123;&#39;name&#39;: &#39;tony&#39;, &#39;age&#39;: 18, &#39;hobbies&#39;: [&#39;play game&#39;, &#39;basketball&#39;],&#39;gender&#39;:&#39;male&#39;&#125;# 1.3 对于赋值操作，如果key原先存在于字典，则会修改对应value的值&gt;&gt;&gt; dic[&#39;name&#39;] &#x3D; &#39;tony&#39;&gt;&gt;&gt; dic&#123;&#39;name&#39;: &#39;tony&#39;, &#39;age&#39;: 18, &#39;hobbies&#39;: [&#39;play game&#39;, &#39;basketball&#39;]&#125;# 2、长度len&gt;&gt;&gt; len(dic) 3# 3、成员运算in和not in&gt;&gt;&gt; &#39;name&#39; in dic  # 判断某个值是否是字典的keyTrue# 4、删除&gt;&gt;&gt; dic.pop(&#39;name&#39;)  # 通过指定字典的key来删除字典的键值对&gt;&gt;&gt; dic&#123;&#39;age&#39;: 18, &#39;hobbies&#39;: [&#39;play game&#39;, &#39;basketball&#39;]&#125;# 5、键keys()，值values()，键值对items()&gt;&gt;&gt; dic &#x3D; &#123;&#39;age&#39;: 18, &#39;hobbies&#39;: [&#39;play game&#39;, &#39;basketball&#39;], &#39;name&#39;: &#39;xxx&#39;&#125;# 获取字典所有的key&gt;&gt;&gt; dic.keys()  dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;hobbies&#39;])# 获取字典所有的value&gt;&gt;&gt; dic.values()dict_values([&#39;xxx&#39;, 18, [&#39;play game&#39;, &#39;basketball&#39;]])# 获取字典所有的键值对&gt;&gt;&gt; dic.items()dict_items([(&#39;name&#39;, &#39;xxx&#39;), (&#39;age&#39;, 18), (&#39;hobbies&#39;, [&#39;play game&#39;, &#39;basketball&#39;])])# 6、循环# 6.1 默认遍历的是字典的key&gt;&gt;&gt; for key in dic:...     print(key)... agehobbiesname# 6.2 只遍历key&gt;&gt;&gt; for key in dic.keys():...     print(key)... agehobbiesname# 6.3 只遍历value&gt;&gt;&gt; for key in dic.values():...     print(key)... 18[&#39;play game&#39;, &#39;basketball&#39;]xxx# 6.4 遍历key与value&gt;&gt;&gt; for key in dic.items():...     print(key)... (&#39;age&#39;, 18)(&#39;hobbies&#39;, [&#39;play game&#39;, &#39;basketball&#39;])(&#39;name&#39;, &#39;xxx&#39;)</code></pre></div></figure><h3 id="6-3-2-需要掌握的操作"><a href="#6-3-2-需要掌握的操作" class="headerlink" title="6.3.2 需要掌握的操作"></a>6.3.2 需要掌握的操作</h3><p><img src="https://pic1.zhimg.com/80/v2-9a6cb9d36cc1ce915091d1937532a35c_720w.jpg" alt="img"></p><p><strong>1.get()</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; dic&#x3D; &#123;&#39;k1&#39;:&#39;jason&#39;,&#39;k2&#39;:&#39;Tony&#39;,&#39;k3&#39;:&#39;JY&#39;&#125;&gt;&gt;&gt; dic.get(&#39;k1&#39;)&#39;jason&#39;  # key存在，则获取key对应的value值&gt;&gt;&gt; res&#x3D;dic.get(&#39;xxx&#39;) # key不存在，不会报错而是默认返回None&gt;&gt;&gt; print(res)None  &gt;&gt;&gt; res&#x3D;dic.get(&#39;xxx&#39;,666) # key不存在时，可以设置默认返回的值&gt;&gt;&gt; print(res)666 # ps:字典取值建议使用get方法</code></pre></div></figure><p><strong>2.pop()</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; dic&#x3D; &#123;&#39;k1&#39;:&#39;jason&#39;,&#39;k2&#39;:&#39;Tony&#39;,&#39;k3&#39;:&#39;JY&#39;&#125;&gt;&gt;&gt; v &#x3D; dic.pop(&#39;k2&#39;)  # 删除指定的key对应的键值对,并返回值&gt;&gt;&gt; dic&#123;&#39;k1&#39;: &#39;jason&#39;, &#39;kk2&#39;: &#39;JY&#39;&#125;&gt;&gt;&gt; v&#39;Tony&#39;</code></pre></div></figure><p><strong>3.popitem()</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; dic&#x3D; &#123;&#39;k1&#39;:&#39;jason&#39;,&#39;k2&#39;:&#39;Tony&#39;,&#39;k3&#39;:&#39;JY&#39;&#125;&gt;&gt;&gt; item &#x3D; dic.popitem()  # 随机删除一组键值对,并将删除的键值放到元组内返回&gt;&gt;&gt; dic&#123;&#39;k3&#39;: &#39;JY&#39;, &#39;k2&#39;: &#39;Tony&#39;&#125;&gt;&gt;&gt; item(&#39;k1&#39;, &#39;jason&#39;)</code></pre></div></figure><p><strong>4.update()</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 用新字典更新旧字典，有则修改，无则添加&gt;&gt;&gt; dic&#x3D; &#123;&#39;k1&#39;:&#39;jason&#39;,&#39;k2&#39;:&#39;Tony&#39;,&#39;k3&#39;:&#39;JY&#39;&#125;&gt;&gt;&gt; dic.update(&#123;&#39;k1&#39;:&#39;JN&#39;,&#39;k4&#39;:&#39;xxx&#39;&#125;)&gt;&gt;&gt; dic&#123;&#39;k1&#39;: &#39;JN&#39;, &#39;k3&#39;: &#39;JY&#39;, &#39;k2&#39;: &#39;Tony&#39;, &#39;k4&#39;: &#39;xxx&#39;&#125;</code></pre></div></figure><p><strong>5.fromkeys()</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; dic &#x3D; dict.fromkeys([&#39;k1&#39;,&#39;k2&#39;,&#39;k3&#39;],[])&gt;&gt;&gt; dic&#123;&#39;k1&#39;: [], &#39;k2&#39;: [], &#39;k3&#39;: []&#125;</code></pre></div></figure><p><strong>6.setdefault()</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># key不存在则新增键值对，并将新增的value返回&gt;&gt;&gt; dic&#x3D;&#123;&#39;k1&#39;:111,&#39;k2&#39;:222&#125;&gt;&gt;&gt; res&#x3D;dic.setdefault(&#39;k3&#39;,333)&gt;&gt;&gt; res333&gt;&gt;&gt; dic # 字典中新增了键值对&#123;&#39;k1&#39;: 111, &#39;k3&#39;: 333, &#39;k2&#39;: 222&#125;# key存在则不做任何修改，并返回已存在key对应的value值&gt;&gt;&gt; dic&#x3D;&#123;&#39;k1&#39;:111,&#39;k2&#39;:222&#125;&gt;&gt;&gt; res&#x3D;dic.setdefault(&#39;k1&#39;,666)&gt;&gt;&gt; res111&gt;&gt;&gt; dic # 字典不变&#123;&#39;k1&#39;: 111, &#39;k2&#39;: 222&#125;</code></pre></div></figure><h2 id="七-集合"><a href="#七-集合" class="headerlink" title="七 集合"></a>七 集合</h2><p><img src="https://pic4.zhimg.com/80/v2-a7172908ebf2b327251e4defb86b6d67_720w.jpg" alt="img"></p><h2 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a>7.1 作用</h2><p>集合、list、tuple、dict一样都可以存放多个值，但是集合主要用于：去重、关系运算</p><p><img src="https://pic2.zhimg.com/80/v2-3c82eb7aaa1df9d7830884196d689979_720w.jpg" alt="img"></p><h2 id="7-2-定义"><a href="#7-2-定义" class="headerlink" title="7.2 定义"></a>7.2 定义</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;定义：在&#123;&#125;内用逗号分隔开多个元素，集合具备以下三个特点：     1：每个元素必须是不可变类型     2：集合内没有重复的元素     3：集合内元素无序&quot;&quot;&quot;s &#x3D; &#123;1,2,3,4&#125;  # 本质 s &#x3D; set(&#123;1,2,3,4&#125;)# 注意1：列表类型是索引对应值，字典是key对应值，均可以取得单个指定的值，而集合类型既没有索引也没有key与值对应，所以无法取得单个的值，而且对于集合来说，主要用于去重与关系元素，根本没有取出单个指定值这种需求。# 注意2:&#123;&#125;既可以用于定义dict，也可以用于定义集合，但是字典内的元素必须是key:value的格式，现在我们想定义一个空字典和空集合，该如何准确去定义两者?d &#x3D; &#123;&#125; # 默认是空字典 s &#x3D; set() # 这才是定义空集合</code></pre></div></figure><h2 id="7-3-类型转换"><a href="#7-3-类型转换" class="headerlink" title="7.3 类型转换"></a>7.3 类型转换</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 但凡能被for循环的遍历的数据类型（强调：遍历出的每一个值都必须为不可变类型）都可以传给set()转换成集合类型&gt;&gt;&gt; s &#x3D; set([1,2,3,4])&gt;&gt;&gt; s1 &#x3D; set((1,2,3,4))&gt;&gt;&gt; s2 &#x3D; set(&#123;&#39;name&#39;:&#39;jason&#39;,&#125;)&gt;&gt;&gt; s3 &#x3D; set(&#39;egon&#39;)&gt;&gt;&gt; s,s1,s2,s3&#123;1, 2, 3, 4&#125; &#123;1, 2, 3, 4&#125; &#123;&#39;name&#39;&#125; &#123;&#39;e&#39;, &#39;o&#39;, &#39;g&#39;, &#39;n&#39;&#125;</code></pre></div></figure><h2 id="7-4-使用"><a href="#7-4-使用" class="headerlink" title="7.4 使用"></a>7.4 使用</h2><h3 id="7-4-1-关系运算"><a href="#7-4-1-关系运算" class="headerlink" title="7.4.1 关系运算"></a>7.4.1 关系运算</h3><p>我们定义两个集合friends与friends2来分别存放两个人的好友名字，然后以这两个集合为例讲解集合的关系运算</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; friends1 &#x3D; &#123;&quot;zero&quot;,&quot;kevin&quot;,&quot;jason&quot;,&quot;egon&quot;&#125; # 用户1的好友们 &gt;&gt;&gt; friends2 &#x3D; &#123;&quot;Jy&quot;,&quot;ricky&quot;,&quot;jason&quot;,&quot;egon&quot;&#125;   # 用户2的好友们</code></pre></div></figure><p>两个集合的关系如下图所示</p><p><img src="https://pic1.zhimg.com/80/v2-db98a5092d33449c4667fd2f9717a2c0_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.合集&#x2F;并集(|)：求两个用户所有的好友（重复好友只留一个）&gt;&gt;&gt; friends1 | friends2&#123;&#39;kevin&#39;, &#39;ricky&#39;, &#39;zero&#39;, &#39;jason&#39;, &#39;Jy&#39;, &#39;egon&#39;&#125;# 2.交集(&amp;)：求两个用户的共同好友&gt;&gt;&gt; friends1 &amp; friends2&#123;&#39;jason&#39;, &#39;egon&#39;&#125;# 3.差集(-)：&gt;&gt;&gt; friends1 - friends2 # 求用户1独有的好友&#123;&#39;kevin&#39;, &#39;zero&#39;&#125;&gt;&gt;&gt; friends2 - friends1 # 求用户2独有的好友&#123;&#39;ricky&#39;, &#39;Jy&#39;&#125;# 4.对称差集(^) # 求两个用户独有的好友们（即去掉共有的好友）&gt;&gt;&gt; friends1 ^ friends2&#123;&#39;kevin&#39;, &#39;zero&#39;, &#39;ricky&#39;, &#39;Jy&#39;&#125;# 5.值是否相等(&#x3D;&#x3D;)&gt;&gt;&gt; friends1 &#x3D;&#x3D; friends2False# 6.父集：一个集合是否包含另外一个集合# 6.1 包含则返回True&gt;&gt;&gt; &#123;1,2,3&#125; &gt; &#123;1,2&#125;True&gt;&gt;&gt; &#123;1,2,3&#125; &gt;&#x3D; &#123;1,2&#125;True# 6.2 不存在包含关系，则返回False&gt;&gt;&gt; &#123;1,2,3&#125; &gt; &#123;1,3,4,5&#125;False&gt;&gt;&gt; &#123;1,2,3&#125; &gt;&#x3D; &#123;1,3,4,5&#125;False# 7.子集&gt;&gt;&gt; &#123;1,2&#125; &lt; &#123;1,2,3&#125;True&gt;&gt;&gt; &#123;1,2&#125; &lt;&#x3D; &#123;1,2,3&#125;True</code></pre></div></figure><h3 id="7-4-2-去重"><a href="#7-4-2-去重" class="headerlink" title="7.4.2 去重"></a>7.4.2 去重</h3><p><img src="https://pic4.zhimg.com/80/v2-3c863c52c62660f0547ff39f09ac41b7_720w.jpg" alt="img"></p><p>集合去重复有局限性</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1. 只能针对不可变类型# 2. 集合本身是无序的，去重之后无法保留原来的顺序</code></pre></div></figure><p>示例如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; l&#x3D;[&#39;a&#39;,&#39;b&#39;,1,&#39;a&#39;,&#39;a&#39;]&gt;&gt;&gt; s&#x3D;set(l)&gt;&gt;&gt; s # 将列表转成了集合&#123;&#39;b&#39;, &#39;a&#39;, 1&#125;&gt;&gt;&gt; l_new&#x3D;list(s) # 再将集合转回列表&gt;&gt;&gt; l_new[&#39;b&#39;, &#39;a&#39;, 1] # 去除了重复，但是打乱了顺序# 针对不可变类型，并且保证顺序则需要我们自己写代码实现，例如l&#x3D;[    &#123;&#39;name&#39;:&#39;lili&#39;,&#39;age&#39;:18,&#39;sex&#39;:&#39;male&#39;&#125;,    &#123;&#39;name&#39;:&#39;jack&#39;,&#39;age&#39;:73,&#39;sex&#39;:&#39;male&#39;&#125;,    &#123;&#39;name&#39;:&#39;tom&#39;,&#39;age&#39;:20,&#39;sex&#39;:&#39;female&#39;&#125;,    &#123;&#39;name&#39;:&#39;lili&#39;,&#39;age&#39;:18,&#39;sex&#39;:&#39;male&#39;&#125;,    &#123;&#39;name&#39;:&#39;lili&#39;,&#39;age&#39;:18,&#39;sex&#39;:&#39;male&#39;&#125;,]new_l&#x3D;[]for dic in l:    if dic not in new_l:        new_l.append(dic)print(new_l)# 结果：既去除了重复，又保证了顺序，而且是针对不可变类型的去重[    &#123;&#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;, &#39;name&#39;: &#39;lili&#39;&#125;,     &#123;&#39;age&#39;: 73, &#39;sex&#39;: &#39;male&#39;, &#39;name&#39;: &#39;jack&#39;&#125;,     &#123;&#39;age&#39;: 20, &#39;sex&#39;: &#39;female&#39;, &#39;name&#39;: &#39;tom&#39;&#125;]</code></pre></div></figure><h3 id="7-4-3-其他操作"><a href="#7-4-3-其他操作" class="headerlink" title="7.4.3 其他操作"></a>7.4.3 其他操作</h3><p><img src="https://pic3.zhimg.com/80/v2-825386b940849f68a704c35e40a1a5de_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1.长度&gt;&gt;&gt; s&#x3D;&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;&gt;&gt;&gt; len(s)3# 2.成员运算&gt;&gt;&gt; &#39;c&#39; in sTrue# 3.循环&gt;&gt;&gt; for item in s:...     print(item)... cab</code></pre></div></figure><h2 id="7-5-练习"><a href="#7-5-练习" class="headerlink" title="7.5 练习"></a>7.5 练习</h2><p><img src="https://pic2.zhimg.com/80/v2-59e6a2d4c402f9178c89e0716037ec51_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;一.关系运算　　有如下两个集合，pythons是报名python课程的学员名字集合，linuxs是报名linux课程的学员名字集合　　pythons&#x3D;&#123;&#39;jason&#39;,&#39;egon&#39;,&#39;kevin&#39;,&#39;ricky&#39;,&#39;gangdan&#39;,&#39;biubiu&#39;&#125;　　linuxs&#x3D;&#123;&#39;kermit&#39;,&#39;tony&#39;,&#39;gangdan&#39;&#125;　　1. 求出即报名python又报名linux课程的学员名字集合　　2. 求出所有报名的学生名字集合　　3. 求出只报名python课程的学员名字　　4. 求出没有同时这两门课程的学员名字集合&quot;&quot;&quot;# 求出即报名python又报名linux课程的学员名字集合&gt;&gt;&gt; pythons &amp; linuxs# 求出所有报名的学生名字集合&gt;&gt;&gt; pythons | linuxs# 求出只报名python课程的学员名字&gt;&gt;&gt; pythons - linuxs# 求出没有同时这两门课程的学员名字集合&gt;&gt;&gt; pythons ^ linuxs</code></pre></div></figure><h2 id="八-可变类型与不可变类型"><a href="#八-可变类型与不可变类型" class="headerlink" title="八 可变类型与不可变类型"></a>八 可变类型与不可变类型</h2><p><strong>可变数据类型：</strong>值发生改变时，内存地址不变，即id不变，证明在改变原值</p><p><strong>不可变类型：</strong>值发生改变时，内存地址也发生改变，即id也变，证明是没有在改变原值，是产生了新的值</p><p><strong>数字类型:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x &#x3D; 10&gt;&gt;&gt; id(x)1830448896 &gt;&gt;&gt; x &#x3D; 20&gt;&gt;&gt; id(x)1830448928# 内存地址改变了，说明整型是不可变数据类型，浮点型也一样</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-aba483b5a4fce5be3c97c4e9eb358c6d_720w.jpg" alt="img"></p><p><strong>字符串</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x &#x3D; &quot;Jy&quot;&gt;&gt;&gt; id(x)938809263920 &gt;&gt;&gt; x &#x3D; &quot;Ricky&quot;&gt;&gt;&gt; id(x)938809264088# 内存地址改变了，说明字符串是不可变数据类型</code></pre></div></figure><p><img src="https://pic2.zhimg.com/80/v2-bb67114dc6c8fe2694d4f9971b8ddc09_720w.jpg" alt="img"></p><p><strong>列表</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; list1 &#x3D; [&#39;tom&#39;,&#39;jack&#39;,&#39;egon&#39;]&gt;&gt;&gt; id(list1)486316639176&gt;&gt;&gt; list1[2] &#x3D; &#39;kevin&#39;&gt;&gt;&gt; id(list1)486316639176&gt;&gt;&gt; list1.append(&#39;lili&#39;)&gt;&gt;&gt; id(list1)486316639176# 对列表的值进行操作时，值改变但内存地址不变，所以列表是可变数据类型</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-e2cc6a90794d0d79719ff0a898b3c467_720w.jpg" alt="img"></p><p><strong>元组</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; t1 &#x3D; (&quot;tom&quot;,&quot;jack&quot;,[1,2])&gt;&gt;&gt; t1[0]&#x3D;&#39;TOM&#39; # 报错：TypeError&gt;&gt;&gt; t1.append(&#39;lili&#39;) # 报错：TypeError# 元组内的元素无法修改，指的是元组内索引指向的内存地址不能被修改&gt;&gt;&gt; t1 &#x3D; (&quot;tom&quot;,&quot;jack&quot;,[1,2])&gt;&gt;&gt; id(t1[0]),id(t1[1]),id(t1[2])(4327403152, 4327403072, 4327422472)&gt;&gt;&gt; t1[2][0]&#x3D;111 # 如果元组中存在可变类型，是可以修改，但是修改后的内存地址不变&gt;&gt;&gt; t1(&#39;tom&#39;, &#39;jack&#39;, [111, 2])&gt;&gt;&gt; id(t1[0]),id(t1[1]),id(t1[2]) # 查看id仍然不变(4327403152, 4327403072, 4327422472)</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-19bc37e4a9fedf83d1b352a502c49a57_720w.jpg" alt="img"></p><p><strong>字典</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; dic &#x3D; &#123;&#39;name&#39;:&#39;egon&#39;,&#39;sex&#39;:&#39;male&#39;,&#39;age&#39;:18&#125;&gt;&gt;&gt; &gt;&gt;&gt; id(dic)4327423112&gt;&gt;&gt; dic[&#39;age&#39;]&#x3D;19&gt;&gt;&gt; dic&#123;&#39;age&#39;: 19, &#39;sex&#39;: &#39;male&#39;, &#39;name&#39;: &#39;egon&#39;&#125;&gt;&gt;&gt; id(dic)4327423112# 对字典进行操作时，值改变的情况下，字典的id也是不变，即字典也是可变数据类型</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-52e2baab5ad65f3e470166e35bde772a_720w.jpg" alt="img"></p><h2 id="九-数据类型总结"><a href="#九-数据类型总结" class="headerlink" title="九 数据类型总结"></a>九 数据类型总结</h2><p><img src="https://pic4.zhimg.com/80/v2-a20045894184b0a3afad79f0542adbab_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-de70fc0b51f69ade62df5cc235acd493_720w.jpg" alt="img"></p><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>1、数字类型：</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=13">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=13<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>2、字符串类型</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=14">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=14<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=15">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=15<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=16">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=16<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>3、列表类型</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=17">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=17<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=18">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=18<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>4、元组类型</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=19">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=19<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>5、字典类型</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=20">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=20<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=21">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=21<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=22">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=22<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=23">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=23<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>6、集合类型</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=24">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=24<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=25">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=25<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p><p>7、小结</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=26">python快速入门（一）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/av73342471?p=26<img src="https://pic4.zhimg.com/v2-c64ada0dd06d0c57ed905be65d17acb7_180x120.jpg" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>01_Python入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-流程控制</title>
    <link href="/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/07_Python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/07_Python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-引子："><a href="#1-引子：" class="headerlink" title="1 引子："></a>1 引子：</h1><p>流程控制即控制流程，具体指控制程序的执行流程，而程序的执行流程分为三种结构：</p><ul><li>顺序结构（之前我们写的代码都是顺序结构）</li><li>分支结构（用到if判断）</li><li>循环结构（用到while与for）</li></ul><p><img src="https://pic3.zhimg.com/80/v2-1c94b67e61036b4b8029f1ff0e04021e_720w.jpg" alt="img"></p><h1 id="2-分支结构"><a href="#2-分支结构" class="headerlink" title="2 分支结构"></a>2 分支结构</h1><h2 id="2-1-什么是分支结构"><a href="#2-1-什么是分支结构" class="headerlink" title="2.1 什么是分支结构"></a>2.1 什么是分支结构</h2><p>分支结构就是根据条件判断的真假去执行不同分支对应的子代码</p><h2 id="2-2-为什么要用分支结构"><a href="#2-2-为什么要用分支结构" class="headerlink" title="2.2 为什么要用分支结构"></a>2.2 为什么要用分支结构</h2><p>人类某些时候需要根据条件来决定做什么事情，比如：如果今天下雨，就带伞</p><p>所以程序中必须有相应的机制来控制计算机具备人的这种判断能力</p><h2 id="2-3-如何使用分支结构"><a href="#2-3-如何使用分支结构" class="headerlink" title="2.3 如何使用分支结构"></a>2.3 如何使用分支结构</h2><h3 id="2-3-1-if语法"><a href="#2-3-1-if语法" class="headerlink" title="2.3.1 if语法"></a>2.3.1 if语法</h3><p><img src="https://pic3.zhimg.com/80/v2-a75171615cb658ae9bb3db7afabc6846_720w.jpg" alt="img"></p><p>用if关键字来实现分支结构，完整语法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">if 条件1:   # 如果条件1的结果为True，就依次执行：代码1、代码2，......  　代码1    代码2    ......elif 条件2: # 如果条件2的结果为True，就依次执行：代码3、代码4，......  　代码3    代码4    ......elif 条件3: # 如果条件3的结果为True，就依次执行：代码5、代码6，......  　代码5    代码6    ......else:　　   # 其它情况，就依次执行：代码7、代码8，......    代码7    代码8    ......# 注意：# 1、python用相同缩进(4个空格表示一个缩进)来标识一组代码块，同一组代码会自上而下依次运行# 2、条件可以是任意表达式，但执行结果必须为布尔类型     # 在if判断中所有的数据类型也都会自动转换成布尔类型       # 2.1、None，0，空（空字符串，空列表，空字典等）三种情况下转换成的布尔值为False       # 2.2、其余均为True</code></pre></div></figure><h3 id="2-3-2-if应用案例"><a href="#2-3-2-if应用案例" class="headerlink" title="2.3.2 if应用案例"></a>2.3.2 if应用案例</h3><p><img src="https://pic4.zhimg.com/80/v2-0dff1efd05c82779f08db912b84ed5a3_720w.jpg" alt="img"></p><p>案例1：</p><p>如果：女人的年龄&gt;30岁，那么：叫阿姨</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age_of_girl &#x3D; 31if age_of_girl &gt; 30:    print(&quot;阿姨&quot;)</code></pre></div></figure><p>案例2：</p><p>如果：女人的年龄&gt;30岁，那么：叫阿姨，否则：叫小姐姐</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">age_of_girl &#x3D; 29if age_of_girl &gt; 30:    print(&quot;阿姨&quot;)else:    print(&quot;小姐姐&quot;)</code></pre></div></figure><p>案例3：</p><p>如果：女人的年龄&gt;&#x3D;18并且&lt;22岁并且身高&gt;170并且体重&lt;100并且是漂亮的，那么：表白，否则：叫阿姨**</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">age_of_girl&#x3D;18height&#x3D;171weight&#x3D;99is_pretty&#x3D;Trueif age_of_girl &gt;&#x3D; 18 and age_of_girl &lt; 22 and height &gt; 170 and weight &lt; 100 and is_pretty &#x3D;&#x3D; True:    print(&#39;表白...&#39;)else:    print(&#39;阿姨好&#39;)</code></pre></div></figure><p>案例4：</p><p>如果：成绩&gt;&#x3D;90，那么：优秀</p><p>如果成绩&gt;&#x3D;80且&lt;90,那么：良好</p><p>如果成绩&gt;&#x3D;70且&lt;80,那么：普通</p><p>其他情况：很差</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">score&#x3D;input(&#39;&gt;&gt;: &#39;)score&#x3D;int(score)if score &gt;&#x3D; 90:    print(&#39;优秀&#39;)elif score &gt;&#x3D; 80:    print(&#39;良好&#39;)elif score &gt;&#x3D; 70:    print(&#39;普通&#39;)else:    print(&#39;很差&#39;)</code></pre></div></figure><p>案例5：if嵌套</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">#在表白的基础上继续：#如果表白成功，那么：在一起#否则：打印。。。age_of_girl&#x3D;18height&#x3D;171weight&#x3D;99is_pretty&#x3D;Truesuccess&#x3D;Falseif age_of_girl &gt;&#x3D; 18 and age_of_girl &lt; 22 and height &gt; 170 and weight &lt; 100 and is_pretty &#x3D;&#x3D; True:    if success:        print(&#39;表白成功,在一起&#39;)    else:        print(&#39;什么爱情不爱情的,爱nmlgb的爱情,爱nmlg啊...&#39;)else:    print(&#39;阿姨好&#39;)</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-3a90716a58a4458640aee154894b0bd2_720w.jpg" alt="img"></p><p>练习1: 登陆功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">username &#x3D; input(&quot;请输入用户名：&quot;).strip()password &#x3D; input(&quot;请输入用户密码：&quot;).strip()if username &#x3D;&#x3D; &#39;admin&#39; and password &#x3D;&#x3D; &#39;local666&#39;:    print(&quot;老铁，登录成功&quot;)else:    print(&quot;滚蛋，登录失败！&quot;)</code></pre></div></figure><p>练习2：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python#根据用户输入内容打印其权限&#39;&#39;&#39;egon --&gt; 超级管理员tom  --&gt; 普通管理员jack,rain --&gt; 业务主管其他 --&gt; 普通用户&#39;&#39;&#39;name &#x3D; input(&#39;请输入用户名字：&#39;)if name &#x3D;&#x3D; &#39;egon&#39;:    print(&#39;超级管理员&#39;)elif name &#x3D;&#x3D; &#39;tom&#39;:    print(&#39;普通管理员&#39;)elif name &#x3D;&#x3D; &#39;jack&#39; or name &#x3D;&#x3D; &#39;rain&#39;:    print(&#39;业务主管&#39;)else:    print(&#39;普通用户&#39;)</code></pre></div></figure><h1 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3 循环结构"></a>3 循环结构</h1><h2 id="3-1-什么是循环结构"><a href="#3-1-什么是循环结构" class="headerlink" title="3.1 什么是循环结构"></a>3.1 什么是循环结构</h2><p>循环结构就是重复执行某段代码块</p><h2 id="3-2-为什么要用循环结构"><a href="#3-2-为什么要用循环结构" class="headerlink" title="3.2 为什么要用循环结构"></a>3.2 为什么要用循环结构</h2><p><img src="https://pic4.zhimg.com/80/v2-f174b482ecf2583633bd31e3a13f8e8b_720w.jpg" alt="img"></p><p>人类某些时候需要重复做某件事情</p><p>所以程序中必须有相应的机制来控制计算机具备人的这种循环做事的能力</p><h2 id="3-3-如何使用循环结构"><a href="#3-3-如何使用循环结构" class="headerlink" title="3.3 如何使用循环结构"></a>3.3 如何使用循环结构</h2><h3 id="3-3-1-while循环语法"><a href="#3-3-1-while循环语法" class="headerlink" title="3.3.1 while循环语法"></a>3.3.1 while循环语法</h3><p><img src="https://pic4.zhimg.com/80/v2-43c2d731786fa1b75f5e45b55f0cf833_720w.jpg" alt="img"></p><p>python中有while与for两种循环机制，其中while循环称之为条件循环，语法如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">while 条件:     代码1          代码2          代码3while的运行步骤：步骤1：如果条件为真，那么依次执行：代码1、代码2、代码3、......步骤2：执行完毕后再次判断条件,如果条件为True则再次执行：代码1、代码2、代码3、......，如果条件为False,则循环终止</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-6f56fdbd7d92dd2a7ce02573d950136a_720w.jpg" alt="img"></p><h3 id="3-3-2-while循环应用案例"><a href="#3-3-2-while循环应用案例" class="headerlink" title="3.3.2 while循环应用案例"></a>3.3.2 while循环应用案例</h3><p><img src="https://pic4.zhimg.com/80/v2-0dff1efd05c82779f08db912b84ed5a3_720w.jpg" alt="img"></p><p>案例一：while循环的基本使用</p><p>用户认证程序</p><p><img src="https://pic2.zhimg.com/80/v2-72163eb478e754fbfd478839c5cbf845_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#用户认证程序的基本逻辑就是接收用户输入的用户名密码然后与程序中存放的用户名密码进行判断，判断成功则登陆成功，判断失败则输出账号或密码错误username &#x3D; &quot;jason&quot;password &#x3D; &quot;123&quot;inp_name &#x3D;  input(&quot;请输入用户名：&quot;)inp_pwd &#x3D;  input(&quot;请输入密码：&quot;)if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:    print(&quot;登陆成功&quot;)else:    print(&quot;输入的用户名或密码错误！&quot;)#通常认证失败的情况下，会要求用户重新输入用户名和密码进行验证，如果我们想给用户三次试错机会，本质就是将上述代码重复运行三遍，你总不会想着把代码复制3次吧。。。。username &#x3D; &quot;jason&quot;password &#x3D; &quot;123&quot;# 第一次验证inp_name &#x3D;  input(&quot;请输入用户名：&quot;)inp_pwd &#x3D;  input(&quot;请输入密码：&quot;)if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:    print(&quot;登陆成功&quot;)else:    print(&quot;输入的用户名或密码错误！&quot;)# 第二次验证inp_name &#x3D;  input(&quot;请输入用户名：&quot;)inp_pwd &#x3D;  input(&quot;请输入密码：&quot;)if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:    print(&quot;登陆成功&quot;)else:    print(&quot;输入的用户名或密码错误！&quot;)# 第三次验证inp_name &#x3D;  input(&quot;请输入用户名：&quot;)inp_pwd &#x3D;  input(&quot;请输入密码：&quot;)if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:    print(&quot;登陆成功&quot;)else:    print(&quot;输入的用户名或密码错误！&quot;)#即使是小白的你，也觉得的太low了是不是，以后要修改功能还得修改3次，因此记住，写重复的代码是程序员最不耻的行为。#那么如何做到不用写重复代码又能让程序重复一段代码多次呢？ 循环语句就派上用场啦（使用while循环实现）username &#x3D; &quot;jason&quot;password &#x3D; &quot;123&quot;# 记录错误验证的次数count &#x3D; 0while count &lt; 3:    inp_name &#x3D; input(&quot;请输入用户名：&quot;)    inp_pwd &#x3D; input(&quot;请输入密码：&quot;)    if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:        print(&quot;登陆成功&quot;)    else:        print(&quot;输入的用户名或密码错误！&quot;)        count +&#x3D; 1</code></pre></div></figure><p>案例二：while+break的使用</p><p>使用了while循环后，代码确实精简多了，但问题是用户输入正确的用户名密码以后无法结束循环，那如何结束掉一个循环呢？这就需要用到break了！</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">username &#x3D; &quot;jason&quot;password &#x3D; &quot;123&quot;# 记录错误验证的次数count &#x3D; 0while count &lt; 3:    inp_name &#x3D; input(&quot;请输入用户名：&quot;)    inp_pwd &#x3D; input(&quot;请输入密码：&quot;)    if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:        print(&quot;登陆成功&quot;)        break # 用于结束本层循环    else:        print(&quot;输入的用户名或密码错误！&quot;)        count +&#x3D; 1</code></pre></div></figure><p>案例三：while循环嵌套+break</p><p>如果while循环嵌套了很多层，要想退出每一层循环则需要在每一层循环都有一个break</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">username &#x3D; &quot;jason&quot;password &#x3D; &quot;123&quot;count &#x3D; 0while count &lt; 3:  # 第一层循环    inp_name &#x3D; input(&quot;请输入用户名：&quot;)    inp_pwd &#x3D; input(&quot;请输入密码：&quot;)    if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:        print(&quot;登陆成功&quot;)        while True:  # 第二层循环            cmd &#x3D; input(&#39;&gt;&gt;: &#39;)            if cmd &#x3D;&#x3D; &#39;quit&#39;:                break  # 用于结束本层循环，即第二层循环            print(&#39;run &lt;%s&gt;&#39; % cmd)        break  # 用于结束本层循环，即第一层循环    else:        print(&quot;输入的用户名或密码错误！&quot;)        count +&#x3D; 1</code></pre></div></figure><p>案例四：while循环嵌套+tag的使用</p><p>针对嵌套多层的while循环，如果我们的目的很明确就是要在某一层直接退出所有层的循环，其实有一个窍门，就让所有while循环的条件都用同一个变量，该变量的初始值为True，一旦在某一层将该变量的值改成False，则所有层的循环都结束</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">username &#x3D; &quot;jason&quot;password &#x3D; &quot;123&quot;count &#x3D; 0tag &#x3D; Truewhile tag:     inp_name &#x3D; input(&quot;请输入用户名：&quot;)    inp_pwd &#x3D; input(&quot;请输入密码：&quot;)    if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password:        print(&quot;登陆成功&quot;)        while tag:              cmd &#x3D; input(&#39;&gt;&gt;: &#39;)            if cmd &#x3D;&#x3D; &#39;quit&#39;:                tag &#x3D; False  # tag变为False， 所有while循环的条件都变为False                 break            print(&#39;run &lt;%s&gt;&#39; % cmd)        break  # 用于结束本层循环，即第一层循环    else:        print(&quot;输入的用户名或密码错误！&quot;)        count +&#x3D; 1</code></pre></div></figure><p>案例五：while+continue的使用</p><p>break代表结束本层循环，而continue则用于结束本次循环，直接进入下一次循环</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 打印1到10之间，除7以外的所有数字number&#x3D;11while number&gt;1:    number -&#x3D; 1    if number&#x3D;&#x3D;7:        continue # 结束掉本次循环，即本次循环continue之后的代码都不会运行了，而是直接进入下一次循环    print(number)</code></pre></div></figure><p>案例五：while+else的使用</p><p>在while循环的后面，我们可以跟else语句，当while 循环正常执行完并且中间没有被break 中止的话，就会执行else后面的语句，所以我们可以用else来验证，循环是否正常结束</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">count &#x3D; 0while count &lt;&#x3D; 5 :    count +&#x3D; 1    print(&quot;Loop&quot;,count)else:    print(&quot;循环正常执行完啦&quot;)print(&quot;-----out of while loop ------&quot;)输出Loop 1Loop 2Loop 3Loop 4Loop 5Loop 6循环正常执行完啦   #没有被break打断，所以执行了该行代码-----out of while loop ------</code></pre></div></figure><p>如果执行过程中被break，就不会执行else的语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">count &#x3D; 0while count &lt;&#x3D; 5 :    count +&#x3D; 1    if count &#x3D;&#x3D; 3:        break    print(&quot;Loop&quot;,count)else:    print(&quot;循环正常执行完啦&quot;)print(&quot;-----out of while loop ------&quot;)输出Loop 1Loop 2-----out of while loop ------ #由于循环被break打断了，所以不执行else后的输出语句</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-3a90716a58a4458640aee154894b0bd2_720w.jpg" alt="img"></p><p>练习1：</p><p>寻找1到100之间数字7最大的倍数（结果是98）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">number&#x3D;100while number&gt;0:    if number%7&#x3D;&#x3D;0:        print(number)        break    number-&#x3D;1</code></pre></div></figure><p>练习2：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age&#x3D;18count&#x3D;0while count&lt;3:    count+&#x3D;1    guess &#x3D; int(input(&quot;&gt;&gt;:&quot;))    if guess &gt; age :        print(&quot;猜的太大了，往小里试试...&quot;)    elif guess &lt; age :        print(&quot;猜的太小了，往大里试试...&quot;)    else:        print(&quot;恭喜你，猜对了...&quot;)</code></pre></div></figure><h3 id="3-3-3-for循环语法"><a href="#3-3-3-for循环语法" class="headerlink" title="3.3.3 for循环语法"></a>3.3.3 for循环语法</h3><p><img src="https://pic3.zhimg.com/80/v2-3a90716a58a4458640aee154894b0bd2_720w.jpg" alt="img"></p><p>循环结构的第二种实现方式是for循环，for循环可以做的事情while循环都可以实现，之所以用for循环是因为在循环取值（即遍历值）时for循环比while循环的使用更为简洁，</p><p><strong>for循环语法如下</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">for 变量名 in 可迭代对象: # 此时只需知道可迭代对象可以是字符串\列表\字典，我们之后会专门讲解可迭代对象    代码一    代码二    ...#例1for item in [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]:    print(item)# 运行结果abc# 参照例1来介绍for循环的运行步骤# 步骤1：从列表[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]中读出第一个值赋值给item（item&#x3D;‘a’），然后执行循环体代码# 步骤2：从列表[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]中读出第二个值赋值给item（item&#x3D;‘b’），然后执行循环体代码# 步骤3: 重复以上过程直到列表中的值读尽</code></pre></div></figure><p><img src="https://pic1.zhimg.com/80/v2-7d7dc5ae41a09a7cd6e043d75c63b81c_720w.jpg" alt="img"></p><h3 id="3-3-4-for循环应用案例"><a href="#3-3-4-for循环应用案例" class="headerlink" title="3.3.4 for循环应用案例"></a>3.3.4 for循环应用案例</h3><p><img src="https://pic4.zhimg.com/80/v2-0dff1efd05c82779f08db912b84ed5a3_720w.jpg" alt="img"></p><p>案例一：打印数字0-5</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 简单版：for循环的实现方式for count in range(6):  # range(6)会产生从0-5这6个数    print(count)# 复杂版：while循环的实现方式count &#x3D; 0while count &lt; 6:    print(count)    count +&#x3D; 1</code></pre></div></figure><p>案例二：遍历字典</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 简单版：for循环的实现方式for k in &#123;&#39;name&#39;:&#39;jason&#39;,&#39;age&#39;:18,&#39;gender&#39;:&#39;male&#39;&#125;:  # for 循环默认取的是字典的key赋值给变量名k    print(k)# 复杂版：while循环确实可以遍历字典，后续将会迭代器部分详细介绍</code></pre></div></figure><p>案例三：for循环嵌套</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#请用for循环嵌套的方式打印如下图形：***************for i in range(3):    for j in range(5):        print(&quot;*&quot;,end&#x3D;&#39;&#39;)    print()  # print()表示换行</code></pre></div></figure><p>注意：break 与 continue也可以用于for循环，使用语法同while循环</p><p><img src="https://pic3.zhimg.com/80/v2-3a90716a58a4458640aee154894b0bd2_720w.jpg" alt="img"></p><p>练习一：</p><p>打印九九乘法表</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i in range(1,10):    for j in range(1,i+1):        print(&#39;%s*%s&#x3D;%s&#39; %(i,j,i*j),end&#x3D;&#39; &#39;)    print()</code></pre></div></figure><p>练习二：</p><p>打印金字塔</p><p><img src="https://pic3.zhimg.com/80/v2-53598748f490542a9700e63433b79496_720w.jpg" alt="img"></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 分析&#39;&#39;&#39;#max_level&#x3D;5     *        # current_level&#x3D;1，空格数&#x3D;4，*号数&#x3D;1    ***       # current_level&#x3D;2,空格数&#x3D;3,*号数&#x3D;3   *****      # current_level&#x3D;3,空格数&#x3D;2,*号数&#x3D;5  *******     # current_level&#x3D;4,空格数&#x3D;1,*号数&#x3D;7 *********    # current_level&#x3D;5,空格数&#x3D;0,*号数&#x3D;9# 数学表达式空格数&#x3D;max_level-current_level*号数&#x3D;2*current_level-1&#39;&#39;&#39;# 实现：max_level&#x3D;5for current_level in range(1,max_level+1):    for i in range(max_level-current_level):        print(&#39; &#39;,end&#x3D;&#39;&#39;) #在一行中连续打印多个空格    for j in range(2*current_level-1):        print(&#39;*&#39;,end&#x3D;&#39;&#39;) #在一行中连续打印多个空格    print()</code></pre></div></figure><h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>1、if判断</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471/?p=10">https://www.bilibili.com/video/av73342471/?p=10www.bilibili.com/video/av73342471/?p=10</a></p><p>2、while循环</p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=11">https://www.bilibili.com/video/av73342471?p=11www.bilibili.com/video/av73342471?p=11</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>01_Python入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-垃圾回收机制</title>
    <link href="/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/day05-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/day05-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="一-、垃圾回收机制（了解）"><a href="#一-、垃圾回收机制（了解）" class="headerlink" title="一 、垃圾回收机制（了解）"></a>一 、垃圾回收机制（了解）</h1><p>垃圾回收机制（简称GC）是Python解释器自带一种机，专门用来回收不可用的变量值所占用的内存空间</p><h2 id="1-1-垃圾回收机制介绍"><a href="#1-1-垃圾回收机制介绍" class="headerlink" title="1.1 垃圾回收机制介绍"></a>1.1 垃圾回收机制介绍</h2><h3 id="1-1-1-什么是垃圾？"><a href="#1-1-1-什么是垃圾？" class="headerlink" title="1.1.1 什么是垃圾？"></a>1.1.1 什么是垃圾？</h3><ul><li>解释器：执行到定义变量的语句 –&gt; 申请内存空间来存放变量的值 </li><li>内存的容量是有限的</li><li>当一个变量值没有用了（简称垃圾）就应该将其占用的内存给回收掉。</li></ul><p>怎么判断变量值没有用了？</p><ul><li><p>单从逻辑层面分析，我们定义变量将变量值存起来的目的是为了以后取出来使用，而取得变量值需要通过其绑定的<code>直接引用</code>或<code>间接引用</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x&#x3D;10 # 值10被x直接引用mylist&#x3D;[x,]# 值10被容器mylist间接引用</code></pre></div></figure></li><li><p>所以当一个变量值<code>不再绑定任何引用</code>时，我们就无法再访问到该变量值了，该变量值自然就是没有用的，就应该被当成一个垃圾回收。</p></li></ul><p>毫无疑问，内存空间的申请与回收都是非常耗费精力的事情，而且存在很大的危险性，稍有不慎就有可能引发<code>内存溢出</code>问题，好在<code>CPython解释器</code>提供了<code>自动垃圾回收机制</code>来帮我们解决了这件事。</p><h3 id="1-1-2-为什么要用垃圾回收机制？"><a href="#1-1-2-为什么要用垃圾回收机制？" class="headerlink" title="1.1.2 为什么要用垃圾回收机制？"></a>1.1.2 为什么要用垃圾回收机制？</h3><p>程序运行过程中会申请大量的内存空间，而对于一些无用的内存空间如果不及时清理的话会导致内存使用殆尽（内存溢出），导致程序崩溃，因此管理内存是一件重要且繁杂的事情，而python解释器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来。</p><h3 id="1-1-3-垃圾回收机制原理分析"><a href="#1-1-3-垃圾回收机制原理分析" class="headerlink" title="1.1.3 垃圾回收机制原理分析"></a>1.1.3 垃圾回收机制原理分析</h3><p>Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，并且通过“分代回收”（generation collection）以空间换取时间的方式来进一步提高垃圾回收的效率。</p><h2 id="1-2-引用计数"><a href="#1-2-引用计数" class="headerlink" title="1.2 引用计数"></a>1.2 引用计数</h2><h3 id="1-2-1-什么是引用计数"><a href="#1-2-1-什么是引用计数" class="headerlink" title="1.2.1 什么是引用计数"></a>1.2.1 什么是引用计数</h3><p>引用计数就是：变量值被变量名关联的次数</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age &#x3D; 18# 变量age --&gt; 值18的内存地址 --- 引用计数为1</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-89915f2dc64db1fe79ce739a233bb09a_720w.jpg" alt="img"></p><p>引用计数增加：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age&#x3D;18  # 此时，值18的引用计数为1m&#x3D;age # 变量m也记录了值18的内存地址，所以值18的引用计数为2</code></pre></div></figure><p><img src="https://pic4.zhimg.com/80/v2-8a46e8993c193017bbbbca370ce6970b_720w.jpg" alt="img"></p><p>引用计数减少：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age&#x3D;10 # 变量age先与值18解除关联，再与值10建立了关联，变量值18的引用计数为1del m# del的意思是解除变量名x与变量值18的关联关系，此时，值18的引用计数为0</code></pre></div></figure><p><img src="https://pic3.zhimg.com/80/v2-6d0ed3fa462194215235ae22888b373a_720w.jpg" alt="img"></p><p>值18的引用计数一旦变为0，其占用的内存地址就应该被解释器的垃圾回收机制回收</p><h3 id="1-2-2-直接引用和间接引用"><a href="#1-2-2-直接引用和间接引用" class="headerlink" title="1.2.2 直接引用和间接引用"></a>1.2.2 直接引用和间接引用</h3><p>除了有引用计数，还有直接引用与间件引用的概念，我通过一个例子来分析</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; 18 # 直接引用，变量x记录了值18的内存地址，值18的引用计数为1mylist &#x3D; [1,x] # 间接引用，列表mylist间件记录了值18的内存地址，值18的引用计数为2x &#x3D; 200print(mylist[1]) # 输出18还是200？答案还是输出18！像这种情况我们可以称值18是被mylist间件引用</code></pre></div></figure><p>这里又涉及到一个问题，即<strong>列表在内存中的存储方式</strong>，可以参考其它文章学习</p><h3 id="1-2-3-引用计数带来的循环引用问题"><a href="#1-2-3-引用计数带来的循环引用问题" class="headerlink" title="1.2.3 引用计数带来的循环引用问题"></a>1.2.3 引用计数带来的循环引用问题</h3><p>引用计数机制还存在着一个致命的弱点，即循环引用（也称交叉引用）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 如下我们定义了两个列表，简称列表1与列表2，变量名l1指向列表1，变量名l2指向列表2&gt;&gt;&gt; l1&#x3D;[&#39;xxx&#39;]  # 列表1被引用一次，列表1的引用计数变为1   &gt;&gt;&gt; l2&#x3D;[&#39;yyy&#39;]  # 列表2被引用一次，列表2的引用计数变为1   &gt;&gt;&gt; l1.append(l2)             # 把列表2追加到l1中作为第二个元素，列表2的引用计数变为2&gt;&gt;&gt; l2.append(l1)             # 把列表1追加到l2中作为第二个元素，列表1的引用计数变为2# l1与l2之间有相互引用# l1 &#x3D; [&#39;xxx&#39;的内存地址,列表2的内存地址]# l2 &#x3D; [&#39;yyy&#39;的内存地址,列表1的内存地址]&gt;&gt;&gt; l1[&#39;xxx&#39;, [&#39;yyy&#39;, [...]]]&gt;&gt;&gt; l2[&#39;yyy&#39;, [&#39;xxx&#39;, [...]]]&gt;&gt;&gt; l1[1][1][0]&#39;xxx&#39;</code></pre></div></figure><p>循环引用会导致：值不再被任何名字关联，但是值的引用计数并不会为0，<font color=red>应该被回收但不能被回收</font>，什么意思呢？试想一下，请看如下操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; del l1 # 列表1的引用计数减1，列表1的引用计数变为1&gt;&gt;&gt; del l2 # 列表2的引用计数减1，列表2的引用计数变为1</code></pre></div></figure><p>此时，只剩下列表1与列表2之间的相互引用，两个列表的引用计数均不为0，但两个列表不再被任何其他对象关联，没有任何人可以再引用到它们，所以它俩占用内存空间应该被回收，但由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放，所以循环引用是致命的，这与手动进行内存管理所产生的内存泄露毫无区别。 所以Python引入了<code>标记-清除</code> 与<code>分代回收</code>来分别解决引用计数的循环引用与效率低的问题</p><h3 id="1-2-4-克服问题：标记-清除"><a href="#1-2-4-克服问题：标记-清除" class="headerlink" title="1.2.4 克服问题：标记&#x2F;清除"></a>1.2.4 克服问题：标记&#x2F;清除</h3><p><em>“标记-清除”机制用来解决循环引用的问题</em></p><p>在了解标记清除算法前，我们需要明确一点，关于变量的存储，内存中有两块区域：<code>堆区</code>与<code>栈区</code>，在定义变</p><p>量时，变量名与值内存地址的关联关系存放于栈区，变量值存放于堆区，内存管理回收的则是堆区的内容，详解如下图,</p><p>定义了两个变量x &#x3D; 10、y &#x3D; 20</p><p><img src="https://pic1.zhimg.com/80/v2-73d5845ef7dc5a403333d2099d456fc0_720w.jpg" alt="img"></p><p>当我们执行x&#x3D;y时，内存中的栈区与堆区变化如下</p><p><img src="https://pic1.zhimg.com/80/v2-9ec5b20fd2c2d2e9c90194d57bcf7778_720w.jpg" alt="img"></p><p>标记&#x2F;清除算法的做法是当应用程序可用的内存空间被耗尽的时，就会停止整个程序，然后进行两项工作，第一项</p><p>则是标记，第二项则是清除。</p><blockquote><p><strong>标记：</strong></p><p>遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），然后将所有GC Roots的对象</p><p>可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。</p><p>通俗的讲就是：遍历一遍这条路，如果不通，说明是非存活的，需要清除</p><p><strong>清除：</strong></p><p>清除的过程将遍历堆中所有的对象，将没有标记存活的对象全部清除掉。</p></blockquote><p>用<code>1.2.3的例子</code>来分析运作流程：</p><p>直接引用指的是从栈区出发直接引用到的内存地址，间接引用指的是从栈区出发引用到堆区后再进一步引用到的内</p><p>存地址，以我们之前的两个列表l1与l2为例画出如下图像</p><p><img src="https://pic3.zhimg.com/80/v2-1bfee07a84fc747da5980d990430d10a_720w.jpg" alt="img"></p><p>当我们同时删除l1与l2时，会清理到栈区中l1与l2的内容</p><p><img src="https://pic2.zhimg.com/80/v2-509de2bd1adfb0566368719c73620fbd_720w.jpg" alt="img"></p><p>这样在启用标记清除算法时，发现栈区内不再有l1与l2（只剩下堆区内二者的相互引用），于是列表1与列表2都没有被标记为存活，二者会被清理掉，这样就解决了循环引用带来的内存泄漏问题。</p><h3 id="1-2-5-克服问题：分代回收"><a href="#1-2-5-克服问题：分代回收" class="headerlink" title="1.2.5 克服问题：分代回收"></a>1.2.5 克服问题：分代回收</h3><p>分代回收机制用来<code>解决引用计数效率慢</code>的问题</p><p>基于引用计数的回收机制，每次回收内存，都需要把所有对象的引用计数都遍历一遍，这是非常消耗时间的，于是引入了分代回收来提高回收效率，分代回收采用的是用“空间换时间”的策略。</p><p><strong>分代：</strong></p><p>分代回收的核心思想是：在历经多次扫描的情况下，都没有被回收的变量，gc机制就会认为，该变量是常用变量，gc对其扫描的频率会降低，具体实现原理如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低</code></pre></div></figure><p><strong>回收：</strong></p><p>回收依然是使用引用计数作为回收的依据</p><p><img src="https://pic1.zhimg.com/80/v2-2458685b385b338192d6b90628ed92a8_720w.jpg" alt="img"></p><p>虽然分代回收可以起到提升效率的效果，但也存在一定的缺点：</p><p>例如一个变量刚刚从新生代移入青春代，该变量的绑定关系就解除了，该变量应该被回收，但青春代的扫描频率低</p><p>于新生代，</p><h1 id="二、用户交互"><a href="#二、用户交互" class="headerlink" title="二、用户交互"></a>二、用户交互</h1><h2 id="2-1-输入"><a href="#2-1-输入" class="headerlink" title="2.1 输入"></a>2.1 输入</h2><p>计算机接收用户的输入，案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; username &#x3D; input(&#39;请输入用户名: &#39;)请输入用户名: Goosh&gt;&gt;&gt; print(username, type(username))Goosh &lt;class &#39;str&#39;&gt;</code></pre></div></figure><p>注意：input会将用户输入的所有内容都存储成字符串类型</p><p>如果需要当作其它类型使用，可以使用<code>类型转换</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; num &#x3D; input(&#39;请输入数字:  &#39;)请输入数字:  80&gt;&gt;&gt; 20 &gt; int(num)# 使用int()将字符串转换为整型False</code></pre></div></figure><blockquote><p>补充：</p><p>Python2和Python3在这里有不同：</p><p>Python3：</p><ul><li>input()输入都存储成字符串类型</li></ul><p>Python2：</p><ul><li>raw_input() 输入都存储成字符串类型</li><li>input()输入的是什么类型，存储就是什么类型（自动判断）</li></ul></blockquote><h2 id="2-2-输出"><a href="#2-2-输出" class="headerlink" title="2.2 输出"></a>2.2 输出</h2><p>格式化输出字符串分为4种方式</p><ul><li>%号</li><li>str.format（推荐）</li><li>f-String（兴趣了解）</li><li>标准库模板（兴趣了解）</li></ul><h3 id="2-2-1-号方式"><a href="#2-2-1-号方式" class="headerlink" title="2.2.1 %号方式"></a>2.2.1 %号方式</h3><p>从python诞生之初就有，官方未弃用这种方式，但是并不推荐使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 普通方式传入：传入的值与s%必须位置对应name &#x3D; &#39;Goosh&#39;age &#x3D; 60print(&#39;My name is %s, age is %s&#39; % (name, age))# 字典方式传入：不需位置对应print(&#39;My name is %(name)s, age is %(age)s&#39; % &#123;&#39;age&#39;:28, &#39;name&#39;:&#39;Goosh&#39;&#125;)</code></pre></div></figure><h3 id="2-2-2-str-format方式"><a href="#2-2-2-str-format方式" class="headerlink" title="2.2.2 str.format方式"></a>2.2.2 str.format方式</h3><p>在Python2.6种引入，是字符串类型的内置方法，该方法在性能和使用灵活性上都优于s%，推荐使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 使用位置参数print(&#39;&#123;&#125; asked &#123;&#125; to do something&#39;.format(&#39;Rick&#39;, &#39;Mody&#39;))# 输出：Rick asked Mody to do something# 使用索引对应位置的值print(&#39;&#123;0&#125;-&#123;0&#125;-&#123;1&#125;-&#123;0&#125;&#39;.format(&#39;x&#39;, &#39;y&#39;))# 输出：x-x-y-x# 使用关键字参数print(&#39;My name is &#123;name&#125;, age is &#123;age&#125;&#39;.format(name&#x3D;&#39;Rick&#39;, age&#x3D;18))# 输出：My name is Rick, age is 18# 填充与格式化print(&#39;&#123;0:*&lt;10&#125;&#39;.format(&#39;开始执行&#39;))  # 左对齐，不足10个字符用*不全print(&#39;&#123;0:*&gt;10&#125;&#39;.format(&#39;开始执行&#39;))  # 右对齐，不足10个字符用*不全print(&#39;&#123;0:*^10&#125;&#39;.format(&#39;开始执行&#39;))  # 居中，不足10个字符用*不全&#39;&#39;&#39;输出：开始执行************开始执行***开始执行***&#39;&#39;&#39;# 精度与进制转换print(&#39;&#123;salary:.3f&#125;&#39;.format(salary&#x3D;123.456789))  # 保留3位小数print(&#39;&#123;0:b&#125;&#39;.format(123))  # 将123转换为2进制print(&#39;&#123;0:o&#125;&#39;.format(123))  # 将123转换为8进制print(&#39;&#123;0:x&#125;&#39;.format(123))  # 将123转换为16进制print(&#39;&#123;0:,&#125;&#39;.format(998998998998))  # 千分位显示&#39;&#39;&#39;输出123.45711110111737b998,998,998,998&#39;&#39;&#39;</code></pre></div></figure><h1 id="三、基本运算符"><a href="#三、基本运算符" class="headerlink" title="三、基本运算符"></a>三、基本运算符</h1><h2 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h2><p> python支持的算数运算符与数学上计算的符号使用是一致的，我们以x&#x3D;9，y&#x3D;2为例来依次介绍它们</p><p><img src="https://pic3.zhimg.com/80/v2-1e691dd00888ffbc6a6a91fd6b871fb2_720w.jpg" alt="img"></p><h2 id="3-2-比较运算符"><a href="#3-2-比较运算符" class="headerlink" title="3.2 比较运算符"></a>3.2 比较运算符</h2><p> 比较运算用来对两个值进行比较，返回的是布尔值True或False，我们以x&#x3D;9，y&#x3D;2为例来依次介绍它们</p><p><img src="https://pic2.zhimg.com/80/v2-4f35183b1ef049ae8e0dff21aa18bd35_720w.jpg" alt="img"></p><h2 id="3-3-赋值运算符"><a href="#3-3-赋值运算符" class="headerlink" title="3.3 赋值运算符"></a>3.3 赋值运算符</h2><p> python语法中除了有&#x3D;号这种简单的赋值运算外，还支持增量赋值、链式赋值、交叉赋值、解压赋值，这些赋值运算符存在的意义都是为了让我们的代码看起来更加精简。我们以x&#x3D;9，y&#x3D;2为例先来介绍一下增量赋值</p><h3 id="3-3-1-增量赋值"><a href="#3-3-1-增量赋值" class="headerlink" title="3.3.1 增量赋值"></a>3.3.1 增量赋值</h3><p><img src="https://pic4.zhimg.com/80/v2-b70005b039398a63c6e28fe7d31ab147_720w.jpg" alt="img"></p><h3 id="3-3-2-链式赋值"><a href="#3-3-2-链式赋值" class="headerlink" title="3.3.2 链式赋值"></a>3.3.2 链式赋值</h3><p>如果我们想把同一个值同时赋值给多个变量名，可以这么做</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; z&#x3D;10&gt;&gt;&gt; y&#x3D;z&gt;&gt;&gt; x&#x3D;y&gt;&gt;&gt; x,y,z(10, 10, 10)</code></pre></div></figure><p>链式赋值指的是可以用一行代码搞定这件事</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x&#x3D;y&#x3D;z&#x3D;10&gt;&gt;&gt; x,y,z(10, 10, 10)</code></pre></div></figure><h3 id="3-3-3-交叉赋值"><a href="#3-3-3-交叉赋值" class="headerlink" title="3.3.3 交叉赋值"></a>3.3.3 交叉赋值</h3><p>我们定义两个变量m与n</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; m&#x3D;10&gt;&gt;&gt; n&#x3D;20</code></pre></div></figure><p>如果我们想将m与n的值交换过来，可以这么做</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; temp&#x3D;m&gt;&gt;&gt; m&#x3D;n&gt;&gt;&gt; n&#x3D;temp&gt;&gt;&gt; m,n(20, 10)</code></pre></div></figure><p>交叉赋值指的是一行代码可以搞定这件事</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; m&#x3D;10&gt;&gt;&gt; n&#x3D;20&gt;&gt;&gt; m,n&#x3D;n,m # 交叉赋值&gt;&gt;&gt; m,n(20, 10)</code></pre></div></figure><h3 id="3-3-4-解压赋值"><a href="#3-3-4-解压赋值" class="headerlink" title="3.3.4 解压赋值"></a>3.3.4 解压赋值</h3><p>如果我们想把列表中的多个值取出来依次赋值给多个变量名，可以这么做</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; nums&#x3D;[11,22,33,44,55]&gt;&gt;&gt; &gt;&gt;&gt; a&#x3D;nums[0]&gt;&gt;&gt; b&#x3D;nums[1]&gt;&gt;&gt; c&#x3D;nums[2]&gt;&gt;&gt; d&#x3D;nums[3]&gt;&gt;&gt; e&#x3D;nums[4]&gt;&gt;&gt; a,b,c,d,e(11, 22, 33, 44, 55)</code></pre></div></figure><p>解压赋值指的是一行代码可以搞定这件事</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; a,b,c,d,e&#x3D;nums # nums包含多个值，就好比一个压缩包，解压赋值因此得名&gt;&gt;&gt; a,b,c,d,e(11, 22, 33, 44, 55)</code></pre></div></figure><p>注意，上述解压赋值，等号左边的变量名个数必须与右面包含值的个数相同,否则会报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、变量名少了&gt;&gt;&gt; a,b&#x3D;numsTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: too many values to unpack (expected 2)#2、变量名多了&gt;&gt;&gt; a,b,c,d,e,f&#x3D;numsTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: not enough values to unpack (expected 6, got 5)</code></pre></div></figure><p>但如果我们只想取头尾的几个值，可以用*_匹配</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; a,b,*_&#x3D;nums&gt;&gt;&gt; a,b(11, 22)</code></pre></div></figure><p>ps：字符串、字典、元组、集合类型都支持解压赋值</p><h2 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h2><p> 逻辑运算符用于连接多个条件，进行关联判断，会返回布尔值True或False</p><p><img src="https://pic2.zhimg.com/80/v2-e4c3abe3eeb2546d6d093f1e5d690055_720w.jpg" alt="img"></p><h3 id="3-4-1-连续多个and"><a href="#3-4-1-连续多个and" class="headerlink" title="3.4.1 连续多个and"></a>3.4.1 连续多个and</h3><p>可以用and连接多个条件，会按照从左到右的顺序依次判断，一旦某一个条件为False，则无需再往右判断，可以立即判定最终结果就为False，只有在所有条件的结果都为True的情况下，最终结果才为True。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 2 &gt; 1 and 1 !&#x3D; 1 and True and 3 &gt; 2 # 判断完第二个条件，就立即结束，得的最终结果为FalseFalse</code></pre></div></figure><h3 id="3-4-2-连续多个or"><a href="#3-4-2-连续多个or" class="headerlink" title="3.4.2 连续多个or"></a>3.4.2 连续多个or</h3><p>可以用or连接多个条件，会按照从左到右的顺序依次判断，一旦某一个条件为True，则无需再往右判断，可以立即判定最终结果就为True，只有在所有条件的结果都为False的情况下，最终结果才为False</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 2 &gt; 1 or 1 !&#x3D; 1 or True or 3 &gt; 2 # 判断完第一个条件，就立即结束，得的最终结果为TrueTrue</code></pre></div></figure><h3 id="3-4-3-优先级not-and-or"><a href="#3-4-3-优先级not-and-or" class="headerlink" title="3.4.3 优先级not&gt;and&gt;or"></a>3.4.3 优先级not&gt;and&gt;or</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、三者的优先级关系：not&gt;and&gt;or，同一优先级默认从左往右计算。&gt;&gt;&gt; 3&gt;4 and 4&gt;3 or 1&#x3D;&#x3D;3 and &#39;x&#39; &#x3D;&#x3D; &#39;x&#39; or 3 &gt;3False#2、最好使用括号来区别优先级，其实意义与上面的一样&#39;&#39;&#39;原理为：(1) not的优先级最高，就是把紧跟其后的那个条件结果取反，所以not与紧跟其后的条件不可分割(2) 如果语句中全部是用and连接，或者全部用or连接，那么按照从左到右的顺序依次计算即可(3) 如果语句中既有and也有or，那么先用括号把and的左右两个条件给括起来，然后再进行运算&#39;&#39;&#39;&gt;&gt;&gt; (3&gt;4 and 4&gt;3) or (1&#x3D;&#x3D;3 and &#39;x&#39; &#x3D;&#x3D; &#39;x&#39;) or 3 &gt;3False #3、短路运算：逻辑运算的结果一旦可以确定，那么就以当前处计算到的值作为最终结果返回&gt;&gt;&gt; 10 and 0 or &#39;&#39; and 0 or &#39;abc&#39; or &#39;egon&#39; &#x3D;&#x3D; &#39;dsb&#39; and 333 or 10 &gt; 4我们用括号来明确一下优先级&gt;&gt;&gt; (10 and 0) or (&#39;&#39; and 0) or &#39;abc&#39; or (&#39;egon&#39; &#x3D;&#x3D; &#39;dsb&#39; and 333) or 10 &gt; 4短路：       0      &#39;&#39;            &#39;abc&#39;                                假     假              真返回：                            &#39;abc&#39;#4、短路运算面试题：&gt;&gt;&gt; 1 or 31&gt;&gt;&gt; 1 and 33&gt;&gt;&gt; 0 and 2 and 10&gt;&gt;&gt; 0 and 2 or 11&gt;&gt;&gt; 0 and 2 or 1 or 41&gt;&gt;&gt; 0 or False and 1False </code></pre></div></figure><h2 id="3-5-成员运算符"><a href="#3-5-成员运算符" class="headerlink" title="3.5 成员运算符"></a>3.5 成员运算符</h2><p><img src="https://pic1.zhimg.com/80/v2-beecc7750f15f6600edce6b64ee41c18_720w.jpg" alt="img"></p><p>注意：虽然下述两种判断可以达到相同的效果，但我们推荐使用第二种格式，因为not in语义更加明确</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; not &#39;lili&#39; in [&#39;jack&#39;,&#39;tom&#39;,&#39;robin&#39;]True&gt;&gt;&gt; &#39;lili&#39; not in [&#39;jack&#39;,&#39;tom&#39;,&#39;robin&#39;]True</code></pre></div></figure><h2 id="3-6-身份运算符"><a href="#3-6-身份运算符" class="headerlink" title="3.6 身份运算符"></a>3.6 身份运算符</h2><p><img src="https://pic3.zhimg.com/80/v2-7a653e8151847e64a6b97d6488e51766_720w.jpg" alt="img"></p><p>需要强调的是：&#x3D;&#x3D;双等号比较的是value是否相等，而is比较的是id是否相等</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1. id相同，内存地址必定相同，意味着type和value必定相同#2. value相同type肯定相同，但id可能不同,如下&gt;&gt;&gt; x&#x3D;&#39;Info Tony:18&#39;&gt;&gt;&gt; y&#x3D;&#39;Info Tony:18&#39;&gt;&gt;&gt; id(x),id(y) # x与y的id不同，但是二者的值相同(4327422640, 4327422256)&gt;&gt;&gt; x &#x3D;&#x3D; y # 等号比较的是valueTrue&gt;&gt;&gt; type(x),type(y) # 值相同type肯定相同(&lt;class &#39;str&#39;&gt;, &lt;class &#39;str&#39;&gt;)&gt;&gt;&gt; x is y # is比较的是id，x与y的值相等但id可以不同False</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>01_Python入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-变量</title>
    <link href="/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/day04%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/07/18/03_Python/01_Python%E5%85%A5%E9%97%A8/day04%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>day04 Python变量与数据结构</p><h1 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h1><h2 id="1-1-注释的作用"><a href="#1-1-注释的作用" class="headerlink" title="1.1 注释的作用"></a>1.1 注释的作用</h2><p>没有注释的代码，不明白函数的功能，一眼懵 </p><p><img src="/../../../img/image-20220912101125598.png" alt="image-20220912101125598"></p><p>添加注释的代码，条理清晰</p><p><img src="/../../../img/image-20220912101214755.png" alt="image-20220912101214755"></p><blockquote><p>这就是注释的作用，能够大大增强程序的可读性。</p></blockquote><h2 id="1-2-注释的分类及语法"><a href="#1-2-注释的分类及语法" class="headerlink" title="1.2 注释的分类及语法"></a>1.2 注释的分类及语法</h2><p>注释分为两类：<code>单行注释</code>和<code>多行注释</code></p><ul><li>单行注释，只能注释一行内容，语法如下：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 注释内容一# 注释内容二</code></pre></div></figure><ul><li>多行注释，可以注释多行内容，一般用在注释一段代码的情况， 语法如下：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;第一行注释第二行注释第三行注释&quot;&quot;&quot;&#39;&#39;&#39;注释1注释2注释3&#39;&#39;&#39;</code></pre></div></figure><blockquote><p>PyCharm快捷键：<code>ctrl + /</code></p></blockquote><p>案例如下：</p><ul><li>单行注释</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 输出hello worldprint(&#39;hello world&#39;)print(&#39;hello Python&#39;)  # 输出(简单的说明可以放到一行代码的后面，一般习惯代码后面添加两个空格再书写注释文字)</code></pre></div></figure><ul><li>多行注释</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;    下面三行都是输出的作用，输出内容分别是：    hello Python    hello itcast    hello itheima&quot;&quot;&quot;print(&#39;hello Python&#39;)print(&#39;hello itcast&#39;)print(&#39;hello itheima&#39;)&#39;&#39;&#39;    下面三行都是输出的作用，输出内容分别是：    hello Python    hello itcast    hello itheima&#39;&#39;&#39;print(&#39;hello Python&#39;)print(&#39;hello itcast&#39;)print(&#39;hello itheima&#39;)</code></pre></div></figure><blockquote><p>注意：解释器不执行任何的注释内容。</p></blockquote><h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><h2 id="2-1-什么是变量？"><a href="#2-1-什么是变量？" class="headerlink" title="2.1 什么是变量？"></a>2.1 什么是变量？</h2><p>相对于内存而言：</p><ul><li>变量就是存储数据的的时候，当前数据所在的<code>内存地址的名字</code>而已。</li></ul><p>对于程序而言：</p><ul><li>数据都是临时存储在内存中，为了更快速的查找或使用这个数据，通常我们把这个数据在内存中存储之后定义一个名称，这个名称就是变量。</li></ul><p>就例如：</p><p>图书馆中的<code>书（数据）</code>都有一个对应的<code>编号（内存地址）</code>，而<code>变量</code>就是给这个<code>编号</code>起的一个<code>别名</code></p><p><img src="/../../../img/image-20220912095405076.png" alt="image-20220912095405076"></p><h2 id="2-2-使用变量"><a href="#2-2-使用变量" class="headerlink" title="2.2 使用变量"></a>2.2 使用变量</h2><h3 id="2-2-1-变量的定义与使用"><a href="#2-2-1-变量的定义与使用" class="headerlink" title="2.2.1 变量的定义与使用"></a>2.2.1 变量的定义与使用</h3><p>变量的定义由三部分组成，如下图</p><p><img src="/../../../img/image-20220718091017221.png" alt="image-20220718091017221"></p><p>定义变量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">name &#x3D; &#39;Jason&#39; # 记下人的名字为&#39;Jason&#39;sex &#x3D; &#39;男&#39;    # 记下人的性别为男性age &#x3D; 18      # 记下人的年龄为18岁salary &#x3D; 30000.1  # 记下人的薪资为30000.1元</code></pre></div></figure><p>使用变量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过变量名即可引用到值，我们可以结合print()功能将其打印出来print(age) # 通过变量名age找到值18，然后执行print(18),输出：18</code></pre></div></figure><h3 id="2-2-2-变量的内存管理"><a href="#2-2-2-变量的内存管理" class="headerlink" title="2.2.2 变量的内存管理"></a>2.2.2 变量的内存管理</h3><p>变量的内存管理 — 垃圾回收机制</p><p>什么是垃圾呢？当一个变量值被当值的变量名的个数为0时，该变量无法被访问，被称为垃圾</p><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 引用计数增加x&#x3D;10# 值10的引用计数为1y&#x3D;x# 值10的引用计数为2z&#x3D;x# 值10的引用计数为2# 引用计数减少del x# 解除变量名x和值10的绑定关系，值10的引用计数减为2del y# 解除变量名y和值10的绑定关系，值10的引用计数减为1print(z)# 可以正常输出10# 重新绑定z&#x3D;12345# 解除变量名z与值10的绑定关系，重新与值12345绑定，值10的引用计数减为0，会当作垃圾回收</code></pre></div></figure><blockquote><p>补充：</p><p>ID不同，值可能相同，也可能不相同</p><p>ID相同，值一定相同</p></blockquote><h3 id="2-2-3-变量名的命名规范"><a href="#2-2-3-变量名的命名规范" class="headerlink" title="2.2.3 变量名的命名规范"></a>2.2.3 变量名的命名规范</h3><p>一个原则，见名知意：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 如果我们要存储的数据18代表的是一个人的年龄，那么变量名推荐命名为ageage &#x3D; 18 # 如果我们要存储的数据18代表的是一个人的等级，那么变量名推荐命名为levellevel &#x3D; 18</code></pre></div></figure><p>四个规范：</p><ul><li><p>由数字、字母、下划线组成</p></li><li><p>不能数字开头</p></li><li><p>不能使用内置关键字</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 常见的内置关键字[&#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;exec&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;,&#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;print&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></pre></div></figure></li><li><p>严格区分大小写</p></li></ul><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 错误示范如下：*a&#x3D;123$b&#x3D;456c$&#x3D;7892_name&#x3D;&#39;lili&#39;123&#x3D;&#39;lili&#39;and&#x3D;123年龄&#x3D;18 # 强烈建议不要使用中文命名# 正确示范如下age_of_jason&#x3D;31page1&#x3D;&#39;首页&#39;_class&#x3D;&#39;终极一班&#39;</code></pre></div></figure><h3 id="2-2-4-变量名的命名风格"><a href="#2-2-4-变量名的命名风格" class="headerlink" title="2.2.4 变量名的命名风格"></a>2.2.4 变量名的命名风格</h3><ul><li>见名知义</li><li>大驼峰：即每个单词首字母都大写，例如：<code>MyName</code></li><li>小驼峰：第二个（含）以后的单词首字母大写，例如：<code>myName</code></li><li>下划线：例如：<code>my_name</code>（多用于：变量名）</li></ul><h3 id="1-2-4-变量值的三大特征"><a href="#1-2-4-变量值的三大特征" class="headerlink" title="1.2.4 变量值的三大特征"></a>1.2.4 变量值的三大特征</h3><ul><li>ID：变量在内存中的唯一编号，内存地址不同id肯定不同</li><li>Type：变量值的类型</li><li>Value：变量值</li></ul><p>案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x&#x3D;&#39;Info Tony:18&#39;# 分别查看ID、Type和Value&gt;&gt;&gt; id(x),type(x),x4376607152，&lt;class &#39;str&#39;&gt;,&#39;Info Tony:18&#39;</code></pre></div></figure><h2 id="2-3-is与-运算"><a href="#2-3-is与-运算" class="headerlink" title="2.3 is与&#x3D;&#x3D;运算"></a>2.3 is与&#x3D;&#x3D;运算</h2><p>在Python中<code>is</code>与<code>==</code>的区别是什么？</p><p>is：比较左右两个变量的ID是否相等</p><p>&#x3D;&#x3D;：比较左右两个变量的Value是否相等</p><p>案例:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义两个Value相同的变量&gt;&gt;&gt; x &#x3D; 888# id 2255586515312&gt;&gt;&gt; y &#x3D; 888# id 2255586518896# 用“&#x3D;&#x3D;”判断Value是否相等&gt;&gt;&gt; print(x&#x3D;&#x3D;y)True# 用&quot;is&quot;判断ID是否相等&gt;&gt;&gt; z &#x3D; x&gt;&gt;&gt; print(x is y)False&gt;&gt;&gt; print(x is z)True</code></pre></div></figure><h2 id="2-4-小整数池"><a href="#2-4-小整数池" class="headerlink" title="2.4 小整数池"></a>2.4 小整数池</h2><p>前面不是说重新定义变量，会重新分配内存空间吗，为什么像如下的情况，变量<code>p的ID</code>和<code>o的ID</code>是一样的?</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; o &#x3D; 10&gt;&gt;&gt; p &#x3D; 10&gt;&gt;&gt; id(o)2255585477136&gt;&gt;&gt; id(p)2255585477136</code></pre></div></figure><p>因为Python解释器从启动的那一刻开始，就会在内存中<code>事先申请</code>一系列内存空间，<code>存放常用的整数</code>，以节省内存空间提高效率，可见如下案例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; q &#x3D; 4&gt;&gt;&gt; w &#x3D; 6&gt;&gt;&gt; id(q)2255585476944&gt;&gt;&gt; id(w)2255585477008# 经历加法后，id变成一样&gt;&gt;&gt; e &#x3D; q + 6&gt;&gt;&gt; r &#x3D; w + 4&gt;&gt;&gt; id(e)2255585477136&gt;&gt;&gt; id(r)2255585477136</code></pre></div></figure><blockquote><p>以上实验在CMD中运行，在PyCharm中会进一步优化，结果可能不同</p></blockquote><h2 id="2-4-常量"><a href="#2-4-常量" class="headerlink" title="2.4 常量"></a>2.4 常量</h2><p>在程序运行过程中，有些值是固定的、不应该被改变，比如圆周率 3.141592653…</p><p>常量就是指像PI这种在程序运行过程中不会改变的量</p><p>在Python中没有一个专门的语法定义常量，约定俗成是用<code>全部大写的变量名</code>表示常量</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义常量PI&#x3D;3.14159</code></pre></div></figure><p>所以单从语法层面去讲，常量的使用与变量完全一致。</p><h1 id="三、数据类型简介"><a href="#三、数据类型简介" class="headerlink" title="三、数据类型简介"></a>三、数据类型简介</h1><p>为应对不同的业务需求，Python中也把数据分为不同类型</p><p><img src="/../../../img/image-20220912100558673.png" alt="image-20220912100558673"></p><p>检测数据类型的方法：<code>type()</code>，比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; 1print(type(a))  # &lt;class &#39;int&#39;&gt; -- 整型b &#x3D; 1.1print(type(b))  # &lt;class &#39;float&#39;&gt; -- 浮点型c &#x3D; Trueprint(type(c))  # &lt;class &#39;bool&#39;&gt; -- 布尔型d &#x3D; &#39;12345&#39;print(type(d))  # &lt;class &#39;str&#39;&gt; -- 字符串e &#x3D; [10, 20, 30]print(type(e))  # &lt;class &#39;list&#39;&gt; -- 列表f &#x3D; (10, 20, 30)print(type(f))  # &lt;class &#39;tuple&#39;&gt; -- 元组h &#x3D; &#123;10, 20, 30&#125;print(type(h))  # &lt;class &#39;set&#39;&gt; -- 集合g &#x3D; &#123;&#39;name&#39;: &#39;TOM&#39;, &#39;age&#39;: 20&#125;print(type(g))  # &lt;class &#39;dict&#39;&gt; -- 字典</code></pre></div></figure><h2 id="3-1-数字类型"><a href="#3-1-数字类型" class="headerlink" title="3.1 数字类型"></a>3.1 数字类型</h2><h3 id="3-1-1-int整型"><a href="#3-1-1-int整型" class="headerlink" title="3.1.1 int整型"></a>3.1.1 int整型</h3><p>用来记录人的年龄，出生年份，学生人数等整数相关的状态</p><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">age &#x3D; 18birthday &#x3D; 1990student_count &#x3D; 48</code></pre></div></figure><h3 id="3-1-2-float浮点型"><a href="#3-1-2-float浮点型" class="headerlink" title="3.1.2 float浮点型"></a>3.1.2 float浮点型</h3><p>用来记录人的身高，体重，薪资等小数相关的状态</p><p>案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">height &#x3D; 172.3weight &#x3D; 103.5salary &#x3D; 15000.89</code></pre></div></figure><h3 id="3-1-3-数字类型的使用"><a href="#3-1-3-数字类型的使用" class="headerlink" title="3.1.3 数字类型的使用"></a>3.1.3 数字类型的使用</h3><p>1 、数学运算</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; a &#x3D; 1&gt;&gt;&gt; b &#x3D; 3&gt;&gt;&gt; c &#x3D; a + b&gt;&gt;&gt; c4</code></pre></div></figure><p>2、比较大小</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x &#x3D; 10&gt;&gt;&gt; y &#x3D; 11&gt;&gt;&gt; x &gt; yFalse</code></pre></div></figure><h2 id="3-2-字符串类型String"><a href="#3-2-字符串类型String" class="headerlink" title="3.2 字符串类型String"></a>3.2 字符串类型String</h2><p>作用：用来记录人的名字，家庭住址，性别等描述性质的状态</p><p>字符串可以用<code>单引号</code>、<code>双引号</code>或者<code>多引号</code>定义，案例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">name &#x3D; &#39;Tony&#39;address &#x3D; &#39;上海市浦东新区&#39;sex &#x3D; &#39;男&#39;hobby &#x3D; &quot;篮球&quot;age &#x3D; &#39;&#39;&#39;18岁狗年生&#39;&#39;&#39;</code></pre></div></figure><p>PS：各种引号定义字符串的注意事项</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#1、需要考虑引号嵌套的配对问题msg &#x3D; &quot;My name is Tony , I&#39;m 18 years old!&quot; #内层有单引号，外层就需要用双引号#2、多引号可以写多行字符串msg &#x3D; &#39;&#39;&#39;        天下只有两种人。比如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留到最后吃。        照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。        不过事实却适得其反，缘故是第二种人还有希望，第一种人只有回忆。&#39;&#39;&#39;</code></pre></div></figure><h3 id="3-2-1-字符串的特殊使用"><a href="#3-2-1-字符串的特殊使用" class="headerlink" title="3.2.1 字符串的特殊使用"></a>3.2.1 字符串的特殊使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">数字可以进行加减乘除等运算，字符串呢？也可以，但只能进行&quot;相加&quot;和&quot;相乘&quot;运算。&gt;&gt;&gt; name &#x3D; &#39;tony&#39;&gt;&gt;&gt; age &#x3D; &#39;18&#39;&gt;&gt;&gt; name + age #相加其实就是简单的字符串拼接&#39;tony18&#39;&gt;&gt;&gt; name * 5 #相乘就相当于将字符串相加了5次&#39;tonytonytonytonytony&#39;</code></pre></div></figure><h2 id="3-3-列表list"><a href="#3-3-列表list" class="headerlink" title="3.3 列表list[]"></a>3.3 列表list[]</h2><h3 id="3-3-1-作用"><a href="#3-3-1-作用" class="headerlink" title="3.3.1 作用"></a>3.3.1 作用</h3><p>用来记录多个同种属性的值（比如同一个班级多个学生的姓名、同一个人的多个爱好等），并且存取</p><p>都十分方便</p><h3 id="3-3-2-定义"><a href="#3-3-2-定义" class="headerlink" title="3.3.2 定义"></a>3.3.2 定义</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; stu_names&#x3D;[&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;]</code></pre></div></figure><h3 id="3-3-3-使用"><a href="#3-3-3-使用" class="headerlink" title="3.3.3 使用"></a>3.3.3 使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、列表类型是用索引来对应值，索引代表的是数据的位置，从0开始计数&gt;&gt;&gt; stu_names&#x3D;[&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;]&gt;&gt;&gt; stu_names[0] &#39;张三&#39;&gt;&gt;&gt; stu_names[1]&#39;李四&#39;&gt;&gt;&gt; stu_names[2]&#39;王五&#39;# 2、列表可以嵌套，嵌套取值如下&gt;&gt;&gt; students_info&#x3D;[[&#39;tony&#39;,18,[&#39;jack&#39;,]],[&#39;jason&#39;,18,[&#39;play&#39;,&#39;sleep&#39;]]]&gt;&gt;&gt; students_info[0][2][0] #取出第一个学生的第一个爱好&#39;play&#39;</code></pre></div></figure><h2 id="3-4-字典dict"><a href="#3-4-字典dict" class="headerlink" title="3.4 字典dict{}"></a>3.4 字典dict{}</h2><h3 id="3-4-1-作用"><a href="#3-4-1-作用" class="headerlink" title="3.4.1 作用"></a>3.4.1 作用</h3><p>如果我们需要用一个变量记录多个值，但多个值是不同属性的，这就用到字典类型，字典类型是用<code>key:value</code>形</p><p>式来存储数据，其中key可以对value有描述性的功能</p><h3 id="3-4-2-定义"><a href="#3-4-2-定义" class="headerlink" title="3.4.2 定义"></a>3.4.2 定义</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; person_info&#x3D;&#123;&#39;name&#39;:&#39;tony&#39;, &#39;age&#39;:18, &#39;height&#39;:185.3&#125;</code></pre></div></figure><h3 id="3-4-3-使用"><a href="#3-4-3-使用" class="headerlink" title="3.4.3 使用"></a>3.4.3 使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、字典类型是用key来对应值，key可以对值有描述性的功能，通常为字符串类型&gt;&gt;&gt; person_info&#x3D;&#123;&#39;name&#39;:&#39;tony&#39;,&#39;age&#39;:18,&#39;height&#39;:185.3&#125;&gt;&gt;&gt; person_info[&#39;name&#39;]&#39;tony&#39;&gt;&gt;&gt; person_info[&#39;age&#39;]18&gt;&gt;&gt; person_info[&#39;height&#39;]185.3# 2、字典可以嵌套，嵌套取值如下(用列表套字典)&gt;&gt;&gt; students&#x3D;[... &#123;&#39;name&#39;:&#39;tony&#39;,&#39;age&#39;:38,&#39;hobbies&#39;:[&#39;play&#39;,&#39;sleep&#39;]&#125;,... &#123;&#39;name&#39;:&#39;jack&#39;,&#39;age&#39;:18,&#39;hobbies&#39;:[&#39;read&#39;,&#39;sleep&#39;]&#125;,... &#123;&#39;name&#39;:&#39;rose&#39;,&#39;age&#39;:58,&#39;hobbies&#39;:[&#39;music&#39;,&#39;read&#39;,&#39;sleep&#39;]&#125;,... ]&gt;&gt;&gt; students[1][&#39;hobbies&#39;][1] #取第二个学生的第二个爱好&#39;sleep&#39;</code></pre></div></figure><h2 id="3-5-布尔bool"><a href="#3-5-布尔bool" class="headerlink" title="3.5 布尔bool"></a>3.5 布尔bool</h2><h3 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a>5.1 作用</h3><p>用来记录真假这两种状态</p><h3 id="3-5-2-定义"><a href="#3-5-2-定义" class="headerlink" title="3.5.2 定义"></a>3.5.2 定义</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; is_ok &#x3D; True&gt;&gt;&gt; is_ok &#x3D; False</code></pre></div></figure><h3 id="3-5-3-使用"><a href="#3-5-3-使用" class="headerlink" title="3.5.3 使用"></a>3.5.3 使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">通常用来当作判断的条件，我们将在if判断中用到它</code></pre></div></figure><h2 id="3-6-集合set"><a href="#3-6-集合set" class="headerlink" title="3.6 集合set{}"></a>3.6 集合set{}</h2><h3 id="3-6-1-作用"><a href="#3-6-1-作用" class="headerlink" title="3.6.1 作用"></a>3.6.1 作用</h3><p>在Python中，集合（set）是无序的、元素不重复的集合</p><h3 id="3-6-2-定义"><a href="#3-6-2-定义" class="headerlink" title="3.6.2 定义"></a>3.6.2 定义</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">set01 &#x3D; &#123;&#39;num1&#39;, &#39;num2&#39;&#125;</code></pre></div></figure><h3 id="3-6-3-集合运算"><a href="#3-6-3-集合运算" class="headerlink" title="3.6.3 集合运算"></a>3.6.3 集合运算</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、定义集合&gt;&gt;&gt; admins &#x3D; &#123;&#39;Justin&#39;, &#39;caterpillar&#39;&#125;&gt;&gt;&gt; users &#x3D; &#123;&#39;momor&#39;, &#39;hamini&#39;, &#39;Justin&#39;&#125;# 2、使用in判断元素在集合&gt;&gt;&gt; &#39;Justin&#39; in adminsTrue# 3、交集&gt;&gt;&gt; admins &amp; users&#123;&#39;Justin&#39;&#125;# 4、并集&gt;&gt;&gt; admins | users&#123;&#39;hamini&#39;, &#39;caterpillar&#39;, &#39;Justin&#39;, &#39;momor&#39;&#125;# 差集&gt;&gt;&gt; admins - users&#123;&#39;caterpillar&#39;&#125;# 对称集&gt;&gt;&gt; admins ^ users&#123;&#39;hamini&#39;, &#39;caterpillar&#39;, &#39;momor&#39;&#125;# 集合比大小&gt;&gt;&gt; admins &gt; usersFalse&gt;&gt;&gt; admins &lt; usersFalse&gt;&gt;&gt;</code></pre></div></figure><h2 id="3-7-元组tuple"><a href="#3-7-元组tuple" class="headerlink" title="3.7 元组tuple()"></a>3.7 元组tuple()</h2><h3 id="3-7-1-作用"><a href="#3-7-1-作用" class="headerlink" title="3.7.1 作用"></a>3.7.1 作用</h3><p><code>tuple</code> 可以做什么？有时候想返回一组值，但是这组值又不想定义某个类型，就可以使用元组</p><h3 id="3-7-2-定义"><a href="#3-7-2-定义" class="headerlink" title="3.7.2 定义"></a>3.7.2 定义</h3><p><code>tuple</code> 定义后，里面的值就无法修改</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 1、创建元组的方式-1&gt;&gt;&gt; 10,(10,)&gt;&gt;&gt; 10, 20, 30,(10, 20, 30)# 2、创建元组的方式-2&gt;&gt;&gt; mytup&#x3D;(1, 2, 3)&gt;&gt;&gt; mytup(1, 2, 3)&gt;&gt;&gt; type(mytup)&lt;class &#39;tuple&#39;&gt;# 尝试修改元组的值&gt;&gt;&gt; mytup[0] &#x3D; 3## 会报错Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;tuple&#39; object does not support item assignment</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>01_Python入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oracle VPS部署V2Ray</title>
    <link href="/2022/07/15/06_%E6%9D%82%E8%AE%B0/%E7%94%B2%E9%AA%A8%E6%96%87VPS%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90/"/>
    <url>/2022/07/15/06_%E6%9D%82%E8%AE%B0/%E7%94%B2%E9%AA%A8%E6%96%87VPS%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​本文介绍如何使用甲骨文（Oracle）的免费VPS部署V2Ray</p><p>甲骨文服务器申请地址：</p><p><a href="https://www.oracle.com/cloud/free/">https://www.oracle.com/cloud/free/</a></p><blockquote><p>c7 &#x2F; 7q &#x2F; F+</p></blockquote><h2 id="2-域名申请"><a href="#2-域名申请" class="headerlink" title="2 域名申请"></a>2 域名申请</h2><p><font color='red'><strong>！！本节使用Firefox浏览器操作！！</strong></font></p><h3 id="2-1-Firefox浏览器Gooreplacer插件设置"><a href="#2-1-Firefox浏览器Gooreplacer插件设置" class="headerlink" title="2.1 Firefox浏览器Gooreplacer插件设置"></a>2.1 Firefox浏览器Gooreplacer插件设置</h3><blockquote><p>防止freenom在订单提交阶段失败</p></blockquote><p>安装完插件后，点击“配置规则”</p><p><img src="/../../img/image-20220715144835831.png" alt="image-20220715144835831"></p><p>规则配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">重定向填写：https:&#x2F;&#x2F;www.google.com&#x2F;recaptcha目标地址填写：https:&#x2F;&#x2F;www.recaptcha.net&#x2F;recaptcha</code></pre></div></figure><p><img src="/../../img/image-20220715145007138.png" alt="image-20220715145007138"></p><h3 id="2-2-freenom域名申请"><a href="#2-2-freenom域名申请" class="headerlink" title="2.2 freenom域名申请"></a>2.2 freenom域名申请</h3><blockquote><p>freenom可以申请免费的域名，申请地址：</p><p><a href="https://www.freenom.com/en/index.html">https://www.freenom.com/en/index.html</a></p></blockquote><ul><li><p>登录，选择”注册一个新域名”<img src="/../../img/image-20220715145353695.png" alt="image-20220715145353695"></p></li><li><p>输入需要注册的域名名</p></li></ul><p><img src="/../../img/image-20220715145306545.png" alt="image-20220715145306545"></p><ul><li>选择免费域名，加入购物车</li></ul><p><img src="/../../img/image-20220715145556778.png" alt="image-20220715145556778"></p><ul><li>期限修改为12个月</li></ul><p><img src="/../../img/image-20220715145640940.png" alt="image-20220715145640940"></p><ul><li>勾选允许协议，点击完成</li></ul><p><img src="/../../img/image-20220715145722733.png" alt="image-20220715145722733"></p><ul><li>看到此界面，说明申请成功，如果申请失败，回到2.1检查Gooreplacer插件是否配置正常</li></ul><p><img src="/../../img/image-20220715145825655.png" alt="image-20220715145825655"></p><ul><li>查看我的域名</li></ul><p><img src="/../../img/image-20220715150619814.png" alt="image-20220715150619814"></p><ul><li><p>设置域名</p><p><img src="/../../img/image-20220715150723654.png" alt="image-20220715150723654"></p></li><li><p>添加域名解析</p></li></ul><p><img src="/../../img/image-20220715150801833.png" alt="image-20220715150801833"></p><ul><li><p>填写域名解析服务器</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">PAITYN.NS.CLOUDFLARE.COMSYEEF.NS.CLOUDFLARE.COM</code></pre></div></figure></li></ul><p><img src="/../../img/image-20220715150832903.png" alt="image-20220715150832903"></p><h2 id="3-域名解析配置（CDN）"><a href="#3-域名解析配置（CDN）" class="headerlink" title="3 域名解析配置（CDN）"></a>3 域名解析配置（CDN）</h2><blockquote><p>这里使用cloudflare</p></blockquote><p>添加站点</p><p><img src="/../../img/image-20220715151303012.png" alt="image-20220715151303012"></p><p>选择免费的方案</p><p><img src="/../../img/image-20220715151454194.png" alt="image-20220715151454194"></p><p>添加VPS服务器地址</p><p><img src="/../../img/image-20220715151735023.png" alt="image-20220715151735023"></p><p>校验服务器是否生效：</p><blockquote><p>解析的IP不一致，是因为勾选了”代理“，不影响正常使用</p></blockquote><p><img src="/../../img/image-20220715151954505.png" alt="image-20220715151954505"></p><h2 id="4-VPS部署V2Ray"><a href="#4-VPS部署V2Ray" class="headerlink" title="4 VPS部署V2Ray"></a>4 VPS部署V2Ray</h2><blockquote><p>参考：<a href="https://www.ioiox.com/archives/99.html">https://www.ioiox.com/archives/99.html</a></p></blockquote><h3 id="4-1-系统设置"><a href="#4-1-系统设置" class="headerlink" title="4.1 系统设置"></a>4.1 系统设置</h3><h4 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h4><p>切换至root创建密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo -i# 切换至 root 账号passwd# 修改密码</code></pre></div></figure><p>修改ssh配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config# 编辑 sshd_config添加或修改Port 22222以确保SSH端口安全.查找到#PermitRootLogin yes,去掉#注释符号.查找到#PasswordAuthentication yes,去掉#注释符号.查找到#ClientAliveInterval 0,去掉#注释符号,0改为30.查找到#MaxSessions 10,去掉#注释符号.</code></pre></div></figure><p>重启ssh服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart sshd# 重启 sshd 生效</code></pre></div></figure><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>关闭防火墙</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop firewalldsystemctl disable firewalld</code></pre></div></figure><h4 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h4><blockquote><p>甲骨文云的<code>CentOS 7</code>在使用<code>hostnamectl set-hostname</code>命令修改主机名时,重启服务器后依旧会恢复为 Web 端创建实例时所设置的名字.网上查找了各种方法都无效,最终找到了解决方案.</p></blockquote><p>编辑修改<code>oci-hostname.conf</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi &#x2F;etc&#x2F;oci-hostname.conf</code></pre></div></figure><p>将<code>PRESERVE_HOSTINFO=0</code>中的的值<code>0</code>修改为<code>1</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># This configuration file controls the hostname persistence behavior for Oracle Linux# compute instance on Oracle Cloud Infrastructure (formerly Baremetal Cloud Services)# Set PRESERVE_HOSTINFO to one of the following values#   0 -- default behavior to update hostname, &#x2F;etc&#x2F;hosts and &#x2F;etc&#x2F;resolv.conf to #        reflect the hostname set during instance creation from the metadata service#   1 -- preserve user configured hostname across reboots; update &#x2F;etc&#x2F;hosts and #           &#x2F;etc&#x2F;resolv.conf from the metadata service  #   2 -- preserve user configured hostname across instance reboots; no custom  #        changes to &#x2F;etc&#x2F;hosts and &#x2F;etc&#x2F;resolv.conf from the metadata service,#        but dhclient will still overwrite &#x2F;etc&#x2F;resolv.conf#   3 -- preserve hostname and &#x2F;etc&#x2F;hosts entries across instance reboots; #        update &#x2F;etc&#x2F;resolv.conf from instance metadata servicePRESERVE_HOSTINFO&#x3D;0</code></pre></div></figure><p>使用<code>hostnamectl set-hostname</code>命令修改主机名即可.重启也不会失效.</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hostnamectl set-hostname xxxxxx</code></pre></div></figure><h4 id="卸载相关程序"><a href="#卸载相关程序" class="headerlink" title="卸载相关程序"></a>卸载相关程序</h4><h5 id="rpcbind"><a href="#rpcbind" class="headerlink" title="rpcbind"></a>rpcbind</h5><p>使用<code>netstat -ntlp</code>命令发现<code>rpcbind</code>监听了<code>111</code>端口,如担心安全可执行以下命令卸载禁用:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop rpcbindsystemctl stop rpcbind.socketsystemctl disable rpcbindsystemctl disable rpcbind.socket </code></pre></div></figure><h5 id="oracle-cloud-agent"><a href="#oracle-cloud-agent" class="headerlink" title="oracle-cloud-agent"></a>oracle-cloud-agent</h5><p>卸载甲骨文云官方后台监控程序</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop oracle-cloud-agentsystemctl disable oracle-cloud-agentsystemctl stop oracle-cloud-agent-updatersystemctl disable oracle-cloud-agent-updater</code></pre></div></figure><h3 id="4-2-安装BBRPlus"><a href="#4-2-安装BBRPlus" class="headerlink" title="4.2 安装BBRPlus"></a>4.2 安装BBRPlus</h3><blockquote><p>参考：<a href="https://www.ioiox.com/archives/63.html">https://www.ioiox.com/archives/63.html</a></p><p>Oracle VPS部署BBR，按普通的方式安装，将导致BBR安装并重启机器后，服务器失联，需要安装特定的内核，并作一些列设置</p></blockquote><h4 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h4><p>更新 yum</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y update</code></pre></div></figure><p>查看内核</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uname -r# 内核版本 3.10.0-1062.12.1.el7.x86_64</code></pre></div></figure><p>手动下载<code>秋水 BBRPlus</code>版内核</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chiakge&#x2F;Linux-NetSpeed&#x2F;master&#x2F;bbrplus&#x2F;centos&#x2F;7&#x2F;kernel-4.14.129-bbrplus.rpm</code></pre></div></figure><p>手动安装内核</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install kernel-4.14.129-bbrplus.rpm</code></pre></div></figure><p>更新引导</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfggrub2-mkconfig -o &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;centos&#x2F;grub.cfg</code></pre></div></figure><p>列出系统开机启动项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo awk -F\&#39; &#39;$1&#x3D;&#x3D;&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#39; &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;centos&#x2F;grub.cfg</code></pre></div></figure><p>设置新版内核默认启动项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grub2-set-default 0</code></pre></div></figure><p>重启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reboot</code></pre></div></figure><h4 id="开启-BBRPlus-及优化"><a href="#开启-BBRPlus-及优化" class="headerlink" title="开启 BBRPlus 及优化"></a>开启 BBRPlus 及优化</h4><p>下载秋水一键脚本<code>tcp.sh</code>,选择<code>7</code>开启<code>BBRPlus</code>加速.<br>等脚本退出后，再次<code>./tcp.sh</code>运行脚本,选择<code>10</code>优化，过程中需要重启。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -N --no-check-certificate &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chiakge&#x2F;Linux-NetSpeed&#x2F;master&#x2F;tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; .&#x2F;tcp.sh</code></pre></div></figure><h3 id="4-3-安装V2Ray"><a href="#4-3-安装V2Ray" class="headerlink" title="4.3 安装V2Ray"></a>4.3 安装V2Ray</h3><p>在梯子服务器，wget下载一键搭建脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;gist.githubusercontent.com&#x2F;JodenHe&#x2F;815dd91277b722d36a860d39c2296083&#x2F;raw&#x2F;7f2b5ac0f8137b245d44741fc4a9f40cffa36755&#x2F;v2Ray-install.sh</code></pre></div></figure><p><strong>20230228更新</strong></p><p>因为其中下载链接中的v2ray分支更新，需要改成继续使用老版本，错误日志如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">安装V2ray... 安装V2Ray v5.3.0 ，架构64 下载V2Ray: https:&#x2F;&#x2F;github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;releases&#x2F;download&#x2F;v5.3.0&#x2F;v2ray-linux-64.zip  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0100 11.1M  100 11.1M    0     0  11.8M      0 --:--:-- --:--:-- --:--:-- 59.4MArchive:  &#x2F;tmp&#x2F;v2ray&#x2F;v2ray.zip  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;config.json    inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geosite.dat    inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geoip-only-cn-private.dat     creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;   creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;system&#x2F;  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;system&#x2F;v2ray.service    inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;system&#x2F;v2ray@.service    inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_socks_vmess.json    inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geoip.dat      inflating: &#x2F;tmp&#x2F;v2ray&#x2F;v2ray          inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_vmess_freedom.json  cp: cannot stat ‘&#x2F;tmp&#x2F;v2ray&#x2F;v2ctl’: No such file or directorychmod: cannot access ‘&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;v2ctl’: No such file or directory V2ray安装失败</code></pre></div></figure><p>修改脚本内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i &#39;s&#x2F;$&#123;NEW_VER&#125;&#x2F;v4.45.2&#x2F;g&#39; v2Ray-install.sh</code></pre></div></figure><p>继续执行脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash v2Ray-install.sh</code></pre></div></figure><p><img src="/../../img/image-20220715155109519.png" alt="image-20220715155109519"></p><p>BBR已经安装过，这里选n （笔者第一次在这选y直接安装BBR，结果服务器重启后失联，没法登录，后采用4.2小节的方式，先安装BBRPlus）</p><p><img src="/../../img/image-20220715155122886.png" alt="image-20220715155122886"></p><p>安装成功，可以使用链接配置V2RayN</p><p><img src="/../../img/image-20220715155230097.png" alt="image-20220715155230097"></p><h2 id="5-v2Ray-客户端"><a href="#5-v2Ray-客户端" class="headerlink" title="5 v2Ray 客户端"></a>5 v2Ray 客户端</h2><p>参考：<a href="https://tlanyan.pp.ua/v2ray-clients-download/">https://tlanyan.pp.ua/v2ray-clients-download/</a></p><p>笔者使用的windows客户端为：<code>V2rayN</code>, 安卓客户端为：<code>V2rayNG</code></p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><a href="https://toutyrater.github.io/">https://toutyrater.github.io/</a></p><p><a href="https://tlanyan.pp.ua/v2ray-clients-download/">https://tlanyan.pp.ua/v2ray-clients-download/</a></p><p><a href="https://baijiahao.baidu.com/s?id=1689185764130254565&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1689185764130254565&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://www.ioiox.com/archives/99.html">https://www.ioiox.com/archives/99.html</a></p><p><a href="https://blog.joden123.top/2022/02/20/proxy/v2ray-install/">https://blog.joden123.top/2022/02/20/proxy/v2ray-install/</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ventoy制作U盘启动器</title>
    <link href="/2022/07/13/06_%E6%9D%82%E8%AE%B0/%E4%BD%BF%E7%94%A8ventoy%E5%88%B6%E4%BD%9CU%E7%9B%98%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
    <url>/2022/07/13/06_%E6%9D%82%E8%AE%B0/%E4%BD%BF%E7%94%A8ventoy%E5%88%B6%E4%BD%9CU%E7%9B%98%E5%90%AF%E5%8A%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="教程：Ventoy制作U盘启动器"><a href="#教程：Ventoy制作U盘启动器" class="headerlink" title="教程：Ventoy制作U盘启动器"></a>教程：Ventoy制作U盘启动器</h1><p>此教程需在<code>Windows</code>电脑中操作</p><h2 id="一、制作U盘启动器"><a href="#一、制作U盘启动器" class="headerlink" title="一、制作U盘启动器"></a>一、制作U盘启动器</h2><p>1、解压<code>ventoy-1.0.67-windows.zip</code>压缩包，解压后的文件如图所示：</p><p><img src="/../../img/image-20230224104122553.png" alt="image-20230224104122553"></p><p>2、电脑插入U盘，选择运行<code>Ventoy2Disk.exe</code>程序，程序界面如图所示，在<code>设备</code>栏选择需要制作为启动器的U盘，点击<code>安装</code></p><p><img src="/../../img/image-20230224102749236.png" alt="image-20230224102749236"></p><p>3、安装成功之后，U盘会变为<code>Ventoy设备</code>，在“我的电脑”中查看，可见如下图所示的存储设备</p><p><img src="/../../img/image-20230224102919161.png" alt="image-20230224102919161"></p><p>4、双击打开<code>Ventoy设备</code>，将<code>ISO镜像</code>文件直接拷贝进去（如常用的麒麟、统信系统的ISO镜像文件），可以一次性放入多个镜像文件</p><p><img src="/../../img/image-20230224104440031.png" alt="image-20230224104440031"></p><p>5、弹出U盘设备，U盘启动器制作完毕</p><h2 id="二、使用U盘启动器"><a href="#二、使用U盘启动器" class="headerlink" title="二、使用U盘启动器"></a>二、使用U盘启动器</h2><p>1、U盘插入长城电脑，开机按<code>F10</code>，选择启动项</p><p><img src="/../../img/image-20230224103929836.png" alt="image-20230224103929836"></p><p>2、进入Ventoy界面，键盘<code>上下方向键</code>选择需要安装的系统镜像，<code>回车键</code>进入系统安装界面</p><p><img src="/../../img/image-20230224104000323.png" alt="image-20230224104000323"></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KylinV10 桌面版SVN搭建</title>
    <link href="/2022/07/11/06_%E6%9D%82%E8%AE%B0/SVN%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/11/06_%E6%9D%82%E8%AE%B0/SVN%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一、服务端配置"><a href="#一、服务端配置" class="headerlink" title="一、服务端配置"></a>一、服务端配置</h2><h3 id="1-1-安装SVN"><a href="#1-1-安装SVN" class="headerlink" title="1.1 安装SVN"></a>1.1 安装SVN</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install subversion</code></pre></div></figure><h3 id="1-2-新建仓库文件夹"><a href="#1-2-新建仓库文件夹" class="headerlink" title="1.2 新建仓库文件夹"></a>1.2 新建仓库文件夹</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建项目仓库文件夹mkdir &#x2F;data&#x2F;svn&#x2F;project# 修改文件夹权限chmod -R 777 &#x2F;data&#x2F;svn&#x2F;project</code></pre></div></figure><h3 id="1-3-创建版本库"><a href="#1-3-创建版本库" class="headerlink" title="1.3 创建版本库"></a>1.3 创建版本库</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">svnadmin create &#x2F;data&#x2F;svn&#x2F;project</code></pre></div></figure><p>完成后会在文件夹中生成一系列文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">greatwall@greatwall-GW-001M1A-FTF:&#x2F;data&#x2F;svn&#x2F;project$ lsconf  db  format  hooks  locks  README.txt</code></pre></div></figure><p>修改db权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod -R 777 db</code></pre></div></figure><h3 id="1-4-设置访问权限"><a href="#1-4-设置访问权限" class="headerlink" title="1.4 设置访问权限"></a>1.4 设置访问权限</h3><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">vim &#x2F;data&#x2F;svn&#x2F;project&#x2F;conf&#x2F;svnserve.conf</code></pre></div></figure><p>做如下修改</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">greatwall@greatwall-GW-001M1A-FTF:&#x2F;data&#x2F;svn&#x2F;project&#x2F;conf$ cat svnserve.conf### This file controls the configuration of the svnserve daemon, if you### use it to allow access to this repository.  (If you only allow### access through http: and&#x2F;or file: URLs, then this file is### irrelevant.)### Visit http:&#x2F;&#x2F;subversion.apache.org&#x2F; for more information.[general]### The anon-access and auth-access options control access to the### repository for unauthenticated (a.k.a. anonymous) users and### authenticated users, respectively.### Valid values are &quot;write&quot;, &quot;read&quot;, and &quot;none&quot;.### Setting the value to &quot;none&quot; prohibits both reading and writing;### &quot;read&quot; allows read-only access, and &quot;write&quot; allows complete### read&#x2F;write access to the repository.### The sample settings below are the defaults and specify that anonymous### users have read-only access to the repository, while authenticated### users have read and write access to the repository.anon-access &#x3D; none# 非认证用户不让写auth-access &#x3D; write### The password-db option controls the location of the password### database file.  Unless you specify a path starting with a &#x2F;,### the file&#39;s location is relative to the directory containing### this configuration file.### If SASL is enabled (see below), this file will NOT be used.### Uncomment the line below to use the default password file.password-db &#x3D; passwd### The authz-db option controls the location of the authorization### rules for path-based access control.  Unless you specify a path### starting with a &#x2F;, the file&#39;s location is relative to the### directory containing this file.  The specified path may be a### repository relative URL (^&#x2F;) or an absolute file:&#x2F;&#x2F; URL to a text### file in a Subversion repository.  If you don&#39;t specify an authz-db,### no path-based access control is done.### Uncomment the line below to use the default authorization file.authz-db &#x3D; authz### The groups-db option controls the location of the groups file.### Unless you specify a path starting with a &#x2F;, the file&#39;s location is### relative to the directory containing this file.  The specified path### may be a repository relative URL (^&#x2F;) or an absolute file:&#x2F;&#x2F; URL to a### text file in a Subversion repository.# groups-db &#x3D; groups### This option specifies the authentication realm of the repository.### If two repositories have the same authentication realm, they should### have the same password database, and vice versa.  The default realm### is repository&#39;s uuid.realm &#x3D; My First Repository### The force-username-case option causes svnserve to case-normalize### usernames before comparing them against the authorization rules in the### authz-db file configured above.  Valid values are &quot;upper&quot; (to upper-### case the usernames), &quot;lower&quot; (to lowercase the usernames), and### &quot;none&quot; (to compare usernames as-is without case conversion, which### is the default behavior).# force-username-case &#x3D; none### The hooks-env options specifies a path to the hook script environment### configuration file. This option overrides the per-repository default### and can be used to configure the hook script environment for multiple### repositories in a single file, if an absolute path is specified.### Unless you specify an absolute path, the file&#39;s location is relative### to the directory containing this file.# hooks-env &#x3D; hooks-env[sasl]### This option specifies whether you want to use the Cyrus SASL### library for authentication. Default is false.### This section will be ignored if svnserve is not built with Cyrus### SASL support; to check, run &#39;svnserve --version&#39; and look for a line### reading &#39;Cyrus SASL authentication is available.&#39;# use-sasl &#x3D; true### These options specify the desired strength of the security layer### that you want SASL to provide. 0 means no encryption, 1 means### integrity-checking only, values larger than 1 are correlated### to the effective key length for encryption (e.g. 128 means 128-bit### encryption). The values below are the defaults.# min-encryption &#x3D; 0# max-encryption &#x3D; 256</code></pre></div></figure><h3 id="1-5-添加访问用户"><a href="#1-5-添加访问用户" class="headerlink" title="1.5 添加访问用户"></a>1.5 添加访问用户</h3><p>修改passwd文件，添加访问用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">greatwall@greatwall-GW-001M1A-FTF:&#x2F;data&#x2F;svn&#x2F;project&#x2F;conf$ cat passwd### This file is an example password file for svnserve.### Its format is similar to that of svnserve.conf. As shown in the### example below it contains one section labelled [users].### The name and password for each user follow, one account per line.[users]# harry &#x3D; harryssecret# sally &#x3D; sallyssecretadmin&#x3D;mysecretgs&#x3D;mysecret</code></pre></div></figure><h3 id="1-6-设置用户权限"><a href="#1-6-设置用户权限" class="headerlink" title="1.6 设置用户权限"></a>1.6 设置用户权限</h3><p>修改authz文件，设置用户权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">greatwall@greatwall-GW-001M1A-FTF:&#x2F;data&#x2F;svn&#x2F;project&#x2F;conf$ cat authz### This file is an example authorization file for svnserve.### Its format is identical to that of mod_authz_svn authorization### files.### As shown below each section defines authorizations for the path and### (optional) repository specified by the section name.### The authorizations follow. An authorization line can refer to:###  - a single user,###  - a group of users defined in a special [groups] section,###  - an alias defined in a special [aliases] section,###  - all authenticated users, using the &#39;$authenticated&#39; token,###  - only anonymous users, using the &#39;$anonymous&#39; token,###  - anyone, using the &#39;*&#39; wildcard.###### A match can be inverted by prefixing the rule with &#39;~&#39;. Rules can### grant read (&#39;r&#39;) access, read-write (&#39;rw&#39;) access, or no access### (&#39;&#39;).[aliases]# joe &#x3D; &#x2F;C&#x3D;XZ&#x2F;ST&#x3D;Dessert&#x2F;L&#x3D;Snake City&#x2F;O&#x3D;Snake Oil, Ltd.&#x2F;OU&#x3D;Research Institute&#x2F;CN&#x3D;Joe Average[groups]# harry_and_sally &#x3D; harry,sally# harry_sally_and_joe &#x3D; harry,sally,&amp;joe# [&#x2F;foo&#x2F;bar]# harry &#x3D; rw# &amp;joe &#x3D; r# * &#x3D;# [repository:&#x2F;baz&#x2F;fuz]# @harry_and_sally &#x3D; rw# * &#x3D; rteam1&#x3D;admin,gs# 创建用户组[&#x2F;]@team1 &#x3D; rw # 用户组权限设置为读写* &#x3D; r</code></pre></div></figure><h3 id="1-7-启动服务"><a href="#1-7-启动服务" class="headerlink" title="1.7 启动服务"></a>1.7 启动服务</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">svnserve -d -r &#x2F;data&#x2F;svn</code></pre></div></figure><p>查看服务是否在运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps aux | grep svnserve</code></pre></div></figure><p>干掉服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">killall svnserve</code></pre></div></figure><h2 id="二、客户端连接"><a href="#二、客户端连接" class="headerlink" title="二、客户端连接"></a>二、客户端连接</h2><p>svn:&#x2F;&#x2F;10.47.76.90&#x2F;project</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>openvpn 使用手册</title>
    <link href="/2022/07/11/06_%E6%9D%82%E8%AE%B0/openvpn%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/07/11/06_%E6%9D%82%E8%AE%B0/openvpn%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="openvpn-使用手册"><a href="#openvpn-使用手册" class="headerlink" title="openvpn 使用手册"></a>openvpn 使用手册</h1><p>此手册的目的是使读者快速上手将openvpn使用起来，满足大部分需求</p><h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><table><thead><tr><th>硬件</th><th>操作系统</th><th>软件</th></tr></thead><tbody><tr><td>ARM64 ft2000+</td><td>centos7.5</td><td>easy-rsa3.0.6 openvpn2.4.7</td></tr></tbody></table><h2 id="二、准备安装源"><a href="#二、准备安装源" class="headerlink" title="二、准备安装源"></a>二、准备安装源</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client.  You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist&#x3D; does not work for you, as a fall back you can try the# remarked out baseurl&#x3D; line instead.##[base]name&#x3D;CentOS-$releasever - Basebaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos-altarch&#x2F;$releasever&#x2F;os&#x2F;$basearch&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;RPM-GPG-KEY-CentOS-7#released updates[updates]name&#x3D;CentOS-$releasever - Updatesbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos-altarch&#x2F;$releasever&#x2F;updates&#x2F;$basearch&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name&#x3D;CentOS-$releasever - Extrasbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos-altarch&#x2F;$releasever&#x2F;extras&#x2F;$basearch&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;RPM-GPG-KEY-CentOS-7enabled&#x3D;1#additional packages that extend functionality of existing packages[centosplus]name&#x3D;CentOS-$releasever - Plusbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos-altarch&#x2F;$releasever&#x2F;centosplus&#x2F;$basearch&#x2F;gpgcheck&#x3D;1enabled&#x3D;0gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;RPM-GPG-KEY-CentOS-7</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo[epel]name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch#baseurl&#x3D;http:&#x2F;&#x2F;download.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;7&#x2F;$basearchmetalink&#x3D;https:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;metalink?repo&#x3D;epel-7&amp;arch&#x3D;$basearchfailovermethod&#x3D;priorityenabled&#x3D;1gpgcheck&#x3D;0gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-EPEL-7[epel-debuginfo]name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch - Debug#baseurl&#x3D;http:&#x2F;&#x2F;download.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;7&#x2F;$basearch&#x2F;debugmetalink&#x3D;https:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;metalink?repo&#x3D;epel-debug-7&amp;arch&#x3D;$basearchfailovermethod&#x3D;priorityenabled&#x3D;0gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-EPEL-7gpgcheck&#x3D;0[epel-source]name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch - Source#baseurl&#x3D;http:&#x2F;&#x2F;download.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;7&#x2F;SRPMSmetalink&#x3D;https:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;metalink?repo&#x3D;epel-source-7&amp;arch&#x3D;$basearchfailovermethod&#x3D;priorityenabled&#x3D;0gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-EPEL-7gpgcheck&#x3D;0</code></pre></div></figure><h2 id="三、安装软件包"><a href="#三、安装软件包" class="headerlink" title="三、安装软件包"></a>三、安装软件包</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn ~]# yum install easy-rsa openvpn -yLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfile * epel: mirrors.yun-idc.comPackage easy-rsa-3.0.6-1.el7.noarch already installed and latest versionPackage openvpn-2.4.7-1.el7.aarch64 already installed and latest versionNothing to do[root@openvpn ~]#</code></pre></div></figure><h2 id="四、配置easy-rsa-3-0-6"><a href="#四、配置easy-rsa-3-0-6" class="headerlink" title="四、配置easy-rsa 3.0.6"></a>四、配置easy-rsa 3.0.6</h2><p>安装完easy-rsa 3.0.6 后，默认会生成 easyrsa 脚本文件和 vars.example 环境变量文件，这两件文件是核心文件，下面会用到</p><p>找到这两个文件所在的目录，复制到相应的位置，然后根据自己的需求配置vars</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn ~]# find &#x2F;usr&#x2F; -name easyrsa -o -name vars.example&#x2F;usr&#x2F;share&#x2F;doc&#x2F;easy-rsa-3.0.6&#x2F;vars.example&#x2F;usr&#x2F;share&#x2F;easy-rsa&#x2F;3.0.6&#x2F;easyrsa[root@openvpn ~]# cp -r &#x2F;usr&#x2F;share&#x2F;easy-rsa&#x2F;3.0.6&#x2F; &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;[root@openvpn ~]# cp &#x2F;usr&#x2F;share&#x2F;doc&#x2F;easy-rsa-3.0.6&#x2F;vars.example &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;vars[root@openvpn ~]# grep -v &quot;^#\|^$&quot; &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;varsif [ -z &quot;$EASYRSA_CALLER&quot; ]; then    echo &quot;You appear to be sourcing an Easy-RSA &#39;vars&#39; file.&quot; &gt;&amp;2    echo &quot;This is no longer necessary and is disallowed. See the section called&quot; &gt;&amp;2    echo &quot;&#39;How to use this file&#39; near the top comments for more details.&quot; &gt;&amp;2    return 1fiset_var EASYRSA_REQ_COUNTRY&quot;CN&quot;set_var EASYRSA_REQ_PROVINCE&quot;HuNan&quot;set_var EASYRSA_REQ_CITY&quot;ChangSha&quot;set_var EASYRSA_REQ_ORG&quot;Greatwall Corporation&quot;set_var EASYRSA_REQ_EMAIL&quot;yuliangliang@greatwall.com.cn&quot;set_var EASYRSA_REQ_OU&quot;Product Department&quot;[root@openvpn ~]# </code></pre></div></figure><h3 id="easyrsa-命令使用"><a href="#easyrsa-命令使用" class="headerlink" title="easyrsa 命令使用"></a>easyrsa 命令使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 查看整体帮助[root@openvpn 3.0.6]# .&#x2F;easyrsa -h&#x2F;&#x2F; 查看某个子命令的详细帮助[root@openvpn 3.0.6]# .&#x2F;easyrsa help import-reqNote: using Easy-RSA configuration from: .&#x2F;vars  import-req &lt;request_file_path&gt; &lt;short_basename&gt;      Import a certificate request from a file      This will copy the specified file into the reqs&#x2F; dir in      preparation for signing.      The &lt;short_basename&gt; is the filename base to create.      Example usage:        import-req &#x2F;some&#x2F;where&#x2F;bob_request.req bob[root@openvpn 3.0.6]#&#x2F;&#x2F; 查看可以用到的 options[root@openvpn 3.0.6]# .&#x2F;easyrsa help options</code></pre></div></figure><h3 id="创建-PKI-和-CA"><a href="#创建-PKI-和-CA" class="headerlink" title="创建 PKI 和 CA"></a>创建 PKI 和 CA</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn ~]# cd &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;[root@openvpn 3.0.6]# .&#x2F;easyrsa init-pki[root@openvpn 3.0.6]# lseasyrsa  openssl-easyrsa.cnf  pki  vars  x509-types[root@openvpn 3.0.6]# .&#x2F;easyrsa build-ca nopass (配置好了vars直接回车即可)</code></pre></div></figure><h3 id="创建服务端证书"><a href="#创建服务端证书" class="headerlink" title="创建服务端证书"></a>创建服务端证书</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# .&#x2F;easyrsa gen-req server nopass (回车即可)</code></pre></div></figure><h3 id="签约服务端证书"><a href="#签约服务端证书" class="headerlink" title="签约服务端证书"></a>签约服务端证书</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# .&#x2F;easyrsa sign server server</code></pre></div></figure><h3 id="创建-Diffie-Hellman"><a href="#创建-Diffie-Hellman" class="headerlink" title="创建 Diffie-Hellman"></a>创建 Diffie-Hellman</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# .&#x2F;easyrsa gen-dh</code></pre></div></figure><h3 id="创建客户端证书"><a href="#创建客户端证书" class="headerlink" title="创建客户端证书"></a>创建客户端证书</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# .&#x2F;easyrsa gen-req jiajia nopass</code></pre></div></figure><h3 id="签约客户端证书"><a href="#签约客户端证书" class="headerlink" title="签约客户端证书"></a>签约客户端证书</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# .&#x2F;easyrsa sign client jiajia</code></pre></div></figure><p>注意: 注意这里的客户端证书用到的pki目录跟服务器端的pki目录是一样的，所以可以直接 sign签署，如果客户端重新生成了pki，那每次生成的证书请求文件都需要用 .&#x2F;easyrsa import-req $PATH&#x2F;jiajia.req jiajia 导入并取一个短名字jiajia，然后执行 .&#x2F;easyrsa sign client jiajia；参见 .&#x2F;easy-rsa help import-req</p><h3 id="生成ta-key文件（防DDos攻击、UDP淹没等恶意攻击）"><a href="#生成ta-key文件（防DDos攻击、UDP淹没等恶意攻击）" class="headerlink" title="生成ta.key文件（防DDos攻击、UDP淹没等恶意攻击）"></a>生成ta.key文件（防DDos攻击、UDP淹没等恶意攻击）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# openvpn --genkey --secret ta.key</code></pre></div></figure><h3 id="整理证书"><a href="#整理证书" class="headerlink" title="整理证书"></a>整理证书</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# pwd&#x2F;etc&#x2F;openvpn&#x2F;3.0.6[root@compute3 3.0.6]# ll pki&#x2F;private&#x2F;total 8-rw-------. 1 root root 1679 Jun  9 21:05 ca.key-rw-------. 1 root root 1708 Jun  9 21:06 server.key[root@compute3 3.0.6]#[root@compute3 3.0.6]# ll pki&#x2F;issued&#x2F;total 8-rw-------. 1 root root 4552 Jun  9 21:18 server.crt[root@compute3 3.0.6]#[root@compute3 3.0.6]# ll pki&#x2F;ca.crt -rw-------. 1 root root 1172 Jun  9 21:05 pki&#x2F;ca.crt[root@compute3 3.0.6]# [root@compute3 3.0.6]# ll pki&#x2F;dh.pem -rw-------. 1 root root 424 Jun  9 21:10 pki&#x2F;dh.pem[root@compute3 3.0.6]#[root@compute3 3.0.6]# cp ta.key pki&#x2F;[root@compute3 3.0.6]# ll pki&#x2F;ta.key -rw-------. 1 root root 636 Jun  9 21:31 pki&#x2F;ta.key[root@compute3 3.0.6]# </code></pre></div></figure><p>以上配置文件将会在服务器端和端户端配置文件中指出</p><h3 id="服务器端配置文件"><a href="#服务器端配置文件" class="headerlink" title="服务器端配置文件"></a>服务器端配置文件</h3><p>以11楼跳板机为例（其实就是当路由器用）：</p><blockquote><p>eno1：10.60.30.145&#x2F;24  网关:10.60.30.250 (连接外网)</p><p>eno2: 10.10.10.253  网关: 10.10.10.254 </p><p>enp94s0: 10.10.11.253 网关：10.10.11.254</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# grep -vE &quot;^#|^$&quot; &#x2F;etc&#x2F;openvpn&#x2F;server.conf （该文件默认没有，需要自己创建）local 10.60.30.145 # 服务器本机连接外网的网卡IPport 1194 # 默认端口号，需要防火墙放通，做端口映射proto tcpdev tunca &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;pki&#x2F;ca.crtcert &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;pki&#x2F;issued&#x2F;server.crtkey &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;pki&#x2F;private&#x2F;server.keydh &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;pki&#x2F;dh.pemserver 10.8.0.0 255.255.255.0 # vpn地址池，不用改ifconfig-pool-persist ipp.txtpush &quot;route 10.10.0.0 255.255.0.0&quot; # 连接内网的路由，这边是10.10.10和10.10.11两个网段keepalive 10 120tls-auth &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;pki&#x2F;ta.key 0cipher AES-256-CBCcomp-lzopersist-keypersist-tunstatus openvpn-status.logverb 3reneg-sec 0# 注意，这个文件用来记录被吊销的证书，阻止被吊销的客户再次登陆# 默认没有这个文件，必须执行 .&#x2F;easyrsa gen-crl 更新生成，否则服务启不来crl-verify &#x2F;etc&#x2F;openvpn&#x2F;3.0.6&#x2F;pki&#x2F;crl.pem[root@openvpn 3.0.6]#</code></pre></div></figure><p>或者可以参考这一份配置文件</p><p>路由器（公网IP + 端口映射）— 内网服务器（15.1.10.32，部署OpenVPN服务1194端口）</p><p>实现的效果：</p><ul><li>Windows客户端连接后，将获取IP，10.8.0.6</li><li>测试可以与openvpn服务器ping通，ping 10.8.0.1</li><li>测试可以与OpenVPN服务器内网IP互通，ping 15.1.10.32</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">port 1194# 改成tcp，默认使用udp，如果使用HTTP Proxy，必须使用tcp协议proto tcpdev tun# # 路径前面加keys，全路径为&#x2F;etc&#x2F;openvpn&#x2F;keys&#x2F;ca.crtca &#x2F;etc&#x2F;openvpn&#x2F;easy-rsa&#x2F;pki&#x2F;ca.crtcert &#x2F;etc&#x2F;openvpn&#x2F;easy-rsa&#x2F;pki&#x2F;issued&#x2F;server.crtkey &#x2F;etc&#x2F;openvpn&#x2F;easy-rsa&#x2F;pki&#x2F;private&#x2F;server.key  # This file should be kept secretdh &#x2F;etc&#x2F;openvpn&#x2F;easy-rsa&#x2F;pki&#x2F;dh.pem# # 默认虚拟局域网网段，不要和实际的局域网冲突即可server 10.8.0.0 255.255.255.0ifconfig-pool-persist ipp.txt# # VPN服务器所在的内网的网段push &quot;route 15.1.10.0 255.255.255.0&quot;# # 让客户端所有的流量都通过VPN转发(全局模式)# push &quot;redirect-gateway def1 bypass-dhcp&quot;# # 可以让客户端之间相互访问直接通过openvpn程序转发# client-to-client# # 如果客户端都使用相同的证书和密钥连接VPN，一定要打开这个选项，否则每个证书只允许一个人连接VPN# duplicate-cnkeepalive 10 120tls-auth &#x2F;etc&#x2F;openvpn&#x2F;easy-rsa&#x2F;pki&#x2F;ta.key 0comp-lzopersist-keypersist-tun# # OpenVPN的状态日志，默认为&#x2F;etc&#x2F;openvpn&#x2F;openvpn-status.logstatus openvpn-status.log# # OpenVPN的运行日志，默认为&#x2F;etc&#x2F;openvpn&#x2F;openvpn.log log-append openvpn.log# # 改成verb 5可以多查看一些调试信息verb 5</code></pre></div></figure><h2 id="五、启动-openvpn-服务"><a href="#五、启动-openvpn-服务" class="headerlink" title="五、启动 openvpn 服务"></a>五、启动 openvpn 服务</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn ~]# systemctl start openvpn@server.service[root@openvpn ~]# systemctl enable openvpn@server.service# 无法启动该服务，或者找不到该服务？以下是处理方法创建文件 vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;openvpn@.service# openvpn@service的内容[Unit]Description&#x3D;OpenVPN Robust And Highly Flexible Tunneling Application On %IAfter&#x3D;network.target[Service]Type&#x3D;notifyPrivateTmp&#x3D;trueExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;openvpn --cd &#x2F;etc&#x2F;openvpn&#x2F; --config %i.conf[Install]WantedBy&#x3D;multi-user.target</code></pre></div></figure><h2 id="六、配置-iptables-规则（NAT出外网）"><a href="#六、配置-iptables-规则（NAT出外网）" class="headerlink" title="六、配置 iptables 规则（NAT出外网）"></a>六、配置 iptables 规则（NAT出外网）</h2><p>为了可以让客户端访问服务器所在局域网的其它主机，需要配置如下规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn ~]# iptables -t nat -A POSTROUTING -s 10.8.0.0&#x2F;24 -j MASQUERADE[root@openvpn ~]# cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward0[root@openvpn ~]# echo &quot;1&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward[root@openvpn ~]# cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward1</code></pre></div></figure><h2 id="七、Windows客户端OpenVPN配置"><a href="#七、Windows客户端OpenVPN配置" class="headerlink" title="七、Windows客户端OpenVPN配置"></a>七、Windows客户端OpenVPN配置</h2><h3 id="7-1-客户端的配置文件（仅供参考，主要通过下面的脚本配置）"><a href="#7-1-客户端的配置文件（仅供参考，主要通过下面的脚本配置）" class="headerlink" title="7.1 客户端的配置文件（仅供参考，主要通过下面的脚本配置）"></a>7.1 客户端的配置文件（仅供参考，主要通过下面的脚本配置）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clientdev tunproto tcpremote 36.158.226.1 16001resolv-retry infinitepersist-keypersist-tunmute-replay-warningsca ca.crtcert yll.crtkey yll.keyremote-cert-tls servertls-auth ta.key 1cipher AES-256-CBCcomp-lzoverb 3mute 20reneg-sec 0</code></pre></div></figure><h3 id="7-2-生成客户端证书的脚本如下"><a href="#7-2-生成客户端证书的脚本如下" class="headerlink" title="7.2 生成客户端证书的脚本如下"></a>7.2 生成客户端证书的脚本如下</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# grep -vE &quot;^#|^$&quot; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;genovpnuser if ! rpm -q expect; then    yum install expect -y    if ! [ $? &#x3D;&#x3D; 0 ]; then        echo &quot;Error: you must install expect manually!&quot;        exit -1    fifidir&#x3D;&#x2F;etc&#x2F;openvpn&#x2F;3.0.6if [ $# -ne 1 ]; then    echo &quot;Usage: $0 USER_NAME&quot;    echo &quot;-1&quot;    exit -1fiif ! [[ $1 &#x3D;~ ^[a-zA-Z0-9_]&#123;3,16&#125;$ ]];then    echo &quot;请使用字母数字或下划线开头的3到16个字符的名字&quot;    echo &quot;-1&quot;    exit -1ficd $dirif .&#x2F;easyrsa show-cert $1 &amp;&gt; &#x2F;dev&#x2F;null;then    echo &quot;此用户已存在，请重新输入&quot;    echo &quot;-1&quot;    exit -1fiexpect &lt;&lt;-EOFspawn .&#x2F;easyrsa gen-req $1 nopassexpect &#123;&quot;$1&quot; &#123; send &quot;\n&quot; &#125;&#125;expect eofEOF.&#x2F;easyrsa import-req $dir&#x2F;pki&#x2F;reqs&#x2F;$&#123;1&#125;.req $1expect &lt;&lt;-EOFspawn .&#x2F;easyrsa sign client $1expect &#123;&quot;Confirm&quot; &#123; send &quot;yes\n&quot; &#125;&#125;expect eofEOFif ! [ -d &#x2F;client.certs&#x2F; ]; then    mkdir &#x2F;client.certs&#x2F;ficat &gt; &#x2F;client.certs&#x2F;clientsample.ovpn &lt;&lt; EOFclientdev tunproto tcpremote 61.187.64.38 11940resolv-retry infinitepersist-keypersist-tunmute-replay-warningsca ca.crtcert sample.crtkey sample.keyremote-cert-tls servertls-auth ta.key 1cipher AES-256-CBCcomp-lzoverb 3mute 20reneg-sec 0EOFif [ -d &#x2F;client.certs&#x2F;$1 ]; then    rm -rf &#x2F;client.certs&#x2F;$1    mkdir &#x2F;client.certs&#x2F;$1else    mkdir &#x2F;client.certs&#x2F;$1ficp $dir&#x2F;pki&#x2F;ca.crt &#x2F;client.certs&#x2F;$1cp $dir&#x2F;pki&#x2F;ta.key &#x2F;client.certs&#x2F;$1cp $dir&#x2F;pki&#x2F;issued&#x2F;$&#123;1&#125;.crt &#x2F;client.certs&#x2F;$1cp $dir&#x2F;pki&#x2F;private&#x2F;$&#123;1&#125;.key &#x2F;client.certs&#x2F;$1cd &#x2F;client.certscp clientsample.ovpn client.ovpnsed -i s@sample.crt@$&#123;1&#125;.crt@g client.ovpnsed -i s@sample.key@$&#123;1&#125;.key@g client.ovpnmv client.ovpn $1&#x2F;[root@openvpn 3.0.6]# </code></pre></div></figure><h3 id="7-3-吊销客户端证书的脚本如下"><a href="#7-3-吊销客户端证书的脚本如下" class="headerlink" title="7.3 吊销客户端证书的脚本如下"></a>7.3 吊销客户端证书的脚本如下</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@openvpn 3.0.6]# grep -vE &quot;^#|^$&quot; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;delovpnuser if [ $# -ne 1 ]; then    echo &quot;Usage: $0 USER_NAME&quot;    echo &quot;-1&quot;    exit -1fiif ! [[ $1 &#x3D;~ ^[a-zA-Z0-9_]&#123;3,16&#125;$ ]];then    echo &quot;请使用字母数字或下划线开头的3到16个字符的名字&quot;    echo &quot;-1&quot;    exit -1fidir&#x3D;&#x2F;etc&#x2F;openvpn&#x2F;3.0.6cd $dirif ! .&#x2F;easyrsa show-cert $1 &amp;&gt; &#x2F;dev&#x2F;null;then    echo &quot;没有这个用户,无法删除&quot;    echo &quot;-1&quot;    exit -1fiexpect &lt;&lt;-EOFspawn .&#x2F;easyrsa revoke $1expect &#123;&quot;revocation&quot; &#123; send &quot;yes\n&quot; &#125;&#125;expect eofEOF.&#x2F;easyrsa gen-crlrm -rf &#x2F;client.certs&#x2F;$1[root@openvpn 3.0.6]# </code></pre></div></figure><h3 id="7-4-创建客户端证书脚本的使用"><a href="#7-4-创建客户端证书脚本的使用" class="headerlink" title="7.4 创建客户端证书脚本的使用"></a>7.4 创建客户端证书脚本的使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建客户端证书genovpnuser suxianjun# 将生成如下文件夹&#x2F;client.certs&#x2F;suxianjun# 将这个文件夹拷贝出来在wndows的openvpn上，将里面的ovpen文件上传上去，然后点击Connect即可</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>长城TD120A2安装OpenEuler</title>
    <link href="/2022/07/11/06_%E6%9D%82%E8%AE%B0/%E9%95%BF%E5%9F%8ETD120A2%E5%AE%89%E8%A3%85OpenEuler/"/>
    <url>/2022/07/11/06_%E6%9D%82%E8%AE%B0/%E9%95%BF%E5%9F%8ETD120A2%E5%AE%89%E8%A3%85OpenEuler/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录安装过程</p></blockquote><h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h3><table><thead><tr><th></th><th>型号</th></tr></thead><tbody><tr><td>CPU</td><td>飞腾D2000&#x2F;8核</td></tr><tr><td>内存</td><td>紫光DDR4 3200</td></tr><tr><td>显卡</td><td>AMD RX520</td></tr><tr><td>安装系统</td><td>OpenEuler 20.09</td></tr></tbody></table><h3 id="二、OpenEuler安装"><a href="#二、OpenEuler安装" class="headerlink" title="二、OpenEuler安装"></a>二、OpenEuler安装</h3><p>1、镜像准备：</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">openEuler-20.09-aarch64-dvd.iso</code></pre></div></figure><p>2、制作启动盘</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">使用win32diskimager制作U盘启动器</code></pre></div></figure><p>3、安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">进入安装界面：Install openEuler 20.09...Test this media &amp; install openEuler 20.09...Troubleshooting选择到Install openEuler 20.09...行Ctrl + e 进入编辑界面删除&quot;video&#x3D;efifb:off&quot;Ctrl + x 保存并退出，进入图形化安装界面</code></pre></div></figure><blockquote><p>为什么要删除此grub参数？ —直接安装将卡在此界面</p><p>EFI stub: Booting Linux Kernel…</p><p>EFI stub: EFI_RNG_PROTOCOL unavaliable, no randomness supplied</p><p>EFI stub: Using DTB from configuration table</p><p>EFT stub: Exiting boot services and installing virtual address map…</p></blockquote><p>4、启动系统</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">进入系统后，修改&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;openEuler&#x2F;grub.cfg文件同样，将&quot;video&#x3D;efifb:off&quot;注释或者删除&gt;&gt;防止重启卡在引导界面</code></pre></div></figure><p>5、无线网卡连接wifi</p><blockquote><p>TD120A2安装OpenEuler后,有线网卡无法识别，需要安装USB无线网卡，并安装配套的驱动，无线网卡识别后可以连接wifi</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmcli dev wifi # 查询wifinmcli dev wifi connet 网络名 password 密码</code></pre></div></figure><p>6、图形化界面安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo dnf makecachesudo dnf groupinstall ukuisystemctl set-default graphical</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux问题处理</title>
    <link href="/2022/07/08/06_%E6%9D%82%E8%AE%B0/linux%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <url>/2022/07/08/06_%E6%9D%82%E8%AE%B0/linux%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1、机器卡顿、慢"><a href="#1、机器卡顿、慢" class="headerlink" title="1、机器卡顿、慢"></a>1、机器卡顿、慢</h1><p>测试硬盘读写：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 测试写time dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;tmp&#x2F;test bs&#x3D;8k count&#x3D;1000000# 测试读time dd if&#x3D;&#x2F;tmp&#x2F;test of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;8k# 测试读写time dd if&#x3D;&#x2F;tmp&#x2F;test of&#x3D;&#x2F;var&#x2F;test bs&#x3D;64k</code></pre></div></figure><p>硬盘坏道测试：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">badblocks -s -o -v test.log &#x2F;dev&#x2F;sda</code></pre></div></figure><p>2、查看NVME硬盘使用时间，机器使用时间</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nvme smart-log &#x2F;dev&#x2F;nvme0n1# 看power_on_hour </code></pre></div></figure><p>查看系统安装时间、文件系统创建时间、挂在次数（开机次数）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tune2fs -l &#x2F;dev&#x2F;sda2# Filesystem created: 文件系统创建时间即系统安装时间# Mount count：挂在次数，即开机次数</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客维护</title>
    <link href="/2022/07/07/06_%E6%9D%82%E8%AE%B0/hexo%E7%BB%B4%E6%8A%A4/"/>
    <url>/2022/07/07/06_%E6%9D%82%E8%AE%B0/hexo%E7%BB%B4%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Hexo博客维护"><a href="#1-Hexo博客维护" class="headerlink" title="1 Hexo博客维护"></a>1 Hexo博客维护</h2><p>版本：<code>Next 8.12.2</code></p><p>1、下载安装nodejs</p><p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>2、切换npm为阿里源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre></div></figure><p>3、使用npm安装hexo</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli</code></pre></div></figure><blockquote><p>否则会报错:</p><p>$ hexo clean<br>ERROR Cannot find module ‘hexo’ from ‘C:\Users\fr724\Desktop\新建文件夹\gsproj.github.io’<br>ERROR Local hexo loading failed in ~\Desktop\新建文件夹\gsproj.github.io<br>ERROR Try running: ‘rm -rf node_modules &amp;&amp; npm install –force’</p></blockquote><p>4、使用npm安装搜索功能依赖</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-excerpt --save</code></pre></div></figure><p>5、内容上线</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo ghexo d # 上线到githubiohexo s # 本地试运行</code></pre></div></figure><h2 id="2-功能添加"><a href="#2-功能添加" class="headerlink" title="2 功能添加"></a>2 功能添加</h2><h3 id="2-1-搜索功能"><a href="#2-1-搜索功能" class="headerlink" title="2.1 搜索功能"></a>2.1 搜索功能</h3><p>安装依赖</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-searchdb --save</code></pre></div></figure><p>修改主题设置文件<code>themes/next/_config.yml</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Local Search# Dependencies: https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-generator-searchdblocal_search:  enable: true# 此处改为true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false</code></pre></div></figure><h3 id="2-2-菜单显示归档-书签"><a href="#2-2-菜单显示归档-书签" class="headerlink" title="2.2 菜单显示归档&#x2F;书签"></a>2.2 菜单显示归档&#x2F;书签</h3><p>修改主题设置文件next&#x2F;_config.yml</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">menu:  #home: &#x2F; || fa fa-home  #about: &#x2F;about&#x2F; || fa fa-user  tags: &#x2F;tags&#x2F; || fa fa-tags# 取消注释  categories: &#x2F;categories&#x2F; || fa fa-th# 取消注释  archives: &#x2F;archives&#x2F; || fa fa-archive# 取消注释  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</code></pre></div></figure><p>效果如下图：</p><p><img src="/../../img/image-20220719101836015.png" alt="image-20220719101836015"></p><h3 id="2-3-鼠标点击烟花效果"><a href="#2-3-鼠标点击烟花效果" class="headerlink" title="2.3 鼠标点击烟花效果"></a>2.3 鼠标点击烟花效果</h3><p>下载<a href="https://aliyun-oss-pic-bucket.oss-cn-beijing.aliyuncs.com/file/fireworks.js">fireworks.js</a>文件放到<code>themes/next/source\js\cursor</code>中</p><p>创建<code>themes/next/layout/_custom</code>文件夹，并在其中创建<code>custom.swig</code>文件，内容如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123;# 鼠标点击烟花特效 #&#125;&#123;% if theme.cursor_effect &#x3D;&#x3D; &quot;fireworks&quot; %&#125;  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;explosion&quot; %&#125;  &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;  &lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt;  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;explosion.min.js&quot;&gt;&lt;&#x2F;script&gt;&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;love&quot; %&#125;  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;love.min.js&quot;&gt;&lt;&#x2F;script&gt;&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;text&quot; %&#125;  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;text.js&quot;&gt;&lt;&#x2F;script&gt;&#123;% endif %&#125;</code></pre></div></figure><p>编辑&#96;themes&#x2F;next&#x2F;layout&#x2F;_layout.njk文件，在尾行导入swig文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">...  &#123;&#123; partial(&#39;_scripts&#x2F;index.njk&#39;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#39;_third-party&#x2F;index.njk&#39;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#39;_third-party&#x2F;statistics&#x2F;index.njk&#39;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;%- include &#39;_third-party&#x2F;math&#x2F;index.njk&#39; -%&#125;  &#123;%- include &#39;_third-party&#x2F;quicklink.njk&#39; -%&#125;  &#123;&#123;- next_inject(&#39;bodyEnd&#39;) &#125;&#125;  &#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;# 导入swig文件&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>编辑<code>themes/next/_config.yml</code>文件，添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 鼠标点击烟花特效cursor_effect: fireworks</code></pre></div></figure><blockquote><p><strong>PS:一个小修改，防止烟花残留</strong></p><p>参考：<a href="https://yfx2012.top/2022/01/17/hexo/mouse-click-fireworks/">https://yfx2012.top/2022/01/17/hexo/mouse-click-fireworks/</a></p><p>修改firewaors.js文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">handlePageHide() &#123;  this.booms &#x3D; []  this.running &#x3D; false  &#x2F;&#x2F; 简单修改，清理停留不动的烟火特效  this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight)  this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight)&#125;</code></pre></div></figure></blockquote><h3 id="2-4-关闭文章目录的自动章节号"><a href="#2-4-关闭文章目录的自动章节号" class="headerlink" title="2.4 关闭文章目录的自动章节号"></a>2.4 关闭文章目录的自动章节号</h3><p>未修改前，自动排了序号，看上去很乱：</p><p><img src="/../../img/image-20220719104324299.png" alt="image-20220719104324299"></p><p>修改主题配置文件<code>/themes/next/_config.yml</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">toc:  enable: true  # Automatically add list number to toc.  number: false# 改为false关闭  # If true, all words will placed on next lines if header width longer then sidebar width.  wrap: false  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.  expand_all: false  # Maximum heading depth of generated toc.  max_depth: 6</code></pre></div></figure><p>修改后，清爽了很多：</p><p><img src="/../../img/image-20220719104519550.png" alt="image-20220719104519550"></p><h3 id="2-5-添加头像"><a href="#2-5-添加头像" class="headerlink" title="2.5 添加头像"></a>2.5 添加头像</h3><p>将头像文件放到<code>themes/next/source/images</code>中</p><p>修改主题配置文件<code>/themes/next/_config.yml</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Sidebar Avataravatar:  # Replace the default image and set the url here.  url: &#x2F;images&#x2F;myavatar.png</code></pre></div></figure><h3 id="2-6-修改背景图片"><a href="#2-6-修改背景图片" class="headerlink" title="2.6 修改背景图片"></a>2.6 修改背景图片</h3><blockquote><p>白花花的有点单调</p></blockquote><p>将背景图片放到<code>themes\next\source\images</code></p><p>新建<code>source\_data</code>文件夹（是hexo目录下的source,不是主题的source）</p><p>在<code>_data</code>中新建<code>styles.styl</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">body &#123;    background:url(&#x2F;images&#x2F;xhc.jpg);    background-repeat: no-repeat;    background-attachment:fixed;    background-position:50% 50%;    &#x2F;&#x2F; background-size: 100% 100%;    background-size: cover;    -webkit-background-size: cover;    -o-background-size: cover;    -moz-background-size: cover;    -ms-background-size: cover;&#125;</code></pre></div></figure><p>然后将<code>themes/next/_config.yml</code>配置文件中<code>custom_file_path:</code>下的<code>#style: source/_data/styles.styl</code>#号去掉，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">custom_file_path:  #head: source&#x2F;_data&#x2F;head.njk  #header: source&#x2F;_data&#x2F;header.njk  #sidebar: source&#x2F;_data&#x2F;sidebar.njk  #postMeta: source&#x2F;_data&#x2F;post-meta.njk  #postBodyEnd: source&#x2F;_data&#x2F;post-body-end.njk  #footer: source&#x2F;_data&#x2F;footer.njk  #bodyEnd: source&#x2F;_data&#x2F;body-end.njk  #variable: source&#x2F;_data&#x2F;variables.styl  #mixin: source&#x2F;_data&#x2F;mixins.styl  style: source&#x2F;_data&#x2F;styles.styl</code></pre></div></figure><h3 id="2-7-修改为圆角"><a href="#2-7-修改为圆角" class="headerlink" title="2.7 修改为圆角"></a>2.7 修改为圆角</h3><p>创建<code>source/_data/variables.styl</code>文件</p><p>在里面添加：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 圆角设置$border-radius-inner     &#x3D; 20px;$border-radius           &#x3D; 20px;</code></pre></div></figure><p>然后将<code>themes/next/_config.yml</code>配置文件中<code>custom_file_path:</code>下的<code>#style: source/_data/variables.styl</code>#号去掉，如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">custom_file_path:  #head: source&#x2F;_data&#x2F;head.njk  #header: source&#x2F;_data&#x2F;header.njk  #sidebar: source&#x2F;_data&#x2F;sidebar.njk  #postMeta: source&#x2F;_data&#x2F;post-meta.njk  #postBodyEnd: source&#x2F;_data&#x2F;post-body-end.njk  #footer: source&#x2F;_data&#x2F;footer.njk  #bodyEnd: source&#x2F;_data&#x2F;body-end.njk  variable: source&#x2F;_data&#x2F;variables.styl  #mixin: source&#x2F;_data&#x2F;mixins.styl  style: source&#x2F;_data&#x2F;styles.styl</code></pre></div></figure><p>部分微调:</p><p>1）侧边栏部分没有圆角</p><p>编辑2.6创建的<code>styles.styl</code>文件，添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">.site-brand-container &#123;    border-radius-inner: 20px 20px 0 0;    border-radius: 20px 20px 0 0;&#125;</code></pre></div></figure><p>2）返回顶部按钮显示为方形</p><p>编辑<code>themes\next\source\css\_variables\Gemini.styl</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">&#x2F;&#x2F; $body-bg-color           &#x3D; #eee;# 注释$body-bg-color           &#x3D; transparent;# 新增</code></pre></div></figure><h3 id="2-8-加载动画速度调整"><a href="#2-8-加载动画速度调整" class="headerlink" title="2.8 加载动画速度调整"></a>2.8 加载动画速度调整</h3><p>页面加载会有段动画，默认比较慢，可以调整</p><p>编辑文件<code>themes\next\source\js\motion.js</code>，调整<code>duration</code>的值，默认200，越大越慢，可以调小一些</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">bootstrap: function() &#123;    if (!CONFIG.motion.async) this.queue &#x3D; [this.queue];    this.queue.forEach(sequence &#x3D;&gt; &#123;        const timeline &#x3D; window.anime.timeline(&#123;            duration: 100,# 调整为100                easing  : &#39;linear&#39;        &#125;);        sequence.forEach(item &#x3D;&gt; &#123;            if (item.deltaT) timeline.add(item, item.deltaT);            else timeline.add(item);        &#125;);    &#125;);&#125;</code></pre></div></figure><h3 id="2-9-图片点击放大"><a href="#2-9-图片点击放大" class="headerlink" title="2.9 图片点击放大"></a>2.9 图片点击放大</h3><p>修改<code>themes/next/_config.yml</code>配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.# For more information: https:&#x2F;&#x2F;fancyapps.com&#x2F;fancybox&#x2F;fancybox: true</code></pre></div></figure><h3 id="2-10-界面透明"><a href="#2-10-界面透明" class="headerlink" title="2.10 界面透明"></a>2.10 界面透明</h3><p>修改<code>source\_data\styles.styl</code>文件，添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 界面透明.main-inner&#123;opacity: 0.9;&#125;.header-inner&#123;opacity: 0.9;z-index: 10;&#125;</code></pre></div></figure><h3 id="2-11-mac代码块"><a href="#2-11-mac代码块" class="headerlink" title="2.11 mac代码块"></a>2.11 mac代码块</h3><p>修改hexo的<code>_config.yml</code>文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">highlight:  enable: true# 开启highlight渲染引擎  line_number: true  auto_detect: true  tab_replace: &#39;&#39;  wrap: true  hljs: falseprismjs:  enable: false# 关闭prismjs渲染引擎  preprocess: true  line_number: true  tab_replace: &#39;&#39;</code></pre></div></figure><p>修改<code>themes/next/_config.yml</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">codeblock:  # Code Highlight theme  # All available themes: https:&#x2F;&#x2F;theme-next.js.org&#x2F;highlight&#x2F;  theme:    light: a11y-dark# 选用highlight引擎，并启用a11y-dark风格    dark: stackoverflow-dark  prism:    light: docco    dark: prism-dark  # Add copy button on codeblock  copy_button:    enable: true    # Available values: default | flat | mac    style: mac# 启用mac风格</code></pre></div></figure><p>效果：</p><p><img src="/../../img/image-20220720150943450.png" alt="image-20220720150943450"></p><h3 id="2-12-添加回到顶部按钮-小猫"><a href="#2-12-添加回到顶部按钮-小猫" class="headerlink" title="2.12 添加回到顶部按钮-小猫"></a>2.12 添加回到顶部按钮-小猫</h3><p>将小猫图片放到<code>themes/next/source/images</code>中</p><p>编辑2.6创建的<code>styles.styl</code>文件，添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F;自定义回到顶部样式.back-to-top &#123;  right: 60px;  width: 70px;  &#x2F;&#x2F;图片素材宽度  height: 900px;  &#x2F;&#x2F;图片素材高度  top: -900px;  bottom: unset;  transition: all .5s ease-in-out;  background: url(&quot;&#x2F;images&#x2F;scroll.png&quot;);  &#x2F;&#x2F;隐藏箭头图标  &gt; i &#123;    display: none;  &#125;  &amp;.back-to-top-on &#123;    bottom: unset;    top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;  &#125;&#125;</code></pre></div></figure><p>编辑<code>themes/next/_config.yml</code>文件，打开返回顶部按钮开关</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">back2top:  enable: true# 改为true打开  # Back to top in sidebar.  sidebar: false  # Scroll percent label in b2t button.  scrollpercent: false</code></pre></div></figure><h3 id="2-13-给blockquote添加颜色"><a href="#2-13-给blockquote添加颜色" class="headerlink" title="2.13 给blockquote添加颜色"></a>2.13 给blockquote添加颜色</h3><p>编辑<code>themes\next\source\css\_common\scaffolding\base.styl</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">blockquote &#123;  border-left: 4px solid $grey-lighter;  color: var(--blockquote-color);  margin: 0;  padding: 0 15px;  &#x2F;&#x2F; 添加颜色  padding-left: 10px;  background-color rgba(212,239,223,.6);  border-left 4px solid rgb(30,132,73);  cite::before &#123;    content: &#39;-&#39;;    padding: 0 5px;  &#125;&#125;</code></pre></div></figure><p>效果如下：</p><blockquote><p><font color=blue><strong>TIPS:</strong></font></p><p>这是一段Blockquote的演示文字</p></blockquote><h3 id="2-14-修改选中文字底色"><a href="#2-14-修改选中文字底色" class="headerlink" title="2.14 修改选中文字底色"></a>2.14 修改选中文字底色</h3><p>编辑2.6创建的<code>styles.styl</code>文件，添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 修改选中文字底色&#x2F;* webkit, opera, IE9 *&#x2F;::selection &#123;     background: #00c4b6;    color: #f7f7f7; &#125;&#x2F;* firefox *&#x2F;::-moz-selection &#123;     background: #00c4b6;    color: #f7f7f7;    &#125;</code></pre></div></figure><h3 id="2-15-添加阅读全文功能"><a href="#2-15-添加阅读全文功能" class="headerlink" title="2.15 添加阅读全文功能"></a>2.15 添加阅读全文功能</h3><p>安装插件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-excerpt --save</code></pre></div></figure><p>编辑hexo的<code>_config.yml</code>文件，添加以下内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 阅读全文excerpt:  depth: 1# 他的大小就是全文阅读预览长度设置  excerpt_excludes: []  more_excludes: []  hideWholePostExcerpts: true</code></pre></div></figure><p>编辑主题的<code>_config.yml</code>文件，添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">excerpt_description: true</code></pre></div></figure><h3 id="2-16-开启不蒜子统计访问量"><a href="#2-16-开启不蒜子统计访问量" class="headerlink" title="2.16 开启不蒜子统计访问量"></a>2.16 开启不蒜子统计访问量</h3><p>编辑<code>themes\next\layout\_partials\footer.njk</code>文件，在<code>首行</code>添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;script  async  src&#x3D;&quot;https:&#x2F;&#x2F;dn-lbstatics.qbox.me&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre></div></figure><p>编辑主题配置文件<code>themes\next\_config.yml</code>，开启设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">busuanzi_count:  enable: true# 开启  total_visitors: true  # 访客数  total_visitors_icon: fa fa-user  total_views: true # 访问量  total_views_icon: fa fa-eye  post_views: true  post_views_icon: far fa-eye</code></pre></div></figure><h3 id="2-17-字体大小修改"><a href="#2-17-字体大小修改" class="headerlink" title="2.17 字体大小修改"></a>2.17 字体大小修改</h3><p>编辑<code>themes\next\source\css\_variables\base.styl</code>, 修改字体大小</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; Font size$font-size-base           &#x3D; (hexo-config(&#39;font.enable&#39;) and hexo-config(&#39;font.global.size&#39;) is a &#39;unit&#39;) ? unit(hexo-config(&#39;font.global.size&#39;), em) : 1em;$font-size-smallest       &#x3D; 10px;$font-size-smaller        &#x3D; 11px;$font-size-small          &#x3D; 12px;$font-size-medium         &#x3D; 13px;$font-size-large          &#x3D; 14px;$font-size-larger         &#x3D; 15px;$font-size-largest        &#x3D; 22px;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器日志收集与分析</title>
    <link href="/2022/07/06/02_%E6%B5%8B%E8%AF%95/04_%E9%95%BF%E5%9F%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/06/02_%E6%B5%8B%E8%AF%95/04_%E9%95%BF%E5%9F%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>23952000000040761600</p><h1 id="服务器日志收集与分析"><a href="#服务器日志收集与分析" class="headerlink" title="服务器日志收集与分析"></a>服务器日志收集与分析</h1><h1 id="一、日志收集"><a href="#一、日志收集" class="headerlink" title="一、日志收集"></a>一、日志收集</h1><h2 id="1-1-基本信息收集"><a href="#1-1-基本信息收集" class="headerlink" title="1.1 基本信息收集"></a>1.1 基本信息收集</h2><h3 id="1-1-1-服务器状态确认"><a href="#1-1-1-服务器状态确认" class="headerlink" title="1.1.1 服务器状态确认"></a>1.1.1 服务器状态确认</h3><p>服务器故障的6个状态，根据不同的状态来收集日志</p><table><thead><tr><th>序</th><th align="left">机器状态</th><th>收集信息</th><th>主要部件</th></tr></thead><tbody><tr><td>1</td><td align="left">无供电输入</td><td>机器外观检查（开关面板、主板灯、PSU灯、供电线、PDU）</td><td>PSU、主板、PDU</td></tr><tr><td>2</td><td align="left">有供电输入，无法启动</td><td>BMC日志</td><td>主板、CPU、DIMM000内存、BMC</td></tr><tr><td>3</td><td align="left">可以启动但无法完成POST自检</td><td>BMC日志、串口输出</td><td>主板、内存、CPU、BIOS</td></tr><tr><td>4</td><td align="left">POST自检完成，但没有开始加载操作系统</td><td>BMC日志、串口输出、RAID卡日志</td><td>PCIE设备、硬盘、操作系统、主板</td></tr><tr><td>5</td><td align="left">操作系统开始加载，但加载失败</td><td>BMC日志、串口输出</td><td>操作系统、主板、CPU、BIOS、CPLD</td></tr><tr><td>6</td><td align="left">操作系统加载完成，但运行中意外中断</td><td>BMC日志、串口输出、操作系统日志</td><td>内存、CPU、主板、操作系统、软件</td></tr></tbody></table><h3 id="1-1-2-日志收集场景"><a href="#1-1-2-日志收集场景" class="headerlink" title="1.1.2 日志收集场景"></a>1.1.2 日志收集场景</h3><table><thead><tr><th>故障场景</th><th>信息收集</th></tr></thead><tbody><tr><td>所有故障</td><td>BMC一键日志（长城BMC）</td></tr><tr><td>服务器启动异常</td><td>串口日志</td></tr><tr><td>操作系统死机-死机状态下</td><td>检查内存ECC、重传</td></tr><tr><td>操作系统死机-重启恢复后</td><td>操作系统日志、阵列卡日志</td></tr><tr><td>操作系统意外重启-重启恢复后</td><td>操作系统日志、阵列卡日志</td></tr><tr><td>操作系统意外重启-安排时间压测</td><td>检查内存ECC、重传</td></tr><tr><td>硬盘、阵列卡故障</td><td>阵列卡日志、硬盘SMART日志</td></tr><tr><td>网络相关故障</td><td>操作系统日志、网络拓扑图</td></tr></tbody></table><h2 id="1-2-BMC日志"><a href="#1-2-BMC日志" class="headerlink" title="1.2 BMC日志"></a>1.2 BMC日志</h2><h3 id="1-2-1-BMC一键收集日志"><a href="#1-2-1-BMC一键收集日志" class="headerlink" title="1.2.1 BMC一键收集日志"></a>1.2.1 BMC一键收集日志</h3><p><strong><font color=red>长城服务器方法</font></strong></p><p>通过BMC日志一键导出功能，可以拿到日志文件压缩包：</p><p>​文件名例如：bmc_logs_YYYY_MM_DD_hh_mm_ss.tar.gz</p><p>日志文件描述和作用如下图所示：</p><p><img src="/../../img/image-20230711145254602.png" alt="BMC一键收集日志解释"></p><h3 id="1-2-2-传感器事件日志"><a href="#1-2-2-传感器事件日志" class="headerlink" title="1.2.2 传感器事件日志"></a>1.2.2 传感器事件日志</h3><p>传感器（SEL）事件日志：主要包含温度、系统、电压、电流、电源和风扇所产生的日志  </p><h4 id="1-2-2-1-事件主体"><a href="#1-2-2-1-事件主体" class="headerlink" title="1.2.2.1 事件主体"></a>1.2.2.1 事件主体</h4><p>事件主体分为：传感器类型 + 传感器码ID，如图所示：</p><p><img src="/../../img/image-20230712092419930.png" alt="传感器事件截图"></p><h4 id="1-2-2-2-传感器代码ID和释义"><a href="#1-2-2-2-传感器代码ID和释义" class="headerlink" title="1.2.2.2 传感器代码ID和释义"></a>1.2.2.2 传感器代码ID和释义</h4><p><img src="/../../img/image-20230712092533841.png" alt="传感器代码ID和释义图1"></p><p><img src="/../../img/image-20230712092543284.png" alt="传感器代码ID和释义图2"></p><p><img src="/../../img/image-20230712092553006.png" alt="传感器代码ID和释义图3"></p><p><img src="/../../img/image-20230712092611926.png" alt="传感器代码ID和释义图4"></p><h4 id="1-2-2-3-事件描述"><a href="#1-2-2-3-事件描述" class="headerlink" title="1.2.2.3 事件描述"></a>1.2.2.3 事件描述</h4><table><thead><tr><th>事件描述</th><th>构成释义</th></tr></thead><tbody><tr><td>Lower Non-critical going low</td><td>低警告</td></tr><tr><td>Lower Non-critical going high</td><td>低警告</td></tr><tr><td>Lower Critical going low</td><td>低严重警告</td></tr><tr><td>Lower Critical going high</td><td>低严重警告</td></tr><tr><td>Lower Non-recoverable going low</td><td>低不可恢复</td></tr><tr><td>Lower Non-recoverable going high</td><td>低不可恢复</td></tr><tr><td>Upper Non-critical going low</td><td>高警告</td></tr><tr><td>Upper Non-critical going high</td><td>高警告</td></tr><tr><td>Upper Critical going low</td><td>高严重警告</td></tr><tr><td>Upper Critical going high</td><td>高严重警告</td></tr><tr><td>Upper Non-recoverable going low</td><td>高不可恢复</td></tr><tr><td>Upper Non-recoverable going high</td><td>高不可恢复</td></tr></tbody></table><h4 id="1-2-2-4-事件状态"><a href="#1-2-2-4-事件状态" class="headerlink" title="1.2.2.4 事件状态"></a>1.2.2.4 事件状态</h4><p>事件分为两个状态：</p><ul><li>Asserted：已产生</li><li>Deasserted：已处理</li></ul><h3 id="1-2-3-部件事件日志"><a href="#1-2-3-部件事件日志" class="headerlink" title="1.2.3 部件事件日志"></a>1.2.3 部件事件日志</h3><p>部件事件日志：主要包含硬盘、内存、PSU所产生的日志  </p><p><img src="/../../img/image-20230712093227704.png" alt="image-20230712093227704"></p><h3 id="1-2-4-审计日志"><a href="#1-2-4-审计日志" class="headerlink" title="1.2.4 审计日志"></a>1.2.4 审计日志</h3><p>查看用户历史操作记录，常用 于 BMC 出错时分析是否为人为操作出错  </p><p>日志格式：</p><p>操作日志主要由操作对象、操作对象信息、操作内容和操作时间构成 。</p><p><img src="/../../img/image-20230712094938711.png" alt="image-20230712094938711"></p><h3 id="1-2-5-串口位置"><a href="#1-2-5-串口位置" class="headerlink" title="1.2.5 串口位置"></a>1.2.5 串口位置</h3><p>一般服务器后置设有 CPU0 系统串口, 下图中编号③是RJ45规格的 CPU0 系统串口  </p><p><img src="/../../img/image-20230712095029546.png" alt="image-20230712095029546"></p><h1 id="二、飞腾S2500-CPU特性和问题排查"><a href="#二、飞腾S2500-CPU特性和问题排查" class="headerlink" title="二、飞腾S2500 CPU特性和问题排查"></a>二、飞腾S2500 CPU特性和问题排查</h1><h2 id="2-1-CPU架构解释"><a href="#2-1-CPU架构解释" class="headerlink" title="2.1 CPU架构解释"></a>2.1 CPU架构解释</h2><h3 id="2-1-1-对称多处理器架构"><a href="#2-1-1-对称多处理器架构" class="headerlink" title="2.1.1 对称多处理器架构"></a>2.1.1 对称多处理器架构</h3><p>SMP（SymmetricalMulti-Processing）对称多处理器架构</p><p>所谓对称多处理器结构，是指服务器中多个CPU对称工作，无主次或从属关系。各CPU共享相同的物理内存，每</p><p>个 CPU访问内存中的任何地址所需时间是相同的，因此SMP也被称为一致存储器访问结构(UMA：UniformMemory </p><p>Access)。</p><p>例如一个主板能放置4颗CPU，若每颗4核，一共就有16个核心，在这种架构下，多个CPU对应一个内存，内存控制</p><p>器也是只有一个的，当其中的一个CPU去与内存控制器进行交互的时候，其它CPU此时此刻不能同时与内存控制器</p><p>交互，即每个CPU通过相同的内存总线访问相同的内存资源，因此随着CPU数量的增加，内存访问冲突将迅速增</p><p>加，最终会造成CPU资源的浪费，使 CPU性能的有效性大大降低  </p><p><img src="/../../img/image-20230712140826899.png" alt="image-20230712140826899"></p><h3 id="2-1-2-NUMA架构"><a href="#2-1-2-NUMA架构" class="headerlink" title="2.1.2 NUMA架构"></a>2.1.2 NUMA架构</h3><p>NUMA（Non-Uniform Memory Access Architecture，非一致性内存访问）架构</p><p>NUMA是一种分布式存储器访问方式,处理器可以同时访问不同的存储器地址，大幅度提高并行性。NUMA 系统的节</p><p>点通常是由一组 CPU 和本地内存组成。由于每个节点都有自己的本地内存,因此全系统的内存在物理上是分布的,每</p><p>个节点访问本地内存和访问其它节点的内存的延迟是不同的。每个核访问内存的时间取决于内存相对于处理器的位</p><p>置，访问本地内存(本节点内)会更快一些。Linux 内核从2.5 版本开始支持 NUMA 架构,现在的操作系统也提供了丰富</p><p>的工具和接口,帮助我们完成就近访问内存的优化和配置。操作系统如果可以根据任务所在CPU去分配本地内存，</p><p>就是基于CPU NUMA亲和性考虑 。</p><p><img src="/../../img/image-20230712141043534.png" alt="image-20230712141043534"></p><h2 id="2-2-飞腾CPU特性和问题排查"><a href="#2-2-飞腾CPU特性和问题排查" class="headerlink" title="2.2 飞腾CPU特性和问题排查"></a>2.2 飞腾CPU特性和问题排查</h2><h3 id="2-2-1-FT2000-CPU架构"><a href="#2-2-1-FT2000-CPU架构" class="headerlink" title="2.2.1 FT2000+ CPU架构"></a>2.2.1 FT2000+ CPU架构</h3><p>FT2000+&#x2F;64 处理器芯片集成的 64 个处理器核心，一个芯片共有 8 个 NUMA 节点，分别对应为 Panel0~7。每个 </p><p>Panel 中有两个 Cluster(每个 Cluster 包含 4 个处理器核心)、4M 二级 cache、两个本地目录控制部件(DCU)、一个片</p><p>上网络路由器节点(Cell)和一个紧密耦合的访存控制器 (mcu)</p><p><img src="/../../img/image-20230712141128241.png" alt="image-20230712141128241"></p><h3 id="2-2-2-S2500-CPU架构"><a href="#2-2-2-S2500-CPU架构" class="headerlink" title="2.2.2 S2500 CPU架构"></a>2.2.2 S2500 CPU架构</h3><p>相对于FT2000+，S2500增加了L3 cache和DLU（直通模块）。同一个 NUMA 节点的两个核通过 cell 内部来通</p><p>讯，不同的 Panel 之间通过内部总线来通讯，PCIe控制器挂在 Panel0 上。S2500 支持 2、4、8 路，socket 之间通过 </p><p>FIT 来进行通讯 。</p><p>NUMA 架构下，不同的核访存性能是有较大的差异的，节点内访问本地内存性能最优，socket 内跨节点访存次之，</p><p>跨 socket 访存最差。  </p><p><img src="/../../img/image-20230712141252208.png" alt="image-20230712141252208"></p><h3 id="2-2-3-飞腾CPU-NUMA特性使用注意事项"><a href="#2-2-3-飞腾CPU-NUMA特性使用注意事项" class="headerlink" title="2.2.3 飞腾CPU NUMA特性使用注意事项"></a>2.2.3 飞腾CPU NUMA特性使用注意事项</h3><p>飞腾 CPU 是遵循 NUMA 架构特征设计的处理器，处理器本身并不支持“关闭 NUMA”的功能。目前，BIOS 或<br>OS 层面所谓“关闭 NUMA”只是关闭上层软件层面的对 NUMA 特性的感知，硬件的 NUMA 特性依然存在。这种假<br>的“关闭 NUMA”的软件做法，会导致应用的实际运行性能无法正确体现硬件的真实能力，严重降低系统的实际运行<br>效率。而且，这种软件错误掩盖硬件 NUMA 特性的使用方式，还会导致系统跨 NUMA 访问操作超出应用正常行为该<br>有的访问量，对系统的稳定性也会带来一定程度的损害。<br>因此，要求飞腾 CPU 系统必须打开 NUMA 特性，这是处理器设计、实现的硬件特性，软件无法将其正确关闭  </p><p>\1. Linux 内核从 2.5 版本开始支持 NUMA 架构，要求 BIOS 和 OS 根据 CPU 的 NUMA 设计实际情况正确使用<br>这些特性，特别注意不要直接将这些软件特性关闭。<br>\2. 使用绑核等措施，利用 cpu 的亲和性和内存的分配策略，让进程与内存的距离“更短”，达到最优性能。绑核<br>手段包含不限于：内核态的 sched_setaffinity 接口；用户态的 numactrl 工具；典型的业务软件绑核配置，例如<br>Nginx 的 nginx.conf 文件中的 worker_cpu_affinity 参数<br>\3. 合理适配内核代码，通过 pcie numa 特性，让外设识别自己的 numa 域，让 DMA 分配“更近”，达到最优<br>性能。典型的内核接口 set_dev_node(struct device *dev, int node);<br>\4. 根据业务场景合理配置外设，减少业务数据的跨 Panel，跨 socket 的数据访问  </p><h3 id="2-2-4-S2500-直连接口-FIT-信号介绍"><a href="#2-2-4-S2500-直连接口-FIT-信号介绍" class="headerlink" title="2.2.4 S2500 直连接口 FIT 信号介绍"></a>2.2.4 S2500 直连接口 FIT 信号介绍</h3><p>腾云 S2500 实现了四路直连接口，通过直连接口将多个腾云 S2500 单芯片连接起来，组成一个支持全局数据共<br>享的系统，并且之间可以共享全局内存地址空间。<br>腾云 S2500 处理器共 4 个直连接口，每个接口组成为 4 Lane，单 Lane 速率 25Gbps。  </p><p><img src="/../../img/image-20230712141415321.png" alt="image-20230712141415321"></p><h3 id="2-2-5-FIT误码"><a href="#2-2-5-FIT误码" class="headerlink" title="2.2.5 FIT误码"></a>2.2.5 FIT误码</h3><p>FIT 链路的稳定性是机器运行的基础，为避免后期由于主板稳定性而导致的量产出货问题，特此增加误码测试。<br>误码测试：更新误码测试专用BIOS，重启机器后自动进入误码测试，一个CPU发送伪随机码，另一个CPU接收并<br>进行判定，通过服务器串口监控误码测试情况。误码标准为：5小时低于20个。  </p><p><img src="/../../img/image-20230712141503675.png" alt="image-20230712141503675"></p><h3 id="2-2-6-重传次数计数器"><a href="#2-2-6-重传次数计数器" class="headerlink" title="2.2.6 重传次数计数器"></a>2.2.6 重传次数计数器</h3><p>误码测试是在物理层的测试，重传计数是数据链路层记录的。数据经过数据链路层，每发生一次误码，就会使得<br>数据链路层触发重传。重传主要用于排查片间连接 FIT 时是否发生某些错误信息，协助定位问题点。<br>重传测试：通过操作系统下跨路stream测试，产生CPU之间的数据流量压力。重传计数可通过带内工具或带外工<br>具获取，测试开始前后各读取一次重传值，计算重传增长情况。重传标准为：每小时低于10个。  </p><p><img src="/../../img/image-20230712141548925.png" alt="image-20230712141548925"></p><h3 id="2-2-7-FIT-误码问题排查"><a href="#2-2-7-FIT-误码问题排查" class="headerlink" title="2.2.7 FIT 误码问题排查"></a>2.2.7 FIT 误码问题排查</h3><p>F625通用BMC固件625FME50 版本后，加入误码数值超阈值上报BMC事件日志的功能  </p><p><img src="/../../img/image-20230712141742086.png" alt="image-20230712141742086"></p><p>带外、带内脚本监控FIT误码和重传数量的脚本使用方法，参考内存问题排查章节中的“带外内存ECC和重传检<br>测”。  </p><p>如误码或重传测试结果超出标准，针对F625的建议解决方案如下，针对F630则跳过第2、3步。<br>\1. 检查主板上是否有散热膏等异物沾污，先清理异物；<br>\2. 使用电源烧录固件V1.4更新电源固件，优化电源固件环参；<br>\3. 更新BIOS版本至625FBE55GW或以上，优化FIT链路参数；<br>\4. 重新测试误码、重传，如未解决问题，更换主板  </p><h2 id="2-3-内存问题排查"><a href="#2-3-内存问题排查" class="headerlink" title="2.3 内存问题排查"></a>2.3 内存问题排查</h2><h3 id="2-3-1-内存报错类型"><a href="#2-3-1-内存报错类型" class="headerlink" title="2.3.1 内存报错类型"></a>2.3.1 内存报错类型</h3><p>correctable error &amp; uncorrectable error</p><p> Correctable error，如果错误能被检测和纠正，则认为是可纠正错误。这可以通过重试读取或使用ECC数据计算<br>正确的存储器内容并将正确的数据写回到存储器中来实现。<br>CE通常是Single Bit Error，也可能是某些类型的Multi-bit error（Intel X86 CPU支持的SDDC能检查并纠正一位<br>或多位（最大4位）内存故障）。通常CE是soft error引起的，如果CE长时间存在在同一位置，则可能是潜在的Hard<br>error。<br>Uncorrectable error，不可纠正的错误是平台无法纠正的multi-bit错误。 这些可能是由soft errors或hard<br>errors的任意组合引起的，但通常是由于多个hard errors而发生的。<br>运行时遇到UCE，可能导致灾难性的处理器崩溃或死机，需要重新启动受影响的服务器，并替换位于错误根源的<br>组件。  </p><h3 id="2-3-2-内存问题排查方法"><a href="#2-3-2-内存问题排查方法" class="headerlink" title="2.3.2 内存问题排查方法"></a>2.3.2 内存问题排查方法</h3><p>• 每个内存通道提供ECC错误寄存器，记录可纠正错误和不可纠正错误<br>• 可通过带内工具或带外工具获取内存ECC计数值<br>• 重启服务器后内存ECC计数将清零，如遇宕机情况，需要在机器重启前检查ECC计数<br>• 内存ECC标准：可纠正错误每小时增长少于6000个，不可纠正错误为0  </p><p><img src="/../../img/image-20230712142000251.png" alt="image-20230712142000251"></p><p>F625通用BMC固件625FME50 版本后，加入内存ECC报错超阈值上报BMC事件日志的功能。  </p><p><img src="/../../img/image-20230712142021427.png" alt="image-20230712142021427"></p><p>操作系统日志中，Internal error 代码96000210一般由内存硬件故障引起  </p><p><img src="/../../img/image-20230712142054048.png" alt="image-20230712142054048"></p><h3 id="2-3-3-内存压测方法"><a href="#2-3-3-内存压测方法" class="headerlink" title="2.3.3 内存压测方法"></a>2.3.3 内存压测方法</h3><h4 id="2-3-3-1-带内压测内存和ECC检测（适用所有服务器）"><a href="#2-3-3-1-带内压测内存和ECC检测（适用所有服务器）" class="headerlink" title="2.3.3.1 带内压测内存和ECC检测（适用所有服务器）"></a>2.3.3.1 带内压测内存和ECC检测（适用所有服务器）</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">一、准备1. 固件版本无特殊要求2. 操作系统建议是麒麟V10 SP13. ECC误码检测工具脚本工具包:ecc_check.V1.0.10.zip二、上传检测工具到待测机器1. ecc_check.V1.0.10.zip复制到桌面和进入目录，解压unzip ecc_check.V1.0.10.zip2. 进入解压目录，修改执行权限，依次输入指令：(需要root权限)sudo -s &#x2F;&#x2F;输入root密码chmod 751 *  三、运行脚本1. 执行memtester内存压力测试脚本，命令：sudo .&#x2F;start_test.sh（压测所需时间和内存容量大小相关，512GB 可能需要4-8小时，期间需要暂停系统其他业务）如果不需要测memtester内存压力，只查询内存ECC命令：.&#x2F;ecc_check.sh2. 等待测试完成  </code></pre></div></figure><h4 id="2-3-3-1-带外压测内存和ECC检测（适用于F625和F630）"><a href="#2-3-3-1-带外压测内存和ECC检测（适用于F625和F630）" class="headerlink" title="2.3.3.1 带外压测内存和ECC检测（适用于F625和F630）"></a>2.3.3.1 带外压测内存和ECC检测（适用于F625和F630）</h4><p>1、将gw_batch_ecc_check脚本拷入到堡垒机中  </p><p>2、编辑iplist.txt文件将需要测试的服务器的BMC的IP地址&#x2F;用户名&#x2F;密码&#x2F;ssh端口号(可选, 默认为22) 填入iplist.txt<br>中，保存退出 </p><p><img src="/../../img/image-20230712142301055.png" alt="image-20230712142301055"></p><p>3、修改batch_ecc_check.py的权限，运行sudo .&#x2F;batch_ecc_check.py，默认一次，可打印  </p><p>4、 Result输出相应的log，里面有独立的log和合在total文本，里面记录软硬件版本信息，温度信息，内存型号和<br>容量以及内存ECC和CPU重传情况，可以单独或者合在一起查看。<br>每次测完要单独建立一个文件夹保存起来，否则下次执行会被清除掉  </p><p><img src="/../../img/image-20230712142326107.png" alt="image-20230712142326107"></p><h2 id="2-4-硬盘问题排查"><a href="#2-4-硬盘问题排查" class="headerlink" title="2.4 硬盘问题排查"></a>2.4 硬盘问题排查</h2><h3 id="2-4-1-硬盘SMART日志"><a href="#2-4-1-硬盘SMART日志" class="headerlink" title="2.4.1 硬盘SMART日志"></a>2.4.1 硬盘SMART日志</h3><p>SMART的目的是监控硬盘的可靠性、预测磁盘故障和执行各种类型的磁盘自检。如今大部分的ATA&#x2F;SATA、<br>SCSI&#x2F;SAS和固态硬盘都搭载内置的SMART系统。作为行业规范，SMART规定了硬盘制造厂商应遵循的标准，满足<br>SMART标准的条件主要包括  </p><ol><li>在设备制造期间完成SMART需要的各项参数、属性的设定；</li><li>在特定系统平台下，能够正常使用SMART；通过BIOS检测，能够识别设备是否支持SMART并可显示相关信息，而且能辨别有效和失效的SMART信息；</li><li>允许用户自由开启和关闭SMART功能；</li><li>在用户使用过程中，能提供SMART的各项有效信息，确定设备的工作状态，并能发出相应的修正指令或警告</li></ol><h3 id="2-4-2-收集SMART日志的方法"><a href="#2-4-2-收集SMART日志的方法" class="headerlink" title="2.4.2 收集SMART日志的方法"></a>2.4.2 收集SMART日志的方法</h3><p>针对JBOD硬盘，阵列卡基本不会进行管理，硬盘报错将直接传递到操作系统。因此监控JBOD硬盘状态主要依靠<br>操作系统日志和硬盘SMART日志。  </p><p>收集SMART日志方法：smartctl -a &#x2F;dev&#x2F;sdX（硬盘对应的盘符）  </p><p>针对配置阵列里的硬盘，阵列卡会监控并记录硬盘状态和报错信息，可通过阵列卡日志和硬盘SMART日志分析硬<br>盘状态。针对阵列里的硬盘，收集SMART日志的方法如下  </p><p>1、通过storcli命令查看对应硬盘的did，例如：&#x2F;storcli &#x2F;call show all  </p><p><img src="/../../img/image-20230724082046260.png" alt="image-20230724082046260"></p><p>2、收集SMART日志，did替换成上一步查询到的did值：smartctl -a -d megaraid,did &#x2F;dev&#x2F;sdX  </p><h3 id="2-4-3-硬盘SMART日志内容"><a href="#2-4-3-硬盘SMART日志内容" class="headerlink" title="2.4.3 硬盘SMART日志内容"></a>2.4.3 硬盘SMART日志内容</h3><p>硬盘基本信息：  </p><p>包含硬盘厂家、原厂model、SN等基本信息  </p><p><img src="/../../img/image-20230724082132102.png" alt="image-20230724082132102"></p><p>硬盘整体状态：  </p><p>硬盘的每项SMART信息中都有一个临界值（阈值），SMART针对各项的当前值、最差值和临界值的比较结果以<br>及数据值进行分析后，提供硬盘当前的评估状态，是判断硬盘健康状态的重要信息。根据SMART的规定，状态一般有<br>正常、警告、故障或错误三种状态。<br>SMART判定这三个状态与SMART的 Pre-failure&#x2F;advisory BIT（预测错误&#x2F;发现位）参数的赋值密切相关，当<br>Pre-failure&#x2F;advisory BIT&#x3D;0，并且当前值、最差值远大于临界值的情况下，为正常标志。当Pre-failure&#x2F;advisory<br>BIT&#x3D;0，并且当前值、最差值大于但接近临界值时，为警告标志；当Pre-failure&#x2F;advisory BIT&#x3D;1，并且当前值、最差<br>值小于临界值时，为故障或错误标志硬盘整体健康状态结果  </p><p><img src="/../../img/image-20230724082212237.png" alt="image-20230724082212237"></p><p>SMART具体检测项 ：</p><blockquote><p>ID，通常是一个1到255之间的十进制或十六进制的数字，表示硬盘的各项检测参数。各硬盘制造商的绝大部分SMART ID代码所代表的参数含义是一致的，但厂商也可以根据需要使用不同的ID代码，或者根据检测项目的多少增减ID代码，不同厂家可能出现相同ID不同定义。</p></blockquote><blockquote><p>ATTRIBUTE_NAME，硬盘制造商<br>定义的属性名，即某一检测项目的名称，<br>是ID代码的文字解释。  </p></blockquote><blockquote><p>当前值（value），当前值是各ID项在硬盘运行时根据实测原始数据（Raw value）通过公式计算的结果，<br>1到253之间（最大正常值通常为100、200或253）。253意味着最好情况，1意味着最坏情况。随着使用损耗或出现错误，当前值会根据实测数据而不断刷新并逐渐减小。当前值接近临界值意味着发生故障的可能性增大，是判定硬盘健康状态或推测寿命的依据之一。  </p></blockquote><blockquote><p>最差值（Worst），最差值是硬盘运行时各ID项曾出现过的最小的value。最差值是对硬盘运行中某项数据变劣的峰值统计，该数值也会不断刷新。通常，最差值与当前值是相等的，如果最差值出现较大的波动（小于当前值），表明硬盘曾出现错误或曾经历过恶劣的工作环境（如温度）。 </p></blockquote><blockquote><p>临界值（Threshold） ，在报告硬盘FAILED状态前，Worst可以允许的最小值。临界值是硬盘厂商指定的表示某一项目可靠性的阈值，通过特定公式计算而得。如果某个参数的当前值接近了临界值，就意味着硬盘将变得不可靠。由于临界值是硬盘厂商根据自己产品特性而确定的，因此用厂商提供的专用检测软件往往会跟第三方软件的检测结果有较大出入。  </p></blockquote><blockquote><p>原始值(RAW_VALUE)，数据值是硬盘运行时各项参数的实测值，大致可以分为三类：<br>1）数据值不直接反映硬盘状态，必须经过硬盘内置的计算公式换算成当前值才能得出结果；<br>2）数据值是直接累计的；<br>3）有些参数的数据是即时数，如Temperature（温度）的数据值是30，表示硬盘的当前温度是30℃。  </p></blockquote><blockquote><p>TYPE，属性的类型（Pre-fail或Oldage）。Pre-fail类型的属性可被看成一个关键属性，表示参与磁盘的整体SMART健康评估（PASSED&#x2F;FAILED）。如果任何Pre-fail类型的属性故障，那么可视为磁盘将要发生故障。另一方面，Oldage类型的属性可被看成一个非关键的属性（如正常的磁盘磨损），表示不会使磁盘本身发生故障。  </p></blockquote><blockquote><p>WHEN_FAILED<br>如果VALUE小于等于THRESH，会被设置成“FAILING_NOW”，需要尽快备份重要文件，特别是属性是Prefail类型时。如果WORST小于等于THRESH会被设置成“In_the_past”，代表属性已经故障了，但在运行测试的时候没问题。如果都不是，会被设置成“-”。  </p></blockquote><p><img src="/../../img/image-20230724082327694.png" alt="image-20230724082327694"></p><h3 id="2-4-4-Self-test结果"><a href="#2-4-4-Self-test结果" class="headerlink" title="2.4.4 Self-test结果"></a>2.4.4 Self-test结果</h3><p>显示硬盘运行SMART test的结果，SMART test可分为offline&#x2F;short&#x2F;long等类型，业务机器一般选用short test，<br>且建议无业务负载下运行。  </p><p>SMART short test测试命令：smartctl -t short &#x2F;dev&#x2F;sdX  </p><p><img src="/../../img/image-20230724082411979.png" alt="image-20230724082411979"></p><h3 id="2-4-5-硬盘原厂日志"><a href="#2-4-5-硬盘原厂日志" class="headerlink" title="2.4.5 硬盘原厂日志"></a>2.4.5 硬盘原厂日志</h3><p>批量硬盘本体不良时需要抓取，抓取的日志仅原厂可解读  </p><ul><li>东芝：tsbdrv工具</li><li>西数：Hugo工具</li><li>希捷：SeaDragon 工具</li></ul><h2 id="2-5-阵列卡问题排查"><a href="#2-5-阵列卡问题排查" class="headerlink" title="2.5 阵列卡问题排查"></a>2.5 阵列卡问题排查</h2><p>阵列卡日志收集方法 : </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">torcli &#x2F;c0 show alilog 阵列卡属性、事件日志、TTY日志等storcli &#x2F;c0 show all 阵列卡及相关部件的概要信息storcli &#x2F;c0 show events 事件日志storcli &#x2F;c0 show termlog TTY日志（固件日志）storcli &#x2F;c0&#x2F;pall show all PHY链路相关信息storcli &#x2F;c0&#x2F;bbu show all 阵列卡电池相关信息storcli &#x2F;c0&#x2F;cv show all 阵列卡超级电容相关信息storcli &#x2F;c0&#x2F;dall show all 硬盘组相关信息storcli &#x2F;c0&#x2F;eall show all 硬盘背板相关信息storcli &#x2F;c0&#x2F;eall&#x2F;sall show all 物理硬盘相关信息storcli &#x2F;c0&#x2F;vall show all 虚拟硬盘相关信息  </code></pre></div></figure><p>阵列卡日志分析 : </p><p>storcli &#x2F;c0 show all包含：</p><ul><li>阵列卡型号</li><li>序列号</li><li>阵列卡时间和系统时间</li><li>固件版本</li><li>驱动版本</li><li>默认设置</li><li>功能</li></ul><p><img src="/../../img/image-20230724103125435.png" alt="image-20230724103125435"></p><ul><li>硬盘拓扑</li></ul><p><img src="/../../img/image-20230724103710307.png" alt="image-20230724103710307"></p><ul><li>虚拟盘清单</li></ul><p><img src="/../../img/image-20230724103726638.png" alt="image-20230724103726638"></p><ul><li>物理盘清单</li></ul><p><img src="/../../img/image-20230724103739126.png" alt="image-20230724103739126"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>国产化POC测试工具使用指南</title>
    <link href="/2022/07/06/02_%E6%B5%8B%E8%AF%95/01_POC%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2022/07/06/02_%E6%B5%8B%E8%AF%95/01_POC%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="POC测试工具使用指南"><a href="#POC测试工具使用指南" class="headerlink" title="POC测试工具使用指南"></a>POC测试工具使用指南</h1><h2 id="1-SPEC-OMP-2012测试"><a href="#1-SPEC-OMP-2012测试" class="headerlink" title="1 SPEC OMP 2012测试"></a>1 SPEC OMP 2012测试</h2><p>SPEC OMP 2012是基于SPEC测试套件的OpenMP评测工具，其中包含15个基于OpenMP的并行程序。</p><p>1、安装工具</p><p>获取源包：omp2012-1.1.zip</p><p>解压后使用install.sh安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装.&#x2F;install.sh -d &#x2F;home&#x2F;xx</code></pre></div></figure><p>2、测试步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source shrculimit -s unlimitedexport OMP_NUM_THREADS&#x3D;48runspec --config&#x3D;gcc.cfg --threads 48 -n 3 -i ref -I all</code></pre></div></figure><p>3、补充参数说明</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 仅编译runspec --action&#x3D;build --config&#x3D;gcc.cfg -i ref -I all</code></pre></div></figure><h2 id="2-CPU性能测试（整型-浮点型）"><a href="#2-CPU性能测试（整型-浮点型）" class="headerlink" title="2 CPU性能测试（整型&#x2F;浮点型）"></a>2 CPU性能测试（整型&#x2F;浮点型）</h2><blockquote><p>测试CPU整型计算性能，包括单线程基准值、满线程基准值</p><p>测试CPU浮点计算性能，包括单线程基准值、满线程基准值</p></blockquote><h3 id="2-1-使用CPU2006"><a href="#2-1-使用CPU2006" class="headerlink" title="2.1 使用CPU2006"></a>2.1 使用CPU2006</h3><blockquote><p>测试环境:</p><p>​CPU：飞腾D2000</p><p>​内存：16G</p><p>​系统：麒麟V10-SP1-2107 桌面操作系统</p></blockquote><p>1、准备</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">测试工具包：d2000-spec2006test.tar.gz</code></pre></div></figure><p>系统优化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改操作系统&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfgsed -i ‘s&#x2F;video&#x3D;VGA-1:640x480-32@60me&#x2F;&amp; mitigations&#x3D;off &#x2F;’ &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfgsed -i ‘s&#x2F;video&#x3D;VGA-1:640x480-32@60me&#x2F;&amp; selinux&#x3D;0 audit&#x3D;0 &#x2F;’ &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfg    （注：与上面是同一行，注意空格）# 配置透明页echo always &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled# 操作系统打开性能模式，关闭服务tuned-adm profile throughput-performancefor srv in firewalld auditd irqbalance tuned; do for act in stop disable; do systemctl $act $&#123;srv&#125;.service输入done输入done # 关闭SELINUXsed -i ‘&#x2F;^SELINUX&#x3D;&#x2F;s&#x2F;&#x3D;.*$&#x2F;&#x3D;disabled&#x2F;g’ &#x2F;etc&#x2F;selinux&#x2F;config </code></pre></div></figure><p>2、测试步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、把下载好的d2000-spec2006test.tar.gz测试包放到根目录下（建议整机内存≥16GB，否则会影响测试跑分）#如果不知道如何放到根目录下，可以先把d2000-spec2006test.tar.gz这个包放到桌面，然后点击鼠标右键打开终端，sudo su ，然后输入密码进入root权限，然后输入cp -r d2000-spec2006test.tar.gz &#x2F;  ，这样就复制到了根目录下。 2、cd &#x2F; ，进入根目录，sudo su ，然后输入密码，进入root权限。3、解压，tar -xvf d2000-spec2006test.tar.gz4、更改权限，chmod -R 777 cpu2006-1.25、进入spec2006目录，cd cpu2006-1.26、执行脚本，bash run.sh   #配置依赖环境，！！需要联网，会自动下载部分依赖！！7、source &#x2F;etc&#x2F;profile  #更新profile文件,此处一定要更新8、source .&#x2F;shrc    #配置环境变量9、ulimit -s unlimited #内存分配无限制，大于或者等于16G内存的机器可以加此命令，如果是8G内存的机器不要运行此命令，会因内存不够用影响整型测试的429测试项10、echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches   #执行测试前，建议清一下缓存11、gcc -v   #测试前查看一下gcc的版本是否为GCC931,若不是GCC931，输入source &#x2F;etc&#x2F;profile， 再gcc -v查看版本，是GCC931即可执行第12步启动测试12、bash d2000-test.sh  #执行8核、单核的整形和浮点测试</code></pre></div></figure><p>3、结果查看</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PDF测试结果存放在results文件夹</code></pre></div></figure><p>4、编译问题处理（如遇到编译问题，可参考）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 450报错：# mpsinput.cc: In member function &#39;bool soplex::MPSInput::readLine()&#39;: mpsinput.cc:75:52: error: no match for &#39;operator&#x3D;&#x3D;&#39; (operand types are &#39;std::basic_istream&lt;char&gt;::__istream_type&#39; &#123;aka &#39;std::basic_istream&lt;char&gt;&#39;&#125; and &#39;int&#39;)g++ -std&#x3D;c++03# lto1 fatal error bytecode stream generated with lto version 编译选项添加: fno-lto# 解决zfnlm问题:actual argument contains too few elements for dummy argument &#39;zfnlm&#39;cfg文件编译选项设置： -std&#x3D;legacy# undefined reference to &#39;__gcov_exit&#39;-lgcov --coverage# glob.c:(.text+0x53c): undefined reference to &#96;__alloca&#39;编辑glob.c文件修改第54行&quot;&#x3D;&#x3D;&quot;改为&quot;&gt;&#x3D;&quot;# if _GNU_GLOB_INTERFACE_VERSION &gt;&#x3D; GLOB_INTERFACE_VERSION# 2006的题483在v10-sp1-2107跑起来，我干了什么？ 否则老是报错483.xalancbmk  non-zero return code (rc&#x3D;254, signal&#x3D;0) XML等1、安装统信UOS的GCC8.3.02、SPEC2006的工具集重新编译，再安装3、清除题下面的run&#x2F;build&#x2F;exe4、执行了一次apt-get install gcc?? 不知道有没有影响5、放到没有中文的路径&#x2F;home&#x2F;gretwall&#x2F;cpu20066、使用普通用户greatwall执行# 416报错# Note: The following floating-point exceptions are signalling: IEEE_UNDERFLOW_FLAG IEEE_DENORMAL</code></pre></div></figure><p>4、测试项说明</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source shrc# 多核测试（8）runspec -c greatwall.cfg -r 8 -n 1 -i ref -T base -I all选项解析：-c # 指定config&#x2F;中的配置文件-r # --rate的缩写，跑rate测试，指定测试的副本数（Copies）--speed # 指定跑speed测试，和测试副本数（Copies）（默认跑speed测试）-n # 指定测试的次数-i（-size） # 指定测试的规模，由小到大为test&#x2F;train&#x2F;ref,其中test最快，适合用来验证CPU的完整性，跑分要用ref--reportable &#x2F; --noreportable # 表示检测&#x2F;不检测生成的二进制文件是否修改过--action&#x3D;build# 只编译，不测试--rebuild# 重新编译选题的二进制文件--tune（-T） # 可选peak &#x2F; base &#x2F; all，默认跑all最后的参数# int-(int选题) &#x2F; fp-(fp选题) &#x2F; all-(所有选题) &#x2F; 单个选题-（如483） </code></pre></div></figure><p>5、去除PDF报告的Invalid标记</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp CINT2006.559.ref.rsf CINT2006.559.ref.rsf.retryrawformat --flagsurl myfixedflags.xml --output_format pdf,raw CINT2006.559.ref.rsf.retry</code></pre></div></figure><h3 id="2-2-使用CPU2017"><a href="#2-2-使用CPU2017" class="headerlink" title="2.2 使用CPU2017"></a>2.2 使用CPU2017</h3><p>1、安装工具</p><p>获取镜像包：cpu2017-1_0_5.iso</p><p>挂载iso文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mount -o loop -t iso9660 cpu2017-1_0_5.iso &#x2F;xxx&#x2F;cpu2017CD</code></pre></div></figure><p>安装工具</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;xxx&#x2F;cpu2017CD.&#x2F;install.sh</code></pre></div></figure><p>2、测试步骤</p><p>spec2017主要分为四项测试：</p><ul><li>​intrate</li><li>​fprate</li><li>​intspeed</li><li>​fpspeed</li></ul><p>​根据需要测试的cpu型号，可以到官网下载相应的cfg文件，修改icc、Jemalloc库、qkmalloc库的路径，放入config文件夹中。</p><p>测试命令如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source shrculimit -s unlimited# speed 测试runcpu --config&#x3D;icc-speed-official.cfg --threads&#x3D;48 --define cores&#x3D;48 -n 3 -i ref fpspeed intspeed# rate 测试runcpu --config&#x3D;icc-rate-official.cfg -copies&#x3D;48 -n 3 -i ref intrate fprate</code></pre></div></figure><p>补充参数说明</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 仅编译不跑测试--action&#x3D;build# 重新编译--rebuild# 绑核跑taskset -c </code></pre></div></figure><p>对于Intel CPU的测试优化手段</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、Bios设置：开启超线程尝试开启LLC-PREFETCH2、cfg文件中的submit可以设置绑核选项</code></pre></div></figure><h2 id="3-SPEC-JVM-2008"><a href="#3-SPEC-JVM-2008" class="headerlink" title="3 SPEC JVM 2008"></a>3 SPEC JVM 2008</h2><p>1、安装步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 确定java安装好后，将specjvm2008放到&#x2F;home路径下，并安装java -jar SPECjvm2008_1_01_setup.jar -i console根据提示安装，全部选择默认即可，也可自行定义安装路径，默认路径为&#x2F;SPECjvm2008。# 安装jdkyum install -y java-1.8.0-openjdk-devel </code></pre></div></figure><p>2、配置JAVA_HOME</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi &#x2F;etc&#x2F;profile在文件最后添加如下几行内容JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-arm64CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:&#x2F;lib.dt.jarPATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport JAVA_HOME CLASSPATH PATHsource &#x2F;etc&#x2F;profile执行 source 命令使&#x2F;etc&#x2F;profile 文件中变量生效</code></pre></div></figure><p>3、优化操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">JAVA_OPTS&#x3D;&quot;-Xms8192M -Xmx131072M -XX:PermSize&#x3D;512M -XX:MaxPermSize&#x3D;1g -Dspecjvm.benchmark.threads.scimark.fft.large&#x3D;1&quot;export JAVA_OPTS</code></pre></div></figure><p>4、测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;SPECjvm2008sudo java -jar SPECjvm2008.jar --base -ikvsudo java -Xms1024m -Xmx349525m -jar SPECjvm2008.jar --peak -ikv</code></pre></div></figure><h2 id="4-LTP测试"><a href="#4-LTP测试" class="headerlink" title="4 LTP测试"></a>4 LTP测试</h2><p>测试步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;ltp-20180510.&#x2F;configuremake &amp;&amp; make installcd &#x2F;opt&#x2F;ltp.&#x2F;testscripts&#x2F;ltpstress.sh -n -t 168</code></pre></div></figure><h2 id="5-lmbench测试（用时3小时）"><a href="#5-lmbench测试（用时3小时）" class="headerlink" title="5 lmbench测试（用时3小时）"></a>5 lmbench测试（用时3小时）</h2><blockquote><p>测试简单的系统调用时间、shell命令启动时间、系统信号处理时间、统计2p&#x2F;16K的上下文切换性能、16p&#x2F;64K的上下文切换性能、0K&#x2F;10K文件创建时间、0K&#x2F;10K文件删除时间</p></blockquote><p>1、源码包准备：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;www.bitmover.com&#x2F;lmbench&#x2F;lmbench3.tar.gz</code></pre></div></figure><p>2、编译前的准备：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar xvf lmbench3.tar.gzcd lmbench3mkdir SCCStouch  SCCS&#x2F;s.ChangeSet</code></pre></div></figure><p>3、优化操作：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">修改 Makefile 文件第 114、115 和 139 行，将 O 修改成 O2，使用 O2 编译可使性能优化。  cd lmbench-3.0-a9&#x2F;src&#x2F; vim MakefileCFLAGS&#x3D;-O 改为 CFLAGS&#x3D;-O2</code></pre></div></figure><p>4、编译并测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">cd lmbench3make results LDFLAGS&#x3D;-ltirpc（1）MULTIPLE COPIES,选择默认（2）Job placement selection 选1（3）MB:建议不超过1G（4）其余选项选择默认（5）Mail results ，选择no注：服务器内存大小指定为16384，桌面采用默认大小即可。</code></pre></div></figure><p>5、读取测试结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make see查看结果，results目录下。make rerun再次运行，不需要重新配置。（注：测试多次时执行）</code></pre></div></figure><p>6、错误处理</p><p>错误一：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">报错: undefined reference to &#39;llseek&#39;解决方法:修改src&#x2F;disk.c文件将llseek改为lseek64</code></pre></div></figure><p>错误二：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gmake[1]: Entering directory &#96;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;lmbench3&#x2F;src&#39;gmake[1]: *** No rule to make target &#96;..&#x2F;SCCS&#x2F;s.ChangeSet&#39;, needed by &#96;bk.ver&#39;.  Stop.gmake[1]: Leaving directory &#96;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;lmbench3&#x2F;src&#39;解决方法：# 修改Makefilevim Makefile231行修改：$O&#x2F;lmbench : ..&#x2F;scripts&#x2F;lmbench bk.ver改为$O&#x2F;lmbench : ..&#x2F;scripts&#x2F;lmbench</code></pre></div></figure><p>错误三：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo yum -y install libtirpc libtirpc-develcp -rf &#x2F;usr&#x2F;include&#x2F;tirpc&#x2F;rpc&#x2F;* &#x2F;usr&#x2F;include&#x2F;rpc&#x2F;，解决了丢失rpc.h的问题ln -s &#x2F;usr&#x2F;include&#x2F;tirpc&#x2F;netconfig.h &#x2F;usr&#x2F;include,解决netconfig.h的问题</code></pre></div></figure><h2 id="6-文件读写测试"><a href="#6-文件读写测试" class="headerlink" title="6 文件读写测试"></a>6 文件读写测试</h2><blockquote><p>测试硬盘内文件（10G）拷贝性能，记录时间</p></blockquote><p>测试步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建10G的大文件dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;big_file count&#x3D;10 bs&#x3D;1G# 测试拷贝时间time cp big_file  big_file_bak</code></pre></div></figure><h2 id="7-USB存储设备读写性能"><a href="#7-USB存储设备读写性能" class="headerlink" title="7 USB存储设备读写性能"></a>7 USB存储设备读写性能</h2><blockquote><p>测试USB存储设备读写性能（Mb&#x2F;s），平均读写速度等</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 可选准备1.将U盘（USB3.0）插入被测试机器,假定识别设备为sdc2.创建vfat文件系统分区&#x2F;dev&#x2F;sdb1分区容量大于30GBumount &#x2F;dev&#x2F;sdc1mkfs -t vfat &#x2F;dev&#x2F;sdc1mkdir &#x2F;upanmount -t vfat &#x2F;dev&#x2F;sdc1 &#x2F;upan</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 测试写性能cd &#x2F;upandd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;.&#x2F;largefile bs&#x3D;64k count&#x3D;10000# 测试读性能sync &amp;&amp; echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_cachesdd if&#x3D;.&#x2F;largefile of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;64k</code></pre></div></figure><h2 id="8-硬盘读写测试-IOZONE"><a href="#8-硬盘读写测试-IOZONE" class="headerlink" title="8 硬盘读写测试-IOZONE"></a>8 硬盘读写测试-IOZONE</h2><p>1、准备源码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载源码包wget http:&#x2F;&#x2F;www.iozone.org&#x2F;src&#x2F;current&#x2F;iozone3_487.tar</code></pre></div></figure><p>2、参数说明：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iozone    -a 全面测试，比如块大小它会自动加    -i N 用来选择测试项, 比如Read&#x2F;Write&#x2F;Random 比较常用的是0 1 2,可以指定成-i 0 -i 1 -i2.这些别的详细内容请查man        0&#x3D;write&#x2F;rewrite        1&#x3D;read&#x2F;re-read        2&#x3D;random-read&#x2F;write        3&#x3D;Read-backwards        4&#x3D;Re-write-record        5&#x3D;stride-read        6&#x3D;fwrite&#x2F;re-fwrite        7&#x3D;fread&#x2F;Re-fread        8&#x3D;random mix        9&#x3D;pwrite&#x2F;Re-pwrite        10&#x3D;pread&#x2F;Re-pread        11&#x3D;pwritev&#x2F;Re-pwritev    12&#x3D;preadv&#x2F;Re-preadv    -r block size 指定一次写入&#x2F;读出的块大小    -s file size 指定测试文件的大小    -f filename 指定测试文件的名字,完成后会自动删除(这个文件必须指定你要测试的那个硬盘中)    -F file1 file2… 指定多线程下测试的文件名        批量测试项:    -g -n 指定测试文件大小范围,最大测试文件为4G,可以这样写 -g 4G    -y -q 指定测试块的大小范围        输出:    下面是几个日志记录的参数.好像要输出成图象进行分析，需要指定-a的测试才能输出    -R 产生Excel到标准输出    -b 指定输出到指定文件上. 比如 -Rb ttt.xls</code></pre></div></figure><p>3、执行：df -h，查看可用空间需大于2倍内存大小的路径。</p><p>4、优化操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">HDD优化：echo deadline &gt; &#x2F;sys&#x2F;block&#x2F;sdb&#x2F;queue&#x2F;scheduler echo 65536 &gt; &#x2F;sys&#x2F;block&#x2F;sdb&#x2F;queue&#x2F;nr_requestsecho 65536 &gt; &#x2F;sys&#x2F;block&#x2F;sdb&#x2F;queue&#x2F;read_ahead_kbecho 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches echo 40 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_background_ratioecho 80 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_ratio 将磁盘格式化为 xfs 格式mkfs.xfs -f -d agcount&#x3D;256 -l size&#x3D;128m,lazy-count&#x3D;1,version&#x3D;2 &#x2F;dev&#x2F;sdb（按实际盘符）</code></pre></div></figure><p>5、编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd iozone3_482&#x2F;src&#x2F;current make linux-arm.&#x2F;iozone -i 0 -i 1 -i 2 -s 16g -r 16m -f &#x2F;date&#x2F;tmpfile注：iozone 在测试过程中测试规模要大于或等于物理内存的两倍，且保证测试硬盘 空闲空间大于测试规模，如果测试规模偏小导致内存压力不够大会使分数不准确。X为内存大小的1&#x2F;2倍、1倍、2倍，-f指定测试文件，测试完自动删除。</code></pre></div></figure><p>6、测试</p><blockquote><p>1、测试硬盘读写性能（Mb&#x2F;s），包括随机和顺序读写平均读写速度（IOzone设置块大小16M，文件大小为物理内存2倍、1倍、1&#x2F;2倍三组数据）</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 需要root权限sudo su# 块大小16M，文件大小为物理内存2倍（测试机器内存为8G的情况下）.&#x2F;iozone -i 0 -i 1 -i 2 -s 16g -r 16m -f &#x2F;iozone.tmpfile -Rb .&#x2F;report&#x2F;iotest_16G_0.xls# 块大小16M，文件大小为物理内存1倍（测试机器内存为8G的情况下）.&#x2F;iozone -i 0 -i 1 -i 2 -s 8g -r 16m -f &#x2F;iozone.tmpfile -Rb .&#x2F;report&#x2F;iotest_8G_0.xls# 块大小16M，文件大小为物理内存0.5倍（测试机器内存为8G的情况下）.&#x2F;iozone -i 0 -i 1 -i 2 -s 4g -r 16m -f &#x2F;iozone.tmpfile -Rb .&#x2F;report&#x2F;iotest_4G_0.xls</code></pre></div></figure><h2 id="9-硬盘测试-FIO"><a href="#9-硬盘测试-FIO" class="headerlink" title="9 硬盘测试-FIO"></a>9 硬盘测试-FIO</h2><p>1、配置优化</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、组raid，使用3块硬盘组成raid5，划分分区，不做文件系统，不挂载，并设置如下：write policy：alway write backBGI：yesI&#x2F;O：cache# 2、修改磁盘策略echo mq-deadline &gt; &#x2F;sys&#x2F;block&#x2F;sdb&#x2F;queue&#x2F;scheduler# 3、关闭IO mergeecho 2 &gt; &#x2F;sys&#x2F;block&#x2F;sdb&#x2F;queue&#x2F;nomerges</code></pre></div></figure><p>2、安装编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;fio-3.2.&#x2F;configuremake make install</code></pre></div></figure><p>3、开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 顺序读性能测试fio -filename&#x3D;&#x2F;dev&#x2F;XXXX -ioengine&#x3D;psync -time_based&#x3D;1 -rw&#x3D;read -direct&#x3D;1 -buffered＝0 -thread -size&#x3D;110g -bs&#x3D;XXK -numjobs&#x3D;16 -iodepth&#x3D;1 -runtime&#x3D;300 -lockmem&#x3D;1G -group_reporting -name&#x3D;“cepreiTest-IOread”# 顺序写性能测试fio -filename&#x3D;&#x2F;dev&#x2F;XXXX -ioengine&#x3D;psync -time_based&#x3D;1 -rw&#x3D;write -direct&#x3D;1 -buffered＝0 -thread -size&#x3D;110g -bs&#x3D;XXK -numjobs&#x3D;16 -iodepth&#x3D;1 -runtime&#x3D;300 -lockmem&#x3D;1G -group_reporting -name&#x3D;“cepreiTest-IOwrite”# 测试时，-filename后指定硬盘裸读写的分区，不可使用系统盘，会使系统崩溃；-bs指定块大小，分别指定512B、1M，各测试3次；部分硬盘不支持512B,改用4K，报告中注明</code></pre></div></figure><h2 id="10-内存读写性能测试-Stream"><a href="#10-内存读写性能测试-Stream" class="headerlink" title="10 内存读写性能测试-Stream"></a>10 内存读写性能测试-Stream</h2><blockquote><p>STREAM是一套综合性能测试程序集，通过fortran和C两种高级且高效的语言编写完成，由于这两种语言在数学计算方面的高效率， 使得 STREAM 测试例程可以充分发挥出内存的能力。Stream测试是内存测试中业界公认的内存带宽性能测试基准工具。</p><p>用户测试内存单线程和并发读写性能（Mb&#x2F;s）</p></blockquote><p>1、编译安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装gfortransudo apt-get install gfortran# 修改源码中的ArraySize&#123;最高级缓存X MB&#125;×1024×1024×4.1×CPU路数&#x2F;8，结果取整数解释：由于stream.c源码推荐设置至少4倍最高级缓存，且STREAM_ARRAY_SIZE为double类型&#x3D;8 Byte。所以公式为：最高级缓存(单位：Byte)×4.1倍×CPU路数&#x2F;8例如：测试机器是双路CPU，最高级缓存32MB，则计算值为32×1024×1024×4.1×2&#x2F;8≈34393292# 单线程编译gcc -O3 stream.c -o stream# 多线程编译gcc -O3 -fopenmp stream.c -o stream_omp</code></pre></div></figure><p>2、系统优化</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、修改操作系统&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfgsed -i ‘s&#x2F;video&#x3D;VGA-1:640x480-32@60me&#x2F;&amp; mitigations&#x3D;off &#x2F;’ &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfgsed -i ‘s&#x2F;video&#x3D;VGA-1:640x480-32@60me&#x2F;&amp; selinux&#x3D;0 audit&#x3D;0 &#x2F;’ &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfg    # 2、配置透明页echo always &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled# 3、操作系统打开性能模式，关闭服务tuned-adm profile throughput-performancefor srv in firewalld auditd irqbalance tuned; do for act in stop disable; do systemctl $act $&#123;srv&#125;.service输入done输入done# 4 、关闭SELINUXsed -i ‘&#x2F;^SELINUX&#x3D;&#x2F;s&#x2F;&#x3D;.*$&#x2F;&#x3D;disabled&#x2F;g’ &#x2F;etc&#x2F;selinux&#x2F;config </code></pre></div></figure><p>3、单线程测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;streamvim stream.c或者双击打开stream.c修改define N 80000000gcc -O3 -mtune&#x3D;native -march&#x3D;native -mcmodel&#x3D;large -DNTIME&#x3D;50 stream.c -o streamecho never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabledecho never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;defragnice -n -20 .&#x2F;stream（多执行几次，数值会越好，取最大值）</code></pre></div></figure><p>4、多线程测试（双路128核CPU）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;streamvim stream.c或者双击打开stream.c修改define N 800000000（按照256内存计算）gcc -O3 -fopenmp -mtune&#x3D;native -march&#x3D;native -mcmodel&#x3D;large -DNTIME&#x3D;50 stream.c -o stream# 绑核export OMP_NUM_THREADS&#x3D;128export GOMP_CPU_AFFINITY&#x3D;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabledecho never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;defragnice -n -20 .&#x2F;stream（多执行几次，数值会越好，取最大值）</code></pre></div></figure><h2 id="11-操作系统综合性能测试-unixbench（用时1小时）"><a href="#11-操作系统综合性能测试-unixbench（用时1小时）" class="headerlink" title="11 操作系统综合性能测试-unixbench（用时1小时）"></a>11 操作系统综合性能测试-unixbench（用时1小时）</h2><p>系统优化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 分别率修改：修改操作系统&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfgsed -i ‘s&#x2F;video&#x3D;VGA-1:640x480-32@60me&#x2F;&amp; mitigations&#x3D;off &#x2F;’ &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfgsed -i ‘s&#x2F;video&#x3D;VGA-1:640x480-32@60me&#x2F;&amp; selinux&#x3D;0 audit&#x3D;0 &#x2F;’ &#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;kylin&#x2F;grub.cfg    # 配置透明页echo always &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled# 操作系统打开性能模式，关闭服务tuned-adm profile throughput-performance# 关闭服务for srv in firewalld auditd irqbalance tuned; do for act in stop disable; do systemctl $act $&#123;srv&#125;.service&gt; done&gt; doneRemoved &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;firewalld.service.Removed &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service.Removed &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;auditd.service.Removed &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;irqbalance.service.Removed &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;tuned.service.# 关闭selinux sed -i &#39;&#x2F;^SELINUX&#x3D;&#x2F;s&#x2F;&#x3D;.*$&#x2F;&#x3D;disabled&#x2F;g&#39; &#x2F;etc&#x2F;selinux&#x2F;config</code></pre></div></figure><p>开始测试：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压UnixBench工具包：unzip Unixbench-Kylin.zip# 进入Unixbench解压后的目录下cd UnixBench# 修改Makefile文件74行OPTON &#x3D; -O3 -fomit-frame-pointer -fforce-addr -ffast-math -Wall -static -flto# 编译：sudo make clean &amp;&amp; make# 清除缓存：sudo susyncecho 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches# 测试单线程和多线程性能，执行命令：sudo .&#x2F;Run -c 1 -c N&#x2F;&#x2F; 其中N代表cpu核数</code></pre></div></figure><h2 id="12-显卡性能测试-unixbench（用时约半小时）"><a href="#12-显卡性能测试-unixbench（用时约半小时）" class="headerlink" title="12 显卡性能测试-unixbench（用时约半小时）"></a>12 显卡性能测试-unixbench（用时约半小时）</h2><blockquote><p>1、测试2D显示处理性能，主要包括画点、画线、画三角形、画平行四边形、画正方形、画多边形等性能测试</p><p>2、测试3D显示处理性能，主要包括3D的显示、色彩填充、渲染、旋转等性能测试</p></blockquote><p>编译Unibench</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装依赖apt-get install libgl1-mesa-dev# 修改Makefile文件,防止编译报错vim UnixBench&#x2F;Makefile# 第47行取消注释GRAPHIC_TESTS &#x3D; defined# 第50行加上-lmGL_LIBS &#x3D; -lGL -lXext -lX11 -lm# 第74行修改OPTON &#x3D; -O2 -fomit-frame-pointer -fforce-addr -ffast-math -Wall# 修改Run文件vim UnixBench&#x2F;Run# 第109-112行，修改可支持的最大核数，当前是8&#39;system&#39;    &#x3D;&gt; &#123; &#39;name&#39; &#x3D;&gt; &quot;System Benchmarks&quot;, &#39;maxCopies&#39; &#x3D;&gt; 8 &#125;,&#39;2d&#39;        &#x3D;&gt; &#123; &#39;name&#39; &#x3D;&gt; &quot;2D Graphics Benchmarks&quot;, &#39;maxCopies&#39; &#x3D;&gt; 8 &#125;,&#39;3d&#39;        &#x3D;&gt; &#123; &#39;name&#39; &#x3D;&gt; &quot;3D Graphics Benchmarks&quot;, &#39;maxCopies&#39; &#x3D;&gt; 8 &#125;,&#39;misc&#39;      &#x3D;&gt; &#123; &#39;name&#39; &#x3D;&gt; &quot;Non-Index Benchmarks&quot;, &#39;maxCopies&#39; &#x3D;&gt; 8 &#125;,</code></pre></div></figure><p>编译运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make clean &amp;&amp; make -j 8.&#x2F;Run graphics</code></pre></div></figure><p>3D测试优化</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建文件10-vsync.conf&lt;driconf&gt;    &lt;option name&#x3D;&quot;vblank_mode&quot; value&#x3D;&quot;0&quot; &#x2F;&gt;&lt;&#x2F;driconf&gt;# 拷贝文件到指定路径sudo cp 10-vsync.conf  ~&#x2F;.drirc# 运行测试vblank_mode&#x3D;0 .&#x2F;Run ubgears</code></pre></div></figure><h2 id="13-显卡测试-Glmark2"><a href="#13-显卡测试-Glmark2" class="headerlink" title="13 显卡测试-Glmark2"></a>13 显卡测试-Glmark2</h2><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo .&#x2F;waf configure --with-flavors&#x3D;x11-glsudo .&#x2F;waf build -j 4sudo .&#x2F;waf install</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">glmark2</code></pre></div></figure><h2 id="14-显卡测试-Glxgears"><a href="#14-显卡测试-Glxgears" class="headerlink" title="14 显卡测试-Glxgears"></a>14 显卡测试-Glxgears</h2><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">sudo apt-get install mesa-utils</code></pre></div></figure><p>测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 终端执行vblank_mode&#x3D;0 glxgears</code></pre></div></figure><h2 id="15-网络性能测试-iperf3"><a href="#15-网络性能测试-iperf3" class="headerlink" title="15 网络性能测试-iperf3"></a>15 网络性能测试-iperf3</h2><blockquote><p>测试网络传输速率、重传等</p></blockquote><p>可以用源安装或者编译安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install iperf3</code></pre></div></figure><p>常用参数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-u：发送 UDP 包，仅客户端可用，服务端默认 tcp udp 都可以接收-b：指定发送速率（比如 100M），发送端不受限速影响，如果有限速，也只是接收端有影响-p：后接服务端监听的端口-i：设置带宽报告的时间间隔，单位为秒-t：设置测试的时长，单位为秒-w：设置tcp窗口大小，一般可以不用设置，默认即可-B：绑定客户端的ip地址-4：指定 ipv4-n：指定传输的字节数-f：格式化带宽数输出，后接单位，比如 K，M--get-server-output：在客户端直接获取服务端输出的结果</code></pre></div></figure><p>使用方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、服务端10.47.74.25开启server服务iperf3 -s# 2、客户端10.47.76.198发起连接iperf3 -c 10.47.74.25 -i 5 -t 30# 3、如服务端拒绝连接请求，需考虑firewall或者selinux</code></pre></div></figure><h2 id="16-网络性能-Netperf"><a href="#16-网络性能-Netperf" class="headerlink" title="16 网络性能-Netperf"></a>16 网络性能-Netperf</h2><p>1、安装编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd netperf-2.7.0&#x2F; .&#x2F;configure --build&#x3D;arm make&amp;&amp;make install</code></pre></div></figure><p>2、优化操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">客户端与服务端相同优化方法# 注释配置参数vim &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;kylin.conf 注释掉 kylin.conf 中所有参数 # 关闭 swap 交换分区和自动化 NUMA 平衡 vim &#x2F;etc&#x2F;sysctl.conf # 增加 vm.swappiness&#x3D;0 Kernel.numa_balancing&#x3D;0 sysctl -p reboot 重启操作系统# 设置高性能 tuned-adm profile throughput-performance # 关闭服务 systemctl stop firewalld.service systemctl stop auditd.service systemctl stop irqbalance.service systemctl stop tuned.service # 清理缓存 echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches # 设置 MTU ifconfig 网口名称 mtu 9000 </code></pre></div></figure><p>3、开始测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">服务端和客户端关闭防火墙systemctl stop firewalld.service服务端运行 cd src&#x2F; .&#x2F;nerserver 客户端运行 cd src&#x2F; .&#x2F;netperf -H serverip -l 60 -t TCP_STREAM .&#x2F;netperf -H serverip -l 60 -t UDP_STREAM .&#x2F;netperf -H serverip -l 120 -t TCP_RR .&#x2F;netperf -H serverip -l 120 -t UDP_RR</code></pre></div></figure><h2 id="17-CPU、内存压测-stress"><a href="#17-CPU、内存压测-stress" class="headerlink" title="17 CPU、内存压测-stress"></a>17 CPU、内存压测-stress</h2><blockquote><p>stress是一款压力测试工具，可以用它来对系统CPU，内存，以及磁盘IO生成负载。</p></blockquote><p>安装stress</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install stress</code></pre></div></figure><p>使用stress</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stress [option]-? 显示帮助信息-v 显示版本号-q 不显示运行信息-n，--dry-run 显示已经完成的指令执行情况-t --timeout N 指定运行N秒后停止   --backoff N 等待N微妙后开始运行-c --cpu 产生n个进程 每个进程都反复不停的计算随机数的平方根-i --io  产生n个进程 每个进程反复调用sync()，sync()用于将内存上的内容写到硬盘上-m --vm n 产生n个进程,每个进程不断调用内存分配malloc和内存释放free函数   --vm-bytes B 指定malloc时内存的字节数 (默认256MB)   --vm-hang N 指示每个消耗内存的进程在分配到内存后转入休眠状态，与正常的无限分配和释放内存的处理相反，这有利于模拟只有少量内存的机器-d --hadd n 产生n个执行write和unlink函数的进程   --hadd-bytes B 指定写的字节数，默认是1GB   --hadd-noclean 不要将写入随机ASCII数据的文件Unlink    时间单位可以为秒s，分m，小时h，天d，年y，文件大小单位可以为K，M，G</code></pre></div></figure><p>使用stress进行CPU压测</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 128进程压测stress -c 128</code></pre></div></figure><p>使用stress进行内存压测</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建三个进程，每个进程使用300M内存stress -m 3 --vm-bytes 300M</code></pre></div></figure><p>使用stress进行磁盘压测</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># stress -i N 会产生N个进程，每个进程反复调用sync()将内存上的内容写到硬盘上.# stress -d N 会产生N个进程，每个进程往当前目录中写入固定大小的临时文件，然后执行unlink操作删除该临时文件。 临时文件的大小默认为1G，但可以通过 --hdd-bytes 设置临时文件的大小。比如stress -i 2 -d 4 </code></pre></div></figure><p>同时对多个指标进行压力测试，只需要把上面的参数组合起来就行</p><h2 id="18-NPB测试"><a href="#18-NPB测试" class="headerlink" title="18 NPB测试"></a>18 NPB测试</h2><p>NAS并行基准测试程序（NPB），是由美国航空航天局开发的一套代表流体动力学计算的应用程序集，它已经成为公认的用于测评大规模并行机和超级计算机的标准测试程序。NPB可用于常用的编程模型，如MPI和OpenMP。</p><p>1、工具安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">源包获取：NPB3.4.tar.gz         OpenMP || MPICHNPB3.4-MZ.tar.gz  OpenMP &amp;&amp; MPICH解压即可。</code></pre></div></figure><p>2、测试步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make suitecd binmpirun -np 4 .&#x2F;xxx</code></pre></div></figure><h2 id="19-Linpack测试"><a href="#19-Linpack测试" class="headerlink" title="19 Linpack测试"></a>19 Linpack测试</h2><blockquote><p>Linpack是国际上使用最广泛的测试高性能计算机系统浮点性能的基准测试。通过对高性能计算机采用高斯消元法求解一元 N次稠密线性代数方程组的测试，评价高性能计算机的浮点计算性能。Linpack的结果按每秒浮点运算次数（flops）表示。</p><p> N ^ 2 * 8 &#x3D; 总内存</p></blockquote><p>1、工具安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">源包获取：linpack.tgz解压即可。</code></pre></div></figure><p>2、测试步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1进48线100G内存.&#x2F;xhpl -n 1 -b 384 -p 1 -q 1 -m 100000# 1进48线200G内存.&#x2F;xhpl -n 1 -b 384 -p 1 -q 1 -m 200000# 2进24线共100G内存mpirun -n 2 .&#x2F;xhpl -b 384 -p 1 -q 2 -m 50000# 2进24线共200G内存mpirun -n 2 .&#x2F;xhpl -b 384 -p 1 -q 2 -m 100000</code></pre></div></figure><p>用mpirun提交xhplrun.sh效果更好</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PRO_SIZE&#x3D;$&#123;PMI_SIZE&#125;threads&#x3D;&#96;echo $&#123;Cores&#125;&#x2F;$&#123;PMI_SIZE&#125; | bc&#96;PMI_RANK_my&#x3D;$&#123;PMI_RANK&#125;</code></pre></div></figure><p>3、测试优化</p><blockquote><p>一、计算理论内存总带宽</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;计算方法：&gt;查看内存带宽：&gt;dmidecode | grep -A 16 &quot;Memory Device&quot;&gt;例如内存信息为：&gt;三星 DDR4 &gt;16G 每根&gt;2666 MT&#x2F;s（Mhz）&gt;查看cpu支持的通道数，例如intel 6252N支持6通道，两个CPU支持12通道&gt;理论带宽计算DDR4：&gt;单条内存带宽 &#x3D; 内存核心频率 x 内存总线位数 x 倍增系数 &#x3D; 2666 * 64 &#x2F; 8 &#x3D; 21328 MB&#x2F;s &#x3D; 21.3G&#x2F;s&gt;12通道总内存带宽 &#x3D; 21328 * 12 &#x3D; 255936 &#x3D; 250G&#x2F;s</code></pre></div></figure><p>二、使用stream测试实际内存总带宽</p><p>​如果可以达到90%或以上，说明内存带宽正常, 继续Linpack测试</p><p>三、计算CPU理论峰值</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;计算方法：Mhz * 每个时钟周期执行浮点运算的次数 * CPU数目&gt;&#x3D;2.3 x ( 8 x 2 x 2 ) x 48 &#x3D; 3532.8 Gflops&gt;说明：峰值计算分为单精度和双精度浮点运算&gt;单精度：32bit的指令长度的运算，对应32位操作系统&gt;双精度：64bit的指令长度的运算，对应64位操作系统&gt;查找CPU可以处理什么样的指令集：例如Intel官网查到Intel Xeon 6252N支持AVX-512，# of AVX-512 FMA Units &#x3D; 2(Fused Multiply Add instructions) 融合了 乘法 和 加法即可以单个周期同时执行2条512bit的加法和2条512bit的乘法&gt;理解上述两个概念，可以开始计算（CPU单周期浮点计算能力）&gt;Intel 6252N (支持avx512，有512位)&gt;单精度：2.3 x 512&#x2F;32 x 2 x 2 &#x3D; 147.2Gflops &gt;双精度2.3 x 512&#x2F;64 x 2 x 2 &#x3D; 73.6Gflops&gt;双精度共48核74.6 x 48 &#x3D; 3580&gt;FT2000+ 和 FT1500A (只有128位)，FT3000加入sve指令集(128-256位)&gt;单精度： 2.2 x 128&#x2F;32 * 2 &#x3D; 4.4&gt;双精度:2.2 x 128&#x2F;64 * 2 &#x3D; 8.8&gt;双精度共64核8.8 x 64 &#x3D; 563.2</code></pre></div></figure><p>四、使用Linapack测试CPU实际峰值</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;如果性能达到理论峰值的70%说明正常，如果未达到尝试以下优化</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;1、使用mpirun运行xhpl, 按&#96;lscpu&#96; 中的NUMA分组绑定,&#96;比如48核，分为两个Numa Node&#96;, 则用mpirun&#96;跑两个xhpl进程&#96;，每个进程使用 OMP_NUM_THREADS&#x3D;24, 跑24线程，这样可以将核用满。&gt;在&#96;Intel&#96;平台，两个进程分别使用 HPL_HOST_CORE&#x3D;&#39;0-23&#39; 以及 HPL_HOST_CORE&#x3D;&#39;24-47&#39; 绑定核&gt;在&#96;Arm64&#96;平台，则使用 GOMP_CPU_AFFINITY&#x3D;&#39;0-23&#39; 以及 GOMP_CPU_AFFINITY&#x3D;&#39;24-47&#39; 绑定&gt;2、内存不用分配太大，根据stream测试结果分配，从小开始测&gt;3、Intel平台编译器使用ICC，测试linpack使用icc自带的linpack，mpi使用icc自带的&gt;4、Bios中关闭超线程，开启超频(turbo&#x2F;P-state)</code></pre></div></figure><p><strong><font color="blue">先测stream,判断带宽是否正常，再测linpack，然后再测Spec Cpu</font></strong></p></blockquote><p>4、Intel平台</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Intel平台可以使用的控制频率的命令cpupower -c all frequency-set -g performancecpupower -c 0-95 frequency-set -g userspacecpupower -c 0-95 frequency-set -f 2700000# 查看当前频率控制是否为perfomance？cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;scaling_governor# 跑xhpl之前设置指令集，或许有用export MKL_ENABLE_INSTRUCTIONS&#x3D;AVX512</code></pre></div></figure><p>5、HPL.dat修改</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 第1-2行，注释说明行HPLinpack benchmark input file   Innovative Computing Laboratory, University of Tennessee  # 第 3-4 行，输出结果文件的形式HPL.out      output file name (if any)  6            device out (6&#x3D;stdout,7&#x3D;stderr,file) # 5-6行，求解矩阵的大小1            # of problems sizes (N)  1000         Ns   # 7-8行 求解矩阵分块的大小1            # of NBs192 256      NBs# 9行 处理器阵列的排列方式，行还是列0：适用于节点较少，单个节点CPU较多的胖系统1：适用于节点较多，单个节点CPU较少的瘦系统（机群上远好于按行排列）1            PMAP process mapping (0&#x3D;Row-,1&#x3D;Column-major) # 10-12行 定义二维处理网格P&#x2F;Q# P X Q &#x3D; 进程数，P尽量小于Q# P&#x3D;2^n,P最好选择2的幂1            # of process grids (P x Q) 1 2          Ps1 2          Qs# 13行 设置阀值，不用修改16.0         threshold# 14-21行 设置L的分解方式1            # of panel fact2 1 0        PFACTs (0&#x3D;left, 1&#x3D;Crout, 2&#x3D;Right) # 对性能影响不大1            # of recursive stopping criterium4 8          NBMINs (&gt;&#x3D; 1)   # 4或8都不错1            # of panels in recursion2            NDIVs  # 选2比较理想1            # of recursive panel fact.1 0 2        RFACTs (0&#x3D;left, 1&#x3D;Crout, 2&#x3D;Right) # 对性能影响不大# 22-23行 设置L的横向广播方式# 前四种，适用于快速网络，后两种适用于速度较慢的网络# 小规模系统，选择0&#x2F;1，大规模系统选择31            # of broadcast0            BCASTs (0&#x3D;1rg,1&#x3D;1rM,2&#x3D;2rg,3&#x3D;2rM,4&#x3D;Lng,5&#x3D;LnM)# 24-25行 设置横向通信的通信深度# 小规模系统选择1&#x2F;2，大规模系统2-5之间1            # of lookahead depth1            DEPTHs (&gt;&#x3D;0)# 26-27 设置U的广播算法# 小规模系统，使用缺省值即可0            SWAP (0&#x3D;bin-exch,1&#x3D;long,2&#x3D;mix)1            swapping threshold# 28-29行 L和U的数据存放格式0：按列存放1：按行存放0            L1 in (0&#x3D;transposed,1&#x3D;no-transposed) form0            U  in (0&#x3D;transposed,1&#x3D;no-transposed) form# 30-31 缺省值即可0            Equilibration (0&#x3D;no,1&#x3D;yes)8            memory alignment in double (&gt; 0)</code></pre></div></figure><p>6、测试脚本编写</p><p>本地mpirun测试脚本（Intel版本）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 本地单节点测试，需要根据&#96;lscpu&#96;中numa分区情况(node)的使用mpirun测试xhpl# eg:在未开超线程的情况下，分为两个node，每个node中有12个核，则最佳测试方法为mpirun -np 2 .&#x2F;myrun.sh# 以下为myrun.sh的具体实现#!&#x2F;bin&#x2F;bashulimit -s unlimitedCores&#x3D;48ThreadsNum&#x3D;&#96;echo &quot;$&#123;Cores&#125;&#x2F;$&#123;PMI_SIZE&#125;&quot; | bc&#96; # 计算每个进程跑的线程数case $&#123;PMI_SIZE&#125; in2)        case $&#123;PMI_RANK&#125; in        0)        export OMP_NUM_THREADS&#x3D;$&#123;ThreadsNum&#125;        export HPL_HOST_CORE&#x3D;&#39;0-23&#39;        .&#x2F;xhpl -n 1 -b 384 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;        ;;        1)        export OMP_NUM_THREADS&#x3D;$&#123;ThreadsNum&#125;        export HPL_HOST_CORE&#x3D;&#39;24-47&#39;        .&#x2F;xhpl -n 1 -b 384 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;        ;;        esac;;esac</code></pre></div></figure><p>Slurm srun测试脚本(FT版本)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># xhplrun.sh#!&#x2F;bin&#x2F;bashulimit -s unlimitedCores&#x3D;48&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PMI_SIZE&#x3D;$SLURM_NPROCSPMI_RANK&#x3D;$SLURM_PROCIDMPI_NUM_NODE&#x3D;$SLURM_NNODESMPI_PER_NODE&#x3D;$((PMI_SIZE &#x2F; MPI_NUM_NODES))MPI_RANK_FOR_NODE&#x3D;$((PMI_RANK % MPI_PER_NODE))PRO_SIZE&#x3D;$&#123;MPI_PER_NODE&#125;PMI_RANK_my&#x3D;$&#123;MPI_RANK_FOR_NODE&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;echo $&#123;PRO_SIZE&#125; $&#123;PMI_RANK_my&#125; $&#123;threads&#125; $&#123;PMI_SIZE&#125; $&#123;PMI_RANK&#125; $&#123;MPI_NUM_NODES&#125; $&#123;MPI_PER_NODE&#125; $&#123;MPI_RANK_FOR_NODE&#125;export HPL_CMDLINE&#x3D;1case $&#123;PRO_SIZE&#125; in1)#numactl -i 0-1 -N 0-1 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 0,4 -N 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-63&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;2)case $&#123;PMI_RANK_my&#125; in0)#numactl -i 0-3 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -m 3 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-31&#39;numactl -i 4-7 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;1)#numactl -i 4-7 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -m 7 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;32-63&#39;numactl -i 0-3 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac#mpirun -n 1 numactl -i 0-3 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125; : -n 1 numactl -i 4-7 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac</code></pre></div></figure><p>yhrun 提交作业 runpro.sh</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#duqiif [ $# -ne 5 ]then        echo Usage: .&#x2F;runpro.sh nodes_list nodes_num proc_per_node mem_per_proc logdir        exit 0fiexport HPL_CMDLINE&#x3D;1export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mpi3&#x2F;lib:$LD_LIBRARY_PATHnodes&#x3D;$&#123;1&#125;nnodes&#x3D;$&#123;2&#125;nprocs&#x3D;$&#123;3&#125;nmem&#x3D;$&#123;4&#125;logdir&#x3D;$&#123;5&#125;mkdir -p $&#123;logdir&#125;tnprocs&#x3D;$(($&#123;nnodes&#125;*$&#123;nprocs&#125;))P&#x3D;1Q&#x3D;1for i in &#96;seq 1 $&#123;tnprocs&#125;&#96;do        for j in &#96;seq 1 $&#123;tnprocs&#125;&#96;        do                PQ&#x3D;$(($&#123;i&#125;*$&#123;j&#125;))                if [ $&#123;PQ&#125; -eq $&#123;tnprocs&#125; ] &amp;&amp; [ $&#123;i&#125; -le $&#123;j&#125; ]                then                        P&#x3D;$&#123;i&#125;                        Q&#x3D;$&#123;j&#125;                fi        donedonefor i in &#96;yhcontrol show hostname $&#123;nodes&#125;&#96;do        scp HPL.dat $i:&#x2F;root&#x2F;linpack &amp;donewaitsleep 1j&#x3D;0runnodes&#x3D;&#39;&#39;for i in &#96;yhcontrol show hostname $&#123;nodes&#125;&#96;do        runnodes+&#x3D;$&#123;i&#125;,        let j++        if [ $&#123;j&#125; -eq $&#123;nnodes&#125; ]        then                echo &quot;yhrun -p all -N $&#123;nnodes&#125; -n $&#123;tnprocs&#125; -w $&#123;runnodes&#125; -D &#x2F;root&#x2F;linpack &#x2F;root&#x2F;linpack&#x2F;xhplrun.sh $&#123;P&#125; $&#123;Q&#125; $&#123;nmem&#125; &amp;&gt;&gt; $&#123;logdir&#125;&#x2F;$&#123;i&#125;.log &amp;&quot;                echo $&#123;runnodes&#125; &amp;&gt;&gt; $&#123;logdir&#125;&#x2F;$&#123;i&#125;.log                yhrun -p all -N $&#123;nnodes&#125; -n $&#123;tnprocs&#125; -w $&#123;runnodes&#125; -D &#x2F;root&#x2F;linpack &#x2F;root&#x2F;linpack&#x2F;xhplrun.sh $&#123;P&#125; $&#123;Q&#125; $&#123;nmem&#125; &amp;&gt;&gt; $&#123;logdir&#125;&#x2F;$&#123;i&#125;.log &amp;                j&#x3D;0                runnodes&#x3D;&#39;&#39;        fidone</code></pre></div></figure><p>bios设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">琦哥的：    UPI Configuration        Link Lop -&gt; disable        Link L1  -&gt; disable         IO Directory Cache -&gt; enable        Isoc Mode -&gt; enable    Memory Configuration        Eufsrce POR -&gt; enable        PPR Type -&gt; Soft PPR        Memory Frequency -&gt; 2666        Data Scrambling for NVMDIMM -&gt; enable        Data Scrambling for DDR4 -&gt; enable        Enable AOR -&gt; enable        Refresh Option -&gt; enable        Memory RAS            Memory Rank Sparing -&gt; enable    IIO Configuration        PCI-E Port Max Payload Size -&gt; 256B    CPU P-State        SpeedStep -&gt; disable&#x2F;enable?        PBF         Hardware P-State -&gt; enable        Package c state -&gt; No limit 网上找的系统Bios设置优化    关闭超线程    打开EIST    打开Turbo Mode    Boot Performance mode设置为max performance    Energy Performance BIAS设置为Performance    打开Monitor&#x2F;Mwait    Package C stat limit设置为C0&#x2F;C1 state    关闭CPU C3 report    关闭CPU C6 report    关闭Enhanced Halt State    关闭Intel VT for Directed I&#x2F;O    Linux OS下CPU Power Management设置为max performance    QPI及Memory Frequency保持为Max Frequency    关闭NUMA功能 </code></pre></div></figure><p>7、结果反馈</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、grep FAILED 关键字,查看是否有节点计算错误2、grep WR 查看节点性能是否正常3、统计跑死的点# 如何反馈？一轮Linpack40分钟测试完成一、6个点本是drain*状态二、3个点跑死，cn[1,2,3]三、5个点Linpack计算FAILED四、其他点linpakc性能正常可以考虑更换下一批</code></pre></div></figure><h2 id="20-风冷系统linpack测试全过程记录"><a href="#20-风冷系统linpack测试全过程记录" class="headerlink" title="20 风冷系统linpack测试全过程记录"></a>20 风冷系统linpack测试全过程记录</h2><blockquote><h5 id="1、了解风冷系统的架构"><a href="#1、了解风冷系统的架构" class="headerlink" title="1、了解风冷系统的架构"></a>1、了解风冷系统的架构</h5><p>按批次测试，测完一批换下一批</p><p>一批为192个节点，每个框32个节点，共6个框</p><p>每个节点128G内存，芯片为FT2000+, 通过mhz获取频率为2000（降频），64物理核</p><p>系统版本： 4.19.46-cn+</p><h5 id="2、计算每个节点的理论峰值"><a href="#2、计算每个节点的理论峰值" class="headerlink" title="2、计算每个节点的理论峰值"></a>2、计算每个节点的理论峰值</h5><p>2000 * 128 &#x2F; 64 * 2 * 64&#x3D; 512000</p><h5 id="3、开始测试"><a href="#3、开始测试" class="headerlink" title="3、开始测试"></a>3、开始测试</h5><p>runpro.sh脚本参数说明:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;.&#x2F;runpro.sh NodeList NodeBind ProcessesPerNode MemSize&gt;NodeList 节点列表,例如cn[0-8]&gt;NodeBind 几个节点绑定运行，例如2，则计算效率时，需要将结果得到的效率&#x2F;2&#x2F;512&gt;ProcessesPerNode 每给节点运行几个xhpl进程，根据numa node来，FT一般是8&gt;MemSize 每个节点中，每个进程分配的内存，一般使用到约总内存的80%，例如单节点128G，填写12000（单位为Mb），则总使用96G内存</code></pre></div></figure><p>单节点测试：</p><p>​不需要互联测试网络联通性，仅对单节点进行压力测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;.&#x2F;runpro.sh cn0 1 8 12000 logdir</code></pre></div></figure><p>多节点测试：</p><p>​需要互联测试网络联通性， 2，4， 8， 16， 32， 64， 128，如果要求测多节点稳定性，测试的8点8进8线，结果按<a href="#jump">章节6.8</a>反馈</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;.&#x2F;runpro.sh cn0 1 8 12000 logdir</code></pre></div></figure><p>问题解决一：</p><p>​测试到128节点，性能异常，效率仅有43%</p><p>互联那边回应：</p><p>​节点数超过64，通信就跨框</p><p>琦哥建议的做法：</p><p>​把128个节点分到4个框，测试一下，看是不是带宽的原因</p><p>最后的解决方法：</p><p>​网络拓扑更换，矩阵值不能相等，使用原本32 x 32，改为16 x 64，但是换成160节点后还是有问题</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;.&#x2F;runpro.sh cn[xx-xx] 128 8 12000 dir&gt;其中执行的xhplrun.sh的参数为&gt;xhplrun.sh 32 32 12000</code></pre></div></figure></blockquote><h2 id="21-附录"><a href="#21-附录" class="headerlink" title="21 附录"></a>21 附录</h2><h3 id="19-1-Linpack脚本"><a href="#19-1-Linpack脚本" class="headerlink" title="19.1 Linpack脚本"></a>19.1 Linpack脚本</h3><blockquote><p>runpro.sh</p><p>.&#x2F;runpro.sh nodes_list nodes_num proc_per_node mem_per_proc logdir</p><p>node_list 节点列表</p><p>nodes_num 几个点连在一起跑，单点 双点 多点</p><p>proc_per_node 每个节点跑几个进程，看node分为几个，FT一般是8</p><p>mem 12000 每个进程分配的内存，*8 大概&#x3D; 总内存的80%</p><p>logdir 日志文件</p><p>单点8进程，一轮≈35分钟</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#! &#x2F;bin&#x2F;bash#duqiif [ $# -ne 5 ]then        echo Usage: .&#x2F;runpro.sh nodes_list nodes_num proc_per_node mem_per_proc logdir        exit 0fiexport HPL_CMDLINE&#x3D;1export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mpi3&#x2F;lib:LD_LIBRARY_PATHnodes&#x3D;$&#123;1&#125;nnodes&#x3D;$&#123;2&#125;nprocs&#x3D;$&#123;3&#125;nmem&#x3D;$&#123;4&#125;logdir&#x3D;$&#123;5&#125;mkdir -p $&#123;logdir&#125;tnprocs&#x3D;$(($&#123;nnodes&#125;*$&#123;nprocs&#125;))P&#x3D;1Q&#x3D;1num_max&#x3D;1for i in &#96;seq 1 $&#123;tnprocs&#125;&#96;do        j&#x3D;$(($&#123;i&#125;*$&#123;i&#125;))        if [ $&#123;tnprocs&#125; -le $&#123;j&#125; ]; then                num_max&#x3D;$&#123;i&#125;                break        fidonefor i in &#96;seq 1 $&#123;num_max&#125;&#96;do        for j in &#96;seq $&#123;num_max&#125; $&#123;tnprocs&#125;&#96;        do                PQ&#x3D;$(($&#123;i&#125;*$&#123;j&#125;))                if [ $&#123;PQ&#125; -eq $&#123;tnprocs&#125; ]                then                        P&#x3D;$&#123;i&#125;                        Q&#x3D;$&#123;j&#125;                fi        donedonefor i in &#96;yhcontrol show hostname $&#123;nodes&#125;&#96;do        scp HPL.dat $i:&#x2F;root&#x2F;linpack &amp;donesleep 1j&#x3D;0runnodes&#x3D;&#39;&#39;for i in &#96;yhcontrol show hostname $&#123;nodes&#125;&#96;do        runnodes+&#x3D;$&#123;i&#125;,        let j++        if [ $&#123;j&#125; -eq $&#123;nnodes&#125; ]        then                echo &quot;yhrun -p All -N $&#123;nnodes&#125; -n $&#123;tnprocs&#125; -w $&#123;runnodes&#125; -D &#x2F;root&#x2F;linpack &#x2F;root&#x2F;linpack&#x2F;xhplrun.sh $&#123;P&#125; $&#123;Q&#125; $&#123;nmem&#125; &amp;&gt;&gt; $&#123;logdir&#125;&#x2F;$&#123;i&#125;.log &amp;&quot;                echo $&#123;runnodes&#125; &amp;&gt;&gt; $&#123;logdir&#125;&#x2F;$&#123;i&#125;.log &amp;                echo &quot;yhrun -p All -N $&#123;nnodes&#125; -n $&#123;tnprocs&#125; -w $&#123;runnodes&#125; -D &#x2F;root&#x2F;linpack &#x2F;root&#x2F;linpack&#x2F;xhplrun.sh $&#123;P&#125; $&#123;Q&#125; $&#123;nmem&#125;&quot; &amp;&gt;&gt; $&#123;logdir&#125;&#x2F;list.log                yhrun -p All -N $&#123;nnodes&#125; -n $&#123;tnprocs&#125; -w $&#123;runnodes&#125; -D &#x2F;root&#x2F;linpack &#x2F;root&#x2F;linpack&#x2F;xhplrun.sh $&#123;P&#125; $&#123;Q&#125; $&#123;nmem&#125; &amp;&gt;&gt; $&#123;logdir&#125;&#x2F;$&#123;i&#125;.log &amp;                j&#x3D;0                runnodes&#x3D;&#39;&#39;        fidone</code></pre></div></figure><blockquote><p>xhplrun.sh</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#! &#x2F;bin&#x2F;bash#duqiulimit -s unlimitedCores&#x3D;64#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PMI_SIZE&#x3D;$SLURM_NPROCSPMI_RANK&#x3D;$SLURM_PROCIDMPI_NUM_NODES&#x3D;$SLURM_NNODESMPI_PER_NODE&#x3D;$((PMI_SIZE &#x2F; MPI_NUM_NODES))MPI_RANK_FOR_NODE&#x3D;$((PMI_RANK % MPI_PER_NODE))#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;threads&#x3D;&#96;echo $&#123;Cores&#125;*$&#123;SLURM_NNODES&#125;&#x2F;$&#123;PMI_SIZE&#125; | bc&#96;PRO_SIZE&#x3D;$&#123;MPI_PER_NODE&#125;PMI_RANK_my&#x3D;$&#123;MPI_RANK_FOR_NODE&#125;echo $&#123;PRO_SIZE&#125; $&#123;PMI_RANK_my&#125; $&#123;threads&#125; $&#123;PMI_SIZE&#125; $&#123;PMI_RANK&#125; $&#123;MPI_NUM_NODES&#125; $&#123;MPI_PER_NODE&#125; $&#123;MPI_RANK_FOR_NODE&#125;export HPL_CMDLINE&#x3D;1case $&#123;PRO_SIZE&#125; in1)#numactl -i 0-1 -N 0-1 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 0,4 -N 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-63&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;2)case $&#123;PMI_RANK_my&#125; in0)#numactl -i 0-3 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -m 3 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-31&#39;numactl -i 4-7 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;1)#numactl -i 4-7 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -m 7 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;32-63&#39;numactl -i 0-3 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac#mpirun -n 1 numactl -i 0-3 -N 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125; : -n 1 numactl -i 4-7 -N 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;4)case $&#123;PMI_RANK_my&#125; in0)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-15&#39;numactl -i 0-7 -N 0-1 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 2-3 -N 0-1 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;1)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;16-31&#39;numactl -i 0-7 -N 2-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 4-5 -N 2-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;2)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;32-47&#39;numactl -i 0-7 -N 4-5 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 6-7 -N 4-5 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;3)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;48-63&#39;numactl -i 0-7 -N 6-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 0-1 -N 6-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac;;8)case $&#123;PMI_RANK_my&#125; in0)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-7&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 4 -N 0 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;1)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;8-15&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 2 -N 1 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;2)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;16-23&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 6 -N 2 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;3)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;24-31&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 1 -N 3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;4)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;32-39&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 0 -N 4 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;5)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;40-47&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 7 -N 5 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;6)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;48-55&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 5 -N 6 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;7)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;56-63&#39;numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#numactl -i 3 -N 7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#.&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac;;16)case $&#123;PMI_RANK_my&#125; in0)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-3&#39;numactl -i 0-7 -C 0-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;1)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;4-7&#39;numactl -i 0-7 -C 4-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;2)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;8-11&#39;numactl -i 0-7 -C 8-11 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;3)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;12-15&#39;numactl -i 0-7 -C 12-15 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;4)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;16-19&#39;numactl -i 0-7 -C 16-19 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;5)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;20-23&#39;numactl -i 0-7 -C 20-23 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;6)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;24-27&#39;numactl -i 0-7 -C 24-27 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;7)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;28-31&#39;numactl -i 0-7 -C 28-31 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;8)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;32-35&#39;numactl -i 0-7 -C 32-35 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;9)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;36-39&#39;numactl -i 0-7 -C 36-39 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;10)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;40-43&#39;numactl -i 0-7 -C 40-43 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;11)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;44-47&#39;numactl -i 0-7 -C 44-47 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;12)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;48-51&#39;numactl -i 0-7 -C 48-51 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;13)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;52-55&#39;numactl -i 0-7 -C 52-55 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;14)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;56-59&#39;numactl -i 0-7 -C 56-59 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;15)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;60-63&#39;numactl -i 0-7 -C 60-63 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac;;32)#export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;#numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#;;case $&#123;PMI_RANK_my&#125; in0)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0-1&#39;numactl -i 0-7 -C 0-1 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;1)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;2-3&#39;numactl -i 0-7 -C 2-3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;2)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;4-5&#39;numactl -i 0-7 -C 4-5 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;3)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;6-7&#39;numactl -i 0-7 -C 6-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;4)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;8-9&#39;numactl -i 0-7 -C 8-9 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;5)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;10-11&#39;numactl -i 0-7 -C 10-11 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;6)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;12-13&#39;numactl -i 0-7 -C 12-13 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;7)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;14-15&#39;numactl -i 0-7 -C 14-15 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;8)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;16-17&#39;numactl -i 0-7 -C 16-17 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;9)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;18-19&#39;numactl -i 0-7 -C 18-19 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;10)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;20-21&#39;numactl -i 0-7 -C 20-21 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;11)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;22-23&#39;numactl -i 0-7 -C 22-23 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;12)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;24-25&#39;numactl -i 0-7 -C 24-25 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;13)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;26-27&#39;numactl -i 0-7 -C 26-27 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;14)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;28-29&#39;numactl -i 0-7 -C 28-29 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;15)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;30-31&#39;numactl -i 0-7 -C 30-31 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;16)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;32-33&#39;numactl -i 0-7 -C 32-33 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;17)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;34-35&#39;numactl -i 0-7 -C 34-35 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;18)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;36-37&#39;numactl -i 0-7 -C 36-37 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;19)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;38-39&#39;numactl -i 0-7 -C 38-39 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;20)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;40-41&#39;numactl -i 0-7 -C 40-41 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;21)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;42-43&#39;numactl -i 0-7 -C 42-43 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;22)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;44-45&#39;numactl -i 0-7 -C 44-45 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;23)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;46-47&#39;numactl -i 0-7 -C 46-47 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;24)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;48-49&#39;numactl -i 0-7 -C 48-49 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;25)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;50-51&#39;numactl -i 0-7 -C 50-51 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;26)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;52-53&#39;numactl -i 0-7 -C 52-53 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;27)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;54-55&#39;numactl -i 0-7 -C 54-55 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;28)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;56-57&#39;numactl -i 0-7 -C 56-57 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;29)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;58-59&#39;numactl -i 0-7 -C 58-59 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;30)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;60-61&#39;numactl -i 0-7 -C 60-61 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;31)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;62-63&#39;numactl -i 0-7 -C 62-63 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac;;64)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;#export GOMP_CPU_AFFINITY&#x3D;&#39;0-63&#39;#numactl -i 0-7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;#;;case $&#123;PMI_RANK_my&#125; in0)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;0&#39;numactl -i 0-7 -C 0 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;1)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;1&#39;numactl -i 0-7 -C 1 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;2)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;2&#39;numactl -i 0-7 -C 2 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;3)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;3&#39;numactl -i 0-7 -C 3 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;4)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;4&#39;numactl -i 0-7 -C 4 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;5)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;5&#39;numactl -i 0-7 -C 5 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;6)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;6&#39;numactl -i 0-7 -C 6 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;7)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;7&#39;numactl -i 0-7 -C 7 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;8)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;8&#39;numactl -i 0-7 -C 8 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;9)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;9&#39;numactl -i 0-7 -C 9 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;10)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;10&#39;numactl -i 0-7 -C 10 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;11)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;11&#39;numactl -i 0-7 -C 11 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;12)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;12&#39;numactl -i 0-7 -C 12 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;13)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;13&#39;numactl -i 0-7 -C 13 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;14)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;14&#39;numactl -i 0-7 -C 14 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;15)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;15&#39;numactl -i 0-7 -C 15 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;16)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;16&#39;numactl -i 0-7 -C 16 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;17)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;17&#39;numactl -i 0-7 -C 17 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;18)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;18&#39;numactl -i 0-7 -C 18 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;19)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;19&#39;numactl -i 0-7 -C 19 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;20)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;20&#39;numactl -i 0-7 -C 20 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;21)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;21&#39;numactl -i 0-7 -C 21 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;22)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;22&#39;numactl -i 0-7 -C 22 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;23)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;23&#39;numactl -i 0-7 -C 23 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;24)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;24&#39;numactl -i 0-7 -C 24 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;25)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;25&#39;numactl -i 0-7 -C 25 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;26)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;26&#39;numactl -i 0-7 -C 26 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;27)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;27&#39;numactl -i 0-7 -C 27 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;28)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;28&#39;numactl -i 0-7 -C 28 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;29)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;29&#39;numactl -i 0-7 -C 29 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;30)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;30&#39;numactl -i 0-7 -C 30 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;31)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;31&#39;numactl -i 0-7 -C 31 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;32)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;32&#39;numactl -i 0-7 -C 32 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;33)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;33&#39;numactl -i 0-7 -C 33 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;34)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;34&#39;numactl -i 0-7 -C 34 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;35)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;35&#39;numactl -i 0-7 -C 35 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;36)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;36&#39;numactl -i 0-7 -C 36 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;37)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;37&#39;numactl -i 0-7 -C 37 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;38)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;38&#39;numactl -i 0-7 -C 38 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;39)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;39&#39;numactl -i 0-7 -C 39 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;40)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;40&#39;numactl -i 0-7 -C 40 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;41)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;41&#39;numactl -i 0-7 -C 41 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;42)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;42&#39;numactl -i 0-7 -C 42 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;43)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;43&#39;numactl -i 0-7 -C 43 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;44)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;44&#39;numactl -i 0-7 -C 44 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;45)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;45&#39;numactl -i 0-7 -C 45 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;46)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;46&#39;numactl -i 0-7 -C 46 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;47)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;47&#39;numactl -i 0-7 -C 47 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;48)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;48&#39;numactl -i 0-7 -C 48 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;49)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;49&#39;numactl -i 0-7 -C 49 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;50)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;50&#39;numactl -i 0-7 -C 50 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;51)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;51&#39;numactl -i 0-7 -C 51 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;52)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;52&#39;numactl -i 0-7 -C 52 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;53)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;53&#39;numactl -i 0-7 -C 53 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;54)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;54&#39;numactl -i 0-7 -C 54 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;55)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;55&#39;numactl -i 0-7 -C 55 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;56)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;56&#39;numactl -i 0-7 -C 56 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;57)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;57&#39;numactl -i 0-7 -C 57 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;58)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;58&#39;numactl -i 0-7 -C 58 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;59)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;59&#39;numactl -i 0-7 -C 59 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;60)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;60&#39;numactl -i 0-7 -C 60 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;61)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;61&#39;numactl -i 0-7 -C 61 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;62)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;62&#39;numactl -i 0-7 -C 62 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;63)export OMP_NUM_THREADS&#x3D;$&#123;threads&#125;export GOMP_CPU_AFFINITY&#x3D;&#39;63&#39;numactl -i 0-7 -C 63 .&#x2F;xhpl -n 1 -b 192 -p $&#123;1&#125; -q $&#123;2&#125; -m $&#123;3&#125;;;esac;;esac</code></pre></div></figure><h3 id="19-2-编译问题"><a href="#19-2-编译问题" class="headerlink" title="19.2 编译问题"></a>19.2 编译问题</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-lc 解决找不到memcpy问题 -lstdc++解决vtable for xxxx 问题-lgcc_sundefined reference to &#96;_Unwind_Resume&#39;undefined reference to &#96;__popcountdi2&#39;#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;types.h&gt; implicit declaration of function ‘fstat’#include &lt;sys&#x2F;sysmacros.h&gt;implicit declaration of function ‘major’</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC编译方法</title>
    <link href="/2022/07/06/02_%E6%B5%8B%E8%AF%95/02_GCC%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/06/02_%E6%B5%8B%E8%AF%95/02_GCC%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="GCC编译方法"><a href="#GCC编译方法" class="headerlink" title="GCC编译方法"></a>GCC编译方法</h1><h2 id="一、GCC编译"><a href="#一、GCC编译" class="headerlink" title="一、GCC编译"></a>一、GCC编译</h2><h3 id="1-1-依赖软件编译"><a href="#1-1-依赖软件编译" class="headerlink" title="1.1 依赖软件编译"></a>1.1 依赖软件编译</h3><p>建议将依赖库和GCC安装到相同目录，方便设置环境变量，本文安装路径为<code>usr/local/gcc1130</code></p><p><strong>编译安装gmp</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130make make install</code></pre></div></figure><p><strong>编译安装mpfr</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130 --with-gmp&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130make make install</code></pre></div></figure><p><strong>编译安装mpc</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130 --with-gmp&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130 --with-mpfr&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130makemake install</code></pre></div></figure><p><strong>编译安装isl</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130 --with-gmp-prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130makemake install</code></pre></div></figure><h3 id="1-2-编译GCC"><a href="#1-2-编译GCC" class="headerlink" title="1.2 编译GCC"></a>1.2 编译GCC</h3><p>cofigure参考鲲鹏GCC得到</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130 --enable-shared --enable-threads&#x3D;posix --enable-checking&#x3D;release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style&#x3D;gnu --enable-languages&#x3D;c,c++,objc,obj-c++,fortran,lto --enable-plugin --enable-initfini-array --disable-libgcj --without-isl --without-cloog --enable-gnu-indirect-function --build&#x3D;aarch64-linux-gnu --with-stage1-ldflags&#x3D;&#39; -Wl,-z,relro,-z,now&#39; --with-boot-ldflags&#x3D;&#39; -Wl,-z,relro,-z,now&#39; --disable-bootstrap --with-multilib-list&#x3D;lp64 --enable-bolt --with-gmp&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130  --with-mpfr&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130  --with-mpc&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130  --with-isl&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130 </code></pre></div></figure><p>设置依赖库的路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130&#x2F;lib:$LD_LIBRARY_PATH</code></pre></div></figure><p>编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make -j 8make install</code></pre></div></figure><h3 id="1-3-编译问题"><a href="#1-3-编译问题" class="headerlink" title="1.3 编译问题"></a>1.3 编译问题</h3><p>报错信息：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">LIBRARY_PATH variable... contains current directory</code></pre></div></figure><p>解决方法：</p><p>改问题由LIBRARY_PATH环境变量乱了导致，清空环境变量，重新配置即可</p><h3 id="1-4-使用GCC"><a href="#1-4-使用GCC" class="headerlink" title="1.4 使用GCC"></a>1.4 使用GCC</h3><p>创建gcc.env文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashexport GCC_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc1130export PATH&#x3D;$GCC_HOME&#x2F;bin&#x2F;:$PATHexport LD_LIBRARY_PATH&#x3D;$GCC_HOME&#x2F;lib64:$GCC_HOME&#x2F;lib:$LD_LIBRARY_PATHexport LIBRARY_PATH&#x3D;$GCC_HOME&#x2F;lib64:$GCC_HOME&#x2F;lib:$LIBRARY_PATHexport C_INCLUDE_PATH&#x3D;$GCC_HOME&#x2F;include:$C_INCLUDE_PATHexport CPLUS_INCLUDE_PATH&#x3D;$GCC_HOME&#x2F;include:$CPLUS_INCLUDE_PATHexport CPATH&#x3D;$GCC_HOME&#x2F;include:$CPATH</code></pre></div></figure><p>使其生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source gcc.env</code></pre></div></figure><p>测试是否成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -v</code></pre></div></figure><h2 id="二、附：MPICH3编译方法"><a href="#二、附：MPICH3编译方法" class="headerlink" title="二、附：MPICH3编译方法"></a>二、附：MPICH3编译方法</h2><p>设置gcc830的环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;gcc830&#x2F;bin:$PATHexport LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;gcc830&#x2F;lib:$LD_LIBRARY_PATHexport LD_INCLUDE_PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;gcc830&#x2F;include:$LD_INCLUDE_PATHexport CPATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;gcc830&#x2F;include:$CPATHexport LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;gcc830&#x2F;lib64:$LD_LIBRARY_PATHexport LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;gcc830&#x2F;libexec:$LD_LIBRARY_PATH</code></pre></div></figure><p>再编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;mpi3-gcc830 --enable-fast --enable-shared&#x3D;yes --enable-threads&#x3D;runtime --with-ch3-rank-bits&#x3D;32 --enable-romio --with-file-system&#x3D;ufs+nfs --with-mpemake make install</code></pre></div></figure><p>设置环境变量使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;mpi3-gcc830&#x2F;bin:$PATHexport LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;mpi3-gcc830&#x2F;lib:$LD_LIBRARY_PATHexport LD_INCLUDE_PATH&#x3D;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;tools&#x2F;mpi3-gcc830&#x2F;include:$LD_INCLUDE_PATH</code></pre></div></figure><h2 id="三、附：Redhat设置本地镜像源"><a href="#三、附：Redhat设置本地镜像源" class="headerlink" title="三、附：Redhat设置本地镜像源"></a>三、附：Redhat设置本地镜像源</h2><p>挂载镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mount -o loop -t iso9660 &#x2F;home&#x2F;IOSYS&#x2F;test652&#x2F;images&#x2F;rhel-server-7.6-x86_64-dvd.iso &#x2F;home&#x2F;IOSYS&#x2F;test652&#x2F;mnt&#x2F;CDROM</code></pre></div></figure><p>设置本地镜像源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;redhat.repo[rhel7.6]name&#x3D;rhel7.6baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;home&#x2F;testcpu&#x2F;test652&#x2F;mnt&#x2F;CDROMenabled&#x3D;1gpgcheck&#x3D;0priority&#x3D;1</code></pre></div></figure><p>使其生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum cleanyum updateyum repolist</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试问题解决</title>
    <link href="/2022/07/06/02_%E6%B5%8B%E8%AF%95/03_%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/07/06/02_%E6%B5%8B%E8%AF%95/03_%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="测试问题解决"><a href="#测试问题解决" class="headerlink" title="测试问题解决"></a>测试问题解决</h1><h2 id="1-找不到so库的解决方法"><a href="#1-找不到so库的解决方法" class="headerlink" title="1 找不到so库的解决方法"></a>1 找不到so库的解决方法</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 方法一：设置LD_LIBRARY_PATH# 方法二： vim &#x2F;etc&#x2F;ld.so.conf ---------------------------------------------------- include ld.so.conf.d&#x2F;*.conf&#x2F;opt&#x2F;intel&#x2F;compilers_and_libraries&#x2F;linux&#x2F;lib&#x2F;intel64ldconfig 更新</code></pre></div></figure><h2 id="2-复制以及查看端口占用"><a href="#2-复制以及查看端口占用" class="headerlink" title="2 复制以及查看端口占用"></a>2 复制以及查看端口占用</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看端口占用netstat -nultp | grep 8080netstat -anp  | grep 80netstat -ano | grep 18130lsof -i:18130# 复制rsync -chavP &#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;postgresql .rsync -avzP 复制显示进度# 查看Bios版本dmidecode</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mpiicc -DAdd__ -DF77_INTEGER&#x3D;int -DStringSunStyle -DHPL_DETAILED_TIMING -DHPL_PROGRESS_REPORT -I&#x2F;root&#x2F;hpl&#x2F;include -I&#x2F;root&#x2F;hpl&#x2F;include&#x2F;Linux_Intel64 -I&#x2F;opt&#x2F;intel&#x2F;compilers_and_libraries_2019.4.243&#x2F;linux&#x2F;mkl&#x2F;mkl&#x2F;include  -O3 -w -ansi-alias -i-static -z noexecstack -z relro -z now -nocompchk -Wall -qopenmp -mt_mpi -o &#x2F;root&#x2F;hpl&#x2F;bin&#x2F;Linux_Intel64&#x2F;xhpl HPL_pddriver.o         HPL_pdinfo.o           HPL_pdtest.o &#x2F;root&#x2F;hpl&#x2F;lib&#x2F;Linux_Intel64&#x2F;libhpl.a  -L&#x2F;opt&#x2F;intel&#x2F;compilers_and_libraries_2019.4.243&#x2F;linux&#x2F;mkl&#x2F;mkl&#x2F;lib&#x2F;intel64 -Wl,--start-group &#x2F;opt&#x2F;intel&#x2F;compilers_and_libraries_2019.4.243&#x2F;linux&#x2F;mkl&#x2F;lib&#x2F;intel64&#x2F;libmkl_intel_lp64.a &#x2F;opt&#x2F;intel&#x2F;compilers_and_libraries_2019.4.243&#x2F;linux&#x2F;mkl&#x2F;lib&#x2F;intel64&#x2F;libmkl_intel_thread.a &#x2F;opt&#x2F;intel&#x2F;compilers_and_libraries_2019.4.243&#x2F;linux&#x2F;mkl&#x2F;lib&#x2F;intel64&#x2F;libmkl_core.a -Wl,--end-group -lpthread -ldl</code></pre></div></figure><h2 id="3-查看cpu主频率-和-内存信息"><a href="#3-查看cpu主频率-和-内存信息" class="headerlink" title="3 查看cpu主频率 和 内存信息"></a>3 查看cpu主频率 和 内存信息</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看CPU信息lscpu 其中 sockets个数代表物理核个数cat &#x2F;proc&#x2F;cpuinfolmbench的mhz&#x2F;usr&#x2F;bin&#x2F;turbostat# 查看内存信息cat &#x2F;proc&#x2F;meminfodmidecode | grep -A 16 &quot;Memory Device&quot;、</code></pre></div></figure><h2 id="4-GLSL-1-50-is-not-supported"><a href="#4-GLSL-1-50-is-not-supported" class="headerlink" title="4 GLSL 1.50 is not supported"></a>4 GLSL 1.50 is not supported</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 报错：ERROR: In &#x2F;home&#x2F;gs&#x2F;src&#x2F;VTK8.2&#x2F;VTK-8.2.0&#x2F;Rendering&#x2F;OpenGL2&#x2F;vtkShaderProgram.cxx, line 447vtkShaderProgram (0x2b87270): 0:1(10): error: GLSL 1.50 is not supported. Supported versions are: 1.10, 1.20, 1.30, 1.00 ES, and 3.00 ES# 解决方法export MESA_GL_VERSION_OVERRIDE&#x3D;3.2</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cn[16-19,24-27,144-147,152-155]</code></pre></div></figure><h2 id="5-ncat端口转发"><a href="#5-ncat端口转发" class="headerlink" title="5 ncat端口转发"></a>5 ncat端口转发</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ncat --sh-exec &quot;ncat 25.8.27.6 15929&quot; -l 15929 --keep-open</code></pre></div></figure><h2 id="6-Git改密码"><a href="#6-Git改密码" class="headerlink" title="6 Git改密码"></a>6 Git改密码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitlab-rails console productionirb(main):002:0&gt; user&#x3D;User.where(email:&#39;cuiyingbomail@163.com&#39;).first&#x3D;&gt; #&lt;User id:30 @cyb&gt;irb(main):003:0&gt; user.password&#x3D;12345678&#x3D;&gt; 12345678irb(main):004:0&gt; user.password_confirmation&#x3D;12345678&#x3D;&gt; 12345678irb(main):005:0&gt; user.save!Enqueued ActionMailer::DeliveryJob (Job ID: 540244db-c6ec-44f9-880e-72338b955aa5) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, #&lt;GlobalID:0x00007f57f5da3208 @uri&#x3D;#&lt;URI::GID gid:&#x2F;&#x2F;gitlab&#x2F;User&#x2F;30&gt;&gt;&#x3D;&gt; true</code></pre></div></figure><h2 id="7-YHPDE（eclipse）FT部署"><a href="#7-YHPDE（eclipse）FT部署" class="headerlink" title="7 YHPDE（eclipse）FT部署"></a>7 YHPDE（eclipse）FT部署</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、安装eclipse:gitlab2、插件安装，参考手册2、新版SLURM需要vim org.eclipse.ptp.rm.slurm.proxy_4.0.7.201104291906&#x2F;src&#x2F;ptp_slurm_proxy.c1625行：slurm_allocation_lookup_lite -&gt; slurm_allocation_lookup2942行: primary &#x3D; 1; -&gt;  primary &#x3D; 0;2943行：secondary &#x3D; 2; -&gt; secondary &#x3D; 1;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>信创POC测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MI协议</title>
    <link href="/2022/07/06/06_%E6%9D%82%E8%AE%B0/MI%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/07/06/06_%E6%9D%82%E8%AE%B0/MI%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Mi协议使用"><a href="#Mi协议使用" class="headerlink" title="Mi协议使用"></a>Mi协议使用</h1><h2 id="1-使用mi启动调试"><a href="#1-使用mi启动调试" class="headerlink" title="1 使用mi启动调试"></a>1 使用mi启动调试</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gs@ft-svr:~&#x2F;matrix$ gdb --interpreter mi test&#x3D;thread-group-added,id&#x3D;&quot;i1&quot;~&quot;GNU gdb (Ubuntu 8.2.91.20190405-0ubuntu3) 8.2.91.20190405-git\n&quot;~&quot;Copyright (C) 2019 Free Software Foundation, Inc.\n&quot;~&quot;License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.&quot;~&quot;\nType \&quot;show copying\&quot; and \&quot;show warranty\&quot; for details.\n&quot;~&quot;This GDB was configured as \&quot;aarch64-linux-gnu\&quot;.\n&quot;~&quot;Type \&quot;show configuration\&quot; for configuration details.\n&quot;~&quot;For bug reporting instructions, please see:\n&quot;~&quot;&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.\n&quot;~&quot;Find the GDB manual and other documentation resources online at:\n    &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.&quot;~&quot;\n\n&quot;~&quot;For help, type \&quot;help\&quot;.\n&quot;~&quot;Type \&quot;apropos word\&quot; to search for commands related to \&quot;word\&quot;...\n&quot;~&quot;Reading symbols from test...\n&quot;(gdb)</code></pre></div></figure><h2 id="2-断点命令（BreakPoint）"><a href="#2-断点命令（BreakPoint）" class="headerlink" title="2 断点命令（BreakPoint）"></a>2 断点命令（BreakPoint）</h2><h3 id="2-1-break-after"><a href="#2-1-break-after" class="headerlink" title="2.1 -break-after"></a>2.1 -break-after</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-after number count第number个断点在执行count次后有效</code></pre></div></figure><h3 id="2-2-break-condition"><a href="#2-2-break-condition" class="headerlink" title="2.2 -break-condition"></a>2.2 -break-condition</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-condition number expr第number个断点在表达式expr为true时有效</code></pre></div></figure><h3 id="2-3-break-delete"><a href="#2-3-break-delete" class="headerlink" title="2.3 -break-delete"></a>2.3 -break-delete</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-delete(breakpoint number)+删除指定number的多个断点</code></pre></div></figure><h3 id="2-4-break-disable"><a href="#2-4-break-disable" class="headerlink" title="2.4 -break-disable"></a>2.4 -break-disable</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-disable(breakpoint number)+使用指定Number的多个断点失效</code></pre></div></figure><h3 id="2-5-break-enable"><a href="#2-5-break-enable" class="headerlink" title="2.5 -break-enable"></a>2.5 -break-enable</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-enable(breakpoint number)+使用指定Number的多个断点生效</code></pre></div></figure><h3 id="2-6-break-info"><a href="#2-6-break-info" class="headerlink" title="2.6 -break-info"></a>2.6 -break-info</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-info breakpoint得到指定断点的信息</code></pre></div></figure><h3 id="2-7-break-insert"><a href="#2-7-break-insert" class="headerlink" title="2.7 -break-insert"></a>2.7 -break-insert</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-insert-t插入临时断点-h插入硬件断点-r插入正则断点，当函数名匹配正则表达式时生效-c condition    插入条件断点-i ignore-count 插入一个指定无效次数的断点-p thread  line | addr(func) </code></pre></div></figure><h3 id="2-8-break-list"><a href="#2-8-break-list" class="headerlink" title="2.8. -break-list"></a>2.8. -break-list</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-list显示已插入的断点列表</code></pre></div></figure><h3 id="2-9-break-watch"><a href="#2-9-break-watch" class="headerlink" title="2.9 -break-watch"></a>2.9 -break-watch</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-break-watch [-a|-r] variable创建一个观察点，-a标识对variable读写时有效，-r标识只读时有效</code></pre></div></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--01-整体架构规划</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="一-、综合架构规划"><a href="#一-、综合架构规划" class="headerlink" title="一 、综合架构规划"></a>一 、综合架构规划</h2><blockquote><p>项目中涵盖了架构，架构中又涵盖了不同的角色（高可用、负载均衡、web集群）<br>五层架构模型–&gt; 负载均衡 web服务 存储服务 缓存服务 数据库服务（通过tcp连接）</p></blockquote><p><img src="/img/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="综合架构图"></p><h3 id="1-架构访问流程"><a href="#1-架构访问流程" class="headerlink" title="1 架构访问流程"></a>1 架构访问流程</h3><h4 id="1-1-用户视角"><a href="#1-1-用户视角" class="headerlink" title="1.1 用户视角"></a>1.1 用户视角</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.用户通过浏览器输入oldboyedu.com-&gt;回车2.浏览器会发生一次跳转，分析URL-&gt;然后进行DNS解析-&gt;获取真实的公网IP地址3.用户通过tcp的三次握手发起连接-&gt;真实的公网IP4.连接会通过公网-&gt;路由器-&gt;交换机-&gt;抵达前端的硬件防火墙5.防火墙根据自身访问规则，进行匹配-&gt;如果恶意的连接则拒绝-&gt;如果是正常的连接则放行6.防火墙会将连接转发给负载均衡器-&gt;查看用户请求的内容-&gt;根据内容进行任务下发-&gt;下发给web服务器7.web服务接收请求后会根据请求进行判断如果是请求图片或者附件-&gt;查找存储服务器存储的静态资源如果请求的网站上的内容-&gt;缓存服务器-&gt;如果缓存服务器没有-&gt;数据库数据库查询完数据之后会返回数据给web服务器-&gt;同时也会返回一份给缓存服务器8.数据库返回内容-&gt;web服务器-&gt;负载均衡-&gt;用户</code></pre></div></figure><h4 id="1-2-运维视角"><a href="#1-2-运维视角" class="headerlink" title="1.2 运维视角"></a>1.2 运维视角</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.用户通过公网连接（隧道）VPN服务器，这样方便管理内部主机，2.自动化配置管理，节省人力成本，便于后期维护。统一环境，标准化3.自动化监控服务，监控系统的运行状态，事前预警，事后追溯。</code></pre></div></figure><h3 id="2-架构环境规划"><a href="#2-架构环境规划" class="headerlink" title="2 架构环境规划"></a>2 架构环境规划</h3><h4 id="2-1-IP分配"><a href="#2-1-IP分配" class="headerlink" title="2.1 IP分配"></a>2.1 IP分配</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> wanip         lanip       hostname10.0.0.5     172.16.1.5     lb0110.0.0.6     172.16.1.6     lb0210.0.0.7     172.16.1.7     web0110.0.0.8     172.16.1.8     web0210.0.0.9     172.16.1.9     web0310.0.0.31    172.16.1.31    nfs10.0.0.41    172.16.1.41    backup10.0.0.51    172.16.1.51    db0110.0.0.61    172.16.1.61    m0110.0.0.71    172.16.1.71    zabbix</code></pre></div></figure><h4 id="2-2-基础环境准备"><a href="#2-2-基础环境准备" class="headerlink" title="2.2 基础环境准备"></a>2.2 基础环境准备</h4><h5 id="2-2-1-虚拟机系统和网卡准备"><a href="#2-2-1-虚拟机系统和网卡准备" class="headerlink" title="2.2.1 虚拟机系统和网卡准备"></a>2.2.1 虚拟机系统和网卡准备</h5><blockquote><p>安装全新Centos7系统，配置网卡为eth0及eth1命名模式<br>1.第一块网卡为NAT模式[公网环境]，配置的网段为10.0.0.0网段<br>2.第二块网卡为LAN模式[私网环境]，配置的网段为172.16.1.0网段<br>3.优化安装好的Centos7虚拟机，安装常用软件、关闭防火墙等等</p></blockquote><p>优化步骤</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.配置yum仓库rm -f &#x2F;etc&#x2F;yum.repos.d&#x2F;*curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repocurl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo# 2.安装基础软件包yum install net-tools vim tree htop iftop \iotop lrzsz sl wget unzip telnet nmap nc psmisc \dos2unix bash-completion bash-completion-extra sysstat \rsync nfs-utils httpd-tools -y# 3.关闭防火墙firewalldsystemctl disable firewalldsystemctl stop firewalld# 4.关闭selinuxsed -i &#39;&#x2F;^SELINUX&#x3D;&#x2F;c SELINUX&#x3D;disabled&#39; &#x2F;etc&#x2F;selinux&#x2F;config# 5.调整单个进程最大能打开文件的数量echo &#39;* - nofile 65535&#39; &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf</code></pre></div></figure><p>基于优化后的虚拟机进行克隆</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.连接克隆（需要依赖于母体）2.完整克隆（完完全全的复制一份，占用磁盘空间）</code></pre></div></figure><p>对新克隆的主机进行如下操作：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.修改主机名  hostnamectl set-hostname backup# 2.修改IP地址  sed -i &#39;s#200#41#g&#39; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth[01]# 3.重启服务器</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--02--Rsync服务器搭建</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/02-Rsync%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/02-Rsync%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="二、Rsync与数据备份"><a href="#二、Rsync与数据备份" class="headerlink" title="二、Rsync与数据备份"></a>二、Rsync与数据备份</h2><h3 id="2-1-备份概念"><a href="#2-1-备份概念" class="headerlink" title="2.1  备份概念"></a>2.1  备份概念</h3><p>为什么要做备份？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">数据非常的重要保证数据不丢失便于快速的恢复</code></pre></div></figure><p>备份方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">完全备份，每次都进行全部备份 (效率低下, 占用空间)增量备份，仅备份客户端与服务端差异的部分 (提高备份效率,节省空间, 适合异地备份 )</code></pre></div></figure><p>用什么工具做备份？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scp  网络之间的拷贝，全量拷贝的方式  （ssh协议）rsync远程同步（增量）</code></pre></div></figure><h3 id="2-2-rsync的基本概念"><a href="#2-2-rsync的基本概念" class="headerlink" title="2.2 rsync的基本概念"></a>2.2 rsync的基本概念</h3><blockquote><p>rsync是一款开源的备份工具，<br>可以在不同主机之间进行同步（windows和Linux之间   Mac和Linux   Linux和Linux）<br>可实现全量备份与增量备份<br>因此非常适合用于架构集中式备份或异地备份等应用</p></blockquote><p>rsync数据的同步模式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">推送： 本地将数据上传至备份服务器上 （上传）拉取： 备份服务器获取本地服务器的数据  （下载）</code></pre></div></figure><p>rsync的数据传输方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">本地传输（类似于使用cp命令）远程传输（通过网络传输  a--&gt;b）守护进程（运行一个服务一直在后台）</code></pre></div></figure><p>rsync选项详解</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync参数:-a           #归档模式传输, 等于-tropgDl *-v           #详细模式输出, 打印速率, 文件数量等 *-z           #传输时进行压缩以提高效率 *-r           #递归传输目录及子目录，即目录下得所有目录都同样传输。-t           #保持文件时间信息-o           #保持文件属主信息-p           #保持文件权限-g           #保持文件属组信息-l           #保留软连接-P           #显示同步的过程及传输时的进度等信息-D           #保持设备文件信息-L           #保留软连接指向的目标文件-e           #使用的信道协议,指定替代rsh的shell程序  ssh--exclude&#x3D;PATTERN   #指定排除不需要传输的文件模式--exclude-from&#x3D;file #文件名所在的目录文件--bwlimit&#x3D;100       #限速传输 *--partial           #断点续传--delete            #让目标目录和源目录数据保持一致 *</code></pre></div></figure><h3 id="2-3-本地传输"><a href="#2-3-本地传输" class="headerlink" title="2.3 本地传输"></a>2.3 本地传输</h3><p>将&#x2F;boot文件夹拷贝到&#x2F;tmp中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -avz &#x2F;boot &#x2F;tmp&#x2F;</code></pre></div></figure><p>将boot文件夹中的内容拷贝到&#x2F;tmp中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -avz &#x2F;boot&#x2F; &#x2F;tmp&#x2F;</code></pre></div></figure><h3 id="2-3-远程传输"><a href="#2-3-远程传输" class="headerlink" title="2.3 远程传输"></a>2.3 远程传输</h3><p>虚拟机准备</p><table><thead><tr><th>主机名</th><th>IP地址</th></tr></thead><tbody><tr><td>nfs</td><td>172.16.1.31&#x2F;24 和 10.0.0.31&#x2F;24</td></tr><tr><td>backup</td><td>172.16.1.41&#x2F;24 和 10.0.0.41&#x2F;24</td></tr></tbody></table><p>backup从nfs拉取&#x2F;boo目录到本地&#x2F;tmp文件夹</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">rsync -avz root@10.0.0.31:&#x2F;boot &#x2F;tmp</code></pre></div></figure><p>backup上传&#x2F;root&#x2F;test.txt到nfs主机的&#x2F;tmp文件夹中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync &#x2F;root&#x2F;test.txt root@10.0.0.31:&#x2F;tmp</code></pre></div></figure><h3 id="2-4-守护进程传输（服务搭建）"><a href="#2-4-守护进程传输（服务搭建）" class="headerlink" title="2.4 守护进程传输（服务搭建）"></a>2.4 守护进程传输（服务搭建）</h3><blockquote><p>为什么需要使用rsync守护进程传输？</p><p>Rsync借助SSH协议同步数据存在的缺陷（临时发送数据）<br>    1.使用系统用户（不安全）<br>    2.使用普通用户（会导致权限不足情况）</p></blockquote><p>backup充当rsync服务端，nfs充当客户端，配置步骤：</p><h4 id="2-4-1-服务端配置"><a href="#2-4-1-服务端配置" class="headerlink" title="2.4.1 服务端配置"></a>2.4.1 服务端配置</h4><p>获取配置文件路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# rpm -qc rsync&#x2F;etc&#x2F;rsyncd.conf# 主配置文件&#x2F;etc&#x2F;sysconfig&#x2F;rsyncd# 选项</code></pre></div></figure><p>编辑配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;rsyncd.conf---------------------uid &#x3D; rsyncgid &#x3D; rsyncport &#x3D; 873fake super &#x3D; yesuse chroot &#x3D; nomax connections &#x3D; 200timeout &#x3D; 600ignore errorsread only &#x3D; falselist &#x3D; falseauth users &#x3D; rsync_backupsecrets file &#x3D; &#x2F;etc&#x2F;rsync.passwdlog file &#x3D; &#x2F;var&#x2F;log&#x2F;rsyncd.log#####################################[backup]comment &#x3D; welcome to oldboyedu backup!path &#x3D; &#x2F;backup</code></pre></div></figure><p>配置详细解析</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uid &#x3D; rsync                      # 运行进程的用户gid &#x3D; rsync                      # 运行进程的用户组port &#x3D; 873                       # 监听端口fake super &#x3D; yes                 # 无需让rsync以root身份运行，允许接收文件的完整属性use chroot &#x3D; no                  # 禁锢推送的数据至某个目录, 不允许跳出该目录max connections &#x3D; 200            # 最大连接数timeout &#x3D; 600                    # 超时时间ignore errors                    # 忽略错误信息read only &#x3D; false                # 对备份数据可读写list &#x3D; false                     # 不允许查看模块信息auth users &#x3D; rsync_backup        # 定义虚拟用户，作为连接认证用户secrets file &#x3D; &#x2F;etc&#x2F;rsync.passwd # 定义rsync服务用户连接认证密码文件路径log file &#x3D; &#x2F;var&#x2F;log&#x2F;rsyncd.log   # 日志文件#####################################[backup]                # 定义模块信息comment &#x3D; commit        # 模块注释信息path &#x3D; &#x2F;backup          # 定义接收备份数据目录</code></pre></div></figure><p>创建rsync进程启动时需要使用的用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# useradd rsync -M -s &#x2F;sbin&#x2F;nologin [root@backup ~]# id rsyncuid&#x3D;1000(rsync) gid&#x3D;1000(rsync) groups&#x3D;1000(rsync)</code></pre></div></figure><p>创建密码文件，在密码文件中写入对应的虚拟用户以及虚拟用户的密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;rsync.passwd---》rsync虚拟用户以及rsync虚拟用户的密码[root@backup ~]# echo &quot;rsync_backup:123456&quot; &gt; &#x2F;etc&#x2F;rsync.passwd[root@backup ~]# chmod 600 &#x2F;etc&#x2F;rsync.passwd </code></pre></div></figure><p>创建存储备份数据的目录，并进行授权</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# mkdir &#x2F;backup[root@backup ~]# chown -R rsync.rsync &#x2F;backup&#x2F;</code></pre></div></figure><p>启动rsync服务并加入开机自启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# systemctl start rsyncd.service [root@backup ~]# systemctl enable rsyncd</code></pre></div></figure><p>检查rsync的873端口是否存在</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# netstat -lntupActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program nametcp6       0      0 :::873                  :::*                    LISTEN      1269&#x2F;rsync</code></pre></div></figure><h4 id="2-4-2-客户端测试"><a href="#2-4-2-客户端测试" class="headerlink" title="2.4.2 客户端测试"></a>2.4.2 客户端测试</h4><p>推送&#x2F;etc文件夹到服务端&#x2F;backup</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -avz &#x2F;etc&#x2F; rsync_backup@172.16.1.41::backup需要输入密码</code></pre></div></figure><p>从服务端&#x2F;backup拉取文件到&#x2F;tmp</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rsync -avz rsync_backup@172.16.1.41::backup &#x2F;tmp需要输入密码</code></pre></div></figure><h3 id="2-5-rsync补充"><a href="#2-5-rsync补充" class="headerlink" title="2.5 rsync补充"></a>2.5 rsync补充</h3><h4 id="2-5-1-无差异同步-慎用"><a href="#2-5-1-无差异同步-慎用" class="headerlink" title="2.5.1 无差异同步(慎用)"></a>2.5.1 无差异同步(慎用)</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#推送方式实现无差异，以客户端为准，客户端有什么服务端就有什么[root@nfs ~]# rsync -avz --delete &#x2F;root rsync_backup@172.16.1.41::backup#拉取方式实现无差异，以服务端为准，服务端有什么客户端就有什么[root@nfs ~]# rsync -avz --delete rsync_backup@172.16.1.41::backup &#x2F;opt&#x2F;</code></pre></div></figure><h4 id="2-5-2-传输限速"><a href="#2-5-2-传输限速" class="headerlink" title="2.5.2 传输限速"></a>2.5.2 传输限速</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 生成大文件[root@nfs ~]# dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;.&#x2F;size.disk bs&#x3D;1M count&#x3D;500  # 限制传输的速率为1MB [root@nfs ~]# rsync -avzP --bwlimit&#x3D;1 .&#x2F;size.disk rsync_backup@172.16.1.41::backupPassword: sending incremental file listsize.disk    118,358,016  22%    1.01MB&#x2F;s    0:06:33</code></pre></div></figure><h4 id="2-5-3-取消每次传输需要输密码"><a href="#2-5-3-取消每次传输需要输密码" class="headerlink" title="2.5.3 取消每次传输需要输密码"></a>2.5.3 取消每次传输需要输密码</h4><p>在客户端配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">方式一：[root@nfs ~]# echo &quot;123456&quot; &gt; &#x2F;etc&#x2F;rsync.pass[root@nfs ~]# chmod 600 &#x2F;etc&#x2F;rsync.pass #上该文件找123456[root@nfs ~]# rsync -avzP --bwlimit&#x3D;1 .&#x2F;size.disk rsync_backup@172.16.1.41::backup --password-file&#x3D;&#x2F;etc&#x2F;rsync.pass方式二：写Shell脚本[root@nfs ~]# export RSYNC_PASSWORD&#x3D;123456[root@nfs ~]# rsync -avzP .&#x2F;size.disk rsync_backup@172.16.1.41::backup</code></pre></div></figure><h2 id="三、Rsync备份案例"><a href="#三、Rsync备份案例" class="headerlink" title="三、Rsync备份案例"></a>三、Rsync备份案例</h2><blockquote><p>客户端需求<br>1.客户端提前准备存放的备份的目录，目录规则如下:&#x2F;backup&#x2F;nfs_172.16.1.31_2018-09-02<br>2.客户端在本地打包备份(系统配置文件、应用配置等)拷贝至&#x2F;backup&#x2F;nfs_172.16.1.31_2018-09-02<br>3.客户端最后将备份的数据进行推送至备份服务器<br>4.客户端每天凌晨1点定时执行该脚本<br>5.客户端本地保留最近7天的数据, 避免浪费磁盘空间</p><p>服务端需求<br>1.服务端部署rsync，用于接收客户端推送过来的备份数据<br>2.服务端需要每天校验客户端推送过来的数据是否完整<br>3.服务端需要每天校验的结果通知给管理员<br>4.服务端仅保留6个月的备份数据,其余的全部删除</p><p>注意：所有服务器的备份目录必须都为&#x2F;backup</p><p>1.客户端将需要备份的文件放入指定的目录中   &#x2F;backup&#x2F;nfs_172.16.1.31_2018-09-02<br>2.客户端每天凌晨1点使用rsync命令推送一次nfs_172.16.1.31_2018-09-0<br>3.客户端保留最近7天的数据即可</p></blockquote><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><blockquote><p>1.我要备份什么？<br>&#x2F;etc&#x2F;fstab &#x2F;var&#x2F;spool&#x2F;cron&#x2F;USERNAME   &#x2F;server&#x2F;scripts</p><p>2.我要怎么备份？<br>&#x2F;backup&#x2F;主机名_ip地址_时间  命名的目录中</p><p>3.我要备份到哪？<br>rsync备份服务器   172.16.1.41</p></blockquote><h4 id="3-1-1-服务端配置"><a href="#3-1-1-服务端配置" class="headerlink" title="3.1.1 服务端配置"></a>3.1.1 服务端配置</h4><p>配置邮件服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# yum install mailx -y[root@backup ~]# vim &#x2F;etc&#x2F;mail.rcset from&#x3D;12345@qq.comset smtp&#x3D;smtps:&#x2F;&#x2F;smtp.qq.com:465set smtp-auth-user&#x3D;12345@qq.comset smtp-auth-password&#x3D;xxxxxx # 授权码set smtp-auth&#x3D;loginset ssl-verify&#x3D;ignoreset nss-config-dir&#x3D;&#x2F;etc&#x2F;pki&#x2F;nssdb&#x2F;</code></pre></div></figure><p>脚本编写</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# mkdir &#x2F;server&#x2F;scripts -p[root@backup ~]# cat &#x2F;server&#x2F;scripts&#x2F;check_client_data.sh#!&#x2F;bin&#x2F;bash#1.定义变量PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;binSRC&#x3D;&#x2F;backupDATE&#x3D;$(date +%F)#1.使用md5进行校验，并保存校验的结果md5sum -c $SRC&#x2F;*_$DATE&#x2F;flag_$DATE &gt; $SRC&#x2F;result_$DATE#2.将保存的结果文件发送给管理员mail -s &quot;Rsync Backup $DATE&quot; 572891887@qq.com &lt;$SRC&#x2F;result_$DATE#3.保留最近180天的数据find $SRC&#x2F; -type d -mtime +180|xargs rm -rf </code></pre></div></figure><h4 id="3-1-2-客户端配置"><a href="#3-1-2-客户端配置" class="headerlink" title="3.1.2 客户端配置"></a>3.1.2 客户端配置</h4><p>创建目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;backupmkdir -p &#x2F;server&#x2F;scripts&#x2F;</code></pre></div></figure><p>编写备份脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# cat &#x2F;server&#x2F;scripts&#x2F;client_push_data.sh#!&#x2F;bin&#x2F;bash#1.定义变量PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;binSRC&#x3D;&#x2F;backupHOST&#x3D;$(hostname)ADDR&#x3D;$(ifconfig eth1|awk &#39;NR&#x3D;&#x3D;2 &#123;print $2&#125;&#39;)DATE&#x3D;$(date +%F)DEST&#x3D;$&#123;HOST&#125;_$&#123;ADDR&#125;_$&#123;DATE&#125;#2.创建目录[ -d $SRC&#x2F;$DEST ] || mkdir -p $SRC&#x2F;$DEST#3.备份文件cd &#x2F; &amp;&amp; \[ -f $SRC&#x2F;$DEST&#x2F;sys.tar.gz ] || tar czf $SRC&#x2F;$DEST&#x2F;sys.tar.gz etc&#x2F;fstab etc&#x2F;passwd &amp;&amp; \[ -f $SRC&#x2F;$DEST&#x2F;other.tar.gz ] || tar czf $SRC&#x2F;$DEST&#x2F;other.tar.gz var&#x2F;spool&#x2F;cron&#x2F; server&#x2F;scripts &amp;&amp; \#4.使用md5打标记[ -f $SRC&#x2F;$DEST&#x2F;flag_$DATE ] || md5sum $SRC&#x2F;$DEST&#x2F;*.tar.gz  &gt; $SRC&#x2F;$DEST&#x2F;flag_$DATE #4.本地推送到备份服务器export RSYNC_PASSWORD&#x3D;123456rsync -avz $SRC&#x2F;$DEST rsync_backup@172.16.1.41::backup#5.保留本地最近7天的数据find $SRC&#x2F; -type d -mtime +7|xargs rm -rf </code></pre></div></figure><h4 id="3-1-3-整体测试-设置定时任务"><a href="#3-1-3-整体测试-设置定时任务" class="headerlink" title="3.1.3 整体测试:设置定时任务"></a>3.1.3 整体测试:设置定时任务</h4><p>客户端每两分钟备份推送一次</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs backup]# crontab -e*&#x2F;2 * * * * sh &#x2F;server&#x2F;scripts&#x2F;client_push_data.sh</code></pre></div></figure><p>服务端每3分钟校验一次，并发送确认邮件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup scripts]# crontab -e*&#x2F;3 * * * * sh &#x2F;server&#x2F;scripts&#x2F;check_client_data.sh</code></pre></div></figure><h4 id="3-1-5-增加客户端数量"><a href="#3-1-5-增加客户端数量" class="headerlink" title="3.1.5 增加客户端数量"></a>3.1.5 增加客户端数量</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">多创建几台客户端服务器，测试</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--03-NFS服务器搭建</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/03-NFS%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/03-NFS%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<ul><li>学习笔记</li></ul><hr><h2 id="一、NFS简介"><a href="#一、NFS简介" class="headerlink" title="一、NFS简介"></a>一、NFS简介</h2><blockquote><p>NFS是Network File System的缩写及网络文件系统。NFS主要功能是通过局域网络让不同的主机系统之间可以共享文件或目录。<br>NFS系统和Windows网络共享、网络驱动器类似, 只不过windows用于局域网, NFS用于企业集群架构中<br>如果是大型网站, 会用到更复杂的分布式文件系统FastDFS（音频、小说、视频）,glusterfs（iso镜像）,HDFS<br>NFS（图片、）解决共享前端web共享</p></blockquote><h3 id="1-1-NFS有什么用？"><a href="#1-1-NFS有什么用？" class="headerlink" title="1.1 NFS有什么用？"></a>1.1 NFS有什么用？</h3><p>解决前端web静态资源的共享<br>解决前端web静态资源一致性<br>解决前端web磁盘空间的浪费</p><h3 id="1-2-NFS的文件操作方式"><a href="#1-2-NFS的文件操作方式" class="headerlink" title="1.2 NFS的文件操作方式"></a>1.2 NFS的文件操作方式</h3><p>1.当用户执行mkdir命令, 该命令会调用shell解释器翻译给内核。<br>2.内核解析完成后会驱动对应的硬件设备，完成相应的操作。</p><h3 id="1-3-NFS的实现原理"><a href="#1-3-NFS的实现原理" class="headerlink" title="1.3 NFS的实现原理"></a>1.3 NFS的实现原理</h3><p>1.用户进程访问NFS客户端，使用不同的函数对数据进行处理<br>2.NFS客户端通过TCP&#x2F;IP的方式传递给NFS服务端。<br>3.NFS服务端接收到请求后，会先调用portmap进程进行端口映射。<br>4.nfsd进程用于判断NFS客户端是否拥有权限连接NFS服务端。<br>5.Rpc.mount进程判断客户端是否有对应的权限进行验证。<br>6.idmap进程实现用户映射和压缩<br>7.最后NFS服务端会将对应请求的函数转换为本地能识别的命令，传递至内核，由内核驱动硬件。<br>注意: rpc是一个远程过程调用，那么使用nfs必须有rpc服务</p><h3 id="1-4-NFS的优缺点"><a href="#1-4-NFS的优缺点" class="headerlink" title="1.4 NFS的优缺点"></a>1.4 NFS的优缺点</h3><p>优点</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.NFS文件系统简单易用、方便部署、数据可靠、服务稳定、满足中小企业需求。2.NFS文件系统内存放的数据都在文件系统之上，所有数据都是能看得见。</code></pre></div></figure><p>缺点</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.存在单点故障, 如果构建高可用维护麻烦web-&gt;nfs(sersync)-&gt;backup2.NFS数据明文, 并不对数据做任何校验。3.客户端挂载NFS服务没有密码验证, 安全性一般(内网使用)</code></pre></div></figure><blockquote><p>3.NFS应用建议<br>1.生产场景应将静态数据尽可能往前端推, 减少后端存储压力<br>2.必须将存储里的静态资源通过CDN缓存jpg\png\mp4\avi\css\js<br>3.如果没有缓存或架构本身历史遗留问题太大, 在多存储也无用</p></blockquote><h2 id="二、NFS部署"><a href="#二、NFS部署" class="headerlink" title="二、NFS部署"></a>二、NFS部署</h2><h3 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1 服务端"></a>2.1 服务端</h3><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# yum install nfs-utils -y</code></pre></div></figure><p>配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# cat &#x2F;etc&#x2F;exports&#x2F;data 172.16.1.0&#x2F;24(rw,sync,all_squash)</code></pre></div></figure><p>授权</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# mkdir &#x2F;data[root@nfs ~]# chown -R nfsnobody.nfsnobody &#x2F;data&#x2F;</code></pre></div></figure><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# systemctl start nfs-server[root@nfs ~]# systemctl enable nfs-server</code></pre></div></figure><p>检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# cat &#x2F;var&#x2F;lib&#x2F;nfs&#x2F;etab &#x2F;data172.16.1.0&#x2F;24(rw,sync,wdelay,hide,nocrossmnt,secure,root_squash,all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid&#x3D;65534,anongid&#x3D;65534,sec&#x3D;sys,rw,secure,root_squash,all_squash)</code></pre></div></figure><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h3><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# yum install nfs-utils -y</code></pre></div></figure><p>检查nfs是否有共享内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# showmount -e 172.16.1.31Export list for 172.16.1.31:&#x2F;data 172.16.1.0&#x2F;24</code></pre></div></figure><p>挂载nfs目录（临时）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# mount -t nfs 172.16.1.31:&#x2F;data &#x2F;opt[root@web01 ~]# df -hFilesystem         Size  Used Avail Use% Mounted on172.16.1.31:&#x2F;data   99G  1.8G   98G   2% &#x2F;opt</code></pre></div></figure><p>挂载nfs目录（永久）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# vim &#x2F;etc&#x2F;fstab 172.16.1.31:&#x2F;data  &#x2F;opt  nfs  defaults  0  0[root@web01 ~]# mount -a   #验证fstab开机启动是否填写错误。</code></pre></div></figure><h3 id="2-3-NFS配置参数说明"><a href="#2-3-NFS配置参数说明" class="headerlink" title="2.3 NFS配置参数说明"></a>2.3 NFS配置参数说明</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ro只读权限root_squash当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户(不常用)no_root_squash当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员(不常用)no_all_squash无论NFS客户端使用什么账户访问，都不进行压缩async优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据rw*读写权限sync*同时将数据写入到内存与硬盘中，保证不丢失数据all_squash*无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户(常用)anonuid*配置all_squash使用,指定NFS的用户UID,必须存在系统anongid*配置all_squash使用,指定NFS的用户UID,必须存在系统</code></pre></div></figure><h3 id="2-4-验证ro权限"><a href="#2-4-验证ro权限" class="headerlink" title="2.4 验证ro权限"></a>2.4 验证ro权限</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# cat &#x2F;etc&#x2F;exports&#x2F;data 172.16.1.0&#x2F;24(ro,sync,all_squash)[root@nfs ~]# systemctl restart nfs-server[root@web01 ~]# touch &#x2F;opt&#x2F;ttttouch: cannot touch ‘&#x2F;opt&#x2F;ttt’: Read-only file system#通常这样的错误都是设定的ro权限导致</code></pre></div></figure><h3 id="2-5-验证all-squash、anonuid、anongid权限"><a href="#2-5-验证all-squash、anonuid、anongid权限" class="headerlink" title="2.5 验证all_squash、anonuid、anongid权限"></a>2.5 验证all_squash、anonuid、anongid权限</h3><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nfs ~]# cat &#x2F;etc&#x2F;exports&#x2F;data 172.16.1.0&#x2F;24(rw,sync,all_squash,anonuid&#x3D;666,anongid&#x3D;666)创建用户[root@nfs ~]# groupadd -g 666 www[root@nfs ~]# useradd -u666 -g666 www[root@nfs ~]# id wwwuid&#x3D;666(www) gid&#x3D;666(www) groups&#x3D;666(www)授权[root@nfs ~]# chown -R www.www &#x2F;data&#x2F;重启[root@nfs ~]# systemctl restart nfs-server</code></pre></div></figure><p>客户端重新挂载验证</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 opt]# touch file[root@web01 opt]# touch test[root@web01 opt]# lltotal 4-rw-r--r-- 1 666 666 0 Jan  7 11:29 file-rw-r--r-- 1 666 666 0 Jan  7 11:29 test</code></pre></div></figure><blockquote><p>PS:由于客户端没有创建id为666的www用户，因此看到的属组和属主都是666</p></blockquote><p>客户端如果觉得666不好看，建议在客户端上创建同名的用户以及uid</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# groupadd -g 666 www[root@web01 ~]# useradd -u 666 -g 666 www[root@web01 ~]# id wwwuid&#x3D;666(www) gid&#x3D;666(www) groups&#x3D;666(www)[root@web01 ~]# ll &#x2F;opt&#x2F;total 4-rw-r--r-- 1 www www 0 Jan  7 11:29 file-rw-r--r-- 1 www www 0 Jan  7 11:29 test</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--05--SSH服务器搭建</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/05-ssh%E6%9C%8D%E5%8A%A1%E8%B7%B3%E6%9D%BF%E6%9C%BA%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/05-ssh%E6%9C%8D%E5%8A%A1%E8%B7%B3%E6%9D%BF%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一、SSH服务器介绍"><a href="#一、SSH服务器介绍" class="headerlink" title="一、SSH服务器介绍"></a>一、SSH服务器介绍</h2><blockquote><p>SSH是一个安全协议，在进行数据传输时，会对数据包进行加密处理，加密后在进行数据传输。确保了数据传输安全。</p></blockquote><p><img src="/../../../img/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95.png" alt="ssh免密登录"></p><h3 id="1-ssh的功能"><a href="#1-ssh的功能" class="headerlink" title="1 ssh的功能"></a>1 ssh的功能</h3><ol><li>提供远程连接服务器的服务</li><li>对传输的数据进行加密</li></ol><h3 id="2-常用服务的端口"><a href="#2-常用服务的端口" class="headerlink" title="2 常用服务的端口"></a>2 常用服务的端口</h3><ul><li>ftp – tcp&#x2F;20  tcp&#x2F;21</li><li>dns – tcp&#x2F;53  udp&#x2F;53</li><li>ssh  –  tcp&#x2F;22</li><li>telnet – tcp&#x2F;23 </li><li>mysql – tcp&#x2F;3306</li><li>http – tcp&#x2F;80</li><li>https – tcp&#x2F;443</li></ul><h3 id="3-telnet服务搭建"><a href="#3-telnet服务搭建" class="headerlink" title="3 telnet服务搭建"></a>3 telnet服务搭建</h3><p>安装并启动telnet服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@backup ~]# yum install telnet-server -y[root@backup ~]# systemctl start telnet.socket [root@backup ~]# useradd gs[root@backup ~]# echo &quot;1&quot; | passwd --stdin gs</code></pre></div></figure><p>使用终端软件通过telnet使用gs用户登录连接</p><h3 id="4-telnet与ssh的对比"><a href="#4-telnet与ssh的对比" class="headerlink" title="4 telnet与ssh的对比"></a>4 telnet与ssh的对比</h3><table><thead><tr><th>服务连接方式</th><th>服务数据传输</th><th>服务监听端口</th><th>服务登陆用户</th></tr></thead><tbody><tr><td>ssh</td><td>加密</td><td>tcp&#x2F;22</td><td>默认支持root登录</td></tr><tr><td>telnet</td><td>明文</td><td>tcp&#x2F;23</td><td>不支持root登录</td></tr></tbody></table><h2 id="二、ssh与scp的使用"><a href="#二、ssh与scp的使用" class="headerlink" title="二、ssh与scp的使用"></a>二、ssh与scp的使用</h2><h3 id="1-使用ssh"><a href="#1-使用ssh" class="headerlink" title="1 使用ssh"></a>1 使用ssh</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh命令ssh 172.16.1.31#取决当前执行此命令的用户ssh root@172.16.1.31#标准的写法ssh -p22 root@172.16.1.31#带端口</code></pre></div></figure><h3 id="2-使用scp"><a href="#2-使用scp" class="headerlink" title="2 使用scp"></a>2 使用scp</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scp # -P 指定端口，默认22端口可不写# -r 表示递归拷贝目录# -p 表示在拷贝文件前后保持文件或目录属性不变# -l 限制传输使用带宽(默认kb) &#x2F;8 -&gt;KB  &#x2F;1024  -&gt;MB </code></pre></div></figure><h2 id="三、使用ssh密钥登录"><a href="#三、使用ssh密钥登录" class="headerlink" title="三、使用ssh密钥登录"></a>三、使用ssh密钥登录</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.生成密钥对    公钥  私钥[root@m01 ~]# ssh-keygen -C 7242xxxxx@qq.com2.将公钥推送到你需要连接的主机，第一次需要输入对端主机的密码[root@m01 ~]# ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub root@172.16.1.31root@172.16.1.31&#39;s password:3.通过ssh命令测试连接是否需要密码[root@m01 ~]# ssh 172.16.1.31Last login: Wed Jan  9 10:39:16 2019 from 172.16.1.61</code></pre></div></figure><h2 id="四、ssh安全"><a href="#四、ssh安全" class="headerlink" title="四、ssh安全"></a>四、ssh安全</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@jumpserver ~]# vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config[root@jumpserver ~]# systemctl restart sshd</code></pre></div></figure><p>SSH作为远程连接服务，通常我们需要考虑到该服务的安全，所以需要对该服务进行安全方面的配置。<br>1.更改远程连接登陆的端口6666<br>2.禁止ROOT管理员直接登录<br>3.密码认证方式改为密钥认证<br>4.重要服务不使用公网IP地址<br>5.使用防火墙限制来源IP地址</p><p>Port 6666                       # 变更SSH服务远程连接端口√<br>PermitRootLogin         no      # 禁止root用户直接远程登录√<br>PasswordAuthentication  no      # 禁止使用密码直接远程登录√<br>UseDNS                  no      # 禁止ssh进行dns反向解析，影响ssh连接效率参数√<br>GSSAPIAuthentication    no      # 禁止GSS认证，减少连接时产生的延迟√</p><h2 id="五、防ssh暴力破解工具fail2ban"><a href="#五、防ssh暴力破解工具fail2ban" class="headerlink" title="五、防ssh暴力破解工具fail2ban"></a>五、防ssh暴力破解工具fail2ban</h2><blockquote><p>fail2ban可以监控系统日志，并且根据一定规则匹配异常IP后使用Firewalld将其屏蔽，尤其是针对一些爆破&#x2F;扫描等非常有效。</p></blockquote><p>部署流程</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.开启Firewalld防火墙[root@bgx ~]# systemctl start firewalld[root@bgx ~]# systemctl enable firewalld[root@bgx ~]# firewall-cmd --staterunning2.修改firewalld规则，启用Firewalld后会禁止一些服务的传输，但默认会放行常用的22端口, 如果想添加更多，以下是放行SSH端口（22）示例，供参考：#放行SSHD服务端口[root@bgx ~]# firewall-cmd --permanent --add-service&#x3D;ssh --add-service&#x3D;http #重载配[root@bgx ~]# firewall-cmd --reload#查看已放行端口[root@bgx ~]# firewall-cmd  --list-service3.安装fail2ban,需要有epel[root@bgx ~]# yum install fail2ban fail2ban-firewalld mailx -y4.配置fail2ban规则.local会覆盖.conf文件[root@bgx fail2ban]# cat &#x2F;etc&#x2F;fail2ban&#x2F;jail.local[DEFAULT]ignoreip &#x3D; 127.0.0.1&#x2F;8bantime  &#x3D; 86400findtime &#x3D; 600maxretry &#x3D; 5banaction &#x3D; firewallcmd-ipsetaction &#x3D; %(action_mwl)s[sshd]enabled &#x3D; truefilter  &#x3D; sshdport    &#x3D; 22action &#x3D; %(action_mwl)slogpath &#x3D; &#x2F;var&#x2F;log&#x2F;secure5.启动服务，并检查状态[root@bgx ~]# systemctl start fail2ban.service[root@bgx ~]# fail2ban-client status sshd6.清除被封掉的IP地址[root@bgx ~]# fail2ban-client set sshd unbanip 10.0.0.1</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--04--Sersync实时备份</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/04-sersync%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E5%A4%87%E4%BB%BD/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/04-sersync%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Sersync服务介绍"><a href="#一、Sersync服务介绍" class="headerlink" title="一、Sersync服务介绍"></a>一、Sersync服务介绍</h2><blockquote></blockquote><h3 id="1-为什么要用sersync"><a href="#1-为什么要用sersync" class="headerlink" title="1 为什么要用sersync"></a>1 为什么要用sersync</h3><ul><li>sersync是基于inotify开发的，类似于inotify-tools的工具</li><li>sersync可以记录下被监听目录中发生变化的（包括增加、删除、修改）具体某一个文件或者某一个目录的名字，然后使用rsync同步的时候，只同步发生变化的文件或者目录</li><li>因为服务异常导致的同步失败有记录，便于恢复，确保高可用！</li></ul><h3 id="2-rsync-inotify-tools与rsync-sersync架构的区别？"><a href="#2-rsync-inotify-tools与rsync-sersync架构的区别？" class="headerlink" title="2 rsync+inotify-tools与rsync+sersync架构的区别？"></a>2 rsync+inotify-tools与rsync+sersync架构的区别？</h3><ul><li><p>rsync+inotify-tools</p><p>a、inotify只能记录下被监听的目录发生了变化（增，删，改）并没有把具体是哪个文件或者哪个目录发生了变化记录下来；</p><p>b、rsync在同步的时候，并不知道具体是哪个文件或目录发生了变化，每次都是对整个目录进行同步，当数据量很大时，整个目录同步非常耗时（rsync要对整个目录遍历查找对比文件），因此效率很低</p></li><li><p>rsync+sersync</p><p>a、sersync可以记录被监听目录中发生变化的（增，删，改）具体某个文件或目录的名字；</p><p>b、rsync在同步时，只同步发生变化的文件或目录（每次发生变化的数据相对整个同步目录数据来说很小，rsync在遍历查找对比文件时，速度很快），因此效率很高。</p></li></ul><h2 id="二、同步过程和原理"><a href="#二、同步过程和原理" class="headerlink" title="二、同步过程和原理"></a>二、同步过程和原理</h2><h3 id="1-同步过程"><a href="#1-同步过程" class="headerlink" title="1 同步过程"></a>1 同步过程</h3><ol><li>在同步服务器上开启sersync服务，sersync负责监控配置路径中的文件系统事件变化</li><li>调用rsync命令把更新的文件同步到目标服务器；</li><li>需要在主服务器配置sersync，在同步目标服务器配置rsync server（注意：是rsync服务</li></ol><h3 id="2-同步原理"><a href="#2-同步原理" class="headerlink" title="2 同步原理"></a>2 同步原理</h3><ol><li>用户实时的往sersync服务器上写入更新文件数据；</li><li>此时需要在同步主服务器上配置sersync服务；</li><li>在另一台服务器开启rsync守护进程服务，以同步拉取来自sersync服务器上的数据；</li></ol><blockquote><p>通过rsync的守护进程服务后可以发现，实际上sersync就是监控本地的数据写入或更新事件；然后，再调用rsync客户端的命令，将写入或更新事件对应的文件通过rsync推送到目标服务器。</p></blockquote><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例: 实现web上传视频文件，实则是写入NFS至存储，当NFS存在新的数据则会实时的复制到备份服务器</p></blockquote><table><thead><tr><th>角色</th><th>内网IP(LAN)</th><th>外网IP(NAT)</th><th>安装工具</th></tr></thead><tbody><tr><td>web01</td><td>eth1:172.16.1.7</td><td>eth0:10.0.0.7</td><td>httpd php</td></tr><tr><td>nfs-server</td><td>eth1:172.16.1.31</td><td>eth0:10.0.0.31</td><td>nfsServer、rsync+inotify+sersync</td></tr><tr><td>backup</td><td>eth1:172.16.1.41</td><td>eth0:10.0.0.41</td><td>rsync-server</td></tr></tbody></table><p><img src="/img/sersync%E6%B5%81%E7%A8%8B-1628145534424.png" alt="sersync流程"></p><h3 id="1-web上传视频至nfs存储"><a href="#1-web上传视频至nfs存储" class="headerlink" title="1 web上传视频至nfs存储"></a>1 web上传视频至nfs存储</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nfs存储服务  172.16.1.311.安装[root@nfs ~]# yum install nfs-utils -y2.配置[root@nfs ~]# cat &#x2F;etc&#x2F;exports&#x2F;data 172.16.1.0&#x2F;24(rw,sync,all_squash,anonuid&#x3D;666,anongid&#x3D;666)[root@nfs ~]# groupadd -g666 www[root@nfs ~]# useradd -u666 -g666 www[root@nfs ~]# mkdir &#x2F;data[root@nfs ~]# chown -R www.www &#x2F;data3.启动[root@nfs ~]# systemctl restart nfs-server[root@nfs ~]# sysytemctl enable nfs-serverweb服务器操作：172.16.1.71.安装[root@web01 ~]# yum install httpd php -y2.配置进程运行的身份（最好是和nfs的匿名用户保持一致）# sed c 匹配到User开头的字段，替换为User www[root@web01 html]# sed -i &#39;&#x2F;^User&#x2F;c User www&#39; &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf [root@web01 html]# sed -i &#39;&#x2F;^Group&#x2F;c Group www&#39; &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf挂载[root@web01 ~]# mount -t nfs 172.16.1.31:&#x2F;data &#x2F;var&#x2F;www&#x2F;html#核心上传代码[root@web01 ~]# cd &#x2F;var&#x2F;www&#x2F;html&#x2F;[root@web01 html]# rz kaoshi.zip[root@web01 html]# unzip kaoshi.zip3.启动[root@web01 ~]# systemctl start httpd4.修改上传大小[root@web01 ~]# vim &#x2F;etc&#x2F;php.ini中设置：upload_max_filesize &#x3D; 200M;post_max_size &#x3D; 200M;5.注意: 修改完配置记得重启服务[root@web01 ~]#  systemctl restart httpd</code></pre></div></figure><h3 id="2-web和nfs的数据都备份在备份服务器的-backup"><a href="#2-web和nfs的数据都备份在备份服务器的-backup" class="headerlink" title="2 web和nfs的数据都备份在备份服务器的&#x2F;backup"></a>2 web和nfs的数据都备份在备份服务器的&#x2F;backup</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">备份服务器操作如下：172.16.1.411.安装[root@backup ~]# yum install rsync -y2.配置[root@backup ~]# cat &#x2F;etc&#x2F;rsyncd.confuid &#x3D; wwwgid &#x3D; wwwport &#x3D; 873fake super &#x3D; yesuse chroot &#x3D; nomax connections &#x3D; 200timeout &#x3D; 600ignore errorsread only &#x3D; falselist &#x3D; trueauth users &#x3D; rsync_backupsecrets file &#x3D; &#x2F;etc&#x2F;rsync.passwdlog file &#x3D; &#x2F;var&#x2F;log&#x2F;rsyncd.log#####################################[backup]path &#x3D; &#x2F;backup[data]path &#x3D; &#x2F;data创建用户[root@backup ~]# groupadd -g666 www[root@backup ~]# useradd -u666 -g666 www准备虚拟连接用户账号和密码[root@backup ~]# cat &#x2F;etc&#x2F;rsync.passwd rsync_backup:123456[root@backup ~]# chmod 600 &#x2F;etc&#x2F;rsync.passwd创建数据存放的目录[root@backup ~]# mkdir -p &#x2F;data &#x2F;backup[root@backup ~]# chown -R www.www &#x2F;data&#x2F; &#x2F;backup&#x2F;3.启动[root@backup ~]# systemctl restart rsyncd4.客户端执行脚本。测试rsync的备份是否ok   （客户端的数据都写入到&#x2F;backup目录中） 172.16.1.7 172.16.1.31[root@web01 ~]# sh &#x2F;server&#x2F;scripts&#x2F;client_push_data.sh sending incremental file listweb01_172.16.1.7_2019-01-08&#x2F;web01_172.16.1.7_2019-01-08&#x2F;flag_2019-01-08web01_172.16.1.7_2019-01-08&#x2F;other.tar.gzweb01_172.16.1.7_2019-01-08&#x2F;sys.tar.gz</code></pre></div></figure><h3 id="3-如何将nfs的数据实时的同步到备份服务器的-data目录"><a href="#3-如何将nfs的数据实时的同步到备份服务器的-data目录" class="headerlink" title="3 如何将nfs的数据实时的同步到备份服务器的&#x2F;data目录"></a>3 如何将nfs的数据实时的同步到备份服务器的&#x2F;data目录</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">监控nfs服务器上面的&#x2F;data目录，如果发生变化则触发动作，动作可以是执行一次同步。1.安装[root@nfs ~]# yum install inotify-tools监控工具[root@nfs ~]# rz -E sersync2.5.4_64bit_binary_stable_final.tar.gz[root@nfs ~]# tar xf sersync2.5.4_64bit_binary_stable_final.tar.gz[root@nfs ~]# mv GNU-Linux-x86&#x2F; &#x2F;usr&#x2F;local&#x2F;sersync2.配置[root@nfs sersync]# diff confxml.xml confxml.xml.bak       5c5       &lt;     &lt;fileSystem xfs&#x3D;&quot;true&quot;&#x2F;&gt;       ---       &gt;     &lt;fileSystem xfs&#x3D;&quot;false&quot;&#x2F;&gt;       15c15       &lt;       &lt;createFile start&#x3D;&quot;true&quot;&#x2F;&gt;       ---       &gt;       &lt;createFile start&#x3D;&quot;false&quot;&#x2F;&gt;       19,20c19,20       &lt;       &lt;attrib start&#x3D;&quot;true&quot;&#x2F;&gt;       &lt;       &lt;modify start&#x3D;&quot;true&quot;&#x2F;&gt;       ---       &gt;       &lt;attrib start&#x3D;&quot;false&quot;&#x2F;&gt;       &gt;       &lt;modify start&#x3D;&quot;false&quot;&#x2F;&gt;       24,25c24,25       &lt;       &lt;localpath watch&#x3D;&quot;&#x2F;data&quot;&gt;       &lt;           &lt;remote ip&#x3D;&quot;172.16.1.41&quot; name&#x3D;&quot;data&quot;&#x2F;&gt;       ---       &gt;       &lt;localpath watch&#x3D;&quot;&#x2F;opt&#x2F;tongbu&quot;&gt;       &gt;           &lt;remote ip&#x3D;&quot;127.0.0.1&quot; name&#x3D;&quot;tongbu1&quot;&#x2F;&gt;       30,31c30,31       &lt;           &lt;commonParams params&#x3D;&quot;-az&quot;&#x2F;&gt;       &lt;           &lt;auth start&#x3D;&quot;true&quot; users&#x3D;&quot;rsync_backup&quot; passwordfile&#x3D;&quot;&#x2F;etc&#x2F;rsync.pass&quot;&#x2F;&gt;       ---       &gt;           &lt;commonParams params&#x3D;&quot;-artuz&quot;&#x2F;&gt;       &gt;           &lt;auth start&#x3D;&quot;false&quot; users&#x3D;&quot;root&quot; passwordfile&#x3D;&quot;&#x2F;etc&#x2F;rsync.pas&quot;&#x2F;&gt;       33c33       &lt;           &lt;timeout start&#x3D;&quot;true&quot; time&#x3D;&quot;100&quot;&#x2F;&gt;&lt;!-- timeout&#x3D;100 --&gt;       ---       &gt;           &lt;timeout start&#x3D;&quot;false&quot; time&#x3D;&quot;100&quot;&#x2F;&gt;&lt;!-- timeout&#x3D;100 --&gt;创建客户端密码文件[root@nfs ~]# cat &#x2F;etc&#x2F;rsync.pass123456[root@nfs ~]# chmod 600 &#x2F;etc&#x2F;rsync.pass3.启动[root@nfs ~]# &#x2F;usr&#x2F;local&#x2F;sersync&#x2F;sersync2  -hset the system paramexecute：echo 50000000 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_user_watchesexecute：echo 327679 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_queued_eventsparse the command param_______________________________________________________参数-d:启用守护进程模式参数-r:在监控前，将监控目录与远程主机用rsync命令推送一遍参数-n: 指定开启守护线程的数量，默认为10个参数-o:指定配置文件，默认使用confxml.xml文件参数-m:单独启用其他模块，使用 -m refreshCDN 开启刷新CDN模块参数-m:单独启用其他模块，使用 -m socket 开启socket模块参数-m:单独启用其他模块，使用 -m http 开启http模块不加-m参数，则默认执行同步程序启动[root@nfs ~]#  &#x2F;usr&#x2F;local&#x2F;sersync&#x2F;sersync2 -dro &#x2F;usr&#x2F;local&#x2F;sersync&#x2F;confxml.xml#启动sersync后一定要提取同步的命令，手动运行一次，检查是否存在错误[root@nfs ~]#  cd &#x2F;data &amp;&amp; rsync -az -R --delete .&#x2F;  --timeout&#x3D;100 rsync_backup@172.16.1.41::data --password-file&#x3D;&#x2F;etc&#x2F;rsync.pass停止[root@nfs data]# pkill sersync</code></pre></div></figure><h3 id="4-如何平滑的迁移nfs数据到backup服务器。并且让后续的上传都是上传至backup-（不能出现业务中断）"><a href="#4-如何平滑的迁移nfs数据到backup服务器。并且让后续的上传都是上传至backup-（不能出现业务中断）" class="headerlink" title="4 如何平滑的迁移nfs数据到backup服务器。并且让后续的上传都是上传至backup   （不能出现业务中断）"></a>4 如何平滑的迁移nfs数据到backup服务器。并且让后续的上传都是上传至backup   （不能出现业务中断）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.backup服务器上需要运行和nfs服务器上一样的业务环境 创建用户[root@backup ~]# groupadd -g 666 www[root@backup ~]# useradd -u666 -g666 www配置[root@backup ~]# yum install -y nfs-utils -y[root@backup ~]# cat &#x2F;etc&#x2F;exports&#x2F;data 172.16.1.0&#x2F;24(rw,sync,all_squash,anonuid&#x3D;666,anongid&#x3D;666)启动[root@backup ~]# systemctl restart nfs-server2.先实现实时的同步 √3.在web上实现切换，卸载nfs的&#x2F;data目录，重新挂载backup服务的&#x2F;data目录[root@web01 ~]# umount -lf &#x2F;var&#x2F;www&#x2F;html&#x2F; &amp;&amp; mount -t nfs 172.16.1.41:&#x2F;data &#x2F;var&#x2F;www&#x2F;html&#x2F;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--06--HTTP协议介绍</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/06-HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/06-HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、HTTP的发展历程"><a href="#一、HTTP的发展历程" class="headerlink" title="一、HTTP的发展历程"></a>一、HTTP的发展历程</h2><p>HTTP协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文</p><p>HTTP&#x2F;0.9 (是个简单的文本协议，只能获取文本资源；)</p><p>HTTP&#x2F;1.0 - 1996年 （确立了大部分现在使用的技术，参考文档，不具备实际约束力）</p><p>HTTP&#x2F;1.1 - 1999年 （正式标准严格遵守，功能也非常完善，互联网爆发式增长，目前互联网上使用最广泛的协议） </p><p>HTTP&#x2F;2 - 2015年 （基于 Google 的 SPDY 协议，注重性能改善，但还未普及）</p><p>HTTP&#x2F;3 - 2018年 （基于 Google 的 QUIC 协议，是将来的发展方向）</p><hr><p>课下作业</p><ol><li>你认为推动 HTTP 发展的原动力是什么？</li><li>你是怎么理解 HTTP（超文本传输协议）的？</li></ol><h2 id="二、HTTP简介"><a href="#二、HTTP简介" class="headerlink" title="二、HTTP简介"></a>二、HTTP简介</h2><p>HyperText transfer protocol （超文本传输协议）</p><ul><li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li><li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。</li><li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li><li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li></ul><hr><p>课下作业：</p><ol><li>有一种流行的说法：“HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议”，你认为这种说法对吗？对在哪里，又错在哪里？</li><li>你能再说出几个“HTTP 不是什么”吗？</li></ol><p><img src="/img/http%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="http思维导图"></p><h3 id="三、HTTP的应用领域"><a href="#三、HTTP的应用领域" class="headerlink" title="三、HTTP的应用领域"></a>三、HTTP的应用领域</h3><ol><li>互联网上绝大部分资源都使用 HTTP 协议传输；</li><li>浏览器是 HTTP 协议里的请求方，即 User Agent；</li><li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li><li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；</li><li>爬虫是另一类 User Agent，是自动访问网络资源的程序。</li></ol><hr><p>课后作业：</p><ol><li>你觉得 CDN 在对待浏览器和爬虫时会有差异吗？为什么？</li><li>你怎么理解 WebService 与 Web Server 这两个非常相似的词？</li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(一)安装与配置</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/07-Nginx(%E4%B8%80)%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/07-Nginx(%E4%B8%80)%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx简介"><a href="#一、Nginx简介" class="headerlink" title="一、Nginx简介"></a>一、Nginx简介</h2><p>参考网站：<a href="https://zhuanlan.zhihu.com/p/266153320">https://zhuanlan.zhihu.com/p/266153320</a></p><h2 id="二、Nginx安装"><a href="#二、Nginx安装" class="headerlink" title="二、Nginx安装"></a>二、Nginx安装</h2><p>​nginx有两种安装方式，yum安装和源码编译安装</p><h3 id="2-1-yum安装（epel源）"><a href="#2-1-yum安装（epel源）" class="headerlink" title="2.1 yum安装（epel源）"></a>2.1 yum安装（epel源）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo[nginx]name&#x3D;nginx repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;$basearch&#x2F;gpgcheck&#x3D;0enabled&#x3D;1yum clean allyum makecacheyum install nginx -y</code></pre></div></figure><h3 id="2-2-编译安装"><a href="#2-2-编译安装" class="headerlink" title="2.2 编译安装"></a>2.2 编译安装</h3><p>查看yum安装的nginx的编译参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# nginx -Vnginx version: nginx&#x2F;1.20.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)built with OpenSSL 1.1.1g FIPS  21 Apr 2020TLS SNI support enabledconfigure arguments: --prefix&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;client_body --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;proxy --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;fastcgi --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;uwsgi --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;scgi --pid-path&#x3D;&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;run&#x2F;lock&#x2F;subsys&#x2F;nginx --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-debug --with-file-aio --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module&#x3D;dynamic --with-http_mp4_module --with-http_perl_module&#x3D;dynamic --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_xslt_module&#x3D;dynamic --with-mail&#x3D;dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream&#x3D;dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads --with-cc-opt&#x3D;&#39;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fexceptions -fstack-protector-strong --param&#x3D;ssp-buffer-size&#x3D;4 -grecord-gcc-switches -specs&#x3D;&#x2F;usr&#x2F;lib&#x2F;rpm&#x2F;redhat&#x2F;redhat-hardened-cc1 -m64 -mtune&#x3D;generic&#39; --with-ld-opt&#x3D;&#39;-Wl,-z,relro -specs&#x3D;&#x2F;usr&#x2F;lib&#x2F;rpm&#x2F;redhat&#x2F;redhat-hardened-ld -Wl,-E&#39;</code></pre></div></figure><p>源码获取</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.20.1.tar.gz</code></pre></div></figure><p>构建与编译</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压源码文件并进入文件夹内tar -vxf nginx-1.20.1.tar.gz &amp;&amp; cd nginx-1.20.1# configure构建.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;client_body --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;proxy --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;fastcgi --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;uwsgi --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;scgi --pid-path&#x3D;&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;run&#x2F;lock&#x2F;subsys&#x2F;nginx --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-debug --with-file-aio --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module&#x3D;dynamic --with-http_mp4_module --with-http_perl_module&#x3D;dynamic --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_xslt_module&#x3D;dynamic --with-mail&#x3D;dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream&#x3D;dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads --with-cc-opt&#x3D;&#39;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fexceptions -fstack-protector-strong --param&#x3D;ssp-buffer-size&#x3D;4 -grecord-gcc-switches -specs&#x3D;&#x2F;usr&#x2F;lib&#x2F;rpm&#x2F;redhat&#x2F;redhat-hardened-cc1 -m64 -mtune&#x3D;generic&#39; --with-ld-opt&#x3D;&#39;-Wl,-z,relro -specs&#x3D;&#x2F;usr&#x2F;lib&#x2F;rpm&#x2F;redhat&#x2F;redhat-hardened-ld -Wl,-E&#39;# 编译并安装make -j 4 &amp;&amp; make install</code></pre></div></figure><p>错误解决</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 错误1：.&#x2F;configure: error: the invalid value in --with-ld-opt&#x3D;&quot;-Wl,-z,relro -specs&#x3D;&#x2F;usr&#x2F;lib&#x2F;rpm&#x2F;redhat&#x2F;redhat-hardened-ld -Wl,-E&quot;解决方法：yum -y install redhat-rpm-config.noarch# 错误2：.&#x2F;configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using --with-pcre&#x3D;&lt;path&gt; option.解决方法：yum install pcre-devel -y# 错误3：.&#x2F;configure: error: SSL modules require the OpenSSL library.You can either do not enable the modules, or install the OpenSSL libraryinto the system, or build the OpenSSL library statically from the sourcewith nginx by using --with-openssl&#x3D;&lt;path&gt; option.解决方法：yum install openssl openssl-devel -y# 错误4：.&#x2F;configure: error: the HTTP XSLT module requires the libxml2&#x2F;libxsltlibraries. You can either do not enable the module or install the libraries.解决方法：yum install libxml2 libxml2-devel libxslt  libxslt-devel -y# 错误5：.&#x2F;configure: error: the HTTP image filter module requires the GD library.You can either do not enable the module or install the libraries.解决方法：yum -y install gd-devel# 错误6：.&#x2F;configure: error: perl module ExtUtils::Embed is required解决方法： yum -y install perl-devel perl-ExtUtils-Embed# 错误7：.&#x2F;configure: error: the Google perftools module requires the Google perftools library解决方法：yum install gperftools-devel.x86_64 gperftools-libs.x86_64 gperftools.x86_64 -y</code></pre></div></figure><h3 id="2-3-启动和停止服务"><a href="#2-3-启动和停止服务" class="headerlink" title="2.3 启动和停止服务"></a>2.3 启动和停止服务</h3><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先关闭httpd服务，防止冲突[root@web01 ~]# systemctl stop httpd[root@web01 ~]# systemctl disable httpd# 再启动nginx服务[root@web01 ~]# systemctl enable nginx[root@web01 html]# systemctl start nginx# 另一种启动方式nginx</code></pre></div></figure><p>停止服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop nginx # 或者nginx -s stop </code></pre></div></figure><p>重启&#x2F;重载服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart&#x2F;reload nginxnginx -s restart&#x2F;reload </code></pre></div></figure><blockquote><p>PS：重载reload和重启restart的差别</p><p>reload将会等服务进程执行完再重启，而restart则是强制重启</p></blockquote><h2 id="三、Nginx目录结构说明"><a href="#三、Nginx目录结构说明" class="headerlink" title="三、Nginx目录结构说明"></a>三、Nginx目录结构说明</h2><p>查看nginx的目录结构</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 html]# rpm -ql nginx</code></pre></div></figure><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/137262519">https://zhuanlan.zhihu.com/p/137262519</a></p><h2 id="四、Nginx配置文件说明"><a href="#四、Nginx配置文件说明" class="headerlink" title="四、Nginx配置文件说明"></a>四、Nginx配置文件说明</h2><blockquote><p>http server location扩展了解项<br>http{}层下允许有多个Server{}层，一个Server{}层下又允许有多个Location<br>http{} 标签主要用来解决用户的请求与响应。<br>server{} 标签主要用来响应具体的某一个网站。<br>location{} 标签主要用于匹配网站具体URL路径。</p></blockquote><p>主配置文件说明</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 html]# cat &#x2F;etc&#x2F;nginx&#x2F;nginx.conf---核心模块---user nginx;#nginx进程运行的用户worker_processes auto;#nginx工作的进程数量error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;#nginx的错误日志【警告及其警告以上的都记录】pid &#x2F;run&#x2F;nginx.pid;#nginx进程运行后的进程id---核心模块---# Load dynamic modules. See &#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx&#x2F;README.dynamic.include &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;modules&#x2F;*.conf;---事件模块---events &#123;    worker_connections 1024; # 一个work进程的最大连接数    use epool; #使用epool网络模型&#125;---事件模块------http核心层模块---http &#123;# 日志格式定义    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;# 访问日志    sendfile            on;    tcp_nopush          on;    tcp_nodelay         on;    keepalive_timeout   65;# 长连接超时时间    types_hash_max_size 4096;    #gzip on;#是否开启压缩功能    include             &#x2F;etc&#x2F;nginx&#x2F;mime.types;    default_type        application&#x2F;octet-stream;    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;# 包含哪个目录下面的*.conf文件，用于写server    server &#123;        listen       80;# 监听端口        listen       [::]:80;        server_name  _;# 域名        root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;#charset koi8-r;#字符集location &#x2F; &#123; #位置root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;#代码的主文件位置index  index.html index.htm;#服务端默认返回给用户的文件&#125;location &#x2F;test &#123; #位置root   &#x2F;code&#x2F;test&#x2F;123&#x2F;;#代码的主文件位置index  index.html index.htm;#服务端默认返回给用户的文件&#125;        # Load configuration files for the default server block.        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;        error_page 404 &#x2F;404.html;        location &#x3D; &#x2F;404.html &#123;        &#125;        error_page 500 502 503 504 &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;        &#125;    &#125;&#125;---http核心层模块---</code></pre></div></figure><h2 id="五、案例：搭建web网站"><a href="#五、案例：搭建web网站" class="headerlink" title="五、案例：搭建web网站"></a>五、案例：搭建web网站</h2><p>准备配置文件ds</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@web01 code]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;game.confserver &#123;        listen 80;        server_name game.oldboy.com;        location &#x2F; &#123;                root &#x2F;code;                index index.html;        &#125;&#125;</code></pre></div></figure><p>按照配置文件创建文件夹并放入html项目文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;codecp html5.zip &#x2F;codecd &#x2F;codeunzip html5.zip[root@web01 code]# lsceshi  game  html5.zip  img  index.html  __MACOSX  readme.txt</code></pre></div></figure><p>重启nginx服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart nginxsystemctl reload nginx</code></pre></div></figure><p>通过物理机浏览器浏览</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改hosts文件10.0.0.7 game.oldboy.com# 网页访问game.oldboy.com</code></pre></div></figure><h2 id="六、Nginx虚拟主机"><a href="#六、Nginx虚拟主机" class="headerlink" title="六、Nginx虚拟主机"></a>六、Nginx虚拟主机</h2><p>Nginx配置虚拟主机有如下三种方式：</p><ul><li>单主机多IP</li><li>单主机多端口</li><li>单主机多域名</li></ul><h3 id="6-1-基于主机多IP方式-不常用"><a href="#6-1-基于主机多IP方式-不常用" class="headerlink" title="6.1 基于主机多IP方式(不常用)"></a>6.1 基于主机多IP方式(不常用)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cat ip.conf server &#123;listen 10.0.0.7:80;server_name _;location &#x2F; &#123;root &#x2F;code_ip_eth0;index index.html;&#125;&#125;server &#123;listen 172.16.1.7:80;server_name _;location &#x2F; &#123;root &#x2F;code_ip_eth1;index index.html;&#125;&#125;2.根据配置创建目录[root@web01 conf.d]# mkdir &#x2F;code_ip_eth0[root@web01 conf.d]# echo &quot;Eth0&quot; &gt; &#x2F;code_ip_eth0&#x2F;index.html[root@web01 conf.d]# mkdir &#x2F;code_ip_eth1[root@web01 conf.d]# echo &quot;Eth1&quot; &gt; &#x2F;code_ip_eth1&#x2F;index.html3.重启nginx服务[root@web01 conf.d]# systemctl restart nginx4.使用curl命令测试[root@web01 ~]# curl 172.16.1.7Eth1[root@web01 ~]# curl 10.0.0.7Eth0</code></pre></div></figure><h3 id="6-2-基于主机多端口方式（多用于内部测试）"><a href="#6-2-基于主机多端口方式（多用于内部测试）" class="headerlink" title="6.2 基于主机多端口方式（多用于内部测试）"></a>6.2 基于主机多端口方式（多用于内部测试）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.配置多端口的虚拟主机[root@web01 conf.d]# vim port.confserver &#123;        listen 81;                location &#x2F; &#123;                 root &#x2F;code_81;                index index.html;        &#125;&#125;server &#123;        listen 82;                location &#x2F; &#123;                 root &#x2F;code_82;                index index.html;        &#125;&#125;2.根据配置文件创建所需的目录[root@web01 conf.d]# mkdir &#x2F;code_8&#123;1..2&#125;[root@web01 conf.d]# echo &quot;81&quot; &gt; &#x2F;code_81&#x2F;index.html[root@web01 conf.d]# echo &quot;82&quot; &gt; &#x2F;code_82&#x2F;index.html3.检查语法并重启服务[root@web01 conf.d]# nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful[root@web01 conf.d]# systemctl restart nginx4.如何去访问http:&#x2F;&#x2F;10.0.0.7:82&#x2F;</code></pre></div></figure><h3 id="6-3-基于主机多域名方式（常用）"><a href="#6-3-基于主机多域名方式（常用）" class="headerlink" title="6.3 基于主机多域名方式（常用）"></a>6.3 基于主机多域名方式（常用）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.准备多虚拟主机配置文件[root@web01 conf.d]# cat test1.oldboy.com.conf server &#123;listen 80;server_name test1.oldboy.com;location &#x2F; &#123;root &#x2F;code&#x2F;test1;index index.html;&#125;&#125;[root@web01 conf.d]# cat test2.oldboy.com.conf server &#123;listen 80;server_name test2.oldboy.com;location &#x2F; &#123;root &#x2F;code&#x2F;test2;index index.html;&#125;&#125;2.根据配置文件创建对应的目录[root@web01 conf.d]# mkdir &#x2F;code&#x2F;test&#123;1..2&#125; -p[root@web01 conf.d]# echo &quot;test1_server&quot; &gt; &#x2F;code&#x2F;test1&#x2F;index.html[root@web01 conf.d]# echo &quot;test2_server&quot; &gt; &#x2F;code&#x2F;test2&#x2F;index.html[root@web01 conf.d]# nginx -t[root@web01 conf.d]# systemctl restart nginx3.配置域名解析10.0.0.7      test1.oldboy.com10.0.0.7      test2.oldboy.com4.通过浏览器访问该网站</code></pre></div></figure><h2 id="七、日志与错误排查"><a href="#七、日志与错误排查" class="headerlink" title="七、日志与错误排查"></a>七、日志与错误排查</h2><h3 id="7-1-nginx配置文件自查"><a href="#7-1-nginx配置文件自查" class="headerlink" title="7.1 nginx配置文件自查"></a>7.1 nginx配置文件自查</h3><p>1.修改完配置记得检查语法</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">nginx -t</code></pre></div></figure><p>2.如果没有检查语法，直接重载导致报错，可查看错误信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status nginx -l </code></pre></div></figure><h3 id="7-2-访问日志"><a href="#7-2-访问日志" class="headerlink" title="7.2 访问日志"></a>7.2 访问日志</h3><p>可以为server和location单独设置访问日志（<em><strong>涉及日志作用域</strong></em>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 80;    server_name code.oldboy.com;        # 将当前的server网站的访问日志记录至对应的目录，使用main格式    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;code.oldboy.com.log main;    location &#x2F; &#123;        root &#x2F;code;    &#125;    # 当有人请求改favicon.ico时，不记录日志    location &#x2F;favicon.ico &#123;        access_log off;  # off 关闭        return 200;    &#125;&#125;</code></pre></div></figure><p>访问日志参数详解</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</code></pre></div></figure><table><thead><tr><th><strong>变量名称</strong></th><th><strong>变量描述</strong></th><th><strong>举例说明</strong></th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端地址</td><td>113.140.15.90</td></tr><tr><td>$remote_user</td><td>客户端用户名称</td><td>–</td></tr><tr><td>$time_local</td><td>访问时间和时区</td><td>18&#x2F;Jul&#x2F;2012:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求的URI和HTTP协议</td><td>“GET &#x2F;pa&#x2F;img&#x2F;home&#x2F;logo-alipay-t.png HTTP&#x2F;1.1″</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td>img.alipay.com10.253.70.103</td></tr><tr><td>$status</td><td>HTTP请求状态</td><td>200</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端文件内容大小</td><td>547</td></tr><tr><td>$http_referer</td><td>跳转来源</td><td>“<a href="https://cashier.alip/">https://cashier.alip</a>ay.com…&#x2F;”</td></tr><tr><td>$http_user_agent</td><td>用户终端代理</td><td>“Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; GTB7.0; .NET4.0C;</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本</td><td>TLSv1</td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.228.35.247:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.205</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr></tbody></table><h3 id="7-3-错误日志"><a href="#7-3-错误日志" class="headerlink" title="7.3 错误日志"></a>7.3 错误日志</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</code></pre></div></figure><h3 id="7-4-日志切割logrotate"><a href="#7-4-日志切割logrotate" class="headerlink" title="7.4 日志切割logrotate"></a>7.4 日志切割logrotate</h3><p>配置文件，一般不需要修改，默认就行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 logrotate.d]# cat &#x2F;etc&#x2F;logrotate.d&#x2F;nginx&#x2F;var&#x2F;log&#x2F;nginx&#x2F;*.log &#123;    create 0640 nginx root     daily# 每天切割日志    rotate 10    missingok# 日志丢失忽略    notifempty    compress# 日志文件压缩    sharedscripts    postrotate        &#x2F;bin&#x2F;kill -USR1 &#96;cat &#x2F;run&#x2F;nginx.pid 2&gt;&#x2F;dev&#x2F;null&#96; 2&gt;&#x2F;dev&#x2F;null || true    endscript&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(三)LNMP介绍</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/09-Nginx(%E4%B8%89)LNMP%E6%9E%B6%E6%9E%84%E5%AE%89%E8%A3%85/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/09-Nginx(%E4%B8%89)LNMP%E6%9E%B6%E6%9E%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="一、LNMP简介-需补充"><a href="#一、LNMP简介-需补充" class="headerlink" title="一、LNMP简介(需补充)"></a>一、LNMP简介(需补充)</h2><h3 id="1-1-什么是LNMP"><a href="#1-1-什么是LNMP" class="headerlink" title="1.1 什么是LNMP"></a>1.1 什么是LNMP</h3><h3 id="1-2-LNMP架构是如何工作的"><a href="#1-2-LNMP架构是如何工作的" class="headerlink" title="1.2 LNMP架构是如何工作的"></a>1.2 LNMP架构是如何工作的</h3><p>浏览器 –http–&gt; Nginx(fastcgi_pass) –fastcgi–&gt;php(fastcgi_fpm调动wrapper再调动php解析再调用mysql)</p><p>大致流程：</p><p>用户在浏览器发起请求，如果请求的是静态资源，Nginx则直接返回，如果请求的是动态资源，Nginx会通过fastcgi协议，将请求交给PHP服务器，再返回动态资源。</p><h3 id="1-3-LNMP和LAMP的区别是什么"><a href="#1-3-LNMP和LAMP的区别是什么" class="headerlink" title="1.3 LNMP和LAMP的区别是什么"></a>1.3 LNMP和LAMP的区别是什么</h3><p>nginx 是以fastcgi协议调用的php<br>apache是以模块的方式加载的php</p><h2 id="二、LNMP架构简单搭建"><a href="#二、LNMP架构简单搭建" class="headerlink" title="二、LNMP架构简单搭建"></a>二、LNMP架构简单搭建</h2><p>1、准备一台名为nginx的服务器</p><p>2、使用官方仓库安装nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加安装源[root@nginx ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo [nginx]name&#x3D;nginx repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;$basearch&#x2F;gpgcheck&#x3D;0enabled&#x3D;1#安装Nginx[root@nginx ~]# yum install nginx -y</code></pre></div></figure><p>3、安装php7.1</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nginx ~]# yum remove php-mysql-5.4 php php-fpm php-common # 卸载默认5.4版本的php[root@nginx ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;php.repo[php]name &#x3D; php Repositorybaseurl &#x3D; http:&#x2F;&#x2F;us-east.repo.webtatic.com&#x2F;yum&#x2F;el7&#x2F;x86_64&#x2F;gpgcheck &#x3D; 0[root@nginx ~]# yum -y install php71w php71w-cli php71w-common php71w-devel php71w-embedded php71w-gd php71w-mcrypt php71w-mbstring php71w-pdo php71w-xml php71w-fpm php71w-mysqlnd php71w-opcache php71w-pecl-memcached php71w-pecl-redis php71w-pecl-mongodb</code></pre></div></figure><p>4、安装maria数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@nginx ~]# yum install mariadb-server mariadb -y</code></pre></div></figure><p>5、配置nginx和php集成</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;[root@web01 conf.d]# cat php.conf server &#123;listen 80;server_name php.oldboy.com;root &#x2F;code;location &#x2F; &#123;index index.php index.html;&#125;location ~ \.php$ &#123;fastcgi_pass 127.0.0.1:9000;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125;&#125;</code></pre></div></figure><p>6、重载nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful[root@web01 conf.d]# systemctl restart nginx</code></pre></div></figure><p>7、启动php-fpm，并加入开机自启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# systemctl start php-fpm[root@web01 conf.d]# systemctl enable  php-fpm</code></pre></div></figure><p>8、准备一个php文件，测试nginx和php是否继承成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cat &#x2F;code&#x2F;page.php&lt;?phpphpinfo();?&gt;# 测试：网页访问:http:&#x2F;&#x2F;php.oldboy.com&#x2F;page.php</code></pre></div></figure><p>9、启动数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# systemctl start mariadb[root@web01 conf.d]# systemctl enable mariadb[root@web01 conf.d]# mysqladmin password &#39;Bgx123.com&#39;#配置密码（默认mysql是空密码）[root@web01 conf.d]# mysql -uroot -pBgx123.com#使用账号和密码登录mysql</code></pre></div></figure><p>10、准备一个php文件，测试是否可以正常连接数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">&lt;?php  $servername &#x3D; &quot;localhost&quot;;  $username &#x3D; &quot;root&quot;;  $password &#x3D; &quot;Bgx123.com&quot;;  &#x2F;&#x2F; 创建连接  $conn &#x3D; mysqli_connect($servername, $username, $password);  &#x2F;&#x2F; 检测连接  if (!$conn) &#123;      die(&quot;Connection failed: &quot; . mysqli_connect_error()); &#x2F;&#x2F; 注意格式  &#125;  echo &quot;php连接MySQL数据库成功&quot;;  ?&gt;</code></pre></div></figure><h2 id="三、案例-搭建wordpress博客"><a href="#三、案例-搭建wordpress博客" class="headerlink" title="三、案例-搭建wordpress博客"></a>三、案例-搭建wordpress博客</h2><h3 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h3><table><thead><tr><th>用途</th><th>公网IP地址</th><th>内网IP地址</th></tr></thead><tbody><tr><td>web服务器01</td><td>10.0.0.7</td><td>172.16.1.7</td></tr></tbody></table><h3 id="3-2-部署安装"><a href="#3-2-部署安装" class="headerlink" title="3.2 部署安装"></a>3.2 部署安装</h3><p>1、添加nginx配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cat blog.oldboy.com.conf server &#123;listen 80;server_name blog.oldboy.com;root &#x2F;code&#x2F;wordpress;location &#x2F; &#123;index index.php index.html;&#125;location ~ \.php$ &#123;fastcgi_pass 127.0.0.1:9000;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125;&#125;</code></pre></div></figure><p>2、根据nginx中定义的内容，创建站点目录并进行授权</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# mkdir &#x2F;code[root@web01 conf.d]# cd &#x2F;code[root@web01 code]# wget https:&#x2F;&#x2F;cn.wordpress.org&#x2F;wordpress-5.0.3-zh_CN.tar.gz[root@web01 code]# tar xf wordpress-5.0.3-zh_CN.tar.gz</code></pre></div></figure><p>3、修改nginx与php-fpm的运行用户为www，并授权代码属主和属组都为www</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#注意：如果没有该用户，启动一定会报错[root@web01 code]# groupadd -g 666 www[root@web01 code]# useradd -u666 -g666 www修改nginx与php-fpm管理进程，的运行身份为www[root@web01 code]# sed -i &#39;&#x2F;^user &#x2F;c user  www;&#39; &#x2F;etc&#x2F;nginx&#x2F;nginx.conf[root@web01 code]# sed -i &#39;&#x2F;^user&#x2F;c user &#x3D; www&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf [root@web01 code]# sed -i &#39;&#x2F;^group&#x2F;c group &#x3D; www&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf 一定要重启才生效[root@web01 code]# systemctl restart nginx[root@web01 code]# systemctl restart php-fpm最后授权代码为www[root@web01 code]# chown -R www.www &#x2F;code&#x2F;wordpress</code></pre></div></figure><p>4、创建数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">MariaDB [(none)]&gt; create database wordpress;#创建一个库，名称叫wordpressQuery OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; show databases;#查询该台数据库服务有多少个库+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || test               || wordpress          |+--------------------+5 rows in set (0.00 sec)</code></pre></div></figure><p>5、解决nginx上传文件大小限制（默认1M，超过大小会报413）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在wordpress的nginx配置文件中添加：client_max_body_size 100m;[root@web01 code]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;blog.oldboy.com.conf server &#123;        listen 80;        server_name blog.oldboy.com;        root &#x2F;code&#x2F;wordpress;        client_max_body_size 100m;  # 默认1M，超过大小会报413        location &#x2F; &#123;                index index.php index.html;        &#125;        location ~ \.php$ &#123;                fastcgi_pass 127.0.0.1:9000;                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;                include fastcgi_params;        &#125;&#125;重启nginx：systemctl restart nginx</code></pre></div></figure><blockquote><p>测试在wordpress页面上传主题或者写文章上传图片，均出现500报错<br>查看日志文件&#x2F;var&#x2F;log&#x2F;nginx&#x2F;err.log<br>2021&#x2F;08&#x2F;16 18:59:31 [crit] 1228#1228: *2 open() “&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;client_body&#x2F;0000000001” failed (13: Permission denied), client: 10.0.0.1, server: php.gs.com, request: “POST &#x2F;wp-admin&#x2F;update.php?action&#x3D;upload-theme HTTP&#x2F;1.1”, host: “php.gs.com”, referrer: “<a href="http://php.gs.com/wp-admin/theme-install.php?browse=popular">http://php.gs.com/wp-admin/theme-install.php?browse=popular</a>“<br>解决方法，参考<a href="https://blog.csdn.net/qq_15941409/article/details/114640122">https://blog.csdn.net/qq_15941409/article/details/114640122</a><br>chown www:www -R &#x2F;var&#x2F;lib&#x2F;nginx&#x2F;</p></blockquote><h2 id="四、案例-搭建wecenter知乎"><a href="#四、案例-搭建wecenter知乎" class="headerlink" title="四、案例-搭建wecenter知乎"></a>四、案例-搭建wecenter知乎</h2><h3 id="4-1-部署安装"><a href="#4-1-部署安装" class="headerlink" title="4.1 部署安装"></a>4.1 部署安装</h3><p>1、添加nginx配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;listen 80;server_name zh.oldboy.com;root &#x2F;code&#x2F;zh;client_max_body_size 100m;location &#x2F; &#123;index index.php index.html;&#125;location ~ \.php$ &#123;fastcgi_pass 127.0.0.1:9000;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125;&#125;[root@web01 code]# systemctl restart nginx</code></pre></div></figure><p>2、wencenter部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 code]# rz -E WeCenter_3-2-1.zip[root@web01 code]# unzip WeCenter_3-2-1.zip[root@web01 code]# mv WeCenter_3-2-1 zh[root@web01 code]# chown -R www.www zh&#x2F;</code></pre></div></figure><p>3、配置数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 code]# mysql -uroot -pBgx123.comMariaDB [(none)]&gt; create database zh;MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || test               || wordpress          || zh                 |+--------------------+6 rows in set (0.00 sec)</code></pre></div></figure><h2 id="五、案例-搭建edusoho在线视频教育"><a href="#五、案例-搭建edusoho在线视频教育" class="headerlink" title="五、案例-搭建edusoho在线视频教育"></a>五、案例-搭建edusoho在线视频教育</h2><h3 id="5-1-部署安装"><a href="#5-1-部署安装" class="headerlink" title="5.1 部署安装"></a>5.1 部署安装</h3><p>1、添加nginx配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 code]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;edu.oldboy.com.conf server &#123;    listen 80;    server_name edu.oldboy.com;    root &#x2F;code&#x2F;edusoho&#x2F;web;    client_max_body_size 200m;    location &#x2F; &#123;        index app.php;        try_files $uri @rewriteapp;    &#125;    location @rewriteapp &#123;        rewrite ^(.*)$ &#x2F;app.php&#x2F;$1 last;    &#125;    location ~ ^&#x2F;udisk &#123;        internal;        root &#x2F;code&#x2F;edusoho&#x2F;app&#x2F;data&#x2F;;    &#125;    location ~ ^&#x2F;(app|app_dev)\.php(&#x2F;|$) &#123;        fastcgi_pass   127.0.0.1:9000;        fastcgi_split_path_info ^(.+\.php)(&#x2F;.*)$;        include fastcgi_params;        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;        fastcgi_param  HTTPS              off;        fastcgi_param HTTP_X-Sendfile-Type X-Accel-Redirect;        fastcgi_param HTTP_X-Accel-Mapping &#x2F;udisk&#x3D;&#x2F;code&#x2F;edusoho&#x2F;app&#x2F;data&#x2F;udisk;        fastcgi_buffer_size 128k;        fastcgi_buffers 8 128k;    &#125;    # 配置设置图片格式文件    location ~* \.(jpg|jpeg|gif|png|ico|swf)$ &#123;        # 过期时间为3年        expires 3y;        # 关闭日志记录        access_log off;        # 关闭gzip压缩，减少CPU消耗，因为图片的压缩率不高。        gzip off;    &#125;    # 配置css&#x2F;js文件    location ~* \.(css|js)$ &#123;        access_log off;        expires 3y;    &#125;    # 禁止用户上传目录下所有.php文件的访问，提高安全性    location ~ ^&#x2F;files&#x2F;.*\.(php|php5)$ &#123;        deny all;    &#125;    # 以下配置允许运行.php的程序，方便于其他第三方系统的集成。    location ~ \.php$ &#123;        fastcgi_pass   127.0.0.1:9000;        fastcgi_split_path_info ^(.+\.php)(&#x2F;.*)$;        include fastcgi_params;        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;        fastcgi_param  HTTPS              off;    &#125;&#125;</code></pre></div></figure><p>2、下载edusoho,并授权文件夹</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;download.edusoho.com&#x2F;edusoho-8.2.17.tar.gztar xf edusoho-8.2.17.tar.gzchown -R www.www edusoho</code></pre></div></figure><p>3、调整php的上传大小(上传文件默认有限制大小)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# vim &#x2F;etc&#x2F;php.inipost_max_size &#x3D; 200Mupload_max_filesize &#x3D; 200M[root@web01 code]# systemctl restart php-fpm</code></pre></div></figure><h2 id="六、各开源项目网站"><a href="#六、各开源项目网站" class="headerlink" title="六、各开源项目网站"></a>六、各开源项目网站</h2><p>phpmyadmin<a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a><br>zblog<a href="https://www.zblogcn.com/">https://www.zblogcn.com/</a><br>wordpress<a href="https://cn.wordpress.org/">https://cn.wordpress.org/</a><br>wecenter<a href="http://www.wecenter.com/downloads/">http://www.wecenter.com/downloads/</a><br>edusohu<a href="http://www.edusoho.com/open/show">http://www.edusoho.com/open/show</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(四)LNMP架构拆分</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/10-Nginx(%E5%9B%9B)LNMP%E6%9E%B6%E6%9E%84%E6%8B%86%E5%88%86/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/10-Nginx(%E5%9B%9B)LNMP%E6%9E%B6%E6%9E%84%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、拆分数据库"><a href="#一、拆分数据库" class="headerlink" title="一、拆分数据库"></a>一、拆分数据库</h2><blockquote><p>为什么要拆分数据库?</p><p>mysql内存占用大，容易引起网页访问速度变慢，甚至oom(out of memory)被系统自动kill掉，不安全</p></blockquote><h3 id="1-2-环境准备"><a href="#1-2-环境准备" class="headerlink" title="1.2 环境准备"></a>1.2 环境准备</h3><table><thead><tr><th>主机名称</th><th>应用环境</th><th>外网地址</th><th>内网地址</th></tr></thead><tbody><tr><td>web01</td><td>nginx+php</td><td>10.0.0.7</td><td>172.16.1.7</td></tr><tr><td>db01</td><td>mysql</td><td></td><td>172.16.1.51</td></tr></tbody></table><h3 id="1-2-拆分过程"><a href="#1-2-拆分过程" class="headerlink" title="1.2 拆分过程"></a>1.2 拆分过程</h3><p>1、备份172.16.1.7服务器上mysql的数据</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# mysqldump -uroot -p&#39;Bgx123.com&#39; --all-databases --single-transaction &gt; mysql-all.sql</code></pre></div></figure><p>2、传输172.16.1.7的备份数据至172.16.1.51的服务器上</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# scp mysql-all.sql root@172.16.1.51:&#x2F;tmp</code></pre></div></figure><p>3、需要先在172.16.1.51服务器上安装mysql服务，然后使用mysql命令进行还原。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]# yum install mariadb-server mariadb -y[root@db01 ~]# systemctl enable mariadb[root@db01 ~]# systemctl start mariadb[root@db01 ~]# mysql &lt;&#x2F;tmp&#x2F;mysql-all.sql[root@db01 ~]# systemctl restart mariadb[root@db01 ~]# mysql -uroot -pBgx123.comMariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || edusoho            || mysql              || performance_schema || test               || wordpress          || zh                 |+--------------------+7 rows in set (0.00 sec)</code></pre></div></figure><p>4、将web程序连接的本地数据库修改到远程数据库上。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1）先在本地172.16.1.7服务器上停止本地的数据库[root@web01 ~]# systemctl disable mariadb[root@web01 ~]# systemctl stop mariadb2）在172.16.1.51的服务器上授权远程主机能够能连接mysql数据库[root@db01 ~]# mysql -uroot -pBgx123.comMariaDB [(none)]&gt; grant all privileges on *.* to oldboy@&#39;%&#39; identified by &#39;Bgx123.com&#39;;解释：*.*: 所有数据库下的所有表oldboy@&#39;%&#39;: 允许所有网段的oldboy用户访问identify: 设置密码3）在172.16.1.7服务器上测试远程账户能否连接172.16.1.51的数据库[root@web01 wordpress]# yum install mariadb -y[root@web01 wordpress]# mysql -h 172.16.1.51 -uoldboy -pBgx123.comMariaDB [(none)]&gt; 4）在172.16.1.7服务器上修改web程序连接数据库的配置文件[root@web01 wordpress]# vim &#x2F;code&#x2F;wordpress&#x2F;wp-config.php&#x2F;&#x2F; ** MySQL 设置 - 具体信息来自您正在使用的主机 ** &#x2F;&#x2F;&#x2F;** WordPress数据库的名称 *&#x2F;define(&#39;DB_NAME&#39;, &#39;wordpress&#39;);&#x2F;** MySQL数据库用户名 *&#x2F;define(&#39;DB_USER&#39;, &#39;oldboy&#39;);&#x2F;** MySQL数据库密码 *&#x2F;define(&#39;DB_PASSWORD&#39;, &#39;Bgx123.com&#39;);&#x2F;** MySQL主机 *&#x2F;define(&#39;DB_HOST&#39;, &#39;172.16.1.51&#39;);</code></pre></div></figure><p>5、拆分172.16.1.7wecenter连接远程172.16.1.51数据库信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 zh]# grep -R &quot;Bgx123.com&quot; *system&#x2F;config&#x2F;database.php:  &#39;password&#39; &#x3D;&gt; &#39;Bgx123.com&#39;,[root@web01 zh]# vim &#x2F;code&#x2F;zh&#x2F;system&#x2F;config&#x2F;database.php $config[&#39;driver&#39;] &#x3D; &#39;MySQLi&#39;;^M$config[&#39;master&#39;] &#x3D; array (  &#39;charset&#39; &#x3D;&gt; &#39;utf8&#39;,  &#39;host&#39; &#x3D;&gt; &#39;172.16.1.51&#39;,  &#39;username&#39; &#x3D;&gt; &#39;oldboy&#39;,  &#39;password&#39; &#x3D;&gt; &#39;Bgx123.com&#39;,  &#39;dbname&#39; &#x3D;&gt; &#39;zh&#39;,);^M</code></pre></div></figure><p>6、拆分172.16.1.7 edusoho连接远程172.16.1.51数据库信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 edusoho]# vim &#x2F;code&#x2F;edusoho&#x2F;app&#x2F;config&#x2F;parameters.ymldatabase_driver: pdo_mysqldatabase_host: 172.16.1.51database_port: 3306database_name: edusohodatabase_user: oldboydatabase_password: &#39;Bgx123.com&#39;必须清理缓存[root@web01 edusoho]# rm -rf &#x2F;code&#x2F;edusoho&#x2F;app&#x2F;cache&#x2F;*</code></pre></div></figure><h2 id="二、扩展多台web服务器"><a href="#二、扩展多台web服务器" class="headerlink" title="二、扩展多台web服务器"></a>二、扩展多台web服务器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.统一环境    0）准备对应的www用户    [root@web02 ~]# groupadd -g666 www    [root@web02 ~]# useradd -u666 -g666 www    1）拷贝web01上面的yum仓库    [root@web02 ~]# scp root@172.16.1.7:&#x2F;etc&#x2F;yum.repos.d&#x2F;*.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;    2）安装nginx和php    [root@web02 ~]# yum -y install nginx php71w php71w-cli php71w-common php71w-devel php71w-embedded php71w-gd php71w-mcrypt php71w-mbstring php71w-pdo php71w-xml php71w-fpm php71w-mysqlnd php71w-opcache php71w-pecl-memcached php71w-pecl-redis php71w-pecl-mongodb2.统一配置（同步web01上面的配置到web02）    1）同步nginx    [root@web02 ~]# rsync  -avz --delete root@172.16.1.7:&#x2F;etc&#x2F;nginx&#x2F; &#x2F;etc&#x2F;nginx&#x2F;    [root@web02 ~]# nginx -t    [root@web02 ~]# systemctl enable nginx    [root@web02 ~]# systemctl start nginx    2）同步php（&#x2F;etc&#x2F;php-fpm.conf &#x2F;etc&#x2F;php-fpm.d  &#x2F;etc&#x2F;php.ini）    [root@web02 ~]# rsync  -avz --delete root@172.16.1.7:&#x2F;etc&#x2F;php* &#x2F;etc&#x2F;    [root@web02 ~]# systemctl enable php-fpm    [root@web02 ~]# systemctl start php-fpm3.统一代码    [root@web01 ~]# tar czf code.tar.gz &#x2F;code#在web01上打包站点    [root@web01 ~]# scp code.tar.gz root@172.16.1.8:&#x2F;tmp#在web01上将打包好的代码发送给web02    [root@web02 ~]# tar xf &#x2F;tmp&#x2F;code.tar.gz -C &#x2F;#在web02上进行解压，并解压到&#x2F;目录下4.配置解析，进行访问</code></pre></div></figure><h2 id="三、NFS共享多台web的静态资源"><a href="#三、NFS共享多台web的静态资源" class="headerlink" title="三、NFS共享多台web的静态资源"></a>三、NFS共享多台web的静态资源</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.准备172.16.1.31共享存储服务器，规划目录，配置好权限    0）创建用户    [root@nfs ~]# groupadd -g666 www    [root@nfs ~]# useradd -u666 -g666 www    1）安装    [root@nfs ~]# yum install nfs-utils -y    2）配置    [root@nfs ~]# cat &#x2F;etc&#x2F;exports    &#x2F;data&#x2F;blog 172.16.1.0&#x2F;24(rw,sync,all_squash,anonuid&#x3D;666,anongid&#x3D;666)    &#x2F;data&#x2F;zh 172.16.1.0&#x2F;24(rw,sync,all_squash,anonuid&#x3D;666,anongid&#x3D;666)    &#x2F;data&#x2F;edu 172.16.1.0&#x2F;24(rw,sync,all_squash,anonuid&#x3D;666,anongid&#x3D;666)    3）根据配置，创建目录，准备用户，授权等等    [root@nfs ~]# rm -rf &#x2F;data&#x2F;    [root@nfs ~]# mkdir &#x2F;data&#x2F;&#123;blog,zh,edu&#125; -p    [root@nfs ~]# chown -R www.www &#x2F;data&#x2F;    4）启动    [root@nfs ~]# systemctl enable nfs-utils     [root@nfs ~]# systemctl restart nfs-utils2.将图片较多的web02服务器，推送到nfs共享存储上    http:&#x2F;&#x2F;blog.oldboy.com&#x2F;wp-content&#x2F;uploads&#x2F;2019&#x2F;01&#x2F;timg.jpg    [root@web02 ~]# cd &#x2F;code&#x2F;wordpress&#x2F;wp-content    [root@web02 wp-content]# scp -r uploads&#x2F;* root@172.16.1.31:&#x2F;data&#x2F;blog&#x2F;    注意：需要上nfs服务器上进行重新的递归授权，否则会出现无法上传文件的错误    [root@nfs ~]# chown -R www.www &#x2F;data&#x2F;3.web01和web02分别都进行挂载，此时图片进行实现了共享    mount -t nfs 172.16.1.31:&#x2F;data&#x2F;blog  &#x2F;code&#x2F;wordpress&#x2F;wp-content&#x2F;uploads&#x2F;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(二)常用官方模块</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/08-Nginx(%E4%BA%8C)%E5%B8%B8%E7%94%A8%E5%AE%98%E6%96%B9%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/08-Nginx(%E4%BA%8C)%E5%B8%B8%E7%94%A8%E5%AE%98%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><blockquote><blockquote><blockquote><p>本篇主要介绍Nginx的常用官方模块</p></blockquote></blockquote></blockquote></blockquote><h2 id="一、目录索引-autoindex"><a href="#一、目录索引-autoindex" class="headerlink" title="一、目录索引-autoindex"></a>一、目录索引-autoindex</h2><h3 id="1-1-使用方法1"><a href="#1-1-使用方法1" class="headerlink" title="1.1 使用方法1"></a>1.1 使用方法1</h3><p>按此方法设置后，访问网页<a href="http://module.test.com将显示文件目录/">http://module.test.com将显示文件目录</a></p><p>实际目录位于: &#x2F;module</p><p>a.准备配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 module]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;autoindex.confserver &#123;listen 80;server_name module.test.com;charset utf-8,gbk; # 解决中文乱码location &#x2F; &#123;root &#x2F;module;autoindex on;# 开启目录索引autoindex_exact_size off;# 显示文件大小，默认为on显示字节，off显示大概单位autoindex_localtime on;# 默认off显示UTC时间，on显示本地时间&#125;&#125;</code></pre></div></figure><p>b.准备对应的目录，并往目录中添加文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;module&#x2F;&#123;centos,ubuntu,redhat&#125;&#x2F; -p</code></pre></div></figure><p>c.检查语法并重新加载nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -t systemctl restart nginx</code></pre></div></figure><h3 id="1-2-使用方法2（推荐）"><a href="#1-2-使用方法2（推荐）" class="headerlink" title="1.2 使用方法2（推荐）"></a>1.2 使用方法2（推荐）</h3><p>按此方法设置后，访问网页<a href="http://www.module.test.com/download%E5%B0%86%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95,%E4%B8%BB%E9%A1%B5%E5%8F%AF%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE">http://www.module.test.com/download将显示文件目录,主页可正常访问</a></p><p>实际目录位于：&#x2F;module&#x2F;download</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 module]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;autoindex.conf server &#123;listen 80;server_name module.oldboy.com;charset utf-8,gbk;location &#x2F; &#123;# 主页可以正常访问root &#x2F;code;index index.html index.htm;&#125;location &#x2F;download &#123;# 当访问http:&#x2F;&#x2F;xxxx&#x2F;download则访问&#x2F;module&#x2F;download文件夹，显示目录索引root &#x2F;module; # 此时，访问的文件夹是&#x2F;module&#x2F;downloadautoindex on;autoindex_exact_size off;autoindex_localtime on;&#125;&#125;</code></pre></div></figure><h2 id="二、-状态监控页面-stub-status"><a href="#二、-状态监控页面-stub-status" class="headerlink" title="二、 状态监控页面-stub_status"></a>二、 状态监控页面-stub_status</h2><blockquote><p>需要nginx附带–with-http_stub_status_module模块才能使用</p></blockquote><h3 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h3><p>a.设置配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;autoindex.conf里面附加内容location &#x2F;nginx_status &#123;stub_status;&#125;</code></pre></div></figure><p>b.重启Nginx服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">重启nginx服务systemctl reload nginx</code></pre></div></figure><p>c.网页访问测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">访问:http:&#x2F;&#x2F;module.test.com&#x2F;nginx_status网页显示：Active connections: 2 server accepts handled requests3 3 33 Reading: 0 Writing: 1 Waiting: 1 </code></pre></div></figure><p>d.通过选项关闭长连接</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 注意, 一次TCP的连接，可以发起多次http的请求, 如下参数可配置进行验证keepalive_timeout  0;   # 类似于关闭长连接keepalive_timeout  65;  # 65s没有活动则断开连接</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;autoindex.conf里面的附加内容修改为location &#x2F;nginx_status &#123;stub_status;keepalive_timeout  0; &#125;</code></pre></div></figure><p>e.再次测试网页访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">关闭长连接后的显示：Active connections: 2 server accepts handled requests 21 21 20 Reading: 0 Writing: 1 Waiting: 1 # 可见每次HTTP请求都要重新发起TCP连接</code></pre></div></figure><h3 id="2-2-监控页面内容解释"><a href="#2-2-监控页面内容解释" class="headerlink" title="2.2 监控页面内容解释"></a>2.2 监控页面内容解释</h3><table><thead><tr><th>参数项</th><th>作用</th></tr></thead><tbody><tr><td>Active connections</td><td>当前活动客户端连接数，包括Waiting等待连接数</td></tr><tr><td>accepts</td><td>已接受总的TCP连接数</td></tr><tr><td>handled</td><td>已处理总的TCP连接数</td></tr><tr><td>requests</td><td>客户端总的http请求数</td></tr><tr><td>Reading</td><td>当前nginx读取请求头的连接数</td></tr><tr><td>Writing</td><td>当前nginx将响应写回客户端的连接数</td></tr><tr><td>Waiting</td><td>当前等待请求的空闲客户端连接数</td></tr></tbody></table><h2 id="三、基于IP的访问控制"><a href="#三、基于IP的访问控制" class="headerlink" title="三、基于IP的访问控制"></a>三、基于IP的访问控制</h2><blockquote><p>某网页内的数据比较重要，怎么控制那些人可以访问，那些人不能访问呢？</p></blockquote><p>可以来源的IP地址做限制，常用的三种控制方法：</p><ul><li><p>拒绝10.0.0.1来源IP访问，其他人允许</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F;nginx_status &#123;    stub_status;    deny 10.0.0.1&#x2F;32;    allow all;&#125;</code></pre></div></figure></li><li><p>允许10.0.0.1来源IP访问，其他人全部拒绝</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F;nginx_status &#123;    stub_status;    allow 10.0.0.1&#x2F;32;    deny all;&#125;</code></pre></div></figure></li><li><p>实际配置监控Nginx状态时，仅允许该服务器的回环地址访问127.0.0.1</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 最安全location &#x2F;nginx_status &#123;    stub_status;    allow 127.0.0.1;    deny all;&#125;</code></pre></div></figure></li></ul><h2 id="四、基于密码的身份验证"><a href="#四、基于密码的身份验证" class="headerlink" title="四、基于密码的身份验证"></a>四、基于密码的身份验证</h2><blockquote><p>重要数据网站，要实现需要用户名密码认证，怎么做呢？</p></blockquote><ol><li><p>生成一个密码文件，密码文件的格式  name:password(加密)  （建议使用htpasswd）  openssl password</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# yum install httpd-tools -y[root@web01 conf.d]# htpasswd -c -b &#x2F;etc&#x2F;nginx&#x2F;auth_conf oldboy oldboy[root@web01 conf.d]# cat &#x2F;etc&#x2F;nginx&#x2F;auth_confoldboy:$apr1$Kp87VSae$658Nt5bm4iiblQkUvP7u61</code></pre></div></figure></li><li><p>配置Nginx，限制对应的资源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F;download &#123;root &#x2F;module;autoindex on;autoindex_exact_size off;autoindex_localtime on;auth_basic &quot;Please Password!!!&quot;;auth_basic_user_file &#x2F;etc&#x2F;nginx&#x2F;auth_conf; # 注意认证文件路径，否则网页认证后会403，可是为什么放其他目录就不行？&#125;</code></pre></div></figure></li></ol><h2 id="五、Nginx连接限制"><a href="#五、Nginx连接限制" class="headerlink" title="五、Nginx连接限制"></a>五、Nginx连接限制</h2><blockquote><p>网站请求数太多，不堪重负了，怎么保障部分用户能够正常访问</p></blockquote><h3 id="5-1-限制连接数"><a href="#5-1-限制连接数" class="headerlink" title="5.1 限制连接数"></a>5.1 限制连接数</h3><p><code>设置共享内存区域和给定键值的最大允许连接数。超过此限制时，服务器将返回错误以回复请求</code></p><ul><li><p>编辑配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># http标签段定义连接限制http&#123;    limit_conn_zone $binary_remote_addr zone&#x3D;conn_zone:10m;&#125;server &#123;    # 同一时刻只允许一个客户端连接    limit_conn conn_zone 1;     location &#x2F; &#123;        root &#x2F;code;        index index.html;    &#125;</code></pre></div></figure></li><li><p>使用ab工具进行压力测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用ab工具进行压力测试[root@xuliangwei ~]# yum install -y httpd-tools[root@xuliangwei ~]# ab -n 500 -c 2  http:&#x2F;&#x2F;127.0.0.1&#x2F;index.html# 可见500次中有失败的请求</code></pre></div></figure></li><li><p>查看拦截日志</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log类似于2019&#x2F;01&#x2F;14 11:11:22 [error] 29962#29962: *19 limiting connections by zone &quot;conn_zone&quot;, client: 47.110.176.164, server: www.xuliangwei.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, host: &quot;www.xuliangwei.com&quot;2019&#x2F;01&#x2F;14 11:11:23 [error] 29962#29962: *19 limiting connections by zone &quot;conn_zone&quot;, client: 47.110.176.164, server: www.xuliangwei.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, host: &quot;www.xuliangwei.com&quot;2019&#x2F;01&#x2F;14 11:11:25 [error] 29962#29962: *19 limiting connections by zone &quot;conn_zone&quot;, client: 47.110.176.164, server: www.xuliangwei.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, host: &quot;www.xuliangwei.com&quot;2019&#x2F;01&#x2F;14 11:11:25 [error] 29962#29962: *19 limiting connections by zone &quot;conn_zone&quot;, client: 47.110.176.164, server: www.xuliangwei.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, host: &quot;www.xuliangwei.com&quot;</code></pre></div></figure></li></ul><h3 id="5-2-限制请求数（更精准）"><a href="#5-2-限制请求数（更精准）" class="headerlink" title="5.2 限制请求数（更精准）"></a>5.2 限制请求数（更精准）</h3><p><code>设置共享内存区域和请求的最大突发大小。过多的请求被延迟，直到它们的数量超过最大突发大小，在这种情况下请求以错误终止。默认情况下，最大突发大小等于零。</code></p><ul><li><p>定义限制的Key</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cat test1.oldboy.com.conf limit_req_zone $binary_remote_addr zone&#x3D;req_zone:10m rate&#x3D;1r&#x2F;s;server &#123;listen 80;server_name test1.oldboy.com;limit_req zone&#x3D;req_zone burst&#x3D;5 nodelay;limit_req_status 412;error_page 412 &#x2F;err.html;    #这个文件必须存在&#x2F;code&#x2F;test1&#x2F;err.htmllocation &#x2F; &#123;root &#x2F;code&#x2F;test1;index index.html;&#125;&#125;</code></pre></div></figure></li><li><p>填写hosts域名解析 （测试：域名访问才有效果，直接访问没效果）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;10.0.0.7 test1.oldboy.com&quot; &gt;&gt; &#x2F;etc&#x2F;hosts</code></pre></div></figure></li><li><p>压力测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ab -n 50 -c 20 http:&#x2F;&#x2F;test1.oldboy.com&#x2F;index.html</code></pre></div></figure></li><li><p>查看错误日志</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2019&#x2F;01&#x2F;14 11:28:22 [error] 2073#2073: *3 limiting requests, excess: 5.737 by zone &quot;req_zone&quot;, client: 10.0.0.1, server: test1.oldboy.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, host: &quot;test1.oldboy.com&quot;2019&#x2F;01&#x2F;14 11:28:22 [error] 2073#2073: *3 limiting requests, excess: 5.611 by zone &quot;req_zone&quot;, client: 10.0.0.1, server: test1.oldboy.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, host: &quot;test1.oldboy.com&quot;2019&#x2F;01&#x2F;14 11:28:22 [error] 2073#2073: *3 limiting requests, excess: 5.450 by zone &quot;req_zone&quot;, client: 10.0.0.1, server: test1.oldboy.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, host: &quot;test1.oldboy.com&quot;</code></pre></div></figure></li></ul><h2 id="六、Nginx匹配符和优先级"><a href="#六、Nginx匹配符和优先级" class="headerlink" title="六、Nginx匹配符和优先级"></a>六、Nginx匹配符和优先级</h2><p>Location语法示例</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location [&#x3D;|^~|~|~*|!~|!~*|&#x2F;] &#x2F;uri&#x2F; &#123; ...&#125;</code></pre></div></figure><p>匹配优先级</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">匹配符匹配规则优先级&#x3D;精确匹配1 用到^~以某个字符串开头2~区分大小写的正则匹配3常用~*不区分大小写的正则匹配4!~区分大小写不匹配的正则5!~*不区分大小写不匹配的正则6&#x2F;通用匹配，任何请求都会匹配到7常用</code></pre></div></figure><h3 id="6-1-匹配案例"><a href="#6-1-匹配案例" class="headerlink" title="6.1 匹配案例"></a>6.1 匹配案例</h3><blockquote><p>参考网站：<a href="https://blog.csdn.net/qq_41980405/article/details/111402208">https://blog.csdn.net/qq_41980405/article/details/111402208</a></p></blockquote><ul><li><p>通用匹配，任何请求都会匹配到</p><figure><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">location &#x2F; &#123;    ...&#125;</code></pre></div></figure></li><li><p>严格区分大小写，匹配以.php结尾的都走这个location    </p><figure><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">location ~ \.php$ &#123;    ...&#125;</code></pre></div></figure></li><li><p>严格区分大小写，匹配以.jsp结尾的都走这个location </p><figure><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">location ~ \.jsp$ &#123;    ...&#125;</code></pre></div></figure></li><li><p>不区分大小写匹配，只要用户访问.jpg,gif,png,js,css 都走这条location</p><figure><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">location ~* .*\.(jpg|gif|png|js|css|mp4)$ &#123;    ...&#125;</code></pre></div></figure></li><li><p>不区分大小写匹配</p><figure><div class="code-wrapper"><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">location ~* &quot;\.(sql|bak|tgz|tar.gz|.git)$&quot; &#123;    ...&#125;</code></pre></div></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(五)代理介绍</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/11-Nginx(%E4%BA%94)Nginx%E4%BB%A3%E7%90%86/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/11-Nginx(%E4%BA%94)Nginx%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是代理"><a href="#一、什么是代理" class="headerlink" title="一、什么是代理"></a>一、什么是代理</h2><h3 id="1-1-正向代理和反向代理的区别"><a href="#1-1-正向代理和反向代理的区别" class="headerlink" title="1.1 正向代理和反向代理的区别"></a>1.1 正向代理和反向代理的区别</h3><p>区别在于形式上服务的”对象”不一样<br>    正向代理代理的对象是客户端，为客户端服务   PC电脑<br>    反向代理代理的对象是服务端，为服务端服务服务器</p><h3 id="1-2-Nginx反向代理模式配置模块"><a href="#1-2-Nginx反向代理模式配置模块" class="headerlink" title="1.2 Nginx反向代理模式配置模块"></a>1.2 Nginx反向代理模式配置模块</h3><p>反向代理模式Nginx配置模块<br>http、websocket、httpsngx_http_proxy_module<br>fastcgingx_http_fastcgi_module<br>uwsgingx_http_uwsgi_module<br>grpcngx_http_v2_module</p><h2 id="二、Nginx代理配置"><a href="#二、Nginx代理配置" class="headerlink" title="二、Nginx代理配置"></a>二、Nginx代理配置</h2><h3 id="2-1-测试环境准备"><a href="#2-1-测试环境准备" class="headerlink" title="2.1 测试环境准备"></a>2.1 测试环境准备</h3><table><thead><tr><th>主机名称</th><th>应用环境</th><th>外网地址</th><th>内网地址</th></tr></thead><tbody><tr><td>web01</td><td>nginx + php（提供网页服务）</td><td>10.0.0.7</td><td>172.16.1.7</td></tr><tr><td>lb01</td><td>nginx（提供代理服务）</td><td>10.0.0.5</td><td>172.16.1.5</td></tr><tr><td>db01</td><td>mysql</td><td>10.0.0.51</td><td>172.16.1.51</td></tr></tbody></table><h3 id="2-2-Nginx代理配置步骤"><a href="#2-2-Nginx代理配置步骤" class="headerlink" title="2.2 Nginx代理配置步骤"></a>2.2 Nginx代理配置步骤</h3><p>1、<code>web01</code>-配置后端的web</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cat web.oldboy.com.conf server &#123;listen 80;server_name web.oldboy.com;root &#x2F;web;location &#x2F; &#123;index index.php index.html;&#125;&#125;</code></pre></div></figure><p>2、创建文件夹和网页文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# mkdir &#x2F;web[root@web01 conf.d]# echo &quot;Web01.....&quot; &gt; &#x2F;web&#x2F;index.html</code></pre></div></figure><p>3、重启nginx服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# nginx -tsysnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successfult[root@web01 conf.d]# systemctl restart nginx</code></pre></div></figure><p>4、<code>lb01</code>-nginx代理配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 conf.d]# cat proxy_web.confserver &#123;listen 80;server_name web.oldboy.com;location &#x2F; &#123;proxy_pass http:&#x2F;&#x2F;10.0.0.7:80;# 设置header将域名传过去proxy_set_header Host $http_host; &#125;&#125;</code></pre></div></figure><p>5、重启Nginx服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart nginx</code></pre></div></figure><p>6、客户机设置hosts，并测试访问网页，可以正常显示web01页面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">10.0.0.5 web.oldboy.com</code></pre></div></figure><p><img src="/../../../img/image-20210820101740471.png" alt="image-20210820101740471"></p><h2 id="三、代理流程分析"><a href="#三、代理流程分析" class="headerlink" title="三、代理流程分析"></a>三、代理流程分析</h2><p>1、走10网关，wireshark的抓包截图如下</p><p><img src="/../../../img/image-20210820102735419.png" alt="image-20210820102735419"></p><p>2、流程图</p><p><img src="/../../../img/image-20210820103041679.png" alt="image-20210820103041679"></p><p>3、测试，关掉web01的公网ip网口(10.0.0.7)，再尝试访问，也可以正常访问到web01的网页</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 conf.d]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_web.confserver &#123;        listen 80;        server_name  web.oldboy.com;        location &#x2F; &#123;                proxy_pass http:&#x2F;&#x2F;172.16.1.7:80;                include &#x2F;etc&#x2F;nginx&#x2F;proxy_params;        &#125;&#125;</code></pre></div></figure><p>4、抓包分析</p><p>因为172网段走的虚拟机内部网络，抓不到</p><p><img src="/../../../img/image-20210820111454152.png" alt="image-20210820111454152"></p><h2 id="三、Nginx代理常用参数"><a href="#三、Nginx代理常用参数" class="headerlink" title="三、Nginx代理常用参数"></a>三、Nginx代理常用参数</h2><h3 id="3-1-常用参数解释"><a href="#3-1-常用参数解释" class="headerlink" title="3.1 常用参数解释"></a>3.1 常用参数解释</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>proxy_pass <a href="http://10.0.0.7/">http://10.0.0.7:80</a>;</td><td></td></tr><tr><td>proxy_http_version 1.1;</td><td>代理向后端请求使用的版本</td></tr><tr><td>proxy_set_header Host $http_host;</td><td>代理向后端请求携带的域名</td></tr><tr><td>proxy_set_header X-Real-IP $remote_addr;</td><td><font color="blue">用于获取客户端真实IP（不如x-forward）</font></td></tr><tr><td>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</td><td><font color="blue">获取客户端真实IP及全链路IP</font></td></tr><tr><td>proxy_connect_timeout 30;</td><td>代理接连后端超时时间</td></tr><tr><td>proxy_send_timeout 60;</td><td>后端传递数据至代理的超时时间</td></tr><tr><td>proxy_read_timeout 60;</td><td>后端相应代理的超时时间</td></tr><tr><td>proxy_buffering on;</td><td>是否开启proxy的buffer功能</td></tr><tr><td>proxy_buffer_size 32k;</td><td>设置buffer大小</td></tr><tr><td>proxy_buffers 4 128k;</td><td>设置存储被代理服务器上的数据所占用的buffer的个数和每个buffer的大小</td></tr></tbody></table><p>X-Forwarded-For可以nginx的日志查看到</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</code></pre></div></figure><h3 id="3-2-参数多的时候如何配置"><a href="#3-2-参数多的时候如何配置" class="headerlink" title="3.2 参数多的时候如何配置"></a>3.2 参数多的时候如何配置</h3><blockquote><p>可将参数写到一个文件中，然后在nginx配置文件里include包含进去</p></blockquote><p>1、创建包含参数的文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 conf.d]# cat &#x2F;etc&#x2F;nginx&#x2F;proxy_paramsproxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffering on;proxy_buffer_size 32k;proxy_buffers 4 128k;</code></pre></div></figure><p>2、在配置文件中导入，方便后续多个location使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;    include proxy_params;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(六)七层负载均衡</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/12-Nginx(%E5%85%AD)Nginx%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/12-Nginx(%E5%85%AD)Nginx%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一、七层负载均衡简介-需补充"><a href="#一、七层负载均衡简介-需补充" class="headerlink" title="一、七层负载均衡简介(需补充)"></a>一、七层负载均衡简介(需补充)</h2><h3 id="1-1-nginx代理的局限性"><a href="#1-1-nginx代理的局限性" class="headerlink" title="1.1 nginx代理的局限性"></a>1.1 nginx代理的局限性</h3><p>​一个location仅能代理后端一台主机</p><h3 id="1-2-七层负载均衡"><a href="#1-2-七层负载均衡" class="headerlink" title="1.2 七层负载均衡"></a>1.2 七层负载均衡</h3><p>Nginx负载均衡<br>    负载<br>    负载均衡<br>    调度<br>    load balance<br>    LB<br>公有云<br>    SLB阿里云负载均衡<br>    QLB青云负载均衡<br>    CLB腾讯负载均衡<br>    ULBucloud的负载均衡</p><h3 id="1-3-四层负载均衡和七层负载均衡的区别"><a href="#1-3-四层负载均衡和七层负载均衡的区别" class="headerlink" title="1.3 四层负载均衡和七层负载均衡的区别"></a>1.3 四层负载均衡和七层负载均衡的区别</h3><p>四层负载均衡数据包在底层就进行了分发，而七层负载均衡数据包则是在最顶层进行分发、由此可以看出，七层负载均衡效率没有四负载均衡高。<br>但七层负载均衡更贴近于服务，如:http协议就是七层协议，我们可以用Nginx可以作会话保持，URL路径规则匹配、head头改写等等，这些是四层负载均衡无法实现的。</p><h2 id="二、配置实例"><a href="#二、配置实例" class="headerlink" title="二、配置实例"></a>二、配置实例</h2><h3 id="2-1-测试环境准备"><a href="#2-1-测试环境准备" class="headerlink" title="2.1 测试环境准备"></a>2.1 测试环境准备</h3><table><thead><tr><th>主机名称</th><th>应用环境</th><th>外网地址</th><th>内网地址</th></tr></thead><tbody><tr><td>web01</td><td>nginx + php（提供网页服务）</td><td>10.0.0.7</td><td>172.16.1.7</td></tr><tr><td>web01</td><td>nginx + php（提供网页服务）</td><td>10.0.0.8</td><td>172.16.1.8</td></tr><tr><td>lb01</td><td>nginx（提供代理服务）</td><td>10.0.0.5</td><td>172.16.1.5</td></tr><tr><td>db01</td><td>mysql</td><td>10.0.0.51</td><td>172.16.1.51</td></tr></tbody></table><h3 id="2-2-配置步骤"><a href="#2-2-配置步骤" class="headerlink" title="2.2 配置步骤"></a>2.2 配置步骤</h3><p>1、web01&#x2F;02的网页服务搭建</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;[root@web01 conf.d]# cat node.conf server &#123;    listen 80;    server_name node.oldboy.com;    location &#x2F; &#123;        root &#x2F;node;        index index.html;    &#125;&#125;[root@web01 conf.d]# mkdir &#x2F;node[root@web01 conf.d]# echo &quot;Web01...&quot; &gt; &#x2F;node&#x2F;index.html[root@web01 conf.d]# systemctl restart nginx</code></pre></div></figure><p>2、配置nginx负载均衡</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;[root@lb01 conf.d]# cat node_proxy.conf upstream node &#123;    server 172.16.1.7:80;    server 172.16.1.8:80;&#125;server &#123;    listen 80;    server_name node.oldboy.com;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;node;        include proxy_params;    &#125;&#125;[root@lb01 conf.d]# systemctl restart nginx</code></pre></div></figure><p>3、客户端网页测试访问，F5刷新，可见web01&#x2F;web02在循环</p><p><img src="/img/image-20210820132420586.png" alt="image-20210820132420586"></p><p><img src="/img/image-20210820132431971.png" alt="image-20210820132431971"></p><h3 id="2-3-负载均衡也可以使用代理参数"><a href="#2-3-负载均衡也可以使用代理参数" class="headerlink" title="2.3 负载均衡也可以使用代理参数"></a>2.3 负载均衡也可以使用代理参数</h3><blockquote><p>与之前部署的知乎wencenter、博客mywordpress结合</p></blockquote><p>1、准备Nginx负载均衡调度使用的proxy_params</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@Nginx ~]# vim &#x2F;etc&#x2F;nginx&#x2F;proxy_paramsproxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffering on;proxy_buffer_size 32k;proxy_buffers 4 128k;</code></pre></div></figure><p>2、负载均衡配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 conf.d]# vim proxy_oldboy.com.confupstream node &#123;        server 172.16.1.7:80;        server 172.16.1.8:80;&#125;server &#123;        listen 80;        server_name blog.oldboy.com;        location &#x2F; &#123;                proxy_pass http:&#x2F;&#x2F;node;                include proxy_params;        &#125;&#125;server &#123;        listen 80;        server_name zh.oldboy.com;        location &#x2F; &#123;                proxy_pass http:&#x2F;&#x2F;node;                include proxy_params;        &#125;&#125;</code></pre></div></figure><h3 id="2-4-负载均衡测试"><a href="#2-4-负载均衡测试" class="headerlink" title="2.4 负载均衡测试"></a>2.4 负载均衡测试</h3><p>正常情况下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、两台web服务器的nginx服务均打开（模拟流量分摊）可以负载均衡，轮流访问2、关掉一台web服务器的nginx服务（模拟容灾）网页仍可以正常打开3、两台web服务器的Nginx服务均关闭网页无法打开，502</code></pre></div></figure><p>存在一种情况，两个web的nginx服务都没挂，但是其中一台的php-fpm服务挂了，模拟这种场景</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02 ~]# systemctl stop php-fpm</code></pre></div></figure><p>此时F5刷新wordpress的页面，将一会502，一会正常，体验不好，可通过添加nginx代理参数解决</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 conf.d]# cat &#x2F;etc&#x2F;nginx&#x2F;proxy_paramsproxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_next_upstream error timeout http_500 http_502 http_503 http_504; # 解决问题proxy_connect_timeout 30;proxy_send_timeout 60;proxy_read_timeout 60;proxy_buffering on;proxy_buffer_size 32k;proxy_buffers 4 128k;</code></pre></div></figure><blockquote><p>PS：问题原因</p><p>使用nginx负载均衡时，如何将后端请求超时的服务器流量平滑的切换到另一台上。<br>Nginx是本身是有机制的，如果出现一个节点down掉的时候，Nginx会更据你具体负载均衡的设置，将请求转移到其他的节点上，但是，如果后台服务连接没有down掉，并且返回错误异常码了如：504、502、500，Nginx就会直接返回从后端获取的异常代码。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(七)均衡调度</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/13-Nginx(%E4%B8%83)Nginx%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/13-Nginx(%E4%B8%83)Nginx%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx均衡调度算法"><a href="#一、Nginx均衡调度算法" class="headerlink" title="一、Nginx均衡调度算法"></a>一、Nginx均衡调度算法</h2><p>Nginx七层负载均衡分为5种调度算法</p><table><thead><tr><th>调度算法</th><th>概述</th></tr></thead><tbody><tr><td>轮询（常用）</td><td>按时间顺序逐一分配到不同的后端服务器(默认)</td></tr><tr><td>weight（面试点）</td><td>加权轮询,weight值越大,分配到的访问几率越高</td></tr><tr><td>ip_hash（面试点）</td><td>每个请求按访问IP的hash结果分配,这样来自同一IP的固定访问一个后端服务器</td></tr><tr><td>url_hash</td><td>按照访问URL的hash结果来分配请求,是每个URL定向到同一个后端服务器</td></tr><tr><td>least_hash</td><td>最少链接数,那个机器链接数少就分发</td></tr></tbody></table><h3 id="1-1-加权轮询"><a href="#1-1-加权轮询" class="headerlink" title="1.1 加权轮询"></a>1.1 加权轮询</h3><p>比如实现访问5次web01，1次web02</p><p>当web服务器配置不相同，有差距时，可以用此方法</p><p>在<code>lb01</code>配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.confupstream node &#123;        server 172.16.1.7:80 weight&#x3D;5;        server 172.16.1.8:80 weight&#x3D;1;&#125;server &#123;...</code></pre></div></figure><h3 id="1-2-ip-hash"><a href="#1-2-ip-hash" class="headerlink" title="1.2 ip_hash"></a>1.2 ip_hash</h3><blockquote><p>PS：不能与weight一起使用</p></blockquote><p>根据请求的IP地址，固定访问到某一后端，除非已选择的后端down了，有点浪费资源</p><p>在<code>lb01</code>配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.confupstream node &#123;        ip_hash;        server 172.16.1.7:80;        server 172.16.1.8:80;&#125;server &#123; ...</code></pre></div></figure><h2 id="二、Nginx负载均衡后端状态"><a href="#二、Nginx负载均衡后端状态" class="headerlink" title="二、Nginx负载均衡后端状态"></a>二、Nginx负载均衡后端状态</h2><table><thead><tr><th>状态</th><th>概述</th></tr></thead><tbody><tr><td>down</td><td>当前的server暂时不参与负载均衡</td></tr><tr><td>backup</td><td>预留的备份服务器</td></tr><tr><td>max_conns</td><td>限制最大的接收连接数</td></tr><tr><td>max_fails（健康检查）</td><td>允许请求失败的次数（不够精准，作用不大，得知道，面试会问）</td></tr><tr><td>fail_timeout（健康检查）</td><td>经过max_fails失败后, 服务暂停时间</td></tr></tbody></table><h3 id="2-1-down状态"><a href="#2-1-down状态" class="headerlink" title="2.1 down状态"></a>2.1 down状态</h3><blockquote><p>一般用于停机维护</p></blockquote><p>在<code>lb01</code>配置，可见当两台web的Nginx服务都正常时，只能访问web02，当web02的Nginx服务挂了，返回502</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.confupstream node &#123;        server 172.16.1.7:80 down;        server 172.16.1.8:80;&#125;server &#123;...</code></pre></div></figure><h3 id="2-2-backup状态"><a href="#2-2-backup状态" class="headerlink" title="2.2 backup状态"></a>2.2 backup状态</h3><p>在<code>lb01</code>配置，可见当两台web都正常时，只能访问web02，如果web02的服务挂了，会访问web01，当web02恢复后，再次访问到的是web02</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.confupstream node &#123;        server 172.16.1.7:80 backup;        server 172.16.1.8:80;&#125;server &#123;...</code></pre></div></figure><h3 id="2-3-健康检查"><a href="#2-3-健康检查" class="headerlink" title="2.3 健康检查"></a>2.3 健康检查</h3><blockquote><p>自带的健康检查不够精准，且看不到信息，面试会问</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.confupstream node &#123;        server 172.16.1.7:80 max_fails&#x3D;2 fail_timeout&#x3D;10s;        server 172.16.1.8:80 max_fails&#x3D;2 fail_timeout&#x3D;10s;&#125;server &#123;...</code></pre></div></figure><h2 id="三、第三方健康检查模块check-upstream"><a href="#三、第三方健康检查模块check-upstream" class="headerlink" title="三、第三方健康检查模块check_upstream"></a>三、第三方健康检查模块check_upstream</h2><blockquote><p>检测更精准，且有页面可以展示服务端的状态，需要编译安装</p></blockquote><h3 id="3-1-编译安装Nginx"><a href="#3-1-编译安装Nginx" class="headerlink" title="3.1 编译安装Nginx"></a>3.1 编译安装Nginx</h3><p>1、安装依赖包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb02 ~]# yum install -y gcc glibc gcc-c++ pcre-devel openssl-devel  patch libxml2 -libxml2-devel libxslt libxslt-devel gd-devel perl-ExtUtils-Embed gperftools-devel.x86_64 gperftools-libs.x86_64 gperftools.x86_64</code></pre></div></figure><p>2、下载Nginx源码及第三方模块源码</p><blockquote><p>PS：为保持一致，先通过yum源安装nginx，这是当前实验环境的Nginx版本</p><p>[root@lb01 nginx]# nginx -version<br>nginx version: nginx&#x2F;1.20.1</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb02 ~]# wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.20.1.tar.gz[root@lb02 ~]# wget https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;nginx_upstream_check_module&#x2F;archive&#x2F;master.zip</code></pre></div></figure><p>3、解压nginx源码包以及第三方模块</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# unzip master.zip[root@lb01 ~]# tar -vxf nginx-1.20.1.tar.gz</code></pre></div></figure><p>4、打补丁</p><blockquote><p>打补丁(nginx的版本是1.20.1补丁就选择1.20.1的,p1代表在nginx目录，p0是不在nginx目录)</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx-1.20.1]# cd nginx-1.20.1&#x2F;[root@lb01 nginx-1.20.1]# patch -p1 &lt; ..&#x2F;nginx_upstream_check_module-master&#x2F;check_1.20.1+.patch</code></pre></div></figure><p>5、编译Nginx，附带模块参数</p><blockquote><p>通过nginx -V获取configure参数，尽量保持一致</p></blockquote><p>–add-module&#x3D;&#x2F;root&#x2F;nginx_upstream_check_module-master</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx-1.20.1]# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx --sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;client_body --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;proxy --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;fastcgi --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;uwsgi --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp&#x2F;scgi --pid-path&#x3D;&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;run&#x2F;lock&#x2F;subsys&#x2F;nginx --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-debug --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module&#x3D;dynamic --with-http_mp4_module --with-http_perl_module&#x3D;dynamic --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_xslt_module&#x3D;dynamic --with-mail&#x3D;dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream&#x3D;dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads --add-module&#x3D;&#x2F;root&#x2F;nginx_upstream_check_module-master</code></pre></div></figure><p>6、在已有的负载均衡上增加健康检查的功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx-1.20.1]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.confupstream node &#123;        server 172.16.1.7:80;        server 172.16.1.8:80;        check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;3 timeout&#x3D;1000 type&#x3D;tcp;&#125;</code></pre></div></figure><h3 id="3-2-功能测试"><a href="#3-2-功能测试" class="headerlink" title="3.2 功能测试"></a>3.2 功能测试</h3><p>1、正常情况下的检测数据</p><p><img src="/img/image-20210821113447825.png" alt="image-20210821113447825"></p><p>2、测试将web01的nginx服务关掉</p><p><img src="/img/image-20210821114011230.png" alt="image-20210821114011230"></p><p>3、日志分析</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 nginx-1.20.1]# tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log# 两web服务正常，能获取peer2021&#x2F;08&#x2F;21 02:42:11 [error] 50522#50522: enable check peer: 172.16.1.8:802021&#x2F;08&#x2F;21 02:42:12 [error] 50522#50522: enable check peer: 172.16.1.7:802021&#x2F;08&#x2F;21 02:46:17 [error] 50522#50522: *13 connect() failed (111: Connection refused) while connecting to upstream, client: 10.0.0.1, server: node.oldboy.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, upstream: &quot;http:&#x2F;&#x2F;172.16.1.7:80&#x2F;&quot;, host: &quot;node.oldboy.com&quot;# 停止web01的nginx服务2021&#x2F;08&#x2F;21 02:46:20 [error] 50522#50522: disable check peer: 172.16.1.7:80# 重新启动web01的nginx服务2021&#x2F;08&#x2F;21 02:47:59 [error] 50522#50522: enable check peer: 172.16.1.7:80</code></pre></div></figure><h2 id="四、如何解决网站重复登录的问题"><a href="#四、如何解决网站重复登录的问题" class="headerlink" title="四、如何解决网站重复登录的问题"></a>四、如何解决网站重复登录的问题</h2><p>有三种方法解决：</p><ol><li>ip_hash – 会造成某一台主机的压力过大</li><li>session复制</li><li>session共享<ol><li>本地文件 –&gt; nfs共享</li><li>通过程序，写入redis数据库（常用）</li><li>通过程序，写入mysql数据库</li></ol></li></ol><p>本案例，选用3.2配置，session共享，写入redis数据库</p><h3 id="4-1-安装phpmyadmin重现问题"><a href="#4-1-安装phpmyadmin重现问题" class="headerlink" title="4.1 安装phpmyadmin重现问题"></a>4.1 安装phpmyadmin重现问题</h3><p><code>web01</code>和<code>web02</code>都需要安装</p><p>1、配置Nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cat php.confserver &#123;listen 80;server_name php.oldboy.com;root &#x2F;code&#x2F;phpMyAdmin-4.8.4-all-languages;location &#x2F; &#123;index index.php index.html;&#125;location ~ \.php$ &#123;fastcgi_pass 127.0.0.1:9000;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125;&#125;[root@web01 conf.d]# systemctl restart nginx</code></pre></div></figure><p>2、安装phpmyadmin</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# cd &#x2F;code[root@web01 code]# wget https:&#x2F;&#x2F;files.phpmyadmin.net&#x2F;phpMyAdmin&#x2F;4.8.4&#x2F;phpMyAdmin-4.8.4-all-languages.zip[root@web01 code]# unzip phpMyAdmin-4.8.4-all-languages.zip</code></pre></div></figure><p>3、配置phpmyadmin连接远程数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 code]# cd phpMyAdmin-4.8.4-all-languages&#x2F;[root@web01 phpMyAdmin-4.8.4-all-languages]# cp config.sample.inc.php config.inc.php[root@web01 phpMyAdmin-4.8.4-all-languages]# vim config.inc.php&#x2F;* Server parameters *&#x2F;$cfg[&#39;Servers&#39;][$i][&#39;host&#39;] &#x3D; &#39;172.16.1.51&#39;;</code></pre></div></figure><p>4、配置授权</p><blockquote><p>这个文件夹中会记录session，需要权限</p><p>session_start(): Failed to read session data: files (path: &#x2F;var&#x2F;lib&#x2F;php&#x2F;session)</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]# chown -R www.www &#x2F;var&#x2F;lib&#x2F;php&#x2F;</code></pre></div></figure><p>5、将web01上配置好的phpmyadmin以及nginx的配置文件推送到web02主机上</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 code]# scp -rp  phpMyAdmin-4.8.4-all-languages root@172.16.1.8:&#x2F;code&#x2F;[root@web01 code]# scp &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;php.conf  root@172.16.1.8:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</code></pre></div></figure><p>6、重载Nginx服务，授权访问权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02 code]# systemctl restart nginx[root@web02 code]# chown -R www.www &#x2F;var&#x2F;lib&#x2F;php&#x2F;</code></pre></div></figure><p>7、接入负载均衡，并重启nginx服务，<code>lb01</code>操作</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 conf.d]# vim proxy_php.com.conf upstream php &#123;        server 172.16.1.7:80;        server 172.16.1.8:80;&#125;server &#123;        listen 80;        server_name php.oldboy.com;        location &#x2F; &#123;                proxy_pass http:&#x2F;&#x2F;php;                include proxy_params;        &#125;&#125;[root@lb01 conf.d]# nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful[root@lb01 conf.d]# systemctl restart nginx</code></pre></div></figure><p>9、测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">网页访问：http:&#x2F;&#x2F;php.oldboy.com登录账户:采用db01（172.16.1.51）的mysql远程账户oldboy&#x2F;Bgx123.com此时访问phpmyadmin登录将一直失败，因为轮询访问，session一直变：报错：Failed to set session cookie. Maybe you are using HTTP instead of HTTPS to access phpMyAdmin.</code></pre></div></figure><h3 id="4-2-解决问题"><a href="#4-2-解决问题" class="headerlink" title="4.2 解决问题"></a>4.2 解决问题</h3><p>1、在<code>db01</code>安装redis数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]# yum install redis -y</code></pre></div></figure><p>2、配置并启动redis</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]# sed  -i &#39;&#x2F;^bind&#x2F;c bind 127.0.0.1 172.16.1.51&#39; &#x2F;etc&#x2F;redis.conf[root@db01 ~]# systemctl start redis[root@db01 ~]# systemctl enable redis</code></pre></div></figure><p>3、<code>web01</code>的php配置session连接redis</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#1.修改&#x2F;etc&#x2F;php.ini文件[root@web01 ~]# vim &#x2F;etc&#x2F;php.inisession.save_handler &#x3D; redissession.save_path &#x3D; &quot;tcp:&#x2F;&#x2F;172.16.1.51:6379&quot;;session.save_path &#x3D; &quot;tcp:&#x2F;&#x2F;172.16.1.51:6379?auth&#x3D;123&quot; #如果redis存在密码，则使用该方式session.auto_start &#x3D; 1</code></pre></div></figure><p>4、注释php-fpm.d&#x2F;<a href="http://www.conf里面的两条内容,否则session内容会一直写入/var/lib/php/session%E7%9B%AE%E5%BD%95%E4%B8%AD">www.conf里面的两条内容，否则session内容会一直写入/var/lib/php/session目录中</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">;php_value[session.save_handler] &#x3D; files;php_value[session.save_path]    &#x3D; &#x2F;var&#x2F;lib&#x2F;php&#x2F;session</code></pre></div></figure><p>5、重启php-fpm</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02 code]# systemctl restart php-fpm</code></pre></div></figure><p>6、将<code>web01</code>的配置文件推送到<code>web02</code>上</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@web01 code]# scp &#x2F;etc&#x2F;php.ini root@172.16.1.8:&#x2F;etc&#x2F;php.ini  [root@web01 code]# scp &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf root@172.16.1.8:&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf </code></pre></div></figure><p>7、重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@web02 code]# systemctl restart php-fpm</code></pre></div></figure><p>8、再次测试访问网站</p><p>可以登录，并且session的值将记录到redis数据库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@db01 ~]# redis-cli -h 172.16.1.51172.16.1.51:6379&gt; KEYS *1) &quot;PHPREDIS_SESSION:716e61cabeb40f974fcbcdcac65f8607&quot;2) &quot;PHPREDIS_SESSION:42ca5a8ea9375a93a7974427b77b3dd7&quot;172.16.1.51:6379&gt;</code></pre></div></figure><p>9、刷新页面的负载均衡效果展示</p><p><img src="/img/image-20210823225246243.png" alt="image-20210823225246243"></p><p><img src="/img/image-20210823225305632.png" alt="image-20210823225305632"></p><p>10、cookie保存到redis展示</p><p><img src="/img/image-20210823225412626.png" alt="image-20210823225412626"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(八)四层负载均衡</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/14-Nginx(%E5%85%AB)Nginx%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/14-Nginx(%E5%85%AB)Nginx%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx四层负载均衡介绍"><a href="#一、Nginx四层负载均衡介绍" class="headerlink" title="一、Nginx四层负载均衡介绍"></a>一、Nginx四层负载均衡介绍</h2><p>四层负载均衡：（OSI传输层   ip:port）<br>    nginx1.9 版本加入<br>硬件：F5<br>软件：LVS、Haproxy、Nginx</p><p>1.四层+七层来作负载均衡，4层可以保证7层的负载均衡的高可用性。如:nginx就无法保证自己的服务高可用，需要依赖lvs或者keepalive来作。</p><p>2.如:tcp协议的负载均衡，有些请求是TCP协议的(mysql、ssh)，或者说这些请求只需要使用4层进行端口的转发就可以了，所以使用4层负载均衡。<br>    比如做：mysql读的负载均衡（轮询）<br>    比如做：端口映射、端口转发         tcp&#x2F;udp</p><p>四层负载均衡总结<br>1.四层负载均衡仅能转发TCP&#x2F;IP协议、UDP协议，通常用来转发端口，如: tcp&#x2F;3306，tcp&#x2F;22，udp&#x2F;53。<br>2.四层负载均衡可以用来解决七层负载均衡的端口限制问题。（七层负载均衡最大使用65535个端口号）<br>3.可以用来解决七层负载均衡的高可用问题。（多台后端七层负载均衡能同时的使用）<br>4.四层的转发效率比七层的高的多，但仅支持tcp&#x2F;ip协议，不支持http或者https协议</p><p><img src="/img/image-20210823230415237.png" alt="image-20210823230415237"></p><h2 id="二、四层负载均衡配置"><a href="#二、四层负载均衡配置" class="headerlink" title="二、四层负载均衡配置"></a>二、四层负载均衡配置</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><table><thead><tr><th>服务器名</th><th>公网IP</th><th>内网IP</th></tr></thead><tbody><tr><td>lb4-01</td><td>10.0.0.3</td><td></td></tr><tr><td>lb01</td><td>10.0.0.5</td><td>172.16.1.5</td></tr><tr><td>lb02</td><td>10.0.0.6</td><td>172.16.1.6</td></tr><tr><td>web、nfs、mysql服务器若干</td><td></td><td></td></tr></tbody></table><h3 id="2-2-新增lb02负载均衡服务器"><a href="#2-2-新增lb02负载均衡服务器" class="headerlink" title="2.2 新增lb02负载均衡服务器"></a>2.2 新增lb02负载均衡服务器</h3><p>1、准备<code>lb02</code>，安装Nginx服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb02 ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo [nginx]name&#x3D;nginx repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;$basearch&#x2F;gpgcheck&#x3D;0enabled&#x3D;1[root@lb02 ~]#  yum install nginx -y</code></pre></div></figure><p>2、拷贝<code>lb01</code>的 Nginx配置到<code>lb02</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb02 ~]# scp -rp root@172.16.1.5:&#x2F;etc&#x2F;nginx &#x2F;etc&#x2F;</code></pre></div></figure><p>3、启动Nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb02 conf.d]# nginx -t[root@lb02 conf.d]# systemctl start nginx[root@lb02 conf.d]# systemctl enable nginx</code></pre></div></figure><blockquote><p>报错：</p><p>[root@lb02 ~]# nginx -t<br>nginx: [emerg] unknown directive “check” in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.conf:4<br>nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test failed<br>[root@lb02 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.conf<br>[root@lb02 ~]# nginx -t<br>nginx: [emerg] unknown directive “check_status” in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_node.conf:17<br>nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test failed</p><p>解决方法：</p><p>因为lb01安装过第三方健康检查工具，而lb02上没有，先将这些报错点注释掉</p></blockquote><p>4、测试lb02是否正常</p><p>将hosts中的10.0.0.5换成10.0.0.6，phpadmin、wordpress网页可以正常访问,<br>但是wecenter异常502 Bad Gateway<br>解决方法: 将web01、02上的的php.ini中的session.auto_start改为0,不然会502</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 php]# vim &#x2F;etc&#x2F;php.inisession.auto_start &#x3D; 0[root@web01 php]# systemctl restart php-fpm.service</code></pre></div></figure><blockquote><p>网上搜索的解释：<br>日常开发中，php.ini配置session.auto_start&#x3D;0默认关闭会话时如果想开启会话需要调用session_start：<br>session.auto_start 开启就自动完成了session_start()<br>区别就在于在用SESSION前是否需要session_start();<br>当session.auto_start &#x3D; on时，执行 session_start() 将产生新的 session_id<br>session.auto_start &#x3D; on 的优点在于，任何时候都不会因忘记执行 session_start() 或 session_start() 在程序里的位置不对，而导致错误<br>缺点在于，如果你使用的是第三方代码，则必须删去其中的全部 session_start() 。否则将不能得到正确的结果</p></blockquote><h3 id="2-3-配置四层负载均衡"><a href="#2-3-配置四层负载均衡" class="headerlink" title="2.3 配置四层负载均衡"></a>2.3 配置四层负载均衡</h3><p>1、新增<code>lb4-01</code>服务器，安装nginx</p><blockquote><p>nginx需要带–with-stream模块</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@lb4-01 ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo [nginx]name&#x3D;nginx repobaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;$basearch&#x2F;gpgcheck&#x3D;0enabled&#x3D;1[root@lb4-01 ~]#  yum install nginx -y[root@lb4-01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;nginx.confevents &#123;    ....&#125;include &#x2F;etc&#x2F;nginx&#x2F;conf.c&#x2F;*.conf;http &#123;.....&#125;</code></pre></div></figure><p>2、创建四层负载均衡配置的目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb4-01 conf.c]# rm -f &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf   #删除http的80端口[root@lb4-01 ~]# mkdir &#x2F;etc&#x2F;nginx&#x2F;conf.c[root@lb4-01 ~]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.c[root@lb4-01 conf.c]# cat lb_domain.conf stream &#123;    upstream lb &#123;        server 172.16.1.5:80 weight&#x3D;5 max_fails&#x3D;3 fail_timeout&#x3D;30s;        server 172.16.1.6:80 weight&#x3D;5 max_fails&#x3D;3 fail_timeout&#x3D;30s;    &#125;    server &#123;        listen 80;        proxy_connect_timeout 3s;        proxy_timeout 3s;        proxy_pass lb;    &#125;&#125;</code></pre></div></figure><p>3、重载服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb4-01 conf.c]# nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful[root@lb4-01 conf.c]# systemctl restart nginx[root@lb4-01 conf.c]# systemctl enable nginx</code></pre></div></figure><blockquote><p>报错：<br>[root@lb4-01 nginx]# nginx  -t<br>nginx: [emerg] unknown directive “stream” in &#x2F;etc&#x2F;nginx&#x2F;conf.c&#x2F;lb_domain.conf:1<br>nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test failed<br>解决方法：<br>yum install nginx-mod-stream.x86_64 -y</p></blockquote><blockquote><p>报错：<br>[root@lb4-01 nginx]# systemctl status nginx<br>nginx.service - The nginx HTTP and reverse proxy server<br>Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service; enabled; vendor preset: disabled)<br>Active: failed (Result: exit-code) since Tue 2021-08-24 07:48:42 CST; 13s ago<br>Process: 2969 ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx (code&#x3D;exited, status&#x3D;1&#x2F;FAILURE)<br>Process: 2967 ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -t (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br>Process: 2965 ExecStartPre&#x3D;&#x2F;usr&#x2F;bin&#x2F;rm -f &#x2F;run&#x2F;nginx.pid (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br>Main PID: 1959 (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)</p><p>Aug 24 07:48:40 lb4-01 nginx[2969]: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>Aug 24 07:48:40 lb4-01 nginx[2969]: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>Aug 24 07:48:41 lb4-01 nginx[2969]: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>Aug 24 07:48:41 lb4-01 nginx[2969]: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>Aug 24 07:48:42 lb4-01 nginx[2969]: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>Aug 24 07:48:42 lb4-01 nginx[2969]: nginx: [emerg] still could not bind()<br>解决方法：<br>需要将[root@lb4-01 nginx]# vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf<br>中默认的80端口改掉，比如改成81,这样才不冲突（奇怪。。）</p></blockquote><p>4、访问测试</p><p>将Hosts中的对应网站地址的IP改成10.0.0.3，尝试访问，可以正常通过四层负载均衡来调度10.0.0.5和10.0.0.6七层负载均衡</p><p><img src="/img/image-20210824001613717.png" alt="image-20210824001613717"></p><p><img src="/img/image-20210824001638506.png" alt="image-20210824001638506"></p><h2 id="三、四层负载均衡日志"><a href="#三、四层负载均衡日志" class="headerlink" title="三、四层负载均衡日志"></a>三、四层负载均衡日志</h2><h3 id="3-1-配置过程"><a href="#3-1-配置过程" class="headerlink" title="3.1 配置过程"></a>3.1 配置过程</h3><p>在四层负载均衡中配置Nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb4-01 ~]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.c&#x2F;lb_domain.confstream &#123;    log_format  proxy &#39;$remote_addr $remote_port - [$time_local] $status $protocol &#39;                  &#39;&quot;$upstream_addr&quot; &quot;$upstream_bytes_sent&quot; &quot;$upstream_connect_time&quot;&#39; ;    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy.log proxy;    upstream lb &#123;....</code></pre></div></figure><h3 id="3-2-查看日志"><a href="#3-2-查看日志" class="headerlink" title="3.2 查看日志"></a>3.2 查看日志</h3><p>网页访问后，可见产生的日志</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb4-01 ~]# tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy.log10.0.0.1 56396 - [25&#x2F;Aug&#x2F;2021:19:25:33 +0800] 200 TCP &quot;172.16.1.5:80&quot; &quot;15150&quot; &quot;0.000&quot;10.0.0.1 59800 - [25&#x2F;Aug&#x2F;2021:19:25:34 +0800] 200 TCP &quot;172.16.1.6:80&quot; &quot;8327&quot; &quot;0.000&quot;10.0.0.1 63468 - [25&#x2F;Aug&#x2F;2021:19:25:34 +0800] 200 TCP &quot;172.16.1.5:80&quot; &quot;17882&quot; &quot;0.000&quot;10.0.0.1 50394 - [25&#x2F;Aug&#x2F;2021:19:25:35 +0800] 200 TCP &quot;172.16.1.5:80&quot; &quot;24490&quot; &quot;0.000&quot;10.0.0.1 55549 - [25&#x2F;Aug&#x2F;2021:19:25:35 +0800] 200 TCP &quot;172.16.1.5:80&quot; &quot;13201&quot; &quot;0.000&quot;10.0.0.1 64324 - [25&#x2F;Aug&#x2F;2021:19:25:42 +0800] 200 TCP &quot;172.16.1.6:80&quot; &quot;70995&quot; &quot;0.000&quot;10.0.0.1 64566 - [25&#x2F;Aug&#x2F;2021:19:25:42 +0800] 200 TCP &quot;172.16.1.6:80&quot; &quot;72650&quot; &quot;0.000&quot;10.0.0.1 65216 - [25&#x2F;Aug&#x2F;2021:19:25:42 +0800] 200 TCP &quot;172.16.1.6:80&quot; &quot;68171&quot; &quot;0.000&quot;10.0.0.1 49668 - [25&#x2F;Aug&#x2F;2021:19:25:42 +0800] 200 TCP &quot;172.16.1.5:80&quot; &quot;82071&quot; &quot;0.004&quot;10.0.0.1 49745 - [25&#x2F;Aug&#x2F;2021:19:25:42 +0800] 200 TCP &quot;172.16.1.5:80&quot; &quot;63941&quot; &quot;0.001&quot;10.0.0.1 50574 - [25&#x2F;Aug&#x2F;2021:19:25:42 +0800] 200 TCP &quot;172.16.1.6:80&quot; &quot;103581&quot; &quot;0.000&quot;</code></pre></div></figure><h2 id="三、使用nginx四层负载均衡实现tcp的转发（跳板）"><a href="#三、使用nginx四层负载均衡实现tcp的转发（跳板）" class="headerlink" title="三、使用nginx四层负载均衡实现tcp的转发（跳板）"></a>三、使用nginx四层负载均衡实现tcp的转发（跳板）</h2><p>实现跳板机的功能，比如：</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">请求负载均衡 5555    ---&gt;     172.16.1.7:22;请求负载均衡 6666    ---&gt;     172.16.1.51:3306;</code></pre></div></figure><h3 id="3-1-配置过程-1"><a href="#3-1-配置过程-1" class="headerlink" title="3.1 配置过程"></a>3.1 配置过程</h3><p>配置Nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb4-01 ~]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.c&#x2F;lb_domain.conf stream &#123;log_format  proxy &#39;$remote_addr $remote_port - [$time_local] $status $protocol &#39;                  &#39;&quot;$upstream_addr&quot; &quot;$upstream_bytes_sent&quot; &quot;$upstream_connect_time&quot;&#39; ;    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;proxy.log proxy;#定义转发ssh的22端口upstream ssh_7 &#123;server 10.0.0.7:22;&#125;#定义转发mysql的3306端口upstream mysql_51 &#123;server 10.0.0.51:3306;&#125;    server &#123;        listen 5555;        proxy_connect_timeout 3s;        proxy_timeout 300s;        proxy_pass ssh_7;    &#125;    server &#123;        listen 6666;        proxy_connect_timeout 3s;        proxy_timeout 3s;        proxy_pass mysql_51;    &#125;&#125;</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 连接web01ssh root@10.0.0.3 -p 5555# 连接db01ssh root@10.0.0.3 -p 6666</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之综合架构--07--Nginx(九)动静分离</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/15-Nginx(%E4%B9%9D)%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%92%8Crewrite/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/02-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/15-Nginx(%E4%B9%9D)%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%92%8Crewrite/</url>
    
    <content type="html"><![CDATA[<h2 id="一、动静分离介绍"><a href="#一、动静分离介绍" class="headerlink" title="一、动静分离介绍"></a>一、动静分离介绍</h2><p>动静分离，通过中间件将动静分离和静态请求进⾏分离；<br>通过中间件将动态请求和静态请求分离，可以建上不必要的请求消耗，同时能减少请求的延时。<br>通过中间件将动态请求和静态请求分离，逻辑图如下:  </p><h2 id="二、单台服务器动静分离配置"><a href="#二、单台服务器动静分离配置" class="headerlink" title="二、单台服务器动静分离配置"></a>二、单台服务器动静分离配置</h2><p>逻辑图如下：</p><p><img src="/img/%E5%8D%95%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB.png" alt="单台服务器动静分离"></p><p>编辑Nginx配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 conf.d]vim blog.confserver &#123;    listen 80;    server_name blog.linux.com;    location &#x2F; &#123;    root &#x2F;code&#x2F;wordpress;    index index.php;&#125;# 如果请求的是以.jpg结尾的静态⽂件 就去&#x2F;code&#x2F;images⽬录下访问location ~* \.jpg$ &#123;    root &#x2F;code&#x2F;images;    &#125;    location ~* \.php$ &#123;    root &#x2F;code&#x2F;wordpress;    fastcgi_pass 127.0.0.1:9000;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;    &#125;&#125; # 创建⽬录[root@web01 conf.d]# mkdir &#x2F;code&#x2F;images&#x2F;# 实现动静分离⽅式⼀：把⽂件挪到&#x2F;code&#x2F;images&#x2F;cp -r &#x2F;code&#x2F;wordpress&#x2F;wp-content &#x2F;code&#x2F;images&#x2F;⽅式⼆：做软连接cd &#x2F;codeln -s wordpress images</code></pre></div></figure><h2 id="三、多台服务器动静分离配置"><a href="#三、多台服务器动静分离配置" class="headerlink" title="三、多台服务器动静分离配置"></a>三、多台服务器动静分离配置</h2><p>参考：<a href="https://www.cnblogs.com/backups/p/nginx10.html">https://www.cnblogs.com/backups/p/nginx10.html</a></p><h3 id="3-1-原理图"><a href="#3-1-原理图" class="headerlink" title="3.1 原理图"></a>3.1 原理图</h3><p><img src="/img/%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB.png" alt="多台服务器动静分离"></p><h3 id="3-2-实验环境准备"><a href="#3-2-实验环境准备" class="headerlink" title="3.2 实验环境准备"></a>3.2 实验环境准备</h3><table><thead><tr><th>主机</th><th>外网</th><th>内网</th><th>作用服务</th></tr></thead><tbody><tr><td>lb01</td><td>10.0.0.5</td><td>172.16.1.5</td><td>负载均衡 nginx proxy</td></tr><tr><td>web01</td><td>10.0.0.7</td><td>172.16.1.7</td><td>静态资源 nginx static</td></tr><tr><td>web02</td><td>10.0.0.8</td><td>172.16.1.8</td><td>动态资源 tomcat server</td></tr></tbody></table><h3 id="3-3-配置web01提供静态资源"><a href="#3-3-配置web01提供静态资源" class="headerlink" title="3.3 配置web01提供静态资源"></a>3.3 配置web01提供静态资源</h3><p>1、配置Nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 images]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;jt.conf# 动静分离，web01提供静态文件服务server &#123;        listen 80;        server_name dongjing.gs.com;                # 提供临时测试的域名        root &#x2F;code&#x2F;dongjing;        index index.html;        location ~* ^.*\.(jpg|png|gif)$ &#123;                root &#x2F;code&#x2F;dongjing&#x2F;images;        &#125;&#125;</code></pre></div></figure><p>2、上传静态资源，测试访问静态页面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web01 ~]# echo &quot;web01...jingtai&quot; &gt; &#x2F;code&#x2F;index.html[root@web01 ~]# mkdir &#x2F;code&#x2F;dongjing&#x2F;images&#x2F; &amp;&amp; cd &#x2F;code&#x2F;dongjing&#x2F;images&#x2F;[root@web01 images]# rz 1.jpg[root@web01 images]# nginx -tnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful[root@web01 images]# systemctl reload nginx</code></pre></div></figure><p><code>在客户端配置hosts，10.0.0.7 dongjing.gs.com</code></p><p>打开浏览器访问<a href="http://dongjing.gs.com/">http://dongjing.gs.com</a></p><p><img src="/img/image-20210825141423629.png" alt="image-20210825141423629"></p><p>打开浏览器访问<a href="http://dongjing.gs.com/1.png">http://dongjing.gs.com/1.png</a></p><p><img src="/img/image-20210825142256349.png" alt="image-20210825142256349"></p><h3 id="3-4-配置web02提供动态资源（tomcat-java模拟"><a href="#3-4-配置web02提供动态资源（tomcat-java模拟" class="headerlink" title="3.4 配置web02提供动态资源（tomcat + java模拟)"></a>3.4 配置web02提供动态资源（tomcat + java模拟)</h3><p>1、安装Tomcat并添加jsp文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@web02 ~]# yum install -y tomcat[root@web02 ~]# mkdir &#x2F;usr&#x2F;share&#x2F;tomcat&#x2F;webapps&#x2F;ROOT[root@web02 ~]# cat &gt;&#x2F;usr&#x2F;share&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;java_test.jsp &lt;&lt;EOF&lt;%@ page language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.*&quot; pageEncoding&#x3D;&quot;utf-8&quot;%&gt;&lt;HTML&gt;    &lt;HEAD&gt;        &lt;TITLE&gt;oldboy JSP Page&lt;&#x2F;TITLE&gt;    &lt;&#x2F;HEAD&gt;    &lt;BODY&gt;        &lt;%            Random rand &#x3D; new Random();            out.println(&quot;&lt;h1&gt;随机数:&lt;h1&gt;&quot;);            out.println(rand.nextInt(99)+100);        %&gt;    &lt;&#x2F;BODY&gt;&lt;&#x2F;HTML&gt;EOF[root@web02 ~]# systemctl start tomcat</code></pre></div></figure><p>2、测试访问</p><p>访问<a href="http://10.0.0.8:8080/java_test.jsp">http://10.0.0.8:8080/java_test.jsp</a></p><p><img src="/img/image-20210825162829977.png" alt="image-20210825162829977"></p><h3 id="3-4-增加负载均衡，实现动静分离"><a href="#3-4-增加负载均衡，实现动静分离" class="headerlink" title="3.4 增加负载均衡，实现动静分离"></a>3.4 增加负载均衡，实现动静分离</h3><p>1、配置Nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 dongtai]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_dj.confupstream jt &#123;        server 172.16.1.7:80;&#125;upstream dt &#123;        server 172.16.1.8:8080;&#125;server &#123;        listen 80;        server_name dongjing.gs.com;        location ~* ^.*\.(jpg|png|gif)$ &#123;                proxy_pass http:&#x2F;&#x2F;jt;                proxy_set_header HOST $http_host;        &#125;        location ~ \.jsp$ &#123;                proxy_pass http:&#x2F;&#x2F;dt;                proxy_set_header HOST $http_host;        &#125;&#125;</code></pre></div></figure><p>2、测试访问</p><p><code>客户端配置hosts，10.0.0.3 dongjing.gs.com</code></p><p>在浏览器访问</p><p><a href="http://dongjing.gs.com/1.png">http://dongjing.gs.com/1.png</a></p><p><a href="http://10.0.0.8:8080/java_test.jsp">http://10.0.0.8:8080/java_test.jsp</a></p><p>的效果是一样的，但是访问<a href="http://dongjing.gs.com显示的是nginx默认的主页,因为lb01中暂时没有对应文件夹的index.html/">http://dongjing.gs.com显示的是Nginx默认的主页，因为lb01中暂时没有对应文件夹的index.html</a></p><h3 id="3-5-在负载均衡上创建同时调用动态和静态资源的index-html"><a href="#3-5-在负载均衡上创建同时调用动态和静态资源的index-html" class="headerlink" title="3.5 在负载均衡上创建同时调用动态和静态资源的index.html"></a>3.5 在负载均衡上创建同时调用动态和静态资源的index.html</h3><p>1、修改Nginx配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 dongtai]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy_dj.confupstream jt &#123;        server 172.16.1.7:80;&#125;upstream dt &#123;        server 172.16.1.8:8080;&#125;server &#123;        listen 80;        server_name dongjing.gs.com;# 新增        location &#x2F; &#123;                root &#x2F;code&#x2F;dongjing;                index index.html;        &#125;        location ~* ^.*\.(jpg|png|gif)$ &#123;                proxy_pass http:&#x2F;&#x2F;jt;                proxy_set_header HOST $http_host;        &#125;        location ~ \.jsp$ &#123;                proxy_pass http:&#x2F;&#x2F;dt;                proxy_set_header HOST $http_host;        &#125;&#125;</code></pre></div></figure><p>2、创建对应的目录和页面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 &#x2F;]# mkdir &#x2F;code&#x2F;dongjing[root@lb01 &#x2F;]# cat &#x2F;code&#x2F;dongjing&#x2F;index.html&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;        &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;        &lt;title&gt;测试ajax和跨域访问&lt;&#x2F;title&gt;        &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;jquery&#x2F;2.1.4&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;$(document).ready(function()&#123;        $.ajax(&#123;        type: &quot;GET&quot;,        url: &quot;http:&#x2F;&#x2F;dongjing.gs.com&#x2F;java_test.jsp&quot;,        success: function(data)&#123;                $(&quot;#get_data&quot;).html(data)        &#125;,        error: function() &#123;                alert(&quot;哎呦喂,失败了,回去检查你服务去~&quot;);        &#125;        &#125;);&#125;);&lt;&#x2F;script&gt;&lt;body&gt;        &lt;h1&gt;测试动静分离&lt;&#x2F;h1&gt;        &lt;div id&#x3D;&quot;get_data&quot;&gt;&lt;&#x2F;div&gt;        &lt;img src&#x3D;&quot;http:&#x2F;&#x2F;dongjing.gs.com&#x2F;1.png&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></figure><p>3、测试访问</p><p>浏览器访问：<a href="http://dongjing.gs.com/">http://dongjing.gs.com</a></p><p><img src="/img/image-20210825143746986.png" alt="image-20210825143746986"></p><p>正常负载均衡的现象：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">关掉web02的Tomcat服务，web01服务正常​http:&#x2F;&#x2F;dongjing.gs.com可以正常打开，图片正常显示，随机数将显示异常web02的Tomcat服务正常，关掉web01的nginx服务​http:&#x2F;&#x2F;dongjing.gs.com可以正常打开，图片显示异常，随机正常显示</code></pre></div></figure><h2 id="四、综合案例-Nginx资源分离"><a href="#四、综合案例-Nginx资源分离" class="headerlink" title="四、综合案例-Nginx资源分离"></a>四、综合案例-Nginx资源分离</h2><h3 id="4-1-什么是资源分离？"><a href="#4-1-什么是资源分离？" class="headerlink" title="4.1 什么是资源分离？"></a>4.1 什么是资源分离？</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">根据浏览器Agent标识可以访问到不同的页面资源：比如：    Android访问到的是Android的页面    PC访问到的是PC的页面    iphone访问放到的是iphone的页面</code></pre></div></figure><h3 id="4-2-实验环境准备"><a href="#4-2-实验环境准备" class="headerlink" title="4.2 实验环境准备"></a>4.2 实验环境准备</h3><table><thead><tr><th>主机</th><th>外网</th><th>内网</th><th>作用服务</th></tr></thead><tbody><tr><td>lb01</td><td>10.0.0.5</td><td>172.16.1.5</td><td>负载均衡 nginx proxy</td></tr><tr><td>web01</td><td>10.0.0.7</td><td>172.16.1.7</td><td>提供Android手机页面</td></tr><tr><td>web02</td><td>10.0.0.8</td><td>172.16.1.8</td><td>提供PC访问页面</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（二）综合架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--文件ACL</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day11-sudo%E4%B8%8Esu/facl/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day11-sudo%E4%B8%8Esu/facl/</url>
    
    <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><blockquote><p>补充：</p><p>​权限的归属</p><p>​a : 属组、属主以及其他人的权限一起设置。</p><p>​o : 其他人</p><p>​g : 属组</p><p>​u : 属主</p></blockquote><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><blockquote><p>就是解决目录及文件的默认权限。</p></blockquote><ul><li>文件的最高权限是多少     777</li><li>文件夹的最高权限是多少  777</li></ul><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><blockquote><p>ACL是为了解决某种特殊环境下的，用户权限需求。</p></blockquote><ul><li>setfacl ： 设置acl权限</li><li>getfacl ：查看ACL权限</li></ul><h3 id="acl权限归属"><a href="#acl权限归属" class="headerlink" title="acl权限归属"></a>acl权限归属</h3><ul><li>u : 指定用户</li><li>g : 指定组</li><li>o : 修改其他用户权限</li><li>m : 指定mask权限</li></ul><p>注：默认情况下，ACL权限跟普通权限保持一致。</p><h2 id="ACL-的流程"><a href="#ACL-的流程" class="headerlink" title="ACL 的流程"></a>ACL 的流程</h2><ul><li><p>1、创建文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod o+x &#x2F;rootchmod o+x &#x2F;root&#x2F;xiaochencd xiaochen[root@localhost xiaochen]# touch abc.txt[root@localhost xiaochen]# chmod 000 abc.txt [root@localhost xiaochen]# lltotal 0---------- 1 root root 0 Mar 16 11:39 abc.txt</code></pre></div></figure></li><li><p>编写文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost xiaochen]# echo 111 &gt; abc.txt [root@localhost xiaochen]# cat abc.txt 111</code></pre></div></figure></li><li><p>设置ACL权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost xiaochen]# useradd xiaozhang[root@localhost xiaochen]# setfacl -m u:xiaozhang:r abc.txt [root@localhost xiaochen]# getfacl abc.txt # file: abc.txt# owner: root# group: rootuser::---user:xiaozhang:r--group::---mask::r--other::---# 注：setfacl -m u:用户名称:权限(rwx) 文件名称</code></pre></div></figure></li><li><p>查看文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# su - xiaozhang[xiaozhang@localhost ~]$ cat &#x2F;root&#x2F;xiaochen&#x2F;abc.txt111</code></pre></div></figure></li></ul><p>mask :  rw-</p><p>xxxx :   -w-</p><p>-w-</p><h2 id="ACL权限的删除"><a href="#ACL权限的删除" class="headerlink" title="ACL权限的删除"></a>ACL权限的删除</h2><ul><li><p>删除某个权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost xiaochen]# getfacl abc.txt # file: abc.txt# owner: root# group: rootuser::---user:xiaozhang:r--group::---group:xiaochen:r-x#effective:r--mask::rw-other::r--[root@localhost xiaochen]# setfacl -x u:xiaozhang abc.txt[root@localhost xiaochen]# getfacl abc.txt # file: abc.txt# owner: root# group: rootuser::---group::---group:xiaochen:r-xmask::r-xother::r--[root@localhost xiaochen]# getfacl abc.txt # file: abc.txt# owner: root# group: rootuser::---group::---group:xiaochen:r-xmask::r-xother::r--[root@localhost xiaochen]# setfacl -x g:xiaochen abc.txt [root@localhost xiaochen]# getfacl abc.txt # file: abc.txt# owner: root# group: rootuser::---group::---mask::---other::r--</code></pre></div></figure></li><li><p>清空acl权限</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost xiaochen]# getfacl abc.txt # file: abc.txt# owner: root# group: rootuser::---user:xiaochen:rw-user:xiaocao:rw-group::---group:xiaochen:rw-group:xiaocao:rw-mask::rw-other::r--[root@localhost xiaochen]# setfacl -b abc.txt [root@localhost xiaochen]# getfacl abc.txt # file: abc.txt# owner: root# group: rootuser::---group::---other::r--</code></pre></div></figure></li></ul><h2 id="ACL继承"><a href="#ACL继承" class="headerlink" title="ACL继承"></a>ACL继承</h2><blockquote><p>默认情况下，ACL是不会继承上层目录的权限的。只有目录设置可继承子集文件才可以继承ACL权限。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost linux12]# setfacl -m d:u:xiaochen:w ..&#x2F;linux12[root@localhost linux12]# touch bcd.txt[root@localhost linux12]# ls -ltotal 0-rw-r--r--  1 root root 0 Mar 16 15:40 abc.txt-rw-rw-r--+ 1 root root 0 Mar 16 15:43 bcd.txt[root@localhost linux12]# getfacl bcd.txt # file: bcd.txt# owner: root# group: rootuser::rw-user:xiaochen:-w-group::r-x#effective:r--mask::rw-other::r--[root@localhost linux12]# </code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--sudo和su</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day11-sudo%E4%B8%8Esu/sudo%20and%20su/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day11-sudo%E4%B8%8Esu/sudo%20and%20su/</url>
    
    <content type="html"><![CDATA[<h1 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h1><blockquote><p>用于普通用提升权限的。</p></blockquote><ul><li><p>相关的文件：<code>/etc/sudoers</code></p></li><li><p>检查<code>/etc/sudoers</code>是否修改正确：visudo -c</p></li><li><p>sudoers文件格式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tom       ALL&#x3D;           (ALL)          ALL用户名称   所有机器可登陆    所有IP或主机名   所有的指令</code></pre></div></figure></li><li><p>指令编写格式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 必须写全路径：which查看命令全路径## 只支持vim命令提权xianchen ALL&#x3D;(ALL)  &#x2F;usr&#x2F;bin&#x2F;vim## 支持所有的命令提权tom ALL&#x3D;(ALL)  ALL## 不支持某个命令提权tom ALL&#x3D;(ALL) ALL, !&#x2F;usr&#x2F;bin&#x2F;vim## 不支持某个命令的部分功能xiaochen ALL&#x3D;(ALL)   ALL, !&#x2F;usr&#x2F;bin&#x2F;vim &#x2F;root&#x2F;123.txt</code></pre></div></figure></li></ul><h1 id="su"><a href="#su" class="headerlink" title="su"></a>su</h1><ul><li><p>su - xxx  和 su xxx之间区别</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、su - xxx ：相当于切换一个窗口，su xxx 仅仅切换了用户2、su - xxx ： 切换用户执行的系统文件要多于 su xxx3、su - xxx 是登录   su  xxx  切换用户</code></pre></div></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--用户组管理</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day09-%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day09-%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="linux中用户介绍"><a href="#linux中用户介绍" class="headerlink" title="linux中用户介绍"></a>linux中用户介绍</h2><p>什么是用户？</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">用户其实就是相当于权限的化身，处于安全考虑所以，我们在进入系统之前都需要登录，根据用户给相应权限</code></pre></div></figure><p>Linux系统中用户角色</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uid : Linux系统当中用户ID（相当于身份证号）gid : ANTA20163307用户组其实是统一某一类用户权限需求：大项目 ： 开发者：a b c d运维 ： e f测试：g共同的权限：</code></pre></div></figure><p>超级用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux当中的老大（皇帝）: rootWindows当中的老大：administrator</code></pre></div></figure><h2 id="用户与组相关的文件"><a href="#用户与组相关的文件" class="headerlink" title="用户与组相关的文件"></a>用户与组相关的文件</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# cat &#x2F;etc&#x2F;passwdroot:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash用户名称   是否存在密码   uid  gid  组名称&#x2F;注释信息 家目录  默认解析器 </code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--用户权限</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day10-Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day10-Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="修改用户信息-usermod"><a href="#修改用户信息-usermod" class="headerlink" title="修改用户信息(usermod)"></a>修改用户信息(usermod)</h1><blockquote><p>修改用户信息最主要的命令是usermod命令，其参数跟useradd基本一致。</p></blockquote><ul><li><p>修改UID</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# tail -1 &#x2F;etc&#x2F;passwdxiaoyu:x:2002:2002::&#x2F;home&#x2F;xiaoyu:&#x2F;bin&#x2F;bash[root@localhost ~]# usermod -u 2302 xiaoyu[root@localhost ~]# tail -1 &#x2F;etc&#x2F;passwdxiaoyu:x:2302:2002::&#x2F;home&#x2F;xiaoyu:&#x2F;bin&#x2F;bash</code></pre></div></figure></li><li><p>修改基本组及附加组</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 基本组 : 一个用户必须拥有的哪个组[root@localhost ~]# tail -1 &#x2F;etc&#x2F;passwdxiaoyu:x:2302:2002::&#x2F;home&#x2F;xiaoyu:&#x2F;bin&#x2F;bash[root@localhost ~]# id xiaoyuuid&#x3D;2302(xiaoyu) gid&#x3D;2002(xiaoyu) groups&#x3D;2002(xiaoyu)[root@localhost ~]# usermod -g group1 xiaoyu[root@localhost ~]# id xiaoyuuid&#x3D;2302(xiaoyu) gid&#x3D;2003(group1) groups&#x3D;2003(group1)[root@localhost ~]# tail -1 &#x2F;etc&#x2F;passwdxiaoyu:x:2302:2003::&#x2F;home&#x2F;xiaoyu:&#x2F;bin&#x2F;bash[root@localhost ~]# # 附加组 ： 用户加入的其他用户组[root@localhost ~]# groupadd group1[root@localhost ~]# iduid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),1000(oldboy),1001(sssssssssssssssssssssss),1002(test)[root@localhost ~]# usermod -G group1 root[root@localhost ~]# vim &#x2F;etc&#x2F;group[root@localhost ~]# tail -1 &#x2F;etc&#x2F;groupgroup1:x:2003:root</code></pre></div></figure></li><li><p>修改家目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# usermod  -d &#x2F;home&#x2F;xiaoyu123 xiaoyu# 注：修改家目录仅仅修改了配置，而原来的家目录文件没有迁移</code></pre></div></figure></li><li><p>修改用户描述信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# tail -1 &#x2F;etc&#x2F;passwdxiaoyu:x:2302:2003::&#x2F;home&#x2F;xiaoyu123:&#x2F;bin&#x2F;bash[root@localhost ~]# usermod -c &quot;这是一个甩锅&quot; xiaoyu[root@localhost ~]# tail -1 &#x2F;etc&#x2F;passwdxiaoyu:x:2302:2003:这是一个甩锅:&#x2F;home&#x2F;xiaoyu123:&#x2F;bin&#x2F;bash</code></pre></div></figure></li><li><p>修改用户默认解析器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# usermod -s &#x2F;bin&#x2F;sh xiaoyu[root@localhost ~]# tail -1 &#x2F;etc&#x2F;passwdxiaoyu:x:2302:2003:这是一个甩锅:&#x2F;home&#x2F;xiaoyu123:&#x2F;bin&#x2F;sh</code></pre></div></figure></li><li><p>锁定与解锁</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# usermod -L xiaoyu[root@localhost home]# usermod -U xiaoyu</code></pre></div></figure></li><li><p>修改登录名称</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# usermod -l dayu xiaoyu[root@localhost home]# tail -1 &#x2F;etc&#x2F;passwddayu:x:2302:2003:这是一个甩锅:&#x2F;home&#x2F;xiaoyu123:&#x2F;bin&#x2F;bash</code></pre></div></figure></li><li><p>追加</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# id dayuuid&#x3D;2302(dayu) gid&#x3D;2003(group1) groups&#x3D;2003(group1),1000(oldboy)[root@localhost home]# usermod -G root dayu[root@localhost home]# id dayuuid&#x3D;2302(dayu) gid&#x3D;2003(group1) groups&#x3D;2003(group1),0(root)[root@localhost home]# usermod -G oldboy dayu[root@localhost home]# id dayuuid&#x3D;2302(dayu) gid&#x3D;2003(group1) groups&#x3D;2003(group1),1000(oldboy)[root@localhost home]# usermod -a -G root dayu[root@localhost home]# id dayuuid&#x3D;2302(dayu) gid&#x3D;2003(group1) groups&#x3D;2003(group1),0(root),1000(oldboy)</code></pre></div></figure></li></ul><h1 id="密码（passwd）"><a href="#密码（passwd）" class="headerlink" title="密码（passwd）"></a>密码（passwd）</h1><blockquote><p>修改或添加Linux普通用户的密码。直接影响的文件是&#x2F;etc&#x2F;shadow</p></blockquote><ul><li><p>增加或修改密码</p><p>当用户密码不存在的时候即为增加密码，当用户密码存在时即为修改密码。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# useradd password[root@localhost home]# tail -1 &#x2F;etc&#x2F;passwdpassword:x:2303:2303::&#x2F;home&#x2F;password:&#x2F;bin&#x2F;bash[root@localhost home]# tail -1 &#x2F;etc&#x2F;shadowpassword:!!:18701:0:99999:7:::[root@localhost home]# passwd passwordChanging password for user password.New password: BAD PASSWORD: The password is a palindromeRetype new password: passwd: all authentication tokens updated successfully.[root@localhost home]# tail -1 &#x2F;etc&#x2F;passwdpassword:x:2303:2303::&#x2F;home&#x2F;password:&#x2F;bin&#x2F;bash[root@localhost home]# tail -1 &#x2F;etc&#x2F;shadowpassword:$6$.EmM.4Bl$f.LimfvMsxxFZq6yFklfyk08JKQORdQovlk2a2dtrpkP31lAMLQpezFqLheBYOTm4Sur9aAqZlC&#x2F;6MN6wHFBM1:18701:0:99999:7:::[root@localhost home]# </code></pre></div></figure></li><li><p>免交互修改密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# echo &quot;123&quot; | passwd --stdin dayuChanging password for user dayu.passwd: all authentication tokens updated successfully.</code></pre></div></figure></li></ul><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><blockquote><p>就类似于班级，是某个同权限用户的集合。</p></blockquote><h2 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# groupadd group2[root@localhost home]# tail -1 &#x2F;etc&#x2F;groupgroup2:x:2304:[root@localhost home]# </code></pre></div></figure><ul><li>指定gid</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# groupadd -g 2204 group3[root@localhost home]# tail -1 &#x2F;etc&#x2F;groupgroup3:x:2204:</code></pre></div></figure><ul><li>创建系统组</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# groupadd -r group4[root@localhost home]# tail -1 &#x2F;etc&#x2F;groupgroup4:x:996:</code></pre></div></figure><h2 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h2><ul><li><p>修改名称</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# tail -8 &#x2F;etc&#x2F;groupgirl:x:2001:[root@localhost home]# groupmod -n boy girl[root@localhost home]# tail -8 &#x2F;etc&#x2F;groupboy:x:2001:</code></pre></div></figure></li><li><p>修改gid</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# groupmod -g 2021 boy[root@localhost home]# tail -8 &#x2F;etc&#x2F;groupboy:x:2021:</code></pre></div></figure></li></ul><h2 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h2><blockquote><p>用户组在系统中删除，如果一个组被用户占用则不能删除。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost home]# groupdel group4[root@localhost home]# tail -8 &#x2F;etc&#x2F;groupdajige:x:1003:abc:x:2000:xiaoyu:x:2002:group1:x:2003:rootpassword:x:2303:group2:x:2304:group3:x:2204:boy:x:2021:[root@localhost home]# # 注：用户被删除，用户基本组也会被删除[root@localhost home]# useradd test-group-del[root@localhost home]# tail -1 &#x2F;etc&#x2F;passwdtest-group-del:x:2304:2305::&#x2F;home&#x2F;test-group-del:&#x2F;bin&#x2F;bash[root@localhost home]# tail -1 &#x2F;etc&#x2F;grouptest-group-del:x:2305:[root@localhost home]# userdel -r test-group-del[root@localhost home]# tail -1 &#x2F;etc&#x2F;passwdpassword:x:2303:2303::&#x2F;home&#x2F;password:&#x2F;bin&#x2F;bash[root@localhost home]# tail -1 &#x2F;etc&#x2F;groupboy:x:2021:[root@localhost home]# </code></pre></div></figure><h2 id="组成员管理"><a href="#组成员管理" class="headerlink" title="组成员管理"></a>组成员管理</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加一个组到用户[root@localhost home]# useradd gtest[root@localhost home]# vim &#x2F;etc&#x2F;group[root@localhost home]# id gtestuid&#x3D;2304(gtest) gid&#x3D;2305(gtest) groups&#x3D;2305(gtest),2204(group3)[root@localhost home]# gpasswd -a gtest group2Adding user gtest to group group2[root@localhost home]# id gtestuid&#x3D;2304(gtest) gid&#x3D;2305(gtest) groups&#x3D;2305(gtest),2304(group2),2204(group3)# 添加多个组到用户[root@localhost home]# gpasswd -M gtest,root,dayu groupgpasswd: group &#39;group&#39; does not exist in &#x2F;etc&#x2F;group[root@localhost home]# gpasswd -M gtest,root,dayu group3[root@localhost home]# id rootuid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),2000(abc),2003(group1),2204(group3)[root@localhost home]# id dayuuid&#x3D;2302(dayu) gid&#x3D;2003(group1) groups&#x3D;2003(group1),0(root),1000(oldboy),2204(group3)[root@localhost home]# id gtestuid&#x3D;2304(gtest) gid&#x3D;2305(gtest) groups&#x3D;2305(gtest),2304(group2),2204(group3)# 为一个组添加组长(组长有权限向组内添加用户，其他用户[除root外]没有权限添加用户到该组)[root@localhost ~]# gpasswd -A dayu group3[root@localhost ~]# cat &#x2F;etc&#x2F;gshadowgroup3:!:dayu:gtest,dayu,oldboy# 组权限[root@localhost ~]# id dayuuid&#x3D;2302(dayu) gid&#x3D;2003(group1) groups&#x3D;2003(group1),1000(oldboy),2204(group3)[root@localhost ~]# chown .group3 &#x2F;tmp&#x2F;12.txt [root@localhost ~]# ls -l &#x2F;tmp&#x2F;12.txt-rw-r--r-- 1 root group3 4 Mar 15 11:35 &#x2F;tmp&#x2F;12.txt[root@localhost ~]# chmod g+w &#x2F;tmp&#x2F;12.txt[root@localhost ~]# ls -l &#x2F;tmp&#x2F;12.txt-rw-rw-r-- 1 root group3 4 Mar 15 11:35 &#x2F;tmp&#x2F;12.txt[root@localhost ~]# su - dayuLast login: Mon Mar 15 11:37:05 CST 2021 on pts&#x2F;3[dayu@localhost ~]$ echo &quot;456&quot; &gt; &#x2F;tmp&#x2F;12.txt [dayu@localhost ~]$ cat &#x2F;tmp&#x2F;12.txt456[dayu@localhost ~]$ </code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--虚拟机安装</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day01-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day01-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="day01-课堂笔记"><a href="#day01-课堂笔记" class="headerlink" title="day01 : 课堂笔记"></a>day01 : 课堂笔记</h1><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p><strong>1、安装虚拟机</strong></p><p><img src="/.%5Cassets%5Cimage-20210302121236930.png" alt="image-20210302121236930"></p><p>解压上述软件，创建vmware.exe快捷方式，然后用快捷方式打开。</p><p><img src="/.%5Cassets%5Cimage-20210302121408360.png" alt="image-20210302121408360"></p><p><strong>2、创建虚拟机</strong></p><p><img src="/.%5Cassets%5Cimage-20210302121456338.png" alt="image-20210302121456338"></p><p><img src="/.%5Cassets%5Cimage-20210302121550128.png" alt="image-20210302121550128"></p><p><img src="/.%5Cassets%5Cimage-20210302121622000.png" alt="image-20210302121622000"></p><p><img src="/.%5Cassets%5Cimage-20210302121745568.png" alt="image-20210302121745568"></p><p><img src="/.%5Cassets%5Cimage-20210302122035359.png" alt="image-20210302122035359"></p><p><img src="/.%5Cassets%5Cimage-20210302122256831.png" alt="image-20210302122256831"></p><p><img src="/.%5Cassets%5Cimage-20210302122359568.png" alt="image-20210302122359568"></p><p><img src="/.%5Cassets%5Cimage-20210302122603313.png" alt="image-20210302122603313"></p><p><img src="/.%5Cassets%5Cimage-20210302122657199.png" alt="image-20210302122657199"></p><p><img src="/.%5Cassets%5Cimage-20210302123826623.png" alt="image-20210302123826623"></p><p><img src="/.%5Cassets%5Cimage-20210302124229475.png" alt="image-20210302124229475"></p><p><img src="/.%5Cassets%5Cimage-20210302124308081.png" alt="image-20210302124308081"></p><p><img src="/.%5Cassets%5Cimage-20210302124327456.png" alt="image-20210302124327456"></p><p><img src="/.%5Cassets%5Cimage-20210302124404318.png" alt="image-20210302124404318"></p><p><img src="/.%5Cassets%5Cimage-20210302124713502.png" alt="image-20210302124713502"></p><p><img src="/.%5Cassets%5Cimage-20210302124741038.png" alt="image-20210302124741038"></p><p><img src="/.%5Cassets%5Cimage-20210302125049653.png" alt="image-20210302125049653"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--打包与压缩</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day08-%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9/%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day08-%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9/%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h1><blockquote><p>将文件或文件夹合并成一个包，然后通过压缩算法进行数据压缩，减小包的体积，方便网络传输。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">windows：ziprarlinux:ziptargzbz2tar.gztar.bz2压缩算法：gzipbzip2</code></pre></div></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><blockquote><p>是一个Windows和Linux中常用打包压缩工具，支持的压缩算法是zip。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zip工具需要安装yum install zip unzip -y</code></pre></div></figure><h3 id="zip压缩一个文件"><a href="#zip压缩一个文件" class="headerlink" title="zip压缩一个文件"></a>zip压缩一个文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 格式zip [参数] 压缩包名称  文件路径[root@abc ~]# zip 123.zip 123.log   adding: 123.log (deflated 87%)[root@abc ~]# ls -ltotal 4732-rw-r--r--  1 root root  646165 Mar  9 10:31 123.log-rw-r--r--  1 root root   85296 Mar 11 11:58 123.zip</code></pre></div></figure><h3 id="zip压缩文件夹"><a href="#zip压缩文件夹" class="headerlink" title="zip压缩文件夹"></a>zip压缩文件夹</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 需要一个-r参数去递归压缩文件夹下的所有内容[root@abc ~]# zip -r dir.zip dir&#x2F;  adding: dir&#x2F; (stored 0%)  adding: dir&#x2F;one&#x2F; (stored 0%)  adding: dir&#x2F;123.log (deflated 87%)</code></pre></div></figure><h3 id="zip的静默输出"><a href="#zip的静默输出" class="headerlink" title="zip的静默输出"></a>zip的静默输出</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># -q：参数就是不输出任何打包信息[root@abc opt]# zip -r -q etc.zip &#x2F;etc&#x2F;[root@abc opt]# ls -ltotal 14200-rw-r--r-- 1 root root 13674457 Mar 11 12:15 etc.zip</code></pre></div></figure><h3 id="zip解压命令（unzip）"><a href="#zip解压命令（unzip）" class="headerlink" title="zip解压命令（unzip）"></a>zip解压命令（unzip）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 格式unzip [参数] 压缩包路径# unzip解压命令只能解压由zip打包的压缩文件[root@abc ~]# unzip dir.zip Archive:  dir.zip  inflating: dir&#x2F;123.log             [root@abc ~]# # 其他压缩包由unzip解压时随即报错。[root@abc opt]# unzip nginx-.tar.gzArchive:  nginx-.tar.gz  End-of-central-directory signature not found.  Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive.  In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive.unzip:  cannot find zipfile directory in one of nginx-.tar.gz or        nginx-.tar.gz.zip, and cannot find nginx-.tar.gz.ZIP, period.# 查看压缩包中压缩那些内容，不解压？# 只查看压缩包内容不解压需要使用 -l 参数[root@abc opt]# unzip -l dir.zip Archive:  dir.zip  Length      Date    Time    Name---------  ---------- -----   ----        0  03-11-2021 12:04   dir&#x2F;---------                     -------        0                     1 file# 解压到指定目录（-d）[root@abc ~]# unzip -d &#x2F;root&#x2F;  etc.zip [root@abc opt]# cd &#x2F;root&#x2F;[root@abc ~]# ls]        anaconda-ks.cfg  dir.zip  index.html           test.pdf.gz  xxxeth0xxx           系统优化.md123.log  demo.txt         etc      nginx-0.1.22.tar.gz  test.txt     上传与下载.md123.zip  dir              eth0xxx  test                 xxxeth0      文件管理_(高级).pdf# 静默输出(-q)[root@abc ~]# rm -rf etc[root@abc ~]# unzip -q -d &#x2F;root&#x2F; &#x2F;opt&#x2F;etc.zip [root@abc ~]# ls -ltotal 4828drwxr-xr-x  91 root root    8192 Mar 11 11:16 etc</code></pre></div></figure><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><blockquote><p>tar压缩支持多种压缩算法</p><p>tar.gz   gzip (用的最多)</p><p>tar.bz2 bzip2</p></blockquote><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><blockquote><p>通过gzip压缩算法，将文件压缩一定体积，有利于传输, 不支持打包</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# ls -ltotal 4828-rw-r--r--   1 root root  244977 Mar 10 12:12 index.html[root@abc ~]# gzip index.html [root@abc ~]# ls -ltotal 4612-rw-r--r--   1 root root   22652 Mar 10 12:12 index.html.gz</code></pre></div></figure><h4 id="gzip压缩一个目录"><a href="#gzip压缩一个目录" class="headerlink" title="gzip压缩一个目录"></a>gzip压缩一个目录</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc etc]# gzip -r &#x2F;etc[root@abc etc]# ls abrt                        GREP_COLORS.gz               my.cnf.d                 securityadjtime.gz                  groff                        my.cnf.gz                selinuxaliases.db.gz               group-.gz                    NetworkManager           services.gzaliases.gz                  group.gz                     networks.gz              sestatus.conf.gzalternatives                grub2.cfg                    nsswitch.conf.bak.gz     sgmlanacrontab.gz               grub.d                       nsswitch.conf.gz         shadow</code></pre></div></figure><h3 id="gzip解压-d"><a href="#gzip解压-d" class="headerlink" title="gzip解压(-d)"></a>gzip解压(-d)</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# ls -l-rw-r--r--   1 0 0   22652 Mar 10 12:12 index.html.gz[root@abc ~]# gzip -d index.html.gz [root@abc ~]# ls -ltotal 4828-rw-r--r--   1 0 0  244977 Mar 10 12:12 index.html</code></pre></div></figure><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><blockquote><p>使用bzip2 压缩算法来压缩一定体积的文件。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# ls -ltotal 4828-rw-r--r--   1 root root  646165 Mar  9 10:31 123.log     [root@abc ~]# bzip2 123.log [root@abc ~]# ls -ltotal 4240-rw-r--r--   1 root root       0 Mar 10 12:04 ]-rw-r--r--   1 root root   42210 Mar  9 10:31 123.log.bz2</code></pre></div></figure><h3 id="bzip2解压（-d）"><a href="#bzip2解压（-d）" class="headerlink" title="bzip2解压（-d）"></a>bzip2解压（-d）</h3><blockquote><p>bzip2解压是针对于bzip2压缩的压缩包来进行解压。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# ls -ltotal 4240-rw-r--r--   1 root root   42210 Mar  9 10:31 123.log.bz2[root@abc ~]# bzip2 -d 123.log.bz2 [root@abc ~]# ls -ltotal 4828-rw-r--r--   1 root root  646165 Mar  9 10:31 123.log</code></pre></div></figure><h3 id="tar-1"><a href="#tar-1" class="headerlink" title="tar"></a>tar</h3><blockquote><p>tar其实是一个打包工具，不具备压缩功能，但是可以使用参数调用压缩工具来进行解压。</p></blockquote><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p>-c : 创建压缩包</p></li><li><p>-f : 指定压缩包名称</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# tar -c -f test.tar 123.log [root@abc ~]# ls -ltotal 5468-rw-r--r--   1 root root  655360 Mar 11 15:49 test.tar</code></pre></div></figure></li><li><p>-z ： 指定使用gzip压缩工具进行压缩</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# tar  -c -z -f test-one.tar 123.log [root@abc ~]# ls -l total 5084-rw-r--r--   1 root root   85279 Mar 11 15:56 test-one.tar# 注：使用-z参数，不会自动添加.gz后缀[root@abc ~]# tar -c -z -f anaconda.tar.gz  anaconda-ks.cfg [root@abc ~]# ls -ltotal 5084-rw-r--r--   1 root root    1010 Mar 11 15:58 anaconda.tar.gz</code></pre></div></figure></li><li><p>-j : 指定使用bzip2压缩工具进行压缩</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# tar -c -j -f 123-bask-one.tar 123.log [root@abc ~]# ls -ltotal 5172-rw-r--r--   1 root root   42328 Mar 11 16:00 123-bak.tar.bz2-rw-r--r--   1 root root   42328 Mar 11 16:01 123-bask-one.tar</code></pre></div></figure></li><li><p>-J : 指定使用xz压缩工具进行压缩</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc test-tar]# tar -c -J  -f etc.tar.xz &#x2F;etc&#x2F;[root@abc ~]# ls -l-rw-r--r-- 1 root root 9493376 Mar 11 17:00 etc.tar.xz</code></pre></div></figure></li><li><p>-t : 查看压缩包内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# tar -t -f 123-bak.tar.bz2 123.log[root@abc ~]# </code></pre></div></figure></li><li><p>-v ： 显示压缩包压缩过程</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# tar -x -v -f etc.tar -C &#x2F;opt&#x2F;&#x2F;etc&#x2F;centos-release&#x2F;etc&#x2F;DIR_COLORS.lightbgcolor&#x2F;etc&#x2F;libaudit.conf&#x2F;etc&#x2F;mail.rc</code></pre></div></figure></li><li><p>-P : 允许使用绝对路径进行打包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# tar -c -P -f 123-three.tar &#x2F;etc&#x2F;passwd[root@abc ~]# tar -c -f 123-three.tar &#x2F;etc&#x2F;passwdtar: Removing leading &#96;&#x2F;&#39; from member names[root@abc ~]# </code></pre></div></figure></li><li><p>-x ： 解压</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># tar解压是按照原来的路径进行解压[root@abc test]# tar -x -f etc.tar # tar会自动识别压缩功能</code></pre></div></figure></li><li><p>-C ： 指定解压路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc ~]# tar -x -f etc.tar -C &#x2F;opt&#x2F;tar: Removing leading &#96;&#x2F;&#39; from member names[root@abc ~]# cd &#x2F;opt&#x2F;[root@abc opt]# lsabc23  dir  dir.zip  etc  nginx-0.1.22.tar.gz  nginx-.tar.gz  xxx[root@abc opt]# </code></pre></div></figure></li><li><p>–exclude : 排除某些文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc test-tar]# tar -c -f abc.tar .&#x2F;* --exclude&#x3D;abc7 --exclude&#x3D;abc5   --exclude&#x3D;abc1 [root@abc test-tar]# tar -t -f abc.tar .&#x2F;abc2.&#x2F;abc3.&#x2F;abc4.&#x2F;abc6.&#x2F;abc8.&#x2F;abc9[root@abc test-tar]# </code></pre></div></figure></li><li><p>–exclude-from : 根据某个文件列表排除多个文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc test-tar]# cat list.txt abc995abc996abc997abc998abc999[root@abc test-tar]# tar -c -f abc.tar .&#x2F;* --exclude-from&#x3D;list.txt </code></pre></div></figure></li><li><p>-h : 打包软连接</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@abc test-tar]# tar -c -h -f bin-h.tar &#x2F;bin</code></pre></div></figure></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar参数-c : 创建压缩-f ； 指定压缩包名称-z : 使用gzip压缩工具进行压缩-j : 使用bzip2压缩工具进行压缩-J : 使用xz压缩工具进行压缩-t : 显示压缩包内容，不解压-v : 显示压缩过程-P : 允许使用绝对路径进行压缩-x : 解压-C : 指定解压路径-h : 打包软连接--exclude : 排除某些文件--exclude-from : 根据文件列表排除多个文件</code></pre></div></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.linux下常见的压缩包类型有哪些zip gz bz2 tar.gz tar.bz tar2.将&#x2F;etc&#x2F;hosts文件用tar格式打包。tar -c -P -f hosts.tar &#x2F;etc&#x2F;hosts3.查看打包之后的&#x2F;etc&#x2F;hosts的文件内容，在不解压的情况下查看。tar -t -f hosts.tar4.使用tar打包&#x2F;var&#x2F;log&#x2F;目录。tar -c -P -f hosts.tar &#x2F;var&#x2F;log&#x2F;5.使用zip打包&#x2F;etc目录。zip -r etc.zip &#x2F;etc6.查看&#x2F;var&#x2F;log&#x2F;abc.zip目录的压缩包中有哪些内容。unzip -l &#x2F;var&#x2F;log&#x2F;abc.zip7.将&#x2F;var&#x2F;log&#x2F;abc.zip目录解压到&#x2F;opt目录中。unzip -d &#x2F;opt &#x2F;var&#x2F;log&#x2F;abc.zip10.解压&#x2F;etc&#x2F;abc.tar.gz目录到&#x2F;opt目录中。tar -xf &#x2F;etc&#x2F;abc.tar.gz -C &#x2F;opt11.用zip打包&#x2F;opt目录，要求不显示打包过程。zip -q opt.zip &#x2F;optzip [参数] 压缩包名称  压缩文件路径 12.打包&#x2F;etc&#x2F;目录，要求是.bz2格式tar -c -j -f etc.tar &#x2F;etc13.打包&#x2F;var&#x2F;log目录，要求是.xz格式tar -c -J -f log.tar.xz &#x2F;var&#x2F;log14.使用tar命令打包&#x2F;etc&#x2F;时，会出现一个删根的操作，怎样打包不会进行删根的操作tar -c -P -f etc.tar &#x2F;etc15.打包&#x2F;etc&#x2F;目录，要求不打包&#x2F;etc&#x2F;hosts这个文件。16.打包&#x2F;etc&#x2F;目录，要求不打包&#x2F;etc&#x2F;hosts和&#x2F;etc&#x2F;hostname这两个文件。17.打包&#x2F;etc&#x2F;目录，但要排除passwd,shadow,group,gshadow,hosts,hostname这些文件。(你能用两种方法实现吗)18.已知&#x2F;etc&#x2F;grub2.cfg文件是个软连接文件，在你不知道的情况下，请问怎么打包该文件的真实文件。19.把&#x2F;var&#x2F;log&#x2F;目录中所有.log的文件进行打包成一个压缩包，名称定义为log.tar.gz的压缩包。20.已知文件oldboy.gz,请问在不解压的情况下，怎样查看该文件的内容。21.打包&#x2F;etc&#x2F;目录，当前时间方式的压缩包:比如: 2019-12-24_etc.tar.gz22.创建&#x2F;data&#x2F;bak目录，然后复制如下文件到&#x2F;data&#x2F;bak目录下23.接22题，使用tar命令对&#x2F;data&#x2F;bak目录下的文件及目录以gzip的格式进行归档压缩到&#x2F;data目录下（压缩包的名字以自己名字命名）24.使用tar命令查看上题&#x2F;data目录下压缩包内的内容。25.把第23题&#x2F;data目录下的压缩包，解压到&#x2F;backup目录下26.再次使用tar命令把&#x2F;data&#x2F;bak目录下的文件及目录以gzip的格式进行归档压缩到&#x2F;data目录下，但是在进行归档压缩时，排除文件“sudoers”，然后查看该压缩包内容是否存在文件“sudoers”（压缩包名自行拟定）27.打包&#x2F;etc目录下所有普通文件到root用户家目录。28.打包&#x2F;etc&#x2F;目录到&#x2F;opt&#x2F;目录下，名称要求以当前主机名和ip地址命名，例：oldboy_10.0.0.100.tar.gz29.如何使用gzip命令对文件进行压缩、解压30.如何用zip命令对文件以及目录进行压缩、解压32.打包opt整个目录，并命名test_opt.tar.gz33.查看打包好的test_opt.tar.gz里的文件34.将打包好的test_opt.tar.gz内容指定解压至&#x2F;tmp目录35.打包etc目录下的所有文件，不要目录只要文件36.打包etc目录下的所有文件，排除passwd，shadow37.打包etc目录下的所有以p开头的文件38.打包etc目录下所有大于1M的文件</code></pre></div></figure><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2.权限中的rwx-，每个字符所代表什么意思？对应的数字是什么？r可读4w可写2x可执行1-没有权限03.-rwxr-xr-x，写出对应数字权限4.-rwxr--r--，写出对应数字权限5.-r-xr-x--x，写出对应数字权限6.-rw-r-xr-x，写出对应数字权限7.-r--r--r--，写出对应数字权限8.-r-xr-----，写出对应数字权限9.---x-w-r--，写出对应数字权限10.-rwxr--rw-，写出对应数字权限11.-rw-r--r--，写出对应数字权限12.---xr--rwx，写出对应数字权限13.777，写出对应字母权限14.545，写出对应字母权限15.744，写出对应字母权限16.600，写出对应字母权限17.641，写出对应字母权限18.711，写出对应字母权限19.700，写出对应字母权限20.555，写出对应字母权限21.733，写出对应字母权限22.713，写出对应字母权限23.建一个目录&#x2F;test,查看这个目录的默认权限是?24.进入&#x2F;test目录中,建一个文件abc,查看其默认的权限为？25.创建一个文件test.txt,并其将权限改为600.26.将test.txt文件的权限改为755.27.将test.txt文件的权限改为000.28.修改test.txt文件的权限为644.29.给test.txt文件的属主加上x权限。30.给test.txt文件的其他用户加上x权限。31.去除test.txt文件的所有执行权限。32.给&#x2F;test目录及目录下的所有文件或目录的权限统一改为744。</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--软件包管理</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day12-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day12-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h1><ul><li><p>rpm包来源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、来源网络下载2、来源本地：自己的镜像自带的rpm包</code></pre></div></figure></li><li><p>rpm命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装rpm -ivh xxx.rpm# http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;x86_64&#x2F;RPMS&#x2F;-v : 显示安装过程-i ：显示安装包的详细信息-h : 安装包哈希标记# 下载Nginx rpm安装包的全名[root@localhost ~]# wget http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;x86_64&#x2F;RPMS&#x2F;nginx-1.18.0-1.el7.ngx.x86_64.rpm--2021-03-17 12:16:47--  http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;x86_64&#x2F;RPMS&#x2F;nginx-1.18.0-1.el7.ngx.x86_64.rpmResolving nginx.org (nginx.org)... 52.58.199.22, 3.125.197.172, 2a05:d014:edb:5702::6, ...Connecting to nginx.org (nginx.org)|52.58.199.22|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 790284 (772K) [application&#x2F;x-redhat-package-manager]Saving to: ‘nginx-1.18.0-1.el7.ngx.x86_64.rpm’100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 790,284      339KB&#x2F;s   in 2.3s   2021-03-17 12:16:51 (339 KB&#x2F;s) - ‘nginx-1.18.0-1.el7.ngx.x86_64.rpm’ saved [790284&#x2F;790284]# 安装rpm安装包[root@localhost ~]# rpm -ivh nginx-1.18.0-1.el7.ngx.x86_64.rpm warning: nginx-1.18.0-1.el7.ngx.x86_64.rpm: Header V4 RSA&#x2F;SHA1 Signature, key ID 7bd9bf62: NOKEYPreparing...                          ################################# [100%]Updating &#x2F; installing...   1:nginx-1:1.18.0-1.el7.ngx         ################################# [100%]----------------------------------------------------------------------Thanks for using nginx!Please find the official documentation for nginx here:* http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;Please subscribe to nginx-announce mailing list to getthe most important news about nginx:* http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;support.htmlCommercial subscriptions for nginx are available on:* http:&#x2F;&#x2F;nginx.com&#x2F;products&#x2F;----------------------------------------------------------------------# 验证nginx是否安装成功[root@localhost ~]# nginx -vnginx version: nginx&#x2F;1.18.0# 卸载[root@localhost ~]# rpm -e nginx (软件包名称)[root@localhost ~]# nginx -v-bash: &#x2F;usr&#x2F;sbin&#x2F;nginx: No such file or directory[root@localhost ~]# # 查看系统当中安装了哪些rpm软件包rpm -qa# 查看系统当中是否安装了某个rpm软件包[root@localhost ~]# rpm -q nginx（软件包名）nginx-1.18.0-1.el7.ngx.x86_64[root@localhost ~]# rpm -q safsdgsfdgfdpackage safsdgsfdgfd is not installed# 显示已经安装过的rpm包详细信息。[root@localhost ~]# rpm -qi nginxName        : nginxEpoch       : 1Version     : 1.18.0Release     : 1.el7.ngxArchitecture: x86_64Install Date: Wed 17 Mar 2021 04:18:55 PM CSTGroup       : System Environment&#x2F;DaemonsSize        : 2830028License     : 2-clause BSD-like licenseSignature   : RSA&#x2F;SHA1, Tue 21 Apr 2020 11:19:18 PM CST, Key ID abf5bd827bd9bf62Source RPM  : nginx-1.18.0-1.el7.ngx.src.rpmBuild Date  : Tue 21 Apr 2020 11:07:33 PM CSTBuild Host  : ip-10-1-17-101.eu-central-1.compute.internalRelocations : (not relocatable)Vendor      : Nginx, Inc.URL         : http:&#x2F;&#x2F;nginx.org&#x2F;Summary     : High performance web serverDescription :nginx [engine x] is an HTTP and reverse proxy server, as well asa mail proxy server.# 查看安装包的内容[root@localhost nginx]# rpm -ql nginx&#x2F;etc&#x2F;logrotate.d&#x2F;nginx&#x2F;etc&#x2F;nginx&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params&#x2F;etc&#x2F;nginx&#x2F;koi-utf&#x2F;etc&#x2F;nginx&#x2F;koi-win&#x2F;etc&#x2F;nginx&#x2F;mime.types&#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&#x2F;etc&#x2F;nginx&#x2F;scgi_params&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params&#x2F;etc&#x2F;nginx&#x2F;win-utf&#x2F;etc&#x2F;sysconfig&#x2F;nginx&#x2F;etc&#x2F;sysconfig&#x2F;nginx-debug&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx-debug.service&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules&#x2F;usr&#x2F;libexec&#x2F;initscripts&#x2F;legacy-actions&#x2F;nginx&#x2F;usr&#x2F;libexec&#x2F;initscripts&#x2F;legacy-actions&#x2F;nginx&#x2F;check-reload&#x2F;usr&#x2F;libexec&#x2F;initscripts&#x2F;legacy-actions&#x2F;nginx&#x2F;upgrade&#x2F;usr&#x2F;sbin&#x2F;nginx&#x2F;usr&#x2F;sbin&#x2F;nginx-debug&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.18.0&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.18.0&#x2F;COPYRIGHT&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;var&#x2F;log&#x2F;nginx# 查看配置信息[root@localhost nginx]# rpm -qc nginx&#x2F;etc&#x2F;logrotate.d&#x2F;nginx&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params&#x2F;etc&#x2F;nginx&#x2F;koi-utf&#x2F;etc&#x2F;nginx&#x2F;koi-win&#x2F;etc&#x2F;nginx&#x2F;mime.types&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&#x2F;etc&#x2F;nginx&#x2F;scgi_params&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params&#x2F;etc&#x2F;nginx&#x2F;win-utf&#x2F;etc&#x2F;sysconfig&#x2F;nginx&#x2F;etc&#x2F;sysconfig&#x2F;nginx-debug# 查看文件帮助信息[root@localhost nginx]# rpm -qd zlib&#x2F;usr&#x2F;share&#x2F;doc&#x2F;zlib-1.2.7&#x2F;ChangeLog&#x2F;usr&#x2F;share&#x2F;doc&#x2F;zlib-1.2.7&#x2F;FAQ&#x2F;usr&#x2F;share&#x2F;doc&#x2F;zlib-1.2.7&#x2F;README# [root@localhost ~]# rpm -qf &#x2F;usr&#x2F;sbin&#x2F;nginxnginx-1.18.0-1.el7.ngx.x86_64# 用 -p 可以查看未安装软件包的详细信息[root@localhost ~]# rpm -qip nginx-1.18.0-1.el7.ngx.x86_64.rpm warning: nginx-1.18.0-1.el7.ngx.x86_64.rpm: Header V4 RSA&#x2F;SHA1 Signature, key ID 7bd9bf62: NOKEYName        : nginxEpoch       : 1Version     : 1.18.0Release     : 1.el7.ngxArchitecture: x86_64Install Date: (not installed)Group       : System Environment&#x2F;DaemonsSize        : 2830028License     : 2-clause BSD-like licenseSignature   : RSA&#x2F;SHA1, Tue 21 Apr 2020 11:19:18 PM CST, Key ID abf5bd827bd9bf62Source RPM  : nginx-1.18.0-1.el7.ngx.src.rpmBuild Date  : Tue 21 Apr 2020 11:07:33 PM CSTBuild Host  : ip-10-1-17-101.eu-central-1.compute.internalRelocations : (not relocatable)Vendor      : Nginx, Inc.URL         : http:&#x2F;&#x2F;nginx.org&#x2F;Summary     : High performance web serverDescription :nginx [engine x] is an HTTP and reverse proxy server, as well asa mail proxy server.# 升级软件包[root@localhost ~]# rpm -Uvh nginx-1.18.0-1.el7.ngx.x86_64.rpm warning: nginx-1.18.0-1.el7.ngx.x86_64.rpm: Header V4 RSA&#x2F;SHA1 Signature, key ID 7bd9bf62: NOKEYPreparing...                          ################################# [100%]Updating &#x2F; installing...   1:nginx-1:1.18.0-1.el7.ngx         ################################# [ 50%]Cleaning up &#x2F; removing...   2:nginx-1:1.14.0-1.el7_4.ngx       ################################# [100%][root@localhost ~]# nginx -vnginx version: nginx&#x2F;1.18.0# 强制删除软件包--nodeps[root@localhost ~]# rpm -e zlib --nodeps</code></pre></div></figure></li></ul><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><blockquote><p>yum是CentOS的软件包管理工具，自动为我们解决软件依赖问题。yum包管理工具必须使用yum源指定软件下载地址去下载需要安装的软件包。配置的路径是：&#x2F;etc&#x2F;yum.repos.d</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 清空本机所有的yum源[root@www yum.repos.d]# rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*</code></pre></div></figure><ul><li><p>yum源命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看当前系统的yum源列表[root@www yum.repos.d]# yum repolist Loaded plugins: fastestmirrorLoading mirror speeds from cached hostfilerepo id                   repo name                                           statusbase                      &quot;This is local repo, and 非常屌&quot;                    10,072repolist: 10,072# yum清空缓存[root@www yum.repos.d]# yum clean allLoaded plugins: fastestmirrorCleaning repos: baseCleaning up list of fastest mirrorsOther repos take up 76 M of disk space (use --verbose for details)# 建立yum缓存[root@www yum.repos.d]# yum makecacheLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfile</code></pre></div></figure></li><li><p>yum源的执行原理</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、需要在&#x2F;etc&#x2F;yum.repos.d目录下配置yum源地址2、清空缓存建立新的缓存3、安装软件（自动解决依赖关系）</code></pre></div></figure></li><li><p>yum常用的基础命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装软件包的命令yum install 软件包名称-y : 免交互安装# 卸载软件（直接将软件的依赖包一起删除）yum remove 软件包名称[root@www yum.repos.d]# yum remove httpd-y : 免交互移除# 查看当前系统需要更新软件yum check-update# 更新所有的需要更新的软件yum update -y ： 免交互# 更新某一个软件yum update (软件包名称)# 重装软件yum reinstall (软件包名称)# 搜索软件包[root@www httpd]# yum search （软件包名称）-------------------------------------------------------# 查看yum执行历史yum history[root@www httpd]# yum history info (历史ID号)[root@www httpd]# yum history undo (历史ID号)# 查看当前系统当中可更新的软件包[root@www yum.repos.d]# yum check-update Loaded plugins: fastestmirrorLoading mirror speeds from cached hostfilepostfix.x86_64                                        2:2.10.1-9.0.1.el7.centos.plus                                      centospluspython-perf.x86_64                                    3.10.0-1160.15.2.el7.centos.plus                                    centosplus[root@www yum.repos.d]# # 查看系统中有哪些仓库地址yum repolist    # 正在启用的yum仓库[root@www yum.repos.d]# yum repolistLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfilerepo id                   repo name                                           statusbase&#x2F;7&#x2F;x86_64             CentOS-7 - Base - repo.huaweicloud.com              10,072extras&#x2F;7&#x2F;x86_64           CentOS-7 - Extras - repo.huaweicloud.com               453updates&#x2F;7&#x2F;x86_64          CentOS-7 - Updates - repo.huaweicloud.com            1,729yum repolist all # 查看系统中所有的yum仓库[root@www yum.repos.d]# yum repolist allLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfilerepo id                                        repo name                                                             statusbase&#x2F;7&#x2F;x86_64                                  CentOS-7 - Base - repo.huaweicloud.com                                enabled: 10,072centosplus&#x2F;7&#x2F;x86_64                            CentOS-7 - Plus - repo.huaweicloud.com                                disabledextras&#x2F;7&#x2F;x86_64                                CentOS-7 - Extras - repo.huaweicloud.com                              enabled:    453updates&#x2F;7&#x2F;x86_64                               CentOS-7 - Updates - repo.huaweicloud.com                             enabled:  1,72# 启用repo仓库yum install yum-utils -y启用一个yum仓库：yum-config-manager --enable (仓库名称)关闭一个yum仓库：yum-config-manager --disable (仓库名称)# 查看一个仓库中的软件包列表[root@www yum.repos.d]# yum list# 查看软件包组[root@www yum.repos.d]# yum grouplist# 安装软件包组[root@www yum.repos.d]# yum groupinstall &quot;Development Tools&quot;</code></pre></div></figure></li><li><p>本地yum源配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、备份&#x2F;etc&#x2F;yum.repos.d&#x2F;下的所文件rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*2、编写本地yum源[root@www yum.repos.d]# cat test.repo [base] # yum源名称name&#x3D;&quot;This is repo infomation&quot; #yum源的简介baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;opt    # 指定yum源地址enabled&#x3D;1# 是否启用yum源gpgcheck&#x3D;0# 是否检查gpg秘钥3、更新缓存yum makecache4、安装软件yum install dos2unix</code></pre></div></figure></li><li><p>共享yum源配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、安装ftpyum install vsftpd -y2、启动vsftpdsystemctl enable --now vsftpd # 设置开机自启动并且立即启动3、创建yum源共享文件夹[root@www ftp]# mkdir &#x2F;var&#x2F;ftp&#x2F;centos4、将映像中的软件复制到&#x2F;var&#x2F;ftp&#x2F;centoscp -rp &#x2F;opt&#x2F;* &#x2F;var&#x2F;ftp&#x2F;centos5、编辑本地yum源，接入ftp[root@localhost yum.repos.d]# cat local.repo [base]baseurl&#x3D;ftp:&#x2F;&#x2F;192.168.15.100&#x2F;centosname&#x3D;&quot;This is ftp repo&quot;enabled&#x3D;1gpgcheck&#x3D;06、测试安装yum install dos2unix -y</code></pre></div></figure></li><li><p>yum的配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># yum仓库的机器上执行1、修改&#x2F;etc&#x2F;yum.conf    cachedir&#x3D;&#x2F;var&#x2F;ftp&#x2F;centos&#x2F;Packages   # 指定yum缓存目录    keepcache&#x3D;1# 下载的缓存软件不立即删除， 0为立即删除2、安装ftpyum install vsftpd -y3、启动vsftpdsystemctl enable --now vsftpd # 设置开机自启动并且立即启动4、创建yum源共享文件夹[root@www ftp]# mkdir &#x2F;var&#x2F;ftp&#x2F;centos5、更新yum仓库[root@www ftp]# yum clean all[root@www ftp]# yum makecache6、建立一个快捷方式cd &#x2F;var&#x2F;ftp&#x2F;centos&#x2F;Packages&#x2F;baseln -s packages Packages7、安装mariadbyum install mariadb -y8、建立&#x2F;var&#x2F;ftp&#x2F;centos&#x2F;Packages&#x2F;base&#x2F;repodatamkdir &#x2F;var&#x2F;ftp&#x2F;centos&#x2F;Packages&#x2F;base&#x2F;repodata9、把&#x2F;var&#x2F;ftp&#x2F;centos&#x2F;Packages&#x2F;base下面的自动生成的压缩文件复制到&#x2F;var&#x2F;ftp&#x2F;centos&#x2F;Packages&#x2F;base&#x2F;repodata用做认证。# 使用yum仓库的机器上执行1、建立yum配置文件[root@localhost ~]# cat &#x2F;etc&#x2F;yum.repos.d&#x2F;local.repo [base]baseurl&#x3D;ftp:&#x2F;&#x2F;192.168.15.100&#x2F;centos&#x2F;Packages&#x2F;basename&#x3D;&quot;This is ftp repo&quot;enabled&#x3D;1gpgcheck&#x3D;02、更新yum仓库[root@www ftp]# yum clean all[root@www ftp]# yum makecache3、测试安装mariadbyum install mariadb -y</code></pre></div></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--进程管理</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day16-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day16-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>程序：安装包</p><p>进程：正在运行的实例</p><p>CPU：计算</p><p>内存：存储CPU计算使用的临时数据</p><p>存储：</p><p>进程和线程</p><p>僵尸进程和孤儿进程</p><p>僵尸进程：进程生命周期结束了，但是PID未被回收</p><p>孤儿进程：父进程生命周期结束了，但是子进程未结束，子进程被系统进程接收</p><p>1、查看进程</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 命令：ps, 默认查看当前进程# 参数-a : 查询所有进程-x : 查看后台所有的进程-u : 查看进程的用户USER ： 开启当前进程的用户PID  ： 当前进程的ID号%CPU ： CPU的使用率%MEM ： 内存使用率VSZ  ： 进程启动时默认向计算机申请的内存RSS  ： 进程运行时实际使用的内存TTY  ： 进程运行的终端？： 后台运行（没有终端）tty：使用系统终端pts：使用虚拟终端STAT ：进程运行状态R ： 正在运行中的进程+ ： 在前台运行S ： 睡眠中状态D ： 不可中断睡眠T ： 停止状态Z :  僵尸状态X ： 死掉的进程&lt; : 优先级较高的进程N ：优先级较低的进程s : 包含子进程       yum install psmisc -y l : 已线程的方式运行| ： 代表管道START ： 进程的启动时间TIME  ： 占用CPU的时间COMMAND ： 进程执行的命令-e : 显示所有的进程-f : 格式化输出同时显示PPIDPPID ： 父进程ID</code></pre></div></figure><p>2、top</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 根据一定频率的去监控系统up前是系统时间up后是开启的时间load average: 0.01, 0.42, 0.730.01  ： 一分钟平均负载0.42  ： 五分钟平均负载0.73  ： 十五分钟平均负载平均负载：# CPU加压工具stress --cpu [需要加压的系统核心数] --timeout [加压的时间]# CPU 性能加压工具## 添加epel源（epel源主要用来安装红帽系列操作系统附加软件）yum install stress -y# CPU 性能分析工具yum install sysstat -ympstat -P ALL 3   # 进程性能分析⼯具pidstat -u 1 5  TasksTasks: 125 total,   1 running, 124 sleeping,   0 stopped,   0 zombietotal : 当前系统一共运行的是125个进程running : 正在运行的是1个sleeping : 124个处于睡眠状态stopped : 停止运行的进程数zombie  ：僵尸进程数%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stus ：在单位时间进程使用CPU所占用的时间百分比sy : 在单位时间内系统进程占用CPU时间百分比ni : 在单位时间内优先使用CPU所占时间百分比id ：在单位时间内CPU空闲所占时间百分比wa : 在单位时间内CPU阻塞态所占CPU时间的百分比hi : 硬件中断si : 软件中断st : 其他占用CPU时间百分比KiB Mem :  2027892 total,  1234180 free,   176352 used,   617360 buff&#x2F;cachetotal ：系统总内存free  ：系统空闲内存used  : 系统使用内存buff&#x2F;cache ： 缓存使用内存avail Mem ：  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    PID ： 进程编号USER ： 启动进程的用户PR : 优先级NI ：nice值VIRT ： 虚拟内存RES  ： 使用内存SHR  ： 共享内存%CPU ： cpu使用率%MEM ：内存使用率</code></pre></div></figure><p>3、top快捷键</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">按1 : 展示所有的CPU的详情按s : 设置top监控频率（默认3秒）按m : 按照内存排序 按z : 添加颜色按p : 按照CPU排序按l : 展示CPU总负载（默认显示）</code></pre></div></figure><p>4、top的参数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-d ： 设置top的刷新频率-p :  设置查看的进程PIDtop -d 1 -p &#96;pgrep nginx | head -1&#96;-u :  查询指定用户的经常的进程top -u oldboy-n : 表示查询n次 top -d 0.1 -u oldboy -n 20</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[epel]name&#x3D;Extra Packages for Enterprise Linux 7 - $basearchbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;epel&#x2F;7&#x2F;$basearch#mirrorlist&#x3D;https:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;metalink?repo&#x3D;epel-7&amp;arch&#x3D;$basearchfailovermethod&#x3D;priorityenabled&#x3D;1gpgcheck&#x3D;0[epel-debuginfo]name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch - Debugbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;epel&#x2F;7&#x2F;$basearch&#x2F;debug#mirrorlist&#x3D;https:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;metalink?repo&#x3D;epel-debug-7&amp;arch&#x3D;$basearchfailovermethod&#x3D;priorityenabled&#x3D;0gpgcheck&#x3D;0[epel-source]name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch - Sourcebaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;epel&#x2F;7&#x2F;SRPMS#mirrorlist&#x3D;https:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;metalink?repo&#x3D;epel-source-7&amp;arch&#x3D;$basearchfailovermethod&#x3D;priorityenabled&#x3D;0gpgcheck&#x3D;0</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--yum仓库</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day13-yum%E4%BB%93%E5%BA%93/yum%E4%BB%93%E5%BA%93/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day13-yum%E4%BB%93%E5%BA%93/yum%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="yum仓库"><a href="#yum仓库" class="headerlink" title="yum仓库"></a>yum仓库</h1><p>1、克隆两台主机</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum仓库主机外网地址：192.168.15.30内网地址：172.16.1.30yum测试主机外网地址：192.168.15.31内网地址：172.16.1.31修改的命令：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1重启网卡：systemctl restart network修改主机名：yum仓库主机：hostnamectl set-hostname warehouseyum测试主机：hostnamectl set-hostname yum-test</code></pre></div></figure><p>2、配置yum仓库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、需要有一个软件包目录，存放软件包的[root@warehouse ~]# mkdir &#x2F;backup1.1、缓存yum安装下载的软件包[root@warehouse 7]# vim &#x2F;etc&#x2F;yum.conf[main]    cachedir&#x3D;&#x2F;var&#x2F;cache&#x2F;yum&#x2F;$basearch&#x2F;$releasever    keepcache&#x3D;1    [root@warehouse ~]# yum install mariadb -y1.2、将缓存的软件包复制到yum仓库目录[root@warehouse ~]# cd &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7&#x2F;base&#x2F;packages&#x2F;[root@warehouse packages]# cp -rp .&#x2F;* &#x2F;backup&#x2F;    [root@warehouse packages]# cd &#x2F;backup&#x2F;    [root@warehouse backup]# ll    total 8964    -rw-r--r-- 1 root root 9175948 Oct 15 02:55 mariadb-5.5.68-1.el7.x86_64.rpm2、建立软件包依赖关系[root@warehouse backup]# yum install createrepo -y[root@warehouse backup]# createrepo &#x2F;backup&#x2F;    Spawning worker 0 with 1 pkgs    Spawning worker 1 with 0 pkgs    Workers Finished    Saving Primary metadata    Saving file lists metadata    Saving other metadata    Generating sqlite DBs    Sqlite DBs complete    [root@warehouse backup]# ll    total 8968    -rw-r--r-- 1 root root 9175948 Oct 15 02:55 mariadb-5.5.68-1.el7.x86_64.rpm    drwxr-xr-x 2 root root    4096 Mar 18 08:54 repodata    [root@warehouse backup]# ll repodata&#x2F;    total 28    -rw-r--r-- 1 root root 1970 Mar 18 08:54 5d54624b2aa7a1fe974ff5553a9a78289683189c6a7b60c8c1421ecf011d270f-other.sqlite.bz2    -rw-r--r-- 1 root root 3449 Mar 18 08:54 5e68ee34f7e8f1a11a039f55c990bcc044f16bceb6af7f4486b55d518ad91346-primary.sqlite.bz2    -rw-r--r-- 1 root root  539 Mar 18 08:54 6e94b0fa1d98955542fb8238348ea171be7a130ba97573eb3ac756e1aadcec50-filelists.xml.gz    -rw-r--r-- 1 root root 1291 Mar 18 08:54 a9afb0b2457f41f5c2d64744a07d5d12599e6c2588c870ae73568cf345a0abca-other.xml.gz    -rw-r--r-- 1 root root 1333 Mar 18 08:54 cf41627875b17ef4bea5f0ea566ac63a5c83adc606d3ca730a74944ceb969028-primary.xml.gz    -rw-r--r-- 1 root root 1158 Mar 18 08:54 f34cbfd9e5608e8402041e98100f853e913f3df04d6946874c73ba31a78969ba-filelists.sqlite.bz2    -rw-r--r-- 1 root root 2969 Mar 18 08:54 repomd.xml    [root@warehouse backup]# </code></pre></div></figure><p>3、测试连接（本地版本）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、备份系统所有的yum源[root@warehouse yum.repos.d]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;[root@warehouse yum.repos.d]# mkdir backup1[root@warehouse yum.repos.d]# mv *.repo backup1[root@warehouse yum.repos.d]# vim local.repo[local]name&#x3D;&quot;This is xxx&quot;baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;backupgpgcheck&#x3D;0enabled&#x3D;1# 清理yum缓存[root@warehouse ~]# yum clean all[root@warehouse ~]# rm -rf &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7&#x2F;*# 生成新的yum缓存[root@warehouse ~]# yum makecache# 测试连接[root@warehouse yum.repos.d]# rpm -e mariadb[root@warehouse yum.repos.d]# rpm -ql mariadbpackage mariadb is not installed[root@warehouse yum.repos.d]# yum install mariadb</code></pre></div></figure><p>4、测试连接（远程版本）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#########################  yum仓库机器上执行  ###################################1、备份系统所有的yum源[root@warehouse yum.repos.d]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;[root@warehouse yum.repos.d]# mkdir local[root@warehouse yum.repos.d]# mv *.repo local2、安装远程访问软件[root@warehouse yum.repos.d]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;[root@warehouse yum.repos.d]# mv backup1&#x2F;*  .[root@warehouse yum.repos.d]# yum install vsftpd -y[root@warehouse yum.repos.d]# systemctl enable --now vsftpd Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;vsftpd.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vsftpd.service.3、配置系统yum仓库[root@warehouse yum.repos.d]# cd &#x2F;var&#x2F;ftp[root@warehouse ftp]# mkdir yum_warehouse4、将软件包复制到yum仓库目录[root@warehouse ftp]# cp -rp &#x2F;backup&#x2F;* &#x2F;var&#x2F;ftp&#x2F;yum_warehouse&#x2F;[root@warehouse ftp]# ll yum_warehouse&#x2F;total 8968-rw-r--r-- 1 root root 9175948 Oct 15 02:55 mariadb-5.5.68-1.el7.x86_64.rpmdrwxr-xr-x 2 root root    4096 Mar 18 08:54 repodata5、建立yum软件包依赖关系[root@warehouse ftp]# createrepo &#x2F;var&#x2F;ftp&#x2F;yum_warehouse&#x2F;#########################  yum测试机器上执行  ###################################1、本机测试网络连接    1、备份系统所有的yum源    [root@warehouse ftp]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;    [root@warehouse yum.repos.d]# mv *.repo backup1    [root@warehouse yum.repos.d]# vim local.repo    [root@warehouse yum.repos.d]# cat local.repo     [local-ftp]    name&#x3D;&quot;This is ftp server&quot;    baseurl&#x3D;ftp:&#x2F;&#x2F;172.16.1.30&#x2F;yum_warehouse    gpgcheck&#x3D;0    enabled&#x3D;1    # 清理yum缓存    [root@warehouse ~]# yum clean all    [root@warehouse ~]# rm -rf &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7&#x2F;*    # 生成新的yum缓存    [root@warehouse ~]# yum makecache    # 测试连接    [root@warehouse yum.repos.d]# rpm -e mariadb    [root@warehouse yum.repos.d]# rpm -ql mariadb    package mariadb is not installed    [root@warehouse yum.repos.d]# yum install mariadb2、yum测试机器执行1、备份yum仓库内容[root@yum-test ~]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;    [root@yum-test yum.repos.d]# mkdir backup1    [root@yum-test yum.repos.d]# mv *.repo backup1    [root@yum-test yum.repos.d]# ll    total 0    drwxr-xr-x. 2 root root 187 Mar  4 09:55 backup    drwxr-xr-x  2 root root 220 Mar 18 09:20 backup1    [root@yum-test yum.repos.d]#         2、编写本地yum源配置文件    [root@yum-test yum.repos.d]# vim local.repo    [root@yum-test yum.repos.d]# cat local.repo     [loacl-ftp-30]    name&#x3D;&quot;This is 30 ftp server&quot;    baseurl&#x3D;ftp:&#x2F;&#x2F;172.16.1.30&#x2F;yum_warehouse    gpgcheck&#x3D;0    enabled&#x3D;1        3、清理yum缓存    [root@yum-test yum.repos.d]# yum clean all    [root@yum-test yum.repos.d]# rm -rf &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7&#x2F;*        4、生成yum缓存    [root@yum-test yum.repos.d]# yum makecache        5、测试安装    [root@yum-test yum.repos.d]# yum install mariadb</code></pre></div></figure><p>4、同步远程yum仓库内容到本机</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、安装华为云镜像仓库[root@warehouse yum.repos.d]# rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*[root@warehouse yum.repos.d]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;repository&#x2F;conf&#x2F;CentOS-7-reg.repo2、生成yum缓存[root@warehouse yum.repos.d]# yum clean all[root@warehouse yum.repos.d]# rm -rf &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7&#x2F;*[root@warehouse yum.repos.d]# yum makecache3、同步华为云镜像站软件包到本地yum仓库[root@warehouse ftp]# yum install yum-utils -y[root@warehouse ftp]# reposync -r (仓库名称：yum repolist)4、建立依赖关系[root@warehouse ftp]# createrepo base5、测试    [loacl-ftp-30]    name&#x3D;&quot;This is 30 ftp server&quot;    baseurl&#x3D;ftp:&#x2F;&#x2F;172.16.1.30&#x2F;base    gpgcheck&#x3D;0    enabled&#x3D;1</code></pre></div></figure><p><img src="/.%5Cassets%5Cimage-20210318112338781.png" alt="image-20210318112338781"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--netstat使用</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day18-netstat%E4%BD%BF%E7%94%A8/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day18-netstat%E4%BD%BF%E7%94%A8/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>1、netstat</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netstat主要用来查询系统端口相关问题注：要使用netstat，需要安装yum install -y net-tools# netstat常用参数-t : 打印tcp链接的进程-u : 打印UDP链接的进程-l : 监听-p : 打印进程的PID-n : 不反解，不将ip地址解析成域名同时不将端口解析成对应的协议名称netstat -nutlp</code></pre></div></figure><p>2、分区</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看系统磁盘[root@localhost ~]# lsblk NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda               8:0    0   20G  0 disk ├─sda1            8:1    0    1G  0 part &#x2F;boot└─sda2            8:2    0   19G  0 part   ├─centos-root 253:0    0   18G  0 lvm  &#x2F;  └─centos-swap 253:1    0    1G  0 lvm  [SWAP]sdb               8:16   0   40G  0 disk sdc               8:32   0  3.9T  0 disk # 分区[root@localhost ~]# fdisk &#x2F;dev&#x2F;sdb n : 新建一个分区p : 查看分区情况m ：查看帮助d : 删除分区w ；保存分区修改内容</code></pre></div></figure><p>3、使用文件系统的流程</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、装硬盘2、查看当前系统硬盘[root@localhost a]# lsblk NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda               8:0    0   20G  0 disk ├─sda1            8:1    0    1G  0 part &#x2F;boot└─sda2            8:2    0   19G  0 part   ├─centos-root 253:0    0   18G  0 lvm  &#x2F;  └─centos-swap 253:1    0    1G  0 lvm  [SWAP]sdb               8:16   0   40G  0 disk sdc               8:32   0  3.9T  0 disk sr0              11:0    1  4.3G  0 rom  3、分区2TB 以下的硬盘，使用MBR分区2TB 以上的硬盘，使用GPT分区fdisk &#x2F;dev&#x2F;sdb4、格式化分区（将分区做成文件系统）mkfs.xfs &#x2F;dev&#x2F;sdb15、挂载分区mount &#x2F;dev&#x2F;sdb1  &#x2F;a6、检测df-h : 显示硬盘大小单位# 注：挂载哪个硬盘则显示对应硬盘里面的内容</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--dd与文件系统备份</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day20-dd%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day20-dd%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>1、dd命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;500M count&#x3D;1  if : 从哪里读文件of : 写入到哪里bs : 写入500Mcount : 写一块</code></pre></div></figure><p>2、模拟文件系统出问题</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、直接向硬盘中写数据，不能测试向分区写数据2、卸载之后重新挂载[root@localhost ~]# mount &#x2F;dev&#x2F;sdc1 &#x2F;root&#x2F;testmount: mount &#x2F;dev&#x2F;sdc1 on &#x2F;root&#x2F;test failed: Structure needs cleaning3、对文件系统进行修复xfs_repair [磁盘或分区路径]注： xfs_repair修改硬盘之后，硬盘数据丢失，所以对重要的数据要进行数据备份</code></pre></div></figure><p>3、文件系统的备份与恢复</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">备份：另外在保存一份恢复：将以前保存的数据进行还原touch 1.txtecho aaaa &gt; 1.txtcp  1.txt   2.txtrm 1.txtcp 2.txt 1.txt1.log   1T &#x3D; 1024G全量备份和增量备份全量备份：将需要备份的文件全部复制一份增量备份：在原来备份基础上，把新增数据重新备份一份备份与恢复的命令xfsdump : 备份的命令xfsrestore  : 恢复的命令# 备份的步骤1、安装备份命令[root@localhost test]# yum install xfsdump -y2、备份的等级0  全量备份1 ~ 9 增量备份（等级）3、备份的参数-L ：记录每次备份的地方-M ：注释，此次备份的注释-l ：指定备份的等级-f ：备份的文件名称-I ：查看备份信息4、备份的条件（限制）1、必须使用root权限2、只能备份已经挂载的内容3、只能备份xfs文件系统4、只能够用xfsrestore来恢复5、备份的命令格式xfsdump [参数] 备份路径xfsdump -L sdb1_bak -M &quot;sbd1_from_xxx&quot; -l 0 -f sdb1_from_bak_1 &#x2F;root&#x2F;oldboy6、数据恢复xfsrestore7、恢复数据的参数-f : 指定备份的文件路径8、恢复的格式xfsrestore [参数] 恢复的路径[root@localhost oldboy]# xfsrestore -f &#x2F;root&#x2F;sdb1_from_bak_3 &#x2F;root&#x2F;oldboy&#x2F;</code></pre></div></figure><p>4、LVM</p><figure><div class="code-wrapper"><pre class="line-numbers language-bsah" data-language="bsah"><code class="language-bsah">1、什么是lvm你如何保证你的硬盘空间恰好够用？如果你的硬盘你够用了怎么扩容？LVM是文件系统管理工具&#x2F;root&#x2F;oldboy ---&gt;  lv[5G]&#x2F;root&#x2F;oldboy ---&gt;  lv[3G]2、LVM的优点1、可以动态扩容与缩容2、可以将新增加的硬盘添加到VG存储池3、可以突破物理存储卷的限制3、使用lvm1、安装lvm软件包yum install lvm2 -y2、将磁盘交给pvpvreate [磁盘|磁盘分区]3、查看pvpvspvscan4、创建vgvgcreate [vg名称] [pv路径]5、查看vg6、创建lvm逻辑卷（lv）-L ： 创建逻辑卷的大小-n : 逻辑卷的名字lvcreate [参数] 逻辑卷名称7、制作文件系统mkfs.xfs &#x2F;dev&#x2F;vg1&#x2F;xxx8、挂载文件系统mount [lv的路径] [挂载点的路径]</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--磁盘分区</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day19-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/01_%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day19-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/01_%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、磁盘分区方案"><a href="#一、磁盘分区方案" class="headerlink" title="一、磁盘分区方案"></a>一、磁盘分区方案</h2><h3 id="1-1-MBR与GPT介绍"><a href="#1-1-MBR与GPT介绍" class="headerlink" title="1.1 MBR与GPT介绍"></a>1.1 MBR与GPT介绍</h3><p>Linux中磁盘分区有两种方案</p><ul><li><strong>MBR</strong>（主引导记录）</li><li><strong>GPT</strong>（GUID分区表）</li></ul><p>**<font color='blue'>MBR分区方案</font>**的特点（支持的磁盘容量&lt;&#x3D;2T）：</p><ol><li>最多支持四个主分区 </li><li>在Linux上使用扩展分区和逻辑分区最多可以创建15个分区， </li><li>由于分区中的数据以32位存储，使用MBR分区是最大支持2T空间。 </li><li>用fdisk管理工具来创建MBR分区</li></ol><p>**<font color='red'>GPT分区方案</font>**的特点（支持的磁盘容量&gt;2T）：</p><ol><li>是UEFI标准的一部分，主板必须要支持UEFI标准 </li><li>GPT分区列表支持最大128PB(1PB&#x3D;1024TB) </li><li>可以定义128个分区 </li><li>没有主分区，扩展分区和逻辑分区的概念，所有分区都能格式化 </li><li>gdisk和parted管理工具可以创建GPT分区</li></ol><h3 id="1-2-MBR与GTP的区别"><a href="#1-2-MBR与GTP的区别" class="headerlink" title="1.2 MBR与GTP的区别"></a>1.2 MBR与GTP的区别</h3><table><thead><tr><th>对比项</th><th>MBR</th><th>GPT</th></tr></thead><tbody><tr><td>新旧度</td><td>旧</td><td>新</td></tr><tr><td>支持的硬盘容量大小</td><td>最大2TB</td><td>支持2T以上</td></tr><tr><td>分区计数</td><td>最多支持4个主分区或3个主分区一个扩展分区</td><td>最多支持128个分区,部分主分区、扩展分区</td></tr><tr><td>安全功能</td><td>不提供任何安全功能</td><td>支持CRC32校验和机制</td></tr></tbody></table><h2 id="二、分区工具使用"><a href="#二、分区工具使用" class="headerlink" title="二、分区工具使用"></a>二、分区工具使用</h2><h3 id="2-1-MBR分区工具fdisk"><a href="#2-1-MBR分区工具fdisk" class="headerlink" title="2.1 MBR分区工具fdisk"></a>2.1 MBR分区工具fdisk</h3><h3 id="2-2-GPT分区工具gdisk"><a href="#2-2-GPT分区工具gdisk" class="headerlink" title="2.2 GPT分区工具gdisk"></a>2.2 GPT分区工具gdisk</h3><h3 id="2-3-GPT分区工具parted"><a href="#2-3-GPT分区工具parted" class="headerlink" title="2.3 GPT分区工具parted"></a>2.3 GPT分区工具parted</h3><p>​parted用于对磁盘（或RAID磁盘）进行分区及管理，与fdisk分区工具相比，支持2TB以上的磁盘分区，并且允许调整分区的大小，<font color='red'>支持命令行方式或交互式方式</font>，常用命令如下：</p><table><thead><tr><th>parted交互命令</th><th>说 明</th></tr></thead><tbody><tr><td>check NUMBER</td><td>做一次简单的文件系统检测</td></tr><tr><td>cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER</td><td>复制文件系统到另一个分区</td></tr><tr><td>help [COMMAND]</td><td>显示所有的命令帮助</td></tr><tr><td>mklabel,mktable LABEL-TYPE</td><td>创建新的磁盘卷标（分区表）</td></tr><tr><td>mkfs NUMBER FS-TYPE</td><td>在分区上建立文件系统</td></tr><tr><td>mkpart PART-TYPE [FS-TYPE] START END</td><td>创建一个分区</td></tr><tr><td>mkpartfs PART-TYPE FS-TYPE START END</td><td>创建分区，并建立文件系统</td></tr><tr><td>move NUMBER START END</td><td>移动分区</td></tr><tr><td>name NUMBER NAME</td><td>给分区命名</td></tr><tr><td>print [devices|free|list,all|NUMBER]</td><td>显示分区表、活动设备、空闲空间、所有分区</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>rescue START END</td><td>修复丢失的分区</td></tr><tr><td>resize NUMBER START END</td><td>修改分区大小</td></tr><tr><td>rm NUMBER</td><td>删除分区</td></tr><tr><td>select DEVICE</td><td>选择需要编辑的设备</td></tr><tr><td>set NUMBER FLAG STATE</td><td>改变分区标记</td></tr><tr><td>toggle [NUMBER [FLAG]]</td><td>切换分区表的状态</td></tr><tr><td>unit UNIT</td><td>设置默认的单位</td></tr><tr><td>Version</td><td>显示版本</td></tr></tbody></table><blockquote><p>关于mkpart与PART-TYPE（FS-TYPE）的解释：</p><p>Make a part-type partition for filesystem fs-type (if specified), beginning at start and ending at end (by default in megabytes).  fs-type can  be  one  of  “btrfs”,  “ext2”, “ext3”, “ext4”, “fat16”, “fat32”, “hfs”, “hfs+”, “linux-swap”, “ntfs”, “reiserfs”, or “xfs”.  part-type should be one of “primary”, “logical”, or “extended”.</p></blockquote><h4 id="2-3-1-使用parted"><a href="#2-3-1-使用parted" class="headerlink" title="2.3.1 使用parted"></a>2.3.1 使用parted</h4><h4 id="2-3-1-1-列出所有块设备分区情况"><a href="#2-3-1-1-列出所有块设备分区情况" class="headerlink" title="2.3.1.1 列出所有块设备分区情况"></a>2.3.1.1 列出所有块设备分区情况</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看当前有哪些块设备[root@lb01 ~]# lsblkNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda      8:0    0   50G  0 disk├─sda1   8:1    0    1G  0 part &#x2F;boot├─sda2   8:2    0    2G  0 part [SWAP]└─sda3   8:3    0   47G  0 part &#x2F;sdb      8:16   0   10G  0 disksr0     11:0    1  792M  0 rom# 查看分区情况[root@lb01 ~]# parted -lModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sda: 53.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size    Type     File system     Flags 1      1049kB  1075MB  1074MB  primary  xfs             boot 2      1075MB  3223MB  2149MB  primary  linux-swap(v1) 3      3223MB  53.7GB  50.5GB  primary  xfsError: &#x2F;dev&#x2F;sdb: unrecognised disk label# sdb还没有分区Model: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: unknownDisk Flags:Warning: Unable to open &#x2F;dev&#x2F;sr0 read-write (Read-only file system).  &#x2F;dev&#x2F;sr0has been opened read-only.Model: NECVMWar VMware IDE CDR10 (scsi)Disk &#x2F;dev&#x2F;sr0: 830MBSector size (logical&#x2F;physical): 2048B&#x2F;2048BPartition Table: msdosDisk Flags:Number  Start  End     Size    Type     File system  Flags 2      885kB  37.7MB  36.8MB  primary</code></pre></div></figure><h4 id="2-3-1-2-创建分区"><a href="#2-3-1-2-创建分区" class="headerlink" title="2.3.1.2 创建分区"></a>2.3.1.2 创建分区</h4><blockquote><p>案例：在&#x2F;dev&#x2F;sdb中创建一个1GB的分区</p></blockquote><p>a、命令行方式，创建一个主分区</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 转换为MBR分区方案msdos, GPT方案为gpt[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb mklabel msdosInformation: You may need to update &#x2F;etc&#x2F;fstab.# 创建主分区[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb mkpart primary ext4 0GB 1GB  # 把1GB换成100%就是分完剩余空间Information: You may need to update &#x2F;etc&#x2F;fstab.[root@lb01 ~]# lsblkNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda      8:0    0   50G  0 disk├─sda1   8:1    0    1G  0 part &#x2F;boot├─sda2   8:2    0    2G  0 part [SWAP]└─sda3   8:3    0   47G  0 part &#x2F;sdb      8:16   0   10G  0 disk└─sdb1   8:17   0  953M  0 partsr0     11:0    1  792M  0 rom</code></pre></div></figure><p>b、再用交互方式，继续创建一个主分区</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# partedGNU Parted 3.1Using &#x2F;dev&#x2F;sdaWelcome to GNU Parted! Type &#39;help&#39; to view a list of commands.(parted) select &#x2F;dev&#x2F;sdb # 选择块设备Using &#x2F;dev&#x2F;sdb(parted) mkpart# 新建分区Partition type?  primary&#x2F;extended? primaryFile system type?  [ext2]? ext4Start? 1GBEnd? 2GB</code></pre></div></figure><p>c、扩展分区与逻辑分区的创建</p><blockquote><p>扩展分区最多只有一个，再创建会提示选择primary&#x2F;logical</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(parted) select &#x2F;dev&#x2F;sdbUsing &#x2F;dev&#x2F;sdb(parted) printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size    Type      File system  Flags 1      1049kB  1000MB  999MB   primary   ext4 2      1000MB  4000MB  3000MB  extended               lba# 给扩展分区2创建一个逻辑分区（使用范围只能在扩展分区2的范围内）(parted) mkpart logical 1GB 2GB(parted) printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size    Type      File system  Flags 1      1049kB  1000MB  999MB   primary   ext4 2      1000MB  4000MB  3000MB  extended               lba 5      1001MB  2000MB  998MB   logical# 给扩展分区2再创建一个逻辑分区(parted) mkpart logical 2GB 3GB(parted) printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size    Type      File system  Flags 1      1049kB  1000MB  999MB   primary   ext4 2      1000MB  4000MB  3000MB  extended               lba 5      1001MB  2000MB  998MB   logical 6      2001MB  3000MB  999MB   logical</code></pre></div></figure><h4 id="2-3-1-3-查看分区"><a href="#2-3-1-3-查看分区" class="headerlink" title="2.3.1.3 查看分区"></a>2.3.1.3 查看分区</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(parted) print # 打印分区Model: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size   Type     File system  Flags 1      1049kB  1000MB  999MB  primary 2      1000MB  2000MB  999MB  primary  (parted) print free # 查看剩余空间Model: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size    Type     File system  Flags        32.3kB  1049kB  1016kB           Free Space 1      1049kB  1000MB  999MB   primary 2      1000MB  2000MB  999MB   primary        2000MB  10.7GB  8738MB           Free Space</code></pre></div></figure><h4 id="2-3-1-4-调整分区大小"><a href="#2-3-1-4-调整分区大小" class="headerlink" title="2.3.1.4 调整分区大小"></a>2.3.1.4 调整分区大小</h4><blockquote><p>将分区2从1GB扩展到2GB</p><p>PS：v2.4之后的版本，resize命令已经移除，更新到3.1-32版本有resizepart</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size   Type     File system  Flags 1      1049kB  1000MB  999MB  primary 2      1000MB  2000MB  999MB  primary# 调整分区2的大小为2GB[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb resizepart 2 3GB(3GB是指END位置，即使用1GB-3GB的空间，共2GB)Information: You may need to update &#x2F;etc&#x2F;fstab.[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size    Type     File system  Flags 1      1049kB  1000MB  999MB   primary 2      1000MB  3000MB  2000MB  primary  # 如果已经格式化并挂载使用，需要重新调整文件系统大小 [root@lb01 ~]# resize2fs &#x2F;dev&#x2F;sdb2</code></pre></div></figure><blockquote><p>缩小分区大小会怎样？将提示有数据丢失的风险</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb resizepart 2 2GBWarning: Shrinking a partition can cause data loss, are you sure you want to continue?Yes&#x2F;No?</code></pre></div></figure><h4 id="2-3-1-5-删除分区"><a href="#2-3-1-5-删除分区" class="headerlink" title="2.3.1.5 删除分区"></a>2.3.1.5 删除分区</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size    Type     File system  Flags 1      1049kB  1000MB  999MB   primary 2      1000MB  4000MB  3000MB  primary  ext4[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb rm 2   &#x2F;&#x2F; 删除2号分区，因为已挂载，会提示要先卸载Error: Partition &#x2F;dev&#x2F;sdb2 is being used. You must unmount it before you modify it with Parted.[root@lb01 ~]# umount &#x2F;dev&#x2F;sdb2[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb rm 2 &#x2F;&#x2F; 删除成功Information: You may need to update &#x2F;etc&#x2F;fstab.[root@lb01 ~]# print-bash: print: command not found[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size   Type     File system  Flags 1      1049kB  1000MB  999MB  primary</code></pre></div></figure><h4 id="2-3-1-6-设置-更改分区标志"><a href="#2-3-1-6-设置-更改分区标志" class="headerlink" title="2.3.1.6 设置&#x2F;更改分区标志"></a>2.3.1.6 设置&#x2F;更改分区标志</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb set 1 lvm onInformation: You may need to update &#x2F;etc&#x2F;fstab.[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start   End     Size   Type     File system  Flags 1      1049kB  1000MB  999MB  primary               lvm</code></pre></div></figure><p>查看有哪些标志可以设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# partedGNU Parted 3.1Using &#x2F;dev&#x2F;sdaWelcome to GNU Parted! Type &#39;help&#39; to view a list of commands.(parted) help set  set NUMBER FLAG STATE                    change the FLAG on partition NUMBER        NUMBER is the partition number used by Linux.  On MS-DOS disk labels, the primary partitions number from 1 to 4, logical partitions from 5 onwards.        FLAG is one of: boot, root, swap, hidden, raid, lvm, lba, hp-service, palo, prep, msftres, bios_grub, atvrecv, diag, legacy_boot        STATE is one of: on, off</code></pre></div></figure><h4 id="2-3-16-GPT分区方案下的NAME标签"><a href="#2-3-16-GPT分区方案下的NAME标签" class="headerlink" title="2.3.16 GPT分区方案下的NAME标签"></a>2.3.16 GPT分区方案下的NAME标签</h4><p>GPT分区的print</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: gptDisk Flags:Number  Start  End  Size  File system  Name  Flags</code></pre></div></figure><p>MBR分区的print</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb mklabel msdosWarning: The existing disk label on &#x2F;dev&#x2F;sdb will be destroyed and all data on this disk will be lost. Do you want to continue?Yes&#x2F;No? YesInformation: You may need to update &#x2F;etc&#x2F;fstab.[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: msdosDisk Flags:Number  Start  End  Size  Type  File system  Flags</code></pre></div></figure><blockquote><p><strong><font color='red'>可见GPT标志中多了一个Name标签</font></strong></p></blockquote><p>使用的时候GPT分区方式可以指定分区名，不用指定主分区、扩展分区这些类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb mkpart BOOT 0GB 1GBInformation: You may need to update &#x2F;etc&#x2F;fstab.[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb printModel: VMware, VMware Virtual S (scsi)Disk &#x2F;dev&#x2F;sdb: 10.7GBSector size (logical&#x2F;physical): 512B&#x2F;512BPartition Table: gptDisk Flags:Number  Start   End     Size   File system  Name  Flags 1      1049kB  1000MB  999MB  xfs          BOOT</code></pre></div></figure><p>但是MBR就不能</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb mkpart BOOT 0GB 1GBparted: invalid token: BOOTPartition type?  primary&#x2F;extended?[root@lb01 ~]# parted &#x2F;dev&#x2F;sdb mkpart primary BOOT 0GB 1GBparted: invalid token: BOOTFile system type?  [ext2]?</code></pre></div></figure><h2 id="三、磁盘挂载"><a href="#三、磁盘挂载" class="headerlink" title="三、磁盘挂载"></a>三、磁盘挂载</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、开机自动挂载开机自动执行：&#x2F;etc&#x2F;rc.localchmod +x &#x2F;etc&#x2F;ec.localecho &quot;mount &#x2F;dev&#x2F;sdc1 &#x2F;root&#x2F;test&quot; &gt;&gt; &#x2F;etc&#x2F;rc.local2、修改配置文件 &#x2F;etc&#x2F;fstab&#x2F;dev&#x2F;sdc100     &#x2F;opt    xfs         defaults   0      0设备挂载点  文件系统类型   挂载类型  是否备份  是否检测UUID&#x3D;1327e665-44b3-4223-a93b-69c36ec602f9   &#x2F;root&#x2F;oldboy  xfs   defaults 0 0 &#x2F;dev&#x2F;sdc100  等价于  UUID3、查询设备UUID[root@localhost ~]# blkid &#x2F;dev&#x2F;sdc1: UUID&#x3D;&quot;b5797ad6-9b98-452c-8962-fa12f6590fa6&quot; TYPE&#x3D;&quot;xfs&quot; PARTLABEL&#x3D;&quot;Linux filesystem&quot;</code></pre></div></figure><h2 id="四、创建SWAP分区"><a href="#四、创建SWAP分区" class="headerlink" title="四、创建SWAP分区"></a>四、创建SWAP分区</h2><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">1、创建一个硬盘分区2、制作swap分区mkswap &#x2F;dev&#x2F;sdb33、激活swapswapon &#x2F;dev&#x2F;sdb34、关闭swapswapoff 5、自动挂载5.1、        echo &quot;mkswap &#x2F;dev&#x2F;sdb3&quot; &gt;&gt; &#x2F;etc&#x2F;rc.local        echo &quot;swapon &#x2F;dev&#x2F;sdb3&quot; &gt;&gt; &#x2F;etc&#x2F;rc.local5.2、echo &quot;&#x2F;dev&#x2F;sdb3  swap  swap  defaults 0  0&quot; &gt;&gt; &#x2F;etc&#x2F;fstab</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--linux信号</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day17-Linux%E4%BF%A1%E5%8F%B7/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day17-Linux%E4%BF%A1%E5%8F%B7/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>1、设置进程的nice值</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 设置进程的优先级nice -n -11 bash test.sh-n ： 设置优先级普通用户：（0~19）超级用户：（-20~19）# 给指定进程设置优先级renice [设置优先级] pid</code></pre></div></figure><p>2、Linux系统信号</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">中断信号ctrl + cctrl + zINT(2) : kill -[信号名称|信号ID]　pidkill -SIGINT  PIDkill -INT     PIDkill -2       PID 退出信号:ctrl + d暂停信号：将进程暂停SIGTSTP（20）kill -20 PID kill -SIGTSTP PID kill -TSTP PID杀死进程信号SIGKILLkill -9 PID kill -SIGKILL PIDkill -KILL PID注：不能够被捕捉终止信号SIGTREMkill -15 PID kill -SIGTERM PIDkill -TERM PID注：优雅终止进程暂停和恢复信号SIGCONT : 恢复SIGSTOP ：暂停重载信号SIGHUP（1）1、nohup [执行的命令] &amp;后台启动，会在当前目录生成一个nohub.out文件，用于执行的命令的输出。2、setsid : 实际上开了一个孤儿进程3、（执行的命令&amp;）4、screen  开启一个子窗口</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--计划任务</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day21-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day21-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><p>1、Crontab表达式</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">*  *  *  * * 分 时 日 月 周每天的凌晨2点   02：00     00 02 * * *每月执行一次    00  00  01  * *每个月的一号零点零时零分同时这一天时星期六 00  00  01  *  6</code></pre></div></figure><p>2、系统级别的计划任务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、&#x2F;etc&#x2F;crontab2、如下的目录    &#x2F;etc&#x2F;cron.hourly&#x2F; # 系统定时任务每个⼩时运⾏这个⽬录⾥的内容    &#x2F;etc&#x2F;cron.daily&#x2F; # 系统定时任务每天运⾏这个⽬录⾥的内容    &#x2F;etc&#x2F;cron.weekly&#x2F; # 系统定时任务每周运⾏这个⽬录⾥的内容    &#x2F;etc&#x2F;cron.monthly&#x2F; # 系统定时任务每⽉运⾏这个⽬录⾥的内容</code></pre></div></figure><p>3、用户级别的计划任务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">crontab -e-e : 编辑计划任务-l : 查看计划任务# 注：用户级别的计划任务存放在&#x2F;var&#x2F;spool&#x2F;cron&#x2F;，不同的用户存放的计划任务是以其自己的名字命名的脚本</code></pre></div></figure><p>4、crontab语法</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1 3 500 00 1,3,5 * *# 1到5号00 00 1-5# 每几分钟，每几个小数，每几天0&#x2F;2  &#x2F;2 00 0&#x2F;2    00 &#x2F;200 00 0&#x2F;2   00 00 &#x2F;2</code></pre></div></figure><p>5、每3分钟同步一下系统时间</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--逻辑卷管理</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day19-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/02_%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day19-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/02_%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、LVM介绍"><a href="#一、LVM介绍" class="headerlink" title="一、LVM介绍"></a>一、LVM介绍</h2><p>​逻辑卷管理LVM是一个多才多艺的硬盘系统工具。无论在Linux或者其他类似的系统，都是非常的好用。传统分区使用固定大小分区，重新调整大小十分麻烦。但是，LVM可以创建和管理“逻辑”卷，而不是直接使用物理硬盘。可以让管理员弹性的管理逻辑卷的扩大缩小，操作简单，而不损坏已存储的数据。可以随意将新的硬盘添加到LVM，以直接扩展已经存在的逻辑卷。LVM并不需要重启就可以让内核知道分区的存在。</p><p>LVM使用分层结构，如下如所示：</p><p><img src="/02_%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86.assets/134408sa12dauefffyszfg.jpg" alt="img"></p><p>​图中顶部，首先是实际的物理磁盘及其划分的分区和其上的物理卷（PV）。一个或多个物理卷可以用来创建卷组（VG）。然后基于卷组可以创建逻辑卷（LV）。只要在卷组中有可用空间，就可以随心所欲的创建逻辑卷。文件系统就是在逻辑卷上创建的，然后可以在操作系统挂载和访问</p><h2 id="二、LVM使用"><a href="#二、LVM使用" class="headerlink" title="二、LVM使用"></a>二、LVM使用</h2><h3 id="2-1-磁盘准备"><a href="#2-1-磁盘准备" class="headerlink" title="2.1 磁盘准备"></a>2.1 磁盘准备</h3><p>加装两块硬盘，sdb-10G与sdc-5G</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lsblkNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda      8:0    0   50G  0 disk├─sda1   8:1    0    1G  0 part &#x2F;boot├─sda2   8:2    0    2G  0 part [SWAP]└─sda3   8:3    0   47G  0 part &#x2F;sdb      8:16   0   10G  0 disksdc      8:32   0    5G  0 disksr0     11:0    1  792M  0 rom</code></pre></div></figure><p>给sbd创建LVM分区</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# fdisk &#x2F;dev&#x2F;sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): n  # 新建分区Partition type:   p   primary (0 primary, 0 extended, 4 free)   e   extendedSelect (default p):Using default response pPartition number (1-4, default 1):First sector (2048-20971519, default 2048):Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): +2GPartition 1 of type Linux and of size 2 GiB is setCommand (m for help): t  # 将分区改为LVM分区Selected partition 1Hex code (type L to list all codes): L 0  Empty           24  NEC DOS         81  Minix &#x2F; old Lin bf  Solaris 1  FAT12           27  Hidden NTFS Win 82  Linux swap &#x2F; So c1  DRDOS&#x2F;sec (FAT- 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS&#x2F;sec (FAT- 3  XENIX usr       3c  PartitionMagic  84  OS&#x2F;2 hidden C:  c6  DRDOS&#x2F;sec (FAT- 4  FAT16 &lt;32M      40  Venix 80286     85  Linux extended  c7  Syrinx 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data 6  FAT16           42  SFS             87  NTFS volume set db  CP&#x2F;M &#x2F; CTOS &#x2F; . 7  HPFS&#x2F;NTFS&#x2F;exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access a  OS&#x2F;2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R&#x2F;O b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD&#x2F;OS          e4  SpeedStor c  W95 FAT32 (LBA) 52  CP&#x2F;M            a0  IBM Thinkpad hi eb  BeOS fs e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT f  W95 Ext&#39;d (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12&#x2F;16&#x2F;10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux&#x2F;PA-RISC b11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor14  Hidden FAT16 &lt;3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary16  Hidden FAT16    63  GNU HURD or Sys af  HFS &#x2F; HFS+      fb  VMware VMFS17  Hidden HPFS&#x2F;NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep1c  Hidden W95 FAT3 75  PC&#x2F;IX           be  Solaris boot    ff  BBT1e  Hidden W95 FAT1 80  Old MinixHex code (type L to list all codes): 8eChanged type of partition &#39;Linux&#39; to &#39;Linux LVM&#39;Command (m for help): pDisk &#x2F;dev&#x2F;sdb: 10.7 GB, 10737418240 bytes, 20971520 sectorsUnits &#x3D; sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytesDisk label type: dosDisk identifier: 0x0005122b   Device Boot      Start         End      Blocks   Id  System&#x2F;dev&#x2F;sdb1            2048     4196351     2097152   8e  Linux LVM</code></pre></div></figure><p>重复添加，再加一个3G，一个2G的分区，可见分区表如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# fdisk -l &#x2F;dev&#x2F;sdbDisk &#x2F;dev&#x2F;sdb: 10.7 GB, 10737418240 bytes, 20971520 sectorsUnits &#x3D; sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytesDisk label type: dosDisk identifier: 0x0005122b   Device Boot      Start         End      Blocks   Id  System&#x2F;dev&#x2F;sdb1            2048     4196351     2097152   8e  Linux LVM&#x2F;dev&#x2F;sdb2         4196352    10487807     3145728   8e  Linux LVM&#x2F;dev&#x2F;sdb3        10487808    14682111     2097152   8e  Linux LVM</code></pre></div></figure><h3 id="2-2-创建物理卷（PV）"><a href="#2-2-创建物理卷（PV）" class="headerlink" title="2.2 创建物理卷（PV）"></a>2.2 创建物理卷（PV）</h3><p>安装LVM工具</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# yum install lvm2 </code></pre></div></figure><p>将准备好的LVM分区生成为物理卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# pvcreate &#x2F;dev&#x2F;sdb1WARNING: ext4 signature detected on &#x2F;dev&#x2F;sdb1 at offset 1080. Wipe it? [y&#x2F;n]: y  Wiping ext4 signature on &#x2F;dev&#x2F;sdb1.  Physical volume &quot;&#x2F;dev&#x2F;sdb1&quot; successfully created.[root@lb01 ~]# pvcreate &#x2F;dev&#x2F;sdb2  Physical volume &quot;&#x2F;dev&#x2F;sdb2&quot; successfully created.[root@lb01 ~]# pvcreate &#x2F;dev&#x2F;sdb3  Physical volume &quot;&#x2F;dev&#x2F;sdb3&quot; successfully created.</code></pre></div></figure><p>查看物理卷信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# pvdisplay  &quot;&#x2F;dev&#x2F;sdb1&quot; is a new physical volume of &quot;2.00 GiB&quot;  --- NEW Physical volume ---  PV Name               &#x2F;dev&#x2F;sdb1  VG Name  PV Size               2.00 GiB  Allocatable           NO  PE Size               0  Total PE              0  Free PE               0  Allocated PE          0  PV UUID               YUHdrd-AH1x-ew0m-Mp9i-3GHp-S4zc-XxlDJM  &quot;&#x2F;dev&#x2F;sdb2&quot; is a new physical volume of &quot;3.00 GiB&quot;  --- NEW Physical volume ---  PV Name               &#x2F;dev&#x2F;sdb2  VG Name  PV Size               3.00 GiB  Allocatable           NO  PE Size               0  Total PE              0  Free PE               0  Allocated PE          0  PV UUID               wGDQvx-7zfs-g018-wqx4-Y8rh-1kWT-PnLuFu  &quot;&#x2F;dev&#x2F;sdb3&quot; is a new physical volume of &quot;2.00 GiB&quot;  --- NEW Physical volume ---  PV Name               &#x2F;dev&#x2F;sdb3  VG Name  PV Size               2.00 GiB  Allocatable           NO  PE Size               0  Total PE              0  Free PE               0  Allocated PE          0  PV UUID               fykcuR-jooY-WKbi-yM8j-7fQ5-mhnH-JCkXC8</code></pre></div></figure><p>补充：如何删除物理卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# pvremove &#x2F;dev&#x2F;sdb1</code></pre></div></figure><h3 id="2-3-创建卷组（VG）"><a href="#2-3-创建卷组（VG）" class="headerlink" title="2.3 创建卷组（VG）"></a>2.3 创建卷组（VG）</h3><p>将&#x2F;dev&#x2F;sdb{1,2,3}合并为卷组vg01</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# vgcreate vg01 &#x2F;dev&#x2F;sdb1 &#x2F;dev&#x2F;sdb2 &#x2F;dev&#x2F;sdb3</code></pre></div></figure><p>查看卷组信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# vgdisplay  --- Volume group ---  VG Name               vg01  System ID  Format                lvm2  Metadata Areas        3  Metadata Sequence No  1  VG Access             read&#x2F;write  VG Status             resizable  MAX LV                0  Cur LV                0  Open LV               0  Max PV                0  Cur PV                3  Act PV                3  VG Size               &lt;6.99 GiB  PE Size               4.00 MiB  Total PE              1789  Alloc PE &#x2F; Size       0 &#x2F; 0  Free  PE &#x2F; Size       1789 &#x2F; &lt;6.99 GiB  VG UUID               gzeouH-16qO-n6xv-V6VM-A9ep-eK6E-ODuIwU</code></pre></div></figure><p>补充：如何删除卷组</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# vgremove vg01  Volume group &quot;vg01&quot; successfully removed</code></pre></div></figure><h3 id="2-4-创建逻辑卷（LV）"><a href="#2-4-创建逻辑卷（LV）" class="headerlink" title="2.4 创建逻辑卷（LV）"></a>2.4 创建逻辑卷（LV）</h3><p>创建一个名为lv01，大小为100M的逻辑卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvcreate -L 100M -n lv01 vg01  Logical volume &quot;lv01&quot; created.</code></pre></div></figure><p>查看逻辑卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvdisplay  --- Logical volume ---  LV Path                &#x2F;dev&#x2F;vg01&#x2F;lv01  LV Name                lv01  VG Name                vg01  LV UUID                xFksnb-ENc2-mEo4-5gEb-yaJj-wP2c-oFuBeT  LV Write Access        read&#x2F;write  LV Creation host, time lb01, 2021-09-01 20:39:16 +0800  LV Status              available  # open                 0  LV Size                100.00 MiB  Current LE             25  Segments               1  Allocation             inherit  Read ahead sectors     auto  - currently set to     8192  Block device           253:0</code></pre></div></figure><p>补充：删除逻辑卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvremove &#x2F;dev&#x2F;vg01&#x2F;lv02Do you really want to remove active logical volume vg01&#x2F;lv02? [y&#x2F;n]: y  Logical volume &quot;lv02&quot; successfully removed</code></pre></div></figure><h3 id="2-5-逻辑卷挂载"><a href="#2-5-逻辑卷挂载" class="headerlink" title="2.5 逻辑卷挂载"></a>2.5 逻辑卷挂载</h3><p>格式化逻辑卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# mkfs.ext4 &#x2F;dev&#x2F;vg01&#x2F;lv01mke2fs 1.42.9 (28-Dec-2013)Filesystem label&#x3D;OS type: LinuxBlock size&#x3D;1024 (log&#x3D;0)Fragment size&#x3D;1024 (log&#x3D;0)Stride&#x3D;0 blocks, Stripe width&#x3D;0 blocks25688 inodes, 102400 blocks5120 blocks (5.00%) reserved for the super userFirst data block&#x3D;1Maximum filesystem blocks&#x3D;3368550413 block groups8192 blocks per group, 8192 fragments per group1976 inodes per groupSuperblock backups stored on blocks:        8193, 24577, 40961, 57345, 73729Allocating group tables: doneWriting inode tables: doneCreating journal (4096 blocks): doneWriting superblocks and filesystem accounting information: done</code></pre></div></figure><p>挂载逻辑卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# mkdir &#x2F;mnt&#x2F;test-lv01[root@lb01 ~]# mount &#x2F;dev&#x2F;vg01&#x2F;lv01 &#x2F;mnt&#x2F;test-lv01[root@lb01 ~]# df -hFilesystem             Size  Used Avail Use% Mounted on&#x2F;dev&#x2F;sda3               47G  1.9G   46G   4% &#x2F;devtmpfs               479M     0  479M   0% &#x2F;devtmpfs                  489M     0  489M   0% &#x2F;dev&#x2F;shmtmpfs                  489M  6.8M  482M   2% &#x2F;runtmpfs                  489M     0  489M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;dev&#x2F;sda1             1014M  119M  896M  12% &#x2F;boottmpfs                   98M     0   98M   0% &#x2F;run&#x2F;user&#x2F;0&#x2F;dev&#x2F;mapper&#x2F;vg01-lv01   93M  1.6M   85M   2% &#x2F;mnt&#x2F;test-lv01</code></pre></div></figure><h3 id="2-6-扩展逻辑卷"><a href="#2-6-扩展逻辑卷" class="headerlink" title="2.6 扩展逻辑卷"></a>2.6 扩展逻辑卷</h3><p>卸载逻辑卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# umount &#x2F;dev&#x2F;vg01&#x2F;lv01</code></pre></div></figure><p>将逻辑卷lv01调整为200M</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvresize -L 200M &#x2F;dev&#x2F;vg01&#x2F;lv01   Size of logical volume vg01&#x2F;lv01 changed from 100.00 MiB (25 extents) to 200.00 MiB (50 extents).  Logical volume vg01&#x2F;lv01 successfully resized.</code></pre></div></figure><p>检查磁盘错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# e2fsck -f &#x2F;dev&#x2F;vg01&#x2F;lv01e2fsck 1.42.9 (28-Dec-2013)Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary information&#x2F;dev&#x2F;vg01&#x2F;lv01: 11&#x2F;25688 files (9.1% non-contiguous), 8896&#x2F;102400 blocks</code></pre></div></figure><p>调整文件系统大小</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# resize2fs &#x2F;dev&#x2F;vg01&#x2F;lv01</code></pre></div></figure><p>查看逻辑卷信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvdisplay  --- Logical volume ---  LV Path                &#x2F;dev&#x2F;vg01&#x2F;lv01  LV Name                lv01  VG Name                vg01  LV UUID                svm5Xk-B8jZ-QhZw-egCm-x6b2-e5Jt-wvMi2F  LV Write Access        read&#x2F;write  LV Creation host, time lb01, 2021-09-01 20:41:53 +0800  LV Status              available  # open                 0  LV Size                200.00 MiB  Current LE             50  Segments               2  Allocation             inherit  Read ahead sectors     auto  - currently set to     8192  Block device           253:0  ...</code></pre></div></figure><p>重新挂载使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# !mountmount &#x2F;dev&#x2F;vg01&#x2F;lv01 &#x2F;mnt&#x2F;test-lv01[root@lb01 ~]# df -hFilesystem             Size  Used Avail Use% Mounted on&#x2F;dev&#x2F;sda3               47G  1.9G   46G   4% &#x2F;devtmpfs               479M     0  479M   0% &#x2F;devtmpfs                  489M     0  489M   0% &#x2F;dev&#x2F;shmtmpfs                  489M  6.8M  482M   2% &#x2F;runtmpfs                  489M     0  489M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;dev&#x2F;sda1             1014M  119M  896M  12% &#x2F;boottmpfs                   98M     0   98M   0% &#x2F;run&#x2F;user&#x2F;0&#x2F;dev&#x2F;mapper&#x2F;vg01-lv01  190M  1.6M  175M   1% &#x2F;mnt&#x2F;test-lv01</code></pre></div></figure><h3 id="2-7-缩减逻辑卷"><a href="#2-7-缩减逻辑卷" class="headerlink" title="2.7 缩减逻辑卷"></a>2.7 缩减逻辑卷</h3><p>卸载逻辑卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# umount &#x2F;dev&#x2F;vg01&#x2F;lv01</code></pre></div></figure><p>检查磁盘错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# e2fsck -f &#x2F;dev&#x2F;vg01&#x2F;lv01e2fsck 1.42.9 (28-Dec-2013)Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary information&#x2F;dev&#x2F;vg01&#x2F;lv01: 11&#x2F;49400 files (9.1% non-contiguous), 11884&#x2F;204800 blocks</code></pre></div></figure><p>缩减文件系统大小，更新ext4信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# resize2fs &#x2F;dev&#x2F;vg01&#x2F;lv01 100Mresize2fs 1.42.9 (28-Dec-2013)Resizing the filesystem on &#x2F;dev&#x2F;vg01&#x2F;lv01 to 102400 (1k) blocks.The filesystem on &#x2F;dev&#x2F;vg01&#x2F;lv01 is now 102400 blocks long.</code></pre></div></figure><p>完成后，减小逻辑卷大小</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvresize -L 100M &#x2F;dev&#x2F;vg01&#x2F;lv01  WARNING: Reducing active logical volume to 100.00 MiB.  THIS MAY DESTROY YOUR DATA (filesystem etc.)Do you really want to reduce vg01&#x2F;lv01? [y&#x2F;n]: y  Size of logical volume vg01&#x2F;lv01 changed from 200.00 MiB (50 extents) to 100.00 MiB (25 extents).  Logical volume vg01&#x2F;lv01 successfully resized.</code></pre></div></figure><p>查看逻辑卷信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvdisplay  --- Logical volume ---  LV Path                &#x2F;dev&#x2F;vg01&#x2F;lv01  LV Name                lv01  VG Name                vg01  LV UUID                svm5Xk-B8jZ-QhZw-egCm-x6b2-e5Jt-wvMi2F  LV Write Access        read&#x2F;write  LV Creation host, time lb01, 2021-09-01 20:41:53 +0800  LV Status              available  # open                 0  LV Size                100.00 MiB  Current LE             25  Segments               1  Allocation             inherit  Read ahead sectors     auto  - currently set to     8192  Block device           253:0  ...</code></pre></div></figure><p>挂载使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# !momount &#x2F;dev&#x2F;vg01&#x2F;lv01 &#x2F;mnt&#x2F;test-lv01[root@lb01 ~]# df -hFilesystem             Size  Used Avail Use% Mounted on&#x2F;dev&#x2F;sda3               47G  1.9G   46G   4% &#x2F;devtmpfs               479M     0  479M   0% &#x2F;devtmpfs                  489M     0  489M   0% &#x2F;dev&#x2F;shmtmpfs                  489M  6.8M  482M   2% &#x2F;runtmpfs                  489M     0  489M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;dev&#x2F;sda1             1014M  119M  896M  12% &#x2F;boottmpfs                   98M     0   98M   0% &#x2F;run&#x2F;user&#x2F;0&#x2F;dev&#x2F;mapper&#x2F;vg01-lv01   93M  1.6M   85M   2% &#x2F;mnt&#x2F;test-lv01</code></pre></div></figure><h3 id="2-8-VG增加一块磁盘"><a href="#2-8-VG增加一块磁盘" class="headerlink" title="2.8 VG增加一块磁盘"></a>2.8 VG增加一块磁盘</h3><p>新盘创建lvm分区</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# fdisk &#x2F;dev&#x2F;sdcWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0x05ff27fa.Command (m for help): nPartition type:   p   primary (0 primary, 0 extended, 4 free)   e   extendedSelect (default p):Using default response pPartition number (1-4, default 1):First sector (2048-10485759, default 2048):Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-10485759, default 10485759): +4GPartition 1 of type Linux and of size 4 GiB is setCommand (m for help): tSelected partition 1Hex code (type L to list all codes):Hex code (type L to list all codes): 8eChanged type of partition &#39;Linux&#39; to &#39;Linux LVM&#39;Command (m for help): pDisk &#x2F;dev&#x2F;sdc: 5368 MB, 5368709120 bytes, 10485760 sectorsUnits &#x3D; sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytesDisk label type: dosDisk identifier: 0x05ff27fa   Device Boot      Start         End      Blocks   Id  System&#x2F;dev&#x2F;sdc1            2048     8390655     4194304   8e  Linux LVM</code></pre></div></figure><p>创建物理卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# pvcreate &#x2F;dev&#x2F;sdc1  Physical volume &quot;&#x2F;dev&#x2F;sdc1&quot; successfully created.</code></pre></div></figure><p>扩容VG</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# vgextend vg01 &#x2F;dev&#x2F;sdc1  Volume group &quot;vg01&quot; successfully extended</code></pre></div></figure><p>查看VG信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# vgdisplay vg01  --- Volume group ---  VG Name               vg01  System ID  Format                lvm2  Metadata Areas        4  Metadata Sequence No  10  VG Access             read&#x2F;write  VG Status             resizable  MAX LV                0  Cur LV                2  Open LV               1  Max PV                0  Cur PV                4  Act PV                4  VG Size               10.98 GiB  PE Size               4.00 MiB  Total PE              2812  Alloc PE &#x2F; Size       50 &#x2F; 200.00 MiB  Free  PE &#x2F; Size       2762 &#x2F; &lt;10.79 GiB  VG UUID               2Tjzna-XmXI-9MQ7-zeyc-AARV-84r5-jyymkf</code></pre></div></figure><blockquote><p>PS：尽管我们使用一个单独的磁盘做示范，其实只要是‘8e’类型的磁盘分区都可以用来扩展卷组。</p></blockquote><p>在VG中创建LV，可以看到磁盘都用上了</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lb01 ~]# lvcreate -L 10G -n lv03 vg01  Logical volume &quot;lv03&quot; created.[root@lb01 ~]# lsblkNAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda             8:0    0   50G  0 disk├─sda1          8:1    0    1G  0 part &#x2F;boot├─sda2          8:2    0    2G  0 part [SWAP]└─sda3          8:3    0   47G  0 part &#x2F;sdb             8:16   0   10G  0 disk├─sdb1          8:17   0    2G  0 part│ ├─vg01-lv01 253:0    0  100M  0 lvm  &#x2F;mnt&#x2F;test-lv01│ ├─vg01-lv02 253:1    0  100M  0 lvm│ └─vg01-lv03 253:2    0   10G  0 lvm├─sdb2          8:18   0    3G  0 part│ └─vg01-lv03 253:2    0   10G  0 lvm└─sdb3          8:19   0    2G  0 part  └─vg01-lv03 253:2    0   10G  0 lvmsdc             8:32   0    5G  0 disk└─sdc1          8:33   0    4G  0 part  └─vg01-lv03 253:2    0   10G  0 lvmsr0            11:0    1  792M  0 rom</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运维之基础命令--防火墙与iptables</title>
    <link href="/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day22-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8Eiptables/iptables%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/06/01_%E8%BF%90%E7%BB%B4/01-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/day22-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8Eiptables/iptables%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="iptables使用手册"><a href="#iptables使用手册" class="headerlink" title="iptables使用手册"></a>iptables使用手册</h1><h2 id="一、简单实践"><a href="#一、简单实践" class="headerlink" title="一、简单实践"></a>一、简单实践</h2><blockquote><p>从信息查看、保存规则、清除规则、恢复规则、更改规则五个方面来学习。</p></blockquote><h3 id="1-1-信息查看"><a href="#1-1-信息查看" class="headerlink" title="1.1 信息查看"></a>1.1 信息查看</h3><p>查看现有规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@controller ~]# iptables -LChain INPUT (policy ACCEPT)target     prot opt source               destinationneutron-linuxbri-INPUT  all  --  anywhere             anywherenova-api-INPUT  all  --  anywhere             anywhereChain FORWARD (policy ACCEPT)target     prot opt source               destinationneutron-filter-top  all  --  anywhere             anywhereneutron-linuxbri-FORWARD  all  --  anywhere             anywherenova-filter-top  all  --  anywhere             anywherenova-api-FORWARD  all  --  anywhere             anywhere....</code></pre></div></figure><p>查看现有规则，显示主机ip和端口号，-n</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@controller ~]# iptables -L -nChain INPUT (policy ACCEPT)target     prot opt source               destinationneutron-linuxbri-INPUT  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0nova-api-INPUT  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT)target     prot opt source               destinationneutron-filter-top  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0neutron-linuxbri-FORWARD  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0nova-filter-top  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0nova-api-FORWARD  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....</code></pre></div></figure><blockquote><p>结果显示：</p><p>默认显示三条链的规则INPUT、FORWARD、OUTPUT，而且所有的规则都是默认接受的</p><p>每条链下面显示的信息是：</p><p>动作  协议 参数 源地址 目标地址</p></blockquote><p>显示详细信息，-v</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 11839 packets, 2842K bytes) pkts bytes target     prot opt in     out     source               destination11839 2842K neutron-linuxbri-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;012985 3090K nova-api-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    0     0 neutron-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 neutron-linuxbri-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-api-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....</code></pre></div></figure><blockquote><p>结果显示：</p><p>-v显示的内容比-L -n 显示的内容多了四个字段</p><p>pkts  规则匹配到的报文数量的多少</p><p>bytes 规则匹配到的报文内容量的大小</p><p>in   规则匹配到的流入的接口，*代表任意接口</p><p>out   规则匹配到的流出的接口</p></blockquote><p>显示规则的标号 –line-numbers</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@controller ~]# iptables -L -n -v --line-numbersChain INPUT (policy ACCEPT 13663 packets, 3221K bytes)num   pkts bytes target     prot opt in     out     source               destination1    13663 3221K neutron-linuxbri-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;02    14809 3469K nova-api-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)num   pkts bytes target     prot opt in     out     source               destination1        0     0 neutron-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;02        0     0 neutron-linuxbri-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;03        0     0 nova-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;04        0     0 nova-api-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....</code></pre></div></figure><p>打印规则命令，将防火墙的编写命令给我们打印出来，可以通过这种方式来学习规则的编写。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@controller ~]# iptables -S-P INPUT ACCEPT-P FORWARD ACCEPT-P OUTPUT ACCEPT-N neutron-filter-top-N neutron-linuxbri-FORWARD-N neutron-linuxbri-INPUT-N neutron-linuxbri-OUTPUT-N neutron-linuxbri-local-N neutron-linuxbri-scope-N neutron-linuxbri-sg-chain-N neutron-linuxbri-sg-fallback-N nova-api-FORWARD-N nova-api-INPUT-N nova-api-OUTPUT-N nova-api-local-N nova-filter-top-A INPUT -j neutron-linuxbri-INPUT-A INPUT -j nova-api-INPUT-A FORWARD -j neutron-filter-top-A FORWARD -j neutron-linuxbri-FORWARD-A FORWARD -j nova-filter-top-A FORWARD -j nova-api-FORWARD....</code></pre></div></figure><h3 id="1-2-保存规则"><a href="#1-2-保存规则" class="headerlink" title="1.2 保存规则"></a>1.2 保存规则</h3><blockquote><p>使用 iptables-save命令可以保存规则</p></blockquote><p>将当前的规则保存到文件中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@controller ~]# iptables-save &gt; iptables.rules[root@controller ~]# cat iptables.rules# Generated by iptables-save v1.4.21 on Wed Oct 20 09:22:53 2021*filter:INPUT ACCEPT [16785:3861723]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [16549:3883715]:neutron-filter-top - [0:0]:neutron-linuxbri-FORWARD - [0:0]:neutron-linuxbri-INPUT - [0:0]:neutron-linuxbri-OUTPUT - [0:0]:neutron-linuxbri-local - [0:0]:neutron-linuxbri-scope - [0:0]:neutron-linuxbri-sg-chain - [0:0]:neutron-linuxbri-sg-fallback - [0:0]:nova-api-FORWARD - [0:0]:nova-api-INPUT - [0:0]....</code></pre></div></figure><h3 id="1-3-清除规则"><a href="#1-3-清除规则" class="headerlink" title="1.3 清除规则"></a>1.3 清除规则</h3><p>清除单个规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先查看[root@controller ~]# iptables -L -n --line-numbersChain INPUT (policy ACCEPT)num  target     prot opt source               destination1    neutron-linuxbri-INPUT  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;02    nova-api-INPUT  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT)num  target     prot opt source               destination1    neutron-filter-top  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;02    neutron-linuxbri-FORWARD  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;03    nova-filter-top  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;04    nova-api-FORWARD  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....# 删除FORWARD的第2条规则[root@controller ~]# iptables -D FORWARD 2# 再次查看，删除成功[root@controller ~]# iptables -L -n --line-numbersChain INPUT (policy ACCEPT)num  target     prot opt source               destination1    neutron-linuxbri-INPUT  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;02    nova-api-INPUT  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT)num  target     prot opt source               destination1    neutron-filter-top  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;02    nova-filter-top  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;03    nova-api-FORWARD  all  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....# 如果不指定删除的序号，会报错[root@controller ~]# iptables -D FORWARDiptables: Bad rule (does a matching rule exist in that chain?).</code></pre></div></figure><p>清除规则计数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看原内容[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 3196 packets, 657K bytes) pkts bytes target     prot opt in     out     source               destination23118 5147K neutron-linuxbri-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;024264 5395K nova-api-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    0     0 neutron-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-api-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....# 清除规则计数 -Z[root@controller ~]# iptables -Z# 查看效果，pkts与bytes减少，即规则匹配到的报文数量与报文内容大小均减少，清除成功[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 58 packets, 11344 bytes) pkts bytes target     prot opt in     out     source               destination   58 11344 neutron-linuxbri-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0   58 11344 nova-api-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    0     0 neutron-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-api-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....</code></pre></div></figure><p>清除所有规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 清除默认规则[root@controller ~]# iptables -F# 清除自定义规则[root@controller ~]# iptables -X# 查看效果[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 424 packets, 84770 bytes) pkts bytes target     prot opt in     out     source               destinationChain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destinationChain OUTPUT (policy ACCEPT 398 packets, 83826 bytes) pkts bytes target     prot opt in     out     source               destination</code></pre></div></figure><h3 id="1-4-恢复规则"><a href="#1-4-恢复规则" class="headerlink" title="1.4 恢复规则"></a>1.4 恢复规则</h3><p>从备份文件恢复规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 从文件恢复[root@controller ~]# iptables-restore &lt; iptables.rules# 查看确认已恢复[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 268 packets, 46570 bytes) pkts bytes target     prot opt in     out     source               destination  268 46570 neutron-linuxbri-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0  268 46570 nova-api-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    0     0 neutron-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 neutron-linuxbri-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-api-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....</code></pre></div></figure><h3 id="1-5-更改规则"><a href="#1-5-更改规则" class="headerlink" title="1.5 更改规则"></a>1.5 更改规则</h3><p>可以从ACCEPT改为DROP</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看原规则[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 342 packets, 49890 bytes) pkts bytes target     prot opt in     out     source               destination 4455  836K neutron-linuxbri-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0 4455  836K nova-api-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    0     0 neutron-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 neutron-linuxbri-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-api-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....# -P 修改[root@controller ~]# iptables -P FORWARD DROP# 再次查看，FORWARD链修改DROP成功[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 38 packets, 5017 bytes) pkts bytes target     prot opt in     out     source               destination 4849  905K neutron-linuxbri-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0 4849  905K nova-api-INPUT  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0Chain FORWARD (policy DROP 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    0     0 neutron-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 neutron-linuxbri-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-filter-top  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 nova-api-FORWARD  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0....</code></pre></div></figure><blockquote><p>-P 更改的规则，使用 -F 不能自动还原</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;[root@controller ~]# iptables -F&gt;[root@controller ~]# iptables -L -n -v&gt;Chain INPUT (policy ACCEPT 36 packets, 6554 bytes)&gt;pkts bytes target     prot opt in     out     source               destination&gt;Chain FORWARD (policy DROP 0 packets, 0 bytes)&gt;pkts bytes target     prot opt in     out     source               destination&gt;....</code></pre></div></figure></blockquote><p>重启iptables服务后，可以使用系统所有默认规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 清除所有默认规则[root@controller ~]# iptables -F# 查看，没有默认规则[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 8 packets, 520 bytes) pkts bytes target     prot opt in     out     source               destinationChain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destinationChain OUTPUT (policy ACCEPT 4 packets, 448 bytes) pkts bytes target     prot opt in     out     source               destination # 重启iptables服务[root@controller ~]# systemctl restart iptables# 再次查看，新增了系统的默认规则[root@controller ~]# iptables -L -n -vChain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    6   432 ACCEPT     all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            state RELATED,ESTABLISHED    0     0 ACCEPT     icmp --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 ACCEPT     all  --  lo     *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0    0     0 ACCEPT     tcp  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            state NEW tcp dpt:22    0     0 REJECT     all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            reject-with icmp-host-prohibitedChain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination    0     0 REJECT     all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            reject-with icmp-host-prohibitedChain OUTPUT (policy ACCEPT 4 packets, 544 bytes) pkts bytes target     prot opt in     out     source               destination</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（一）基础命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>K8S系列(一)-安装K8S</title>
    <link href="/2021/07/08/01_%E8%BF%90%E7%BB%B4/05-K8S/K8S%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%AE%89%E8%A3%85K8S/"/>
    <url>/2021/07/08/01_%E8%BF%90%E7%BB%B4/05-K8S/K8S%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%AE%89%E8%A3%85K8S/</url>
    
    <content type="html"><![CDATA[<p>课程目录：</p><blockquote><p>第一部分：K8S概念和架构</p><p>第二部分：K8S安装</p><p>​kubeadm</p><p>​二进制</p><p>第三部分：K8S核心概念</p><p>POD </p><p>CONTROLLER</p><p>SERVICE</p><p>INGRESS</p><p>RABC</p><p>HELM</p><p>持久化存储</p><p>第四部分：集群监控平台</p><p>第五部分：从零开始搭建高可用K8S集群</p><p>第六部分：在集群环境中部署项目</p></blockquote><h2 id="一、K8S概念和架构"><a href="#一、K8S概念和架构" class="headerlink" title="一、K8S概念和架构"></a>一、K8S概念和架构</h2><h3 id="1-K8S概述和特性"><a href="#1-K8S概述和特性" class="headerlink" title="1 K8S概述和特性"></a>1 K8S概述和特性</h3><h4 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h4><ul><li>K8S是谷歌在2014年开发的容器化集群管理系统</li><li>使用K8S可以进行容器化应用部署</li><li>使用K8S利于应用扩展</li><li>K8S目标是让部署容器化应用更加简洁和高效</li></ul><p>容器化部署的好处：</p><h4 id="1-2-K8S的特性和优势"><a href="#1-2-K8S的特性和优势" class="headerlink" title="1.2 K8S的特性和优势"></a>1.2 K8S的特性和优势</h4><p>自动装箱：自动部署应用容器</p><p>自我修复（自愈能力）： </p><p>水平扩展：副本数量增加</p><p>服务发现（负载均衡）：通过Service实现，为多个副本对外提供统一的入口，节点调度负载均衡</p><p>滚动更新：</p><p>版本回退：</p><p>密钥配置管理：不需要重新构建镜像，可以部署和更新密钥和应用配置</p><p>存储编排：</p><p>批处理：</p><h3 id="2-K8S架构组件"><a href="#2-K8S架构组件" class="headerlink" title="2 K8S架构组件"></a>2 K8S架构组件</h3><h3 id="3-K8S核心概念"><a href="#3-K8S核心概念" class="headerlink" title="3 K8S核心概念"></a>3 K8S核心概念</h3><p>3.1 Pod</p><p>3.2 Controller</p><p>3.3 Service</p><h2 id="二、K8S安装"><a href="#二、K8S安装" class="headerlink" title="二、K8S安装"></a>二、K8S安装</h2><blockquote><p>master  192.168.44.146</p><p>node1192.168.44.145</p><p>node2192.168.44.144</p></blockquote><h3 id="1-kubeadm安装"><a href="#1-kubeadm安装" class="headerlink" title="1 kubeadm安装"></a>1 kubeadm安装</h3><h3 id="2-二进制安装"><a href="#2-二进制安装" class="headerlink" title="2 二进制安装"></a>2 二进制安装</h3><hr><p>生产环境通用需求：</p><p>​服务的自动发现和负载均衡</p><p>​自愈</p><p>​一键升级和回滚</p><p>​水平扩展（弹性伸缩） </p><h3 id="1-容器管理平台"><a href="#1-容器管理平台" class="headerlink" title="1 容器管理平台"></a>1 容器管理平台</h3><p>docker swarm</p><p>messos</p><p>marathon</p><p>kubernetes  (90%市场)</p><h2 id="2-K8S发展"><a href="#2-K8S发展" class="headerlink" title="2 K8S发展"></a>2 K8S发展</h2><p>发布频繁，一年4个版本</p><h3 id="3-核心组件"><a href="#3-核心组件" class="headerlink" title="3 核心组件"></a>3 核心组件</h3><h2 id="二、K8S安装-1"><a href="#二、K8S安装-1" class="headerlink" title="二、K8S安装"></a>二、K8S安装</h2><blockquote><p>K8S安装方式很多：</p><ul><li>源码编译安装 ：golang编译环境</li><li>二进制安装 ：文档，全程手动，ansible等</li><li>kubeadm安装：网络要求</li><li>minikube ：开发者学习</li><li>yum安装</li></ul><p>这里使用yum安装的方法</p></blockquote><h3 id="1-虚拟机准备"><a href="#1-虚拟机准备" class="headerlink" title="1 虚拟机准备"></a>1 虚拟机准备</h3><blockquote><p>centos7, 1CPU 1G</p><p>设置主机名，<strong>添加hosts解析</strong></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">k8s-master  --  10.0.0.21k8s-node1   --  10.0.0.22k8s-node2   --  10.0.0.23</code></pre></div></figure><p>配置Centos7源和epel7源</p><figure><div class="code-wrapper"><pre class="line-numbers language-he" data-language="he"><code class="language-he">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repocurl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repoyum clean allyum makecache</code></pre></div></figure><h3 id="2-Master节点安装"><a href="#2-Master节点安装" class="headerlink" title="2 Master节点安装"></a>2 Master节点安装</h3><h4 id="2-1-安装docker"><a href="#2-1-安装docker" class="headerlink" title="2.1 安装docker"></a>2.1 安装docker</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install docker -y</code></pre></div></figure><h4 id="2-2-安装etcd"><a href="#2-2-安装etcd" class="headerlink" title="2.2 安装etcd"></a>2.2 安装etcd</h4><blockquote><p>etcd是一个nosql数据库</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install etcd -y</code></pre></div></figure><p>修改etcd配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;etcd&#x2F;etcd.confETCD_LISTEN_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;0.0.0.0:2379&quot;ETCD_ADVERTISE_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.21:2379&quot;</code></pre></div></figure><p>启动etcd服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable etcdsystemctl restart etcd</code></pre></div></figure><p>测试etcd</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">etcdctl set testdir&#x2F;testkey0 0etcdctl get testdir&#x2F;testkey0</code></pre></div></figure><p>etcdctl相关设置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">etcdctl -C http:&#x2F;&#x2F;10.0.0.21:2379 cluster-health</code></pre></div></figure><h4 id="2-3-安装k8s服务"><a href="#2-3-安装k8s服务" class="headerlink" title="2.3 安装k8s服务"></a>2.3 安装k8s服务</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install kubernetes-master -y</code></pre></div></figure><p>配置文件修改</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;kubernetes&#x2F;apiserverKUBE_API_ADDRESS&#x3D;&quot;--insecure-bind-address&#x3D;0.0.0.0&quot;KUBE_API_PORT&#x3D;&quot;--port&#x3D;8080&quot;KUBE_ETCD_SERVERS&#x3D;&quot;--etcd-servers&#x3D;http:&#x2F;&#x2F;10.0.0.21:2379&quot;# 23行删除ServiceAccount，如下KUBE_ADMISSION_CONTROL&#x3D;&quot;--admission-control&#x3D;NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&quot; # </code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;kubernetes&#x2F;configKUBE_MASTER&#x3D;&quot;--master&#x3D;http:&#x2F;&#x2F;10.0.0.21:8080&quot;</code></pre></div></figure><p>开放防火墙端口【重要】</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone&#x3D;public --add-port&#x3D;2379&#x2F;tcp --permanentfirewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanentfirewall-cmd --reload</code></pre></div></figure><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable kube-apiserversystemctl restart kube-apiserversystemctl enable kube-controller-managersystemctl restart kube-controller-managersystemctl enable kube-schedulersystemctl restart kube-scheduler</code></pre></div></figure><h3 id="3-Node节点安装"><a href="#3-Node节点安装" class="headerlink" title="3 Node节点安装"></a>3 Node节点安装</h3><h4 id="3-1-安装k8s-node服务"><a href="#3-1-安装k8s-node服务" class="headerlink" title="3.1 安装k8s-node服务"></a>3.1 安装k8s-node服务</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install kubernetes-node</code></pre></div></figure><p>编辑配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;kubernetes&#x2F;configKUBE_MASTER&#x3D;&quot;--master&#x3D;http:&#x2F;&#x2F;10.0.0.21:8080&quot;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;kubernetes&#x2F;kubeletKUBELET_ADDRESS&#x3D;&quot;--address&#x3D;0.0.0.0&quot;KUBELET_PORT&#x3D;&quot;--port&#x3D;10250&quot;KUBELET_HOSTNAME&#x3D;&quot;--hostname-override&#x3D;10.0.0.22&quot;KUBELET_API_SERVER&#x3D;&quot;--api-servers&#x3D;http:&#x2F;&#x2F;10.0.0.21:8080&quot;</code></pre></div></figure><p>启动服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable kubeletsystemctl restart kubeletsystemctl enable kube-proxysystemctl restart kube-proxy</code></pre></div></figure><h4 id="3-2-fannel网络服务安装"><a href="#3-2-fannel网络服务安装" class="headerlink" title="3.2 fannel网络服务安装"></a>3.2 fannel网络服务安装</h4><blockquote><p>用于节点之间通信</p></blockquote><p>所有节点安装并配置fannel</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install flannel -y</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;sysconfig&#x2F;flanneldFLANNEL_ETCD_ENDPOINTS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.21:2379&quot;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">etcdctl mk &#x2F;atomic.io&#x2F;network&#x2F;config &#39;&#123;&quot;Network&quot;:&quot;172.16.0.0&#x2F;16&quot;&#125;&#39;</code></pre></div></figure><p>重新启动服务—Master节点</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable fanneldsystemctl restart fanneldsystemctl restart kube-apiserversystemctl restart kube-controller-managersystemctl restart kube-scheduler</code></pre></div></figure><p>重新启动服务—Node节点</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable fanneldsystemctl restart fanneldsystemctl restart kubeletsystemctl restart kube-proxy</code></pre></div></figure><h3 id="4-配置Master为镜像服务器"><a href="#4-配置Master为镜像服务器" class="headerlink" title="4 配置Master为镜像服务器"></a>4 配置Master为镜像服务器</h3><h2 id="三、K8S使用"><a href="#三、K8S使用" class="headerlink" title="三、K8S使用"></a>三、K8S使用</h2><p>1 查看节点</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get nodes</code></pre></div></figure><p>2 查看服务状态</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get componentstatus</code></pre></div></figure><h3 id="1-Pod使用"><a href="#1-Pod使用" class="headerlink" title="1 Pod使用"></a>1 Pod使用</h3><p>创建pod</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create -f k8s_pod.yml</code></pre></div></figure><p>删除pod</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">kubectl delete pod oldboykubectl delete pod --all 删除所有</code></pre></div></figure><p>查看pod</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get podskubectl get pods -o wides</code></pre></div></figure><p>查看pod详细信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl descripe pod nginx</code></pre></div></figure><p> 更新</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl replace xxxx.yml</code></pre></div></figure><h4 id="1-1-创建一个pod-为什么要启动两个容器？"><a href="#1-1-创建一个pod-为什么要启动两个容器？" class="headerlink" title="1.1 创建一个pod,为什么要启动两个容器？"></a>1.1 创建一个pod,为什么要启动两个容器？</h4><blockquote><p>一个pod中可以挂多个容器</p></blockquote><p>比如创建一个niginx pod，将启动一个pod容器，一个nginx容器</p><p>Pod容器172.16.18.2</p><p>Nginx容器，共用pod容器ip</p><p>主要通过用POD来实现K8S的高级功能</p><h4 id="1-2-rc副本控制器的使用"><a href="#1-2-rc副本控制器的使用" class="headerlink" title="1.2 rc副本控制器的使用"></a>1.2 rc副本控制器的使用</h4><p>通过rc保证容器高可用</p><p>调整rc副本数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl scale rc myweb --replicates&#x3D;1</code></pre></div></figure><h4 id="1-3-利用rc实现滚动升级和一键回滚"><a href="#1-3-利用rc实现滚动升级和一键回滚" class="headerlink" title="1.3 利用rc实现滚动升级和一键回滚"></a>1.3 利用rc实现滚动升级和一键回滚</h4><p>案例：nginx 1.13升级1.15</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 每5s升级一个kubectl rolling-update myweb -f nginx-rc1.15.yaml --update-period&#x3D;5s</code></pre></div></figure><p>案例：nginx1.15回滚到1.13</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl rolling-update mywebv2 -f nginx-rc1.13.yaml</code></pre></div></figure><h3 id="service的创建和访问"><a href="#service的创建和访问" class="headerlink" title="service的创建和访问"></a>service的创建和访问</h3><blockquote><p>外部访问容器，端口映射</p></blockquote><h4 id="K8S小结"><a href="#K8S小结" class="headerlink" title="K8S小结"></a>K8S小结</h4><p>1 端口30000开始？</p><p>2 查看yml字段编写帮助</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl explain svc.spec</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（五）K8S</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(十)-Dokcer单机编排docker-compose</title>
    <link href="/2021/07/07/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%8D%81-Dokcer%E5%8D%95%E6%9C%BA%E7%BC%96%E6%8E%92docker-compose/"/>
    <url>/2021/07/07/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%8D%81-Dokcer%E5%8D%95%E6%9C%BA%E7%BC%96%E6%8E%92docker-compose/</url>
    
    <content type="html"><![CDATA[<blockquote><p>docker-compose 单机版的容器编排工具</p></blockquote><h2 id="一、安装docker-compose"><a href="#一、安装docker-compose" class="headerlink" title="一、安装docker-compose"></a>一、安装docker-compose</h2><p>添加Centos7的epel源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -o epel-7.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repoyum clean allyum makecache</code></pre></div></figure><p>安装pip</p><blockquote><p>Python 2.7已于2020年1月1日到期，请停止使用。请升级您的Python，因为不再维护Python 2.7。pip 21.0将于2021年1月停止对Python 2.7的支持。pip 21.0将删除对此功能的支持。因此安装&lt;21.0的版本</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">yum install -y python2-pippip install --upgrade &quot;pip &lt; 21.0&quot;</code></pre></div></figure><p>安装docker-compose</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install docker-compose</code></pre></div></figure><p>创建文件夹用于存放docker-compose脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;opt&#x2F;docker-compose</code></pre></div></figure><h2 id="一、案例：compose构建wordpress并使用nginx负载均衡"><a href="#一、案例：compose构建wordpress并使用nginx负载均衡" class="headerlink" title="一、案例：compose构建wordpress并使用nginx负载均衡"></a>一、案例：compose构建wordpress并使用nginx负载均衡</h2><p>docker01主机创建docker-compose文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;opt&#x2F;docker-compose&#x2F;wordpress&#x2F;docker-compose.yml</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;3&#39;services:  db:    image: mysql:5.7    volumes:      - db_data:&#x2F;var&#x2F;lib&#x2F;mysql    restart: always    environment:      MYSQL_ROOT_PASSWORD: somewordpress      MYSQL_DATABASE: wordpress      MYSQL_USER: wordpress      MYSQL_PASSWORD: wordpress  wordpress:    depends_on:      - db    image: wordpress:latest    volumes:      - web_data:&#x2F;var&#x2F;www&#x2F;html    ports:     - &quot;80&quot;  # 随机端口映射到内网80端口    restart: always    environment:     WORDPRESS_DB_HOST: db:3306     WORDPRESS_DB_USER: wordpress     WORDPRESS_DB_PASSWORD: wordpressvolumes:  db_data:  web_data:</code></pre></div></figure><p>构建Docker容器(三个wordpress，一个mysql）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose up --scale wordpress&#x3D;3 -d-d 后台运行--scale 生成的实例数</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">netstaus -lntup可以看到3个连续的端口号tcp        0      0 0.0.0.0:49156           0.0.0.0:*               LISTEN      2110&#x2F;docker-proxytcp        0      0 0.0.0.0:49157           0.0.0.0:*               LISTEN      2126&#x2F;docker-proxytcp        0      0 0.0.0.0:49158           0.0.0.0:*               LISTEN      2143&#x2F;docker-proxy</code></pre></div></figure><p>docker02主机安装nginx，用于负载均衡</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">curl -o epel-7.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repoyum clean allyum makecacheyum install nginx</code></pre></div></figure><p>配置nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">cd &#x2F;etc&#x2F;nginx&#x2F;mv nginx.conf nginx.conf.bakgrep -Ev &#39;^$|#&#39; nginx.conf.default  &gt; nginx.confvim nginx.conf</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">worker_processes  1;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    sendfile        on;    keepalive_timeout  65;    upstream wordpress &#123;        server 10.0.0.11:49156;        server 10.0.0.11:49157;        server 10.0.0.11:49158;    &#125;    server &#123;        listen       80;        server_name  localhost;        location &#x2F; &#123;            proxy_pass  http:&#x2F;&#x2F;wordpress;            proxy_set_header Host $host;  # 不加上网页没有Host信息，显示不全        &#125;    &#125;&#125;</code></pre></div></figure><p>重启nginx服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -tsystemctl restart nginx</code></pre></div></figure><p>测试访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">浏览器访问:10.0.0.12,可以进入wordpress</code></pre></div></figure><p>查看是否负载均衡</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建一个查看信息的页面cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;wordpress_web_data&#x2F;_data&#x2F;vim info.php</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php phpinfo(); ?&gt;</code></pre></div></figure><p>浏览器访问：10.0.0.12&#x2F;info.php，查看其中IP信息</p><h2 id="二、案例：构建zabbix"><a href="#二、案例：构建zabbix" class="headerlink" title="二、案例：构建zabbix"></a>二、案例：构建zabbix</h2>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(九)-Dokcer跨主机容器互连</title>
    <link href="/2021/07/06/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B9%9D-Dokcer%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BF%9E/"/>
    <url>/2021/07/06/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B9%9D-Dokcer%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BF%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Docker容器的四种网络类型"><a href="#一、Docker容器的四种网络类型" class="headerlink" title="一、Docker容器的四种网络类型"></a>一、Docker容器的四种网络类型</h2><blockquote><p>哪四种？</p><ul><li>bridge（默认）：NAT桥接模式</li><li>none：不分配网络，什么服务都访问不了</li><li>host：与宿主机共享网络，共享主机名，端口共用(宿主机用了的端口，容器也不能用)，【网络性能最高】</li><li>container:容器id：与容器xx共享网络，共享主机名、hosts、hostname、端口等….【K8S常用】</li></ul></blockquote><h3 id="1-指定与查看容器网络类型的方法"><a href="#1-指定与查看容器网络类型的方法" class="headerlink" title="1 指定与查看容器网络类型的方法"></a>1 指定与查看容器网络类型的方法</h3><p>指定容器网络类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --network none # 指定网络类型</code></pre></div></figure><p>查看容器网络类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker instpect 容器id # 可以查看当前的容器网络类型# 查看字段&quot;NetworkSettings&quot;: &#123;&quot;Bridge&quot;: &quot;&quot;,</code></pre></div></figure><p>查看有哪些网络类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker network ls # 查看有哪些网络类型</code></pre></div></figure><h2 id="二、使用macvlan实现"><a href="#二、使用macvlan实现" class="headerlink" title="二、使用macvlan实现"></a>二、使用macvlan实现</h2><blockquote><p>优势：</p><p>​性能比overlay高</p><p>​不用做端口映射，外界可直接访问</p><p>劣势：</p><p>​IP需要手动指定</p></blockquote><h3 id="1-案例：使用macvlan实现两个centos6-9-ssh容器跨主机网络通信"><a href="#1-案例：使用macvlan实现两个centos6-9-ssh容器跨主机网络通信" class="headerlink" title="1 案例：使用macvlan实现两个centos6.9_ssh容器跨主机网络通信"></a>1 案例：使用macvlan实现两个centos6.9_ssh容器跨主机网络通信</h3><blockquote><p>宿主机信息（虚拟机）：</p><p>​docker01: 10.0.0.11 网关: 10.0.0.2</p><p>​docker02: 10.0.0.12 网关: 10.0.0.2</p></blockquote><p>宿主机1,2分别创建macvlan</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker network create --driver macvlan --subnet 10.0.0.0&#x2F;24 --gateway 10.0.0.2 -o parent&#x3D;ens33 macvlan_1</code></pre></div></figure><p>设置网卡为混杂模式【Ubuntu需要设置】</p><blockquote><p>混杂模式是计算机网络中的术语。 是指一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip link set ens33 promisc on</code></pre></div></figure><p>宿主机1,2分别使用centos7.9_ssh:v2镜像创建容器，并指定为macvlan_1网络</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># docker01docker run -d --network macvlan_1 --ip&#x3D;10.0.0.100 centos6.9_ssh:v2# docker02docker run -d --network macvlan_1 --ip&#x3D;10.0.0.200 centos6.9_ssh:v2</code></pre></div></figure><p>测试，docker exec进入docker01中运行容器，开启抓包，并使用docker02中的容器ping它</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump icmp</code></pre></div></figure><p>通过xshell或者mobaxterm可以直接ssh到容器中 (PS:并没有 -p 22端口)</p><blockquote><p>实际测试宿主机并不能ssh到容器，显示No route to host，但是物理机可以连接</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh root@10.0.0.100</code></pre></div></figure><h2 id="三、使用overlay实现"><a href="#三、使用overlay实现" class="headerlink" title="三、使用overlay实现"></a>三、使用overlay实现</h2><blockquote><p>优势：</p><p>​可以自动分配ip地址</p><p>劣势：</p><p>​需要做端口映射才能访问容器服务</p><p>overlay参考：<a href="https://www.cnblogs.com/CloudMan6/p/7270551.html">https://www.cnblogs.com/CloudMan6/p/7270551.html</a></p></blockquote><h3 id="1-案例：使用overlay实现两个centos6-9-ssh容器跨主机网络通信"><a href="#1-案例：使用overlay实现两个centos6-9-ssh容器跨主机网络通信" class="headerlink" title="1 案例：使用overlay实现两个centos6.9_ssh容器跨主机网络通信"></a>1 案例：使用overlay实现两个centos6.9_ssh容器跨主机网络通信</h3><p>docker01启动consul</p><blockquote><p>consul是一个key:value类型的存储数据库</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 8500:8500 --restart&#x3D;always -h consul --name consul progrium&#x2F;consul -server -bootstrap</code></pre></div></figure><p>docker01,02上设置daemon.json文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;hosts&quot;:[&quot;tcp:&#x2F;&#x2F;0.0.0.0:2376&quot;,&quot;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock&quot;],&quot;cluster-store&quot;:&quot;consul:&#x2F;&#x2F;10.0.0.11:8500&quot;,&quot;cluster-advertise&quot;:&quot;10.0.0.11:2376&quot; # 此处不同，docker01为10.0.0.11，docker02为12</code></pre></div></figure><p>修改docker.service文件</p><blockquote><p>因为daemon.json中的hosts项与docker.service中的-H参数冲突，需要去掉</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.serviceExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F; --containerd&#x3D;&#x2F;run&#x2F;containerd&#x2F;containerd.sock# 删除-H fd:&#x2F;&#x2F;ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd --containerd&#x3D;&#x2F;run&#x2F;containerd&#x2F;containerd.sock</code></pre></div></figure><p>重启docker服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reloadsystemctl restart docker</code></pre></div></figure><p>测试consul是否搭建成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">浏览器访问：http:&#x2F;&#x2F;10.0.0.11:8500&#x2F;在KEY&#x2F;VALUE标签页正常显示10.0.0.11和12两台宿主机</code></pre></div></figure><p>docker01,02创建overlay网络</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker network create -d overlay --subnet 172.16.1.0&#x2F;24 --gateway 172.16.1.254 ol1</code></pre></div></figure><p>启动容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># docker01docker run -d --network ol1 --name centos6.9_01 centos6.9_ssh:v2# docker02docker run -d --network ol1 --name centos6.9_02 centos6.9_ssh:v2</code></pre></div></figure><p>测试容器间网络</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># docker01中的容器ping另一容器的hostname[root@e1e8cc01792d &#x2F;]# ping centos6.9_02PING centos6.9_02 (172.16.1.2) 56(84) bytes of data.64 bytes from centos6.9_02.ol1 (172.16.1.2): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.197 ms64 bytes from centos6.9_02.ol1 (172.16.1.2): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.269 ms64 bytes from centos6.9_02.ol1 (172.16.1.2): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;1.04 ms</code></pre></div></figure><h3 id="2-Overlay的网络访问流程图"><a href="#2-Overlay的网络访问流程图" class="headerlink" title="2 Overlay的网络访问流程图"></a>2 Overlay的网络访问流程图</h3><img src="/2021/07/06/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B9%9D-Dokcer%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BF%9E/overlay%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE.png" class="" title="overlay网络访问">]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(八)-Docker私有仓库</title>
    <link href="/2021/07/06/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%85%AB-Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <url>/2021/07/06/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%85%AB-Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、官方私有仓库registry"><a href="#一、官方私有仓库registry" class="headerlink" title="一、官方私有仓库registry"></a>一、官方私有仓库registry</h2><h3 id="1-安装步骤"><a href="#1-安装步骤" class="headerlink" title="1 安装步骤"></a>1 安装步骤</h3><p>拉取私有仓库镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull registry</code></pre></div></figure><p>启动私有仓库容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -di --name&#x3D;registry -p 5000:5000 registry</code></pre></div></figure><p>验证是否正常</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 浏览器输入10.0.0.12:5000&#x2F;v2&#x2F;_catalog</code></pre></div></figure><p>修改daemon.json，让 docker信任私有仓库地址</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json# 添加&#123;&quot;insecure-registries&quot;:[&quot;10.0.0.12:5000&quot;]&#125; </code></pre></div></figure><p>重启docker服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl reset-failed docker.service</code></pre></div></figure><p>上传镜像到私有仓库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker push 10.0.0.11:5000&#x2F;registry</code></pre></div></figure><p>从私有仓库下载镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull http:&#x2F;&#x2F;10.0.0.12:5000&#x2F;registry</code></pre></div></figure><h2 id="二、企业级私有仓库Harbor"><a href="#二、企业级私有仓库Harbor" class="headerlink" title="二、企业级私有仓库Harbor"></a>二、企业级私有仓库Harbor</h2><blockquote><p>Harbor：第三方registry组件</p><p>项目地址：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p><p>老男孩强哥博客地址：<a href="https://oldqiang.com/">https://oldqiang.com/</a></p></blockquote><h3 id="1-为什么使用Harbor"><a href="#1-为什么使用Harbor" class="headerlink" title="1 为什么使用Harbor"></a>1 为什么使用Harbor</h3><p>因为官方仓库registry存在诸多问题：</p><ul><li><p>https问题</p></li><li><p>网页简陋，查看镜像、删除镜像不方便</p></li><li><p>权限控制不方便（要么有权限，要么完全没权限），不支持多用户</p></li></ul><h3 id="2-Harbor安装步骤"><a href="#2-Harbor安装步骤" class="headerlink" title="2 Harbor安装步骤"></a>2 Harbor安装步骤</h3><blockquote><p>这里以v2.2.3为例</p></blockquote><p>离线安装包获取</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;github.com&#x2F;goharbor&#x2F;harbor&#x2F;releases&#x2F;download&#x2F;v2.2.3&#x2F;harbor-offline-installer-v2.2.3.tgz</code></pre></div></figure><p>解压文件，并修改配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -vxf harbor-offline-installer-v2.2.3.tgzcd harbor&#x2F;cp harbor.yml.tmpl harbor.ymlvim harbor.yml# 注释https设置项，并修改以下内容hostname &#x3D; 10.0.0.12  harbor_admin_password &#x3D; 1qaz@WSX</code></pre></div></figure><p>执行安装脚本（时间比较长）</p><blockquote><p>需要先安装docker-compose，</p><p><a href="https://gsproj.github.io/2021/07/07/Docker%E7%B3%BB%E5%88%97-%E5%8D%81-Dokcer%E5%8D%95%E6%9C%BA%E7%BC%96%E6%8E%92docker-compose/">docker-compose安装参考</a></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;install.sh</code></pre></div></figure><p>网页访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;10.0.0.12admin</code></pre></div></figure><h3 id="3-镜像推送与下载"><a href="#3-镜像推送与下载" class="headerlink" title="3 镜像推送与下载"></a>3 镜像推送与下载</h3><p>docker配置文件添加白名单</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json&quot;insecure-registries&quot;:[&quot;10.0.0.12&quot;],  # 不要加端口,可以是IP或域名，中间逗号隔开可加多个</code></pre></div></figure><p>镜像打标签</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull 10.0.0.12&#x2F;xxx&#x2F;centos6.9_ssh:v2   # xxx是仓库中的创建的项目名</code></pre></div></figure><p>登录到仓库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker login 10.0.0.12</code></pre></div></figure><p>推送到仓库</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker push 10.0.0.12&#x2F;xxx&#x2F;centos6.9_ssh:v2</code></pre></div></figure><p>从仓库下载镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull 10.0.0.12&#x2F;xxx&#x2F;centos6.9_ssh:v2</code></pre></div></figure><h3 id="4-将Harbor升级为https访问"><a href="#4-将Harbor升级为https访问" class="headerlink" title="4 将Harbor升级为https访问"></a>4 将Harbor升级为https访问</h3><p>配置文件修改，主要是添加证书路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># https related confighttps:  # https port for harbor, default is 443  port: 443  # The path of cert and key files for nginx  certificate: &#x2F;your&#x2F;certificate&#x2F;path  private_key: &#x2F;your&#x2F;private&#x2F;key&#x2F;path</code></pre></div></figure><p>再次执行安装脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;install.sh</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(七)-Docker镜像分层与同主机中容器互连</title>
    <link href="/2021/07/05/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B8%83-Docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E4%B8%8E%E5%90%8C%E4%B8%BB%E6%9C%BA%E4%B8%AD%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BF%9E/"/>
    <url>/2021/07/05/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B8%83-Docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E4%B8%8E%E5%90%8C%E4%B8%BB%E6%9C%BA%E4%B8%AD%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BF%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Docker镜像分层"><a href="#一、Docker镜像分层" class="headerlink" title="一、Docker镜像分层"></a>一、Docker镜像分层</h2><blockquote><p>镜像分层的好处：</p><p>​复用、节省磁盘空间，相同的内容只需加载一份到内存</p><p>​修改dockerfile后，重新构建时可以用缓存，速度快</p></blockquote><h3 id="1-查看docker镜像分层"><a href="#1-查看docker镜像分层" class="headerlink" title="1 查看docker镜像分层"></a>1 查看docker镜像分层</h3><p>通过导入镜像可以查看到镜像分层</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker load -i [镜像文件]</code></pre></div></figure><p>通过查看镜像历史可以查看到分层</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 ~]# docker image history centos6.9_ssh:v2IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT57761235f898   2 days ago    &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot; &quot;-D…   0Bc0a2c21457c4   2 days ago    &#x2F;bin&#x2F;sh -c echo &#39;123456&#39; | passwd --stdin ro…   537B29d10ff8b8e0   2 days ago    &#x2F;bin&#x2F;sh -c service sshd restart                 4.91kB666b9ddfff15   2 days ago    &#x2F;bin&#x2F;sh -c yum install openssh-server -y        154MB5b00553af9fc   2 days ago    &#x2F;bin&#x2F;sh -c #(nop) ADD file:65a30e1b327fec80b…   1.18kB2199b8eb8390   2 years ago   &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;&#x2F;bin&#x2F;bash&quot;]            0B&lt;missing&gt;      2 years ago   &#x2F;bin&#x2F;sh -c #(nop)  LABEL name&#x3D;CentOS Base Im…   0B&lt;missing&gt;      2 years ago   &#x2F;bin&#x2F;sh -c #(nop) ADD file:0e6d175401c5b4260…   195MB</code></pre></div></figure><p>所有的这些层都会在<code>Docker</code>主机本地存储区域内存储，可以通过以下指令来列出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;</code></pre></div></figure><h3 id="2-通过Dockerfile优化分层信息"><a href="#2-通过Dockerfile优化分层信息" class="headerlink" title="2  通过Dockerfile优化分层信息"></a>2  通过Dockerfile优化分层信息</h3><ul><li>尽量合并RUN和ADD来减少镜像分层数</li><li>新加的Dockerfile语句加到最后，不要加到前面</li></ul><h2 id="二、同主机中容器互连（–link是单向的）"><a href="#二、同主机中容器互连（–link是单向的）" class="headerlink" title="二、同主机中容器互连（–link是单向的）"></a>二、同主机中容器互连（–link是单向的）</h2><blockquote><p>docker官方已不推荐使用docker run –link来链接2个容器互相通信，随后的版本中会删除–link</p></blockquote><h3 id="1-功能介绍"><a href="#1-功能介绍" class="headerlink" title="1 功能介绍"></a>1 功能介绍</h3><p>docker run –link可以用来链接2个容器，使得源容器（被链接的容器）和接受容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。使用案例如下：</p><p>源容器启动：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name src_docker nginx 容器ID:xxxx01, IP:172.16.0.2</code></pre></div></figure><p>接受容器连接：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name dest_docker --link src_docker:web centos7.9:v2容器ID:xxxx02, IP:172.16.0.3</code></pre></div></figure><p>进入接受容器测试，不需要ping IP，直接ping别名就可以，web和src_docker都指向172.16.0.2<font color=red>（单向）</font></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it xxxx01 &#x2F;bin&#x2F;bashping webping src_docker</code></pre></div></figure><blockquote><p>接受容器的&#x2F;etc&#x2F;hosts将更新</p></blockquote><h3 id="2-案例：构建zabbix-server"><a href="#2-案例：构建zabbix-server" class="headerlink" title="2 案例：构建zabbix-server"></a>2 案例：构建zabbix-server</h3><p>启动一个mysql的容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --name mysql-server -t \      -e MYSQL_DATABASE&#x3D;&quot;zabbix&quot; \      -e MYSQL_USER&#x3D;&quot;zabbix&quot; \      -e MYSQL_PASSWORD&#x3D;&quot;zabbix_pwd&quot; \      -e MYSQL_ROOT_PASSWORD&#x3D;&quot;root_pwd&quot; \      -d mysql:5.7 \      --character-set-server&#x3D;utf8 --collation-server&#x3D;utf8_bin </code></pre></div></figure><p>启动java-gateway容器监控java服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --name zabbix-java-gateway -t \      -d zabbix&#x2F;zabbix-java-gateway:latest</code></pre></div></figure><p>启动zabbix-mysql容器使用link连接mysql与java-gateway</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --name zabbix-server-mysql -t \      -e DB_SERVER_HOST&#x3D;&quot;mysql-server&quot; \      -e MYSQL_DATABASE&#x3D;&quot;zabbix&quot; \      -e MYSQL_USER&#x3D;&quot;zabbix&quot; \      -e MYSQL_PASSWORD&#x3D;&quot;zabbix_pwd&quot; \      -e MYSQL_ROOT_PASSWORD&#x3D;&quot;root_pwd&quot; \      -e ZBX_JAVAGATEWAY&#x3D;&quot;zabbix-java-gateway&quot; \      --link mysql-server:mysql \      --link zabbix-java-gateway:zabbix-java-gateway \      -p 10051:10051 \      -d zabbix&#x2F;zabbix-server-mysql:latest</code></pre></div></figure><p>启动zabbix web显示，使用link连接zabbix-mysql与mysql</p><blockquote><p>zabbix的默认端口已有80改为8080，可见配置文件&#x2F;etc&#x2F;zabbix&#x2F;nginx.conf</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">docker run --name zabbix-web-nginx-mysql -t \      -e DB_SERVER_HOST&#x3D;&quot;mysql-server&quot; \      -e MYSQL_DATABASE&#x3D;&quot;zabbix&quot; \      -e MYSQL_USER&#x3D;&quot;zabbix&quot; \      -e MYSQL_PASSWORD&#x3D;&quot;zabbix_pwd&quot; \      -e MYSQL_ROOT_PASSWORD&#x3D;&quot;root_pwd&quot; \      --link mysql-server:mysql \      --link zabbix-server-mysql:zabbix-server \      -p 8082:8080 \           -d zabbix&#x2F;zabbix-web-nginx-mysql:latest</code></pre></div></figure><p>登录Zabbix</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">浏览器访问：10.0.0.11:8082Adminzabbix</code></pre></div></figure><p>添加被监控节点-安装zabbix-agent</p><blockquote><p>获取zabbix-agent：</p><p>uname -a 查看内核版本</p><p>web页面查看zabbix版本</p><p><a href="https://www.zabbix.com/download">https://www.zabbix.com/download</a> 获取对应agent的安装方法</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rpm -Uvh https:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;5.4&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-release-5.4-1.el7.noarch.rpmyum clean allyum install zabbix-agent</code></pre></div></figure><p>添加被监控节点-agent配置文件修改</p><blockquote><p>117行：Server&#x3D;10.0.0.11, 注意防火墙和selinux的阻挡</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agentd.confsystemctl restart zabbix-agent</code></pre></div></figure><h2 id="三、docker重启后容器不退出"><a href="#三、docker重启后容器不退出" class="headerlink" title="三、docker重启后容器不退出"></a>三、docker重启后容器不退出</h2><blockquote><p>默认情况下，systemctl restart docker之后，容器将处于Exited状态</p></blockquote><h3 id="1-添加容器启动参数"><a href="#1-添加容器启动参数" class="headerlink" title="1 添加容器启动参数"></a>1 添加容器启动参数</h3><blockquote><p>docker重启后，容器先停止，再立即重新启动</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --restart&#x3D;always</code></pre></div></figure><h3 id="2-daemon配置文件修改（不推荐）"><a href="#2-daemon配置文件修改（不推荐）" class="headerlink" title="2 daemon配置文件修改（不推荐）"></a>2 daemon配置文件修改（不推荐）</h3><blockquote><p>docker重启后，容器不会停止，一直在运行，不推荐使用，不好控制</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json# 添加一行，上行后面加逗号&quot;live-restore&quot;:true</code></pre></div></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(六)-Dockfile的使用</title>
    <link href="/2021/06/30/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%85%AD-Dockfile%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/06/30/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%85%AD-Dockfile%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Dokerfile简介"><a href="#一、Dokerfile简介" class="headerlink" title="一、Dokerfile简介"></a>一、Dokerfile简介</h2><blockquote><p>Dockerfile 是一个用来自动构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><p>建议存放在&#x2F;opt&#x2F;dockerfile中，如创建centosXX的镜像，则创建&#x2F;opt&#x2F;dockerfile&#x2F;centosXX&#x2F;Dockerfile</p></blockquote><h3 id="1-Dockerfile的简单使用"><a href="#1-Dockerfile的简单使用" class="headerlink" title="1 Dockerfile的简单使用"></a>1 Dockerfile的简单使用</h3><blockquote><p>创建一个开启sshd服务的centos6.9镜像</p></blockquote><p>创建yum源文件，用于拷贝到centos6.9镜像中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;dockfile&#x2F;centos6.9_sshvim CentOS-Base.repo...内容省略</code></pre></div></figure><p>创建Dockerfile文件&#x2F;opt&#x2F;dockfile&#x2F;centos6.9_ssh&#x2F;Dockerfile，内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM centos:6.9ADD CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.dRUN yum install openssh-server -yRUN service sshd restartRUN echo &#39;123456&#39; | passwd --stdin rootCMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,&quot;-D&quot;]</code></pre></div></figure><blockquote><p>PS：RUN的执行过程：创建临时容器，执行命令，提交成临时镜像，删除临时容器，重复此步骤。</p></blockquote><p>构建镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t centos6.9_ssh:v2 &#x2F;opt&#x2F;dockfile&#x2F;centos6.9_ssh</code></pre></div></figure><blockquote><p>PS：最后传入的是包含Dockerfile的文件夹，区分大小写，可以用”.”代替 </p></blockquote><p>验证镜像是否正常</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 1022:22 centos6.9_ssh:v2</code></pre></div></figure><blockquote><p>PS：最后不用接命令，将自动执行CMD指定的命令</p></blockquote><h3 id="2-小案例"><a href="#2-小案例" class="headerlink" title="2 小案例"></a>2 小案例</h3><blockquote><p>创建centos6.9 + ssh + nginx的Dockerfile</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 centos6.9_ssh_nginx]# pwd&#x2F;opt&#x2F;dockfile&#x2F;centos6.9_ssh_nginx[root@docker01 centos6.9_ssh_nginx]# lsCentOS-Base.repo  Dockerfile  epel.repo  init.sh</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># init.sh#!&#x2F;bin&#x2F;bashservice sshd restartnginx -g &quot;daemon off;&quot;</code></pre></div></figure><p>编写Dockerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM centos:6.9ADD CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.dADD epel.repo &#x2F;etc&#x2F;yum.repos.dADD init.sh &#x2F;rootRUN yum install openssh-server nginx -yRUN echo &#39;123456&#39; | passwd --stdin rootCMD [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;&#x2F;root&#x2F;init.sh&quot;]</code></pre></div></figure><p>构建镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">docker build -t centos6.9_ssh_nginx:v3 .</code></pre></div></figure><p>测试使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 1022:22 -p 81:80 centos6.9_ssh_nginx:v3</code></pre></div></figure><h2 id="二、Docker指令"><a href="#二、Docker指令" class="headerlink" title="二、Docker指令"></a>二、Docker指令</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">FROM</td><td align="left">基于那个镜像来构建</td></tr><tr><td align="left">MAINTAINER</td><td align="left">镜像的创建者</td></tr><tr><td align="left">ENV</td><td align="left">设置环境变量</td></tr><tr><td align="left">ADD</td><td align="left">添加宿主机文件到容器里，有需要解压的文件会自动解压</td></tr><tr><td align="left">COPY</td><td align="left">添加宿主机文件到容器里</td></tr><tr><td align="left">WORKDIR</td><td align="left">切换工作目录</td></tr><tr><td align="left">EXPOSE</td><td align="left">开放可用端口</td></tr><tr><td align="left">CMD</td><td align="left">容器启动后执行的命令，可被docker run指定的命令覆盖</td></tr><tr><td align="left">ENTRYPOINT</td><td align="left">容器启动后执行的命令，但不回被docker run指定的命令覆盖，如需覆盖，需要加–entrypoint参数</td></tr><tr><td align="left">VOLUME</td><td align="left">创建挂载卷，将宿主机的目录挂载到容器里</td></tr></tbody></table><h2 id="三、案例：Dockerfile构建可道云容器"><a href="#三、案例：Dockerfile构建可道云容器" class="headerlink" title="三、案例：Dockerfile构建可道云容器"></a>三、案例：Dockerfile构建可道云容器</h2><blockquote><p>项目：</p><p>​可道云网盘kodexplorer</p><p>环境：</p><p>​httpd+php或者nginx+php<br>​php所需模块：php5.5以上<br>​基础镜像：centos:7.9<br>​项目下载地址: <a href="http://static.kodcloud.com/update/download/kodexplorer4.37.zip">http://static.kodcloud.com/update/download/kodexplorer4.37.zip</a><br>​项目官网：<a href="https://kodcloud.com/download/">https://kodcloud.com/download/</a></p></blockquote><h3 id="1-手工部署一遍"><a href="#1-手工部署一遍" class="headerlink" title="1 手工部署一遍"></a>1 手工部署一遍</h3><blockquote><p>写Dockerfile前自己手动部署一遍，主要是nginx + php的搭建，参考博客</p><p><a href="https://cloud.tencent.com/developer/article/1015237">https://cloud.tencent.com/developer/article/1015237</a></p></blockquote><p>修改nginx.conf</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># For more information on configuration, see:#   * Official English Documentation: http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;#   * Official Russian Documentation: http:&#x2F;&#x2F;nginx.org&#x2F;ru&#x2F;docs&#x2F;user nginx;worker_processes auto;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;pid &#x2F;run&#x2F;nginx.pid;# Load dynamic modules. See &#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx&#x2F;README.dynamic.include &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;modules&#x2F;*.conf;events &#123;    worker_connections 1024;&#125;http &#123;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;    sendfile            on;    tcp_nopush          on;    tcp_nodelay         on;    keepalive_timeout   65;    types_hash_max_size 4096;    include             &#x2F;etc&#x2F;nginx&#x2F;mime.types;    default_type        application&#x2F;octet-stream;    # Load modular configuration files from the &#x2F;etc&#x2F;nginx&#x2F;conf.d directory.    # See http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;ngx_core_module.html#include    # for more information.    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;    server &#123;        listen       80;        listen       [::]:80;        server_name  _;        root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;        # Load configuration files for the default server block.        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;        error_page 404 &#x2F;404.html;        location &#x3D; &#x2F;404.html &#123;        &#125;        error_page 500 502 503 504 &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;        &#125;    location ~ \.php$ &#123;        try_files $uri &#x3D;404;        fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php-fpm&#x2F;php-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    &#125;    location &#x2F; &#123;        index  index.php index.html index.htm;        try_files $uri $uri&#x2F; &#x2F;index.php?$args;    &#125;    &#125;# Settings for a TLS enabled server.##    server &#123;#        listen       443 ssl http2;#        listen       [::]:443 ssl http2;#        server_name  _;#        root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;##        ssl_certificate &quot;&#x2F;etc&#x2F;pki&#x2F;nginx&#x2F;server.crt&quot;;#        ssl_certificate_key &quot;&#x2F;etc&#x2F;pki&#x2F;nginx&#x2F;private&#x2F;server.key&quot;;#        ssl_session_cache shared:SSL:1m;#        ssl_session_timeout  10m;#        ssl_ciphers HIGH:!aNULL:!MD5;#        ssl_prefer_server_ciphers on;##        # Load configuration files for the default server block.#        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;##        error_page 404 &#x2F;404.html;#            location &#x3D; &#x2F;40x.html &#123;#        &#125;##        error_page 500 502 503 504 &#x2F;50x.html;#            location &#x3D; &#x2F;50x.html &#123;#        &#125;#    &#125;&#125;</code></pre></div></figure><p>修改php-fpm.conf</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">;;;;;;;;;;;;;;;;;;;;;; FPM Configuration ;;;;;;;;;;;;;;;;;;;;;;; All relative paths in this configuration file are relative to PHP&#39;s install; prefix.; Include one or more files. If glob(3) exists, it is used to include a bunch of; files from a glob(3) pattern. This directive can be used everywhere in the; file.include&#x3D;&#x2F;etc&#x2F;php-fpm.d&#x2F;*.conf;;;;;;;;;;;;;;;;;;; Global Options ;;;;;;;;;;;;;;;;;;;[global]; Pid file; Default Value: nonepid &#x3D; &#x2F;run&#x2F;php-fpm&#x2F;php-fpm.pid; Error log file; Default Value: &#x2F;var&#x2F;log&#x2F;php-fpm.logerror_log &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;error.log; Log level; Possible Values: alert, error, warning, notice, debug; Default Value: notice;log_level &#x3D; notice; If this number of child processes exit with SIGSEGV or SIGBUS within the time; interval set by emergency_restart_interval then FPM will restart. A value; of &#39;0&#39; means &#39;Off&#39;.; Default Value: 0;emergency_restart_threshold &#x3D; 0; Interval of time used by emergency_restart_interval to determine when ; a graceful restart will be initiated.  This can be useful to work around; accidental corruptions in an accelerator&#39;s shared memory.; Available Units: s(econds), m(inutes), h(ours), or d(ays); Default Unit: seconds; Default Value: 0;emergency_restart_interval &#x3D; 0; Time limit for child processes to wait for a reaction on signals from master.; Available units: s(econds), m(inutes), h(ours), or d(ays); Default Unit: seconds; Default Value: 0;process_control_timeout &#x3D; 0; Send FPM to background. Set to &#39;no&#39; to keep FPM in foreground for debugging.; Default Value: yesdaemonize &#x3D; no;;;;;;;;;;;;;;;;;;;;; Pool Definitions ; ;;;;;;;;;;;;;;;;;;;;; See &#x2F;etc&#x2F;php-fpm.d&#x2F;*.conf</code></pre></div></figure><p>修改<a href="http://www.conf/">www.conf</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 12行listen &#x3D; &#x2F;var&#x2F;run&#x2F;php-fpm&#x2F;php-fpm.sock# 31-32行listen.owner &#x3D; nobodylisten.group &#x3D; nobody# 39-41行user &#x3D; nginx; RPM: Keep a group allowed to write in log dir.group &#x3D; nginx</code></pre></div></figure><p>修改php.ini</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cgi.fix_pathinfo 把它的值设置为 0</code></pre></div></figure><h3 id="2-Dockerfile部署"><a href="#2-Dockerfile部署" class="headerlink" title="2 Dockerfile部署"></a>2 Dockerfile部署</h3><p>文件存放</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker01 centos7.9_kod]# lltotal 92-rw-r--r--. 1 root root   661 Jul  2 11:21 Dockerfile-rw-r--r--. 1 root root   171 Jul  1 14:28 init.sh-rw-r--r--. 1 root root  2715 Jul  1 13:50 nginx.conf-rw-r--r--. 1 root root  1691 Jul  1 13:50 php-fpm.conf-rw-r--r--. 1 root root 64945 Jul  1 14:48 php.ini-rw-r--r--. 1 root root 10029 Jul  1 13:50 www.conf[root@docker01 centos7.9_kod]# pwd&#x2F;opt&#x2F;dockfile&#x2F;centos7.9_kod</code></pre></div></figure><p>编写Dockerfile</p><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM centos:7.9.2009RUN curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo &amp;&amp; \curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo &amp;&amp; \yum install openssh-server nginx net-tools php-cli php-fpm unzip php-gd php-mbstring  -yADD nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.confADD php-fpm.conf &#x2F;etc&#x2F;php-fpm.confADD www.conf &#x2F;etc&#x2F;php-fpm.d&#x2F;www.confADD php.ini &#x2F;etcADD init.sh &#x2F;root&#x2F;EXPOSE 80 22WORKDIR &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;htmlRUN curl -o kod.zip https:&#x2F;&#x2F;static.kodcloud.com&#x2F;update&#x2F;download&#x2F;kodexplorer4.45.zip &amp;&amp; \unzip kod.zip &amp;&amp; \chmod -R 777 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;CMD [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;&#x2F;root&#x2F;init.sh&quot;]</code></pre></div></figure><p>构建镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t centos7.9_kod:v1 .</code></pre></div></figure><p>运行容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 80:80 -p 1022:22 -e &quot;SSH_PWD&#x3D;redhat123&quot; --privileged centos7.9_kod:v1 &#x2F;usr&#x2F;sbin&#x2F;init</code></pre></div></figure><p>进入容器，并运行初始化命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it 865 &#x2F;bin&#x2F;bash# 容器启动服务，设置root密码[root@88179198e672 html]#systemctl restart sshd php-fpm nginx[root@88179198e672 html]#echo &quot;redhat123&quot; | passwd --stdin root</code></pre></div></figure><p>测试访问：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">网页访问：http:&#x2F;&#x2F;10.0.0.11可进去可道云界面ssh 10.0.0.11 -p1022 可以登录镜像</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(五)-手动制作docker镜像</title>
    <link href="/2021/06/29/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%BA%94-%E6%89%8B%E5%8A%A8%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F/"/>
    <url>/2021/06/29/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%BA%94-%E6%89%8B%E5%8A%A8%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、制作Docker镜像"><a href="#一、制作Docker镜像" class="headerlink" title="一、制作Docker镜像"></a>一、制作Docker镜像</h2><h3 id="1-启动基础容器"><a href="#1-启动基础容器" class="headerlink" title="1 启动基础容器"></a>1 启动基础容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">docker run -it centos:6.9 # yumdocker run -it alpine:3.9 # apk</code></pre></div></figure><h3 id="2-在容器中安装服务"><a href="#2-在容器中安装服务" class="headerlink" title="2 在容器中安装服务"></a>2 在容器中安装服务</h3><p>修改yum源（Centos6阿里源已停止维护）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;[centos-office]name&#x3D;centos-officefailovermethod&#x3D;prioritybaseurl&#x3D;https:&#x2F;&#x2F;vault.centos.org&#x2F;6.10&#x2F;os&#x2F;x86_64&#x2F;gpgcheck&#x3D;1gpgkey&#x3D;https:&#x2F;&#x2F;vault.centos.org&#x2F;6.10&#x2F;os&#x2F;x86_64&#x2F;RPM-GPG-KEY-CentOS-6&#39; &gt; CentOS-Base.repo</code></pre></div></figure><p>安装并启动openssh服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install openssh-server -yservice sshd restart</code></pre></div></figure><p>修改root密码(默认没有密码)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;123456&#39; | passwd --stdin root# 或者echo root:123456 | chpassw</code></pre></div></figure><p>将已经安装好sshd服务的容器打包成镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker container commit 981877f137c9 centos6.9_ssh:v1</code></pre></div></figure><p>测试镜像</p><blockquote><p>sshd -D：以后台守护进程的方式运行服务</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动sshd并将22端口映射出来，可以使用xshell连接docker run -d -p 1022:22 centos6.9_ssh:v1 &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre></div></figure><h2 id="二、小案例：创建一个ssh-nginx双服务的镜像"><a href="#二、小案例：创建一个ssh-nginx双服务的镜像" class="headerlink" title="二、小案例：创建一个ssh+nginx双服务的镜像"></a>二、小案例：创建一个ssh+nginx双服务的镜像</h2><p>创建容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 1023:22 centos6.9_ssh:v1 &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre></div></figure><p>修改yum源和epel源</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">由于Centos6阿里云停止维护参考：https:&#x2F;&#x2F;blog.csdn.net&#x2F;u013250554&#x2F;article&#x2F;details&#x2F;110684307</code></pre></div></figure><p>安装nginx</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install nginx -y</code></pre></div></figure><p>创建运行服务的脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;root&#x2F;init.sh#!&#x2F;bin&#x2F;bashservice sshd restartnginx -g &#39;daemon off;&#39;</code></pre></div></figure><p>将容器封装成镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker commit e6a6dsa6 centos6.9_ssh_nginx:v2</code></pre></div></figure><p>启动镜像，开启服务，并夯住</p><blockquote><p>可以使用工具ssh登录，并且可以访问到nginx的欢迎页面</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 1025:22 -p 80:80 centos6.9_ssh_nginx:v2 &#x2F;bin&#x2F;bash &#x2F;root&#x2F;init.sh</code></pre></div></figure><h2 id="三、通过环境变量设置容器密码"><a href="#三、通过环境变量设置容器密码" class="headerlink" title="三、通过环境变量设置容器密码"></a>三、通过环境变量设置容器密码</h2><p>修改&#x2F;root&#x2F;init.sh文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashif [ -z $SSH_PWD ];then        SSH_PWD&#x3D;123456fiecho &quot;$SSH_PWD&quot; | passwd --stdin rootservice sshd restartnginx -g &#39;daemon off;&#39;</code></pre></div></figure><p>打包成镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker commit 12386c6504d4 centos6.9_ssh_nginx_passwd</code></pre></div></figure><p>运行容器</p><blockquote><p>docker run -e：指定环境变量</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 1022:22 -p 80:80 -e &quot;SSH_PWD&#x3D;123456&quot; centos6.9_ssh_nginx_passwd &#x2F;bin&#x2F;bash &#x2F;root&#x2F;init.sh</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(四)-容器的数据卷挂载与小案例练习</title>
    <link href="/2021/06/29/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%9B%9B-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%B0%8F%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/06/29/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E5%9B%9B-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%B0%8F%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据卷挂载"><a href="#一、数据卷挂载" class="headerlink" title="一、数据卷挂载"></a>一、数据卷挂载</h2><h3 id="1-临时挂载"><a href="#1-临时挂载" class="headerlink" title="1 临时挂载"></a>1 临时挂载</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将&#x2F;opt&#x2F;xiaoniao目录挂载到容器的html目录docker run -d -p 80:80 -v &#x2F;opt&#x2F;xiaoniao:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest</code></pre></div></figure><h3 id="2-使用卷挂载"><a href="#2-使用卷挂载" class="headerlink" title="2 使用卷挂载"></a>2 使用卷挂载</h3><blockquote><p>容器被删除，创建的卷可以保留，可以再次挂载到新建的容器中</p></blockquote><p>创建名为myvol的容器卷并挂载到容器html目录</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 80:80 -v myvol:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest</code></pre></div></figure><p>查看当前有哪些容器卷</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker volume ls</code></pre></div></figure><p>查看名为myvol的卷的信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker volume inspect myvol</code></pre></div></figure><p>删除容器并删除卷（无效）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># PS：删除容器并删除卷，无法将卷删除docker rm -f -v [容器ID]    -v --volume</code></pre></div></figure><h2 id="二、小案例：多端口多站点"><a href="#二、小案例：多端口多站点" class="headerlink" title="二、小案例：多端口多站点"></a>二、小案例：多端口多站点</h2><blockquote><p>80端口访问nginx首页</p><p>81端口访问水果忍者</p></blockquote><p>获取水果忍者HTML5小游戏源码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;7npmedia.w3cschool.cn&#x2F;1-FruitNinja.7z</code></pre></div></figure><p>创建81端口nginx配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;opt&#x2F;fruitninjia.confserver &#123;    listen       81;    listen  [::]:81;    server_name  localhost;    #access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log  main;    location &#x2F; &#123;        root   &#x2F;data;        index  index.html index.htm;    &#125;&#125;</code></pre></div></figure><p>将游戏源码文件解压至&#x2F;opt&#x2F;fruitninjia，并运行nginx容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将&#x2F;opt&#x2F;fruitninjia挂载到容器&#x2F;data中docker run -d -p 80:80 -p 81:81 -v &#x2F;opt&#x2F;fruitninjia:&#x2F;data -v &#x2F;opt&#x2F;fruitninjia.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;fruitninjia.conf nginx</code></pre></div></figure><p>网页访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https:&#x2F;&#x2F;10.0.0.11:80</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(三)-容器的网络访问</title>
    <link href="/2021/06/29/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE/"/>
    <url>/2021/06/29/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、容器的网络访问流程"><a href="#一、容器的网络访问流程" class="headerlink" title="一、容器的网络访问流程"></a>一、容器的网络访问流程</h2><blockquote><p>参考：<a href="https://z.itpub.net/article/detail/FE8EBAC62D5881E3A432291F8C8E4F02">https://z.itpub.net/article/detail/FE8EBAC62D5881E3A432291F8C8E4F02</a></p></blockquote><h3 id="1-虚拟机注意事项"><a href="#1-虚拟机注意事项" class="headerlink" title="1 虚拟机注意事项"></a>1 虚拟机注意事项</h3><p>查看net.ipv4.ip_forward值是否为1</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysctl -a | grep ipv4 | grep forward </code></pre></div></figure><p>只有值为1时docker容器才能上网，而vmware虚拟机挂起将使他变成0，解决方法：</p><ul><li>sysctl net.ipv4.ip_forward &#x3D; 1 设置为1</li><li>不要挂起虚拟机，直接关机重启，docker服务在启动时会将它改为1</li></ul><h2 id="二、容器端口映射"><a href="#二、容器端口映射" class="headerlink" title="二、容器端口映射"></a>二、容器端口映射</h2><h3 id="1-docker-run-p端口映射参数"><a href="#1-docker-run-p端口映射参数" class="headerlink" title="1 docker run -p端口映射参数"></a>1 docker run -p端口映射参数</h3><p>指定端口访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将容器80端口，映射到主机180端口docker run -p 180:80</code></pre></div></figure><p>指定IP+端口访问</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 多网卡环境下，将容器80端口映射到10.0.0.1的180端口docker run -p 10.0.0.1:180:80</code></pre></div></figure><p>指定随机端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she"># 将容器80端口，映射到主机随机端口docker run -p 10.0.0.1::80</code></pre></div></figure><p>指定随机端口+UDP (默认映射TCP)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将容器80端口映射到主机随机端口，并使用UDP协议-p 10.0.0.100:80:udp # 指定随机端口 + udp</code></pre></div></figure><p>可以指定多个端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-p 180:80 -p 1443:443 # 指定多个端口</code></pre></div></figure><p>随机映射</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -P</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(二)-Docker常用管理命令</title>
    <link href="/2021/06/28/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%BA%8C-Docker%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/06/28/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%BA%8C-Docker%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、常用镜像管理命令"><a href="#一、常用镜像管理命令" class="headerlink" title="一、常用镜像管理命令"></a>一、常用镜像管理命令</h2><blockquote><p>​Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote><h3 id="1-在镜像仓库查找镜像"><a href="#1-在镜像仓库查找镜像" class="headerlink" title="1 在镜像仓库查找镜像"></a>1 在镜像仓库查找镜像</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker search tomcat</code></pre></div></figure><h3 id="2-在镜像仓库拉取镜像"><a href="#2-在镜像仓库拉取镜像" class="headerlink" title="2 在镜像仓库拉取镜像"></a>2 在镜像仓库拉取镜像</h3><blockquote><p>不指定版本号时默认下载最新版（latest），版本可在dockerhub(官方仓库)、DaoCloud(私有仓库)等仓库查到</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># dockerhub拉取docker pull alpine:3.6# daocloud拉取docker pull daocloud.io&#x2F;jermine&#x2F;alpine:latest</code></pre></div></figure><h3 id="3-查看已有镜像"><a href="#3-查看已有镜像" class="headerlink" title="3 查看已有镜像"></a>3 查看已有镜像</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker image ls# 别名docker images</code></pre></div></figure><h3 id="4-导出镜像"><a href="#4-导出镜像" class="headerlink" title="4 导出镜像"></a>4 导出镜像</h3><blockquote><p>弃用export，导出的镜像不带版本TAG信息</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker image save alpine -o alpine.tar.gz</code></pre></div></figure><h3 id="5-删除镜像"><a href="#5-删除镜像" class="headerlink" title="5 删除镜像"></a>5 删除镜像</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 删除alpine镜像docker image rm d4ff818577bc</code></pre></div></figure><h3 id="6-导入镜像"><a href="#6-导入镜像" class="headerlink" title="6 导入镜像"></a>6 导入镜像</h3><blockquote><p>弃用import，导入的镜像不带版本TAG信息</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker image load -i alpine.tar.gz</code></pre></div></figure><h3 id="7-查看镜像属性"><a href="#7-查看镜像属性" class="headerlink" title="7 查看镜像属性"></a>7 查看镜像属性</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker image inspect 4f380adfc10f</code></pre></div></figure><h3 id="8-镜像批量删除"><a href="#8-镜像批量删除" class="headerlink" title="8 镜像批量删除"></a>8 镜像批量删除</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker image prune</code></pre></div></figure><h3 id="9-指定TAG信息"><a href="#9-指定TAG信息" class="headerlink" title="9 指定TAG信息"></a>9 指定TAG信息</h3><blockquote><p>docker images查看docker image import的镜像，没有镜像名和TAG，可以使用此方法来修改</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker image tag d4ff818577bc oldbly</code></pre></div></figure><h2 id="二、常用容器管理命令"><a href="#二、常用容器管理命令" class="headerlink" title="二、常用容器管理命令"></a>二、常用容器管理命令</h2><blockquote><p>​镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>​容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立宿主的系统下操作一样。这种特性使容器封装的应用比直接在宿主运行更加安全。</p></blockquote><h3 id="1-运行容器"><a href="#1-运行容器" class="headerlink" title="1 运行容器"></a>1 运行容器</h3><blockquote><p>1、docker容器内的第一个进程（初始命令）必须一直处于前台运行的状态（必须夯住），否则这个容器，就会处于退出状态。</p><p>2、业务在容器中运行：前台运行夯住，启动服务</p><p>3、如果不指定执行命令，会运行默认的执行命令</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 放后台运行docker run -d -p 80:80 nginx:latestrun 创建并运行一个容器-d放在后台运行-p 端口映射-v 源地址(宿主机)：目标地址(容器)# 交互式方式进入容器执行docker run -it --name centos6 centos:6.9 &#x2F;bin&#x2F;bash-it 分配交互式的终端--name 制定容器的名称&#x2F;bin&#x2F;sh 容器执行的命令，每个进程默认有初始执行命令，可以覆盖</code></pre></div></figure><h3 id="2-查看已有容器"><a href="#2-查看已有容器" class="headerlink" title="2 查看已有容器"></a>2 查看已有容器</h3><blockquote><p>-a 显示所有容器（默认只显示running的容器）</p><p>-l 显示最新的容器</p><p>–no-trunc 显示完整id</p><p>-q 静默输出（只显示容器id）</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker container ls -a# 别名docker ps -a</code></pre></div></figure><h3 id="3-停止容器"><a href="#3-停止容器" class="headerlink" title="3 停止容器"></a>3 停止容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker container stop 55e9c7c</code></pre></div></figure><h3 id="4-杀死容器"><a href="#4-杀死容器" class="headerlink" title="4 杀死容器"></a>4 杀死容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker container kill 55e9c7c</code></pre></div></figure><blockquote><p>kill与stop的区别：</p><ul><li><p>kill：不管容器同不同意，发送SIGKILL信号，强行终止。</p></li><li><p>stop：首先给容器发送一个SIGTERM信号，让容器做一些退出前必须的保护性、安全性操作，然后让容器自动停止运行，如果在一段时间内，容器还是没有停止，再发送SIGKILL信号，强行终止。</p></li></ul></blockquote><h3 id="5-启动容器"><a href="#5-启动容器" class="headerlink" title="5 启动容器"></a>5 启动容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker container start 55e9c7c</code></pre></div></figure><h3 id="6-进入容器（重要！调试、排错）"><a href="#6-进入容器（重要！调试、排错）" class="headerlink" title="6 进入容器（重要！调试、排错）"></a>6 进入容器（重要！调试、排错）</h3><p>使用同一终端：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 交互式方式运行容器（开启新终端）docker run -it --name centos6.9 centos:6.9 &#x2F;bin&#x2F;bash# 暂时退出当前终端ctrl + p 再 ctrl + q# 重新进入该终端docker attach d4ff818577bc</code></pre></div></figure><p>使用不同终端（常用）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it d4ff818577bc &#x2F;bin&#x2F;bash</code></pre></div></figure><h3 id="7-删除容器"><a href="#7-删除容器" class="headerlink" title="7 删除容器"></a>7 删除容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker container rm 55e9c7cb59a6 55e9c7cb59a5# 别名docker rm 55e9c7cb59a6# 批量删除容器docker rm &#96;docker ps -a -q&#96;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(一)-安装Docker</title>
    <link href="/2021/06/28/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%AE%89%E8%A3%85Docker/"/>
    <url>/2021/06/28/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%AE%89%E8%A3%85Docker/</url>
    
    <content type="html"><![CDATA[<h2 id="一、容器简介"><a href="#一、容器简介" class="headerlink" title="一、容器简介"></a>一、容器简介</h2><blockquote><p>容器就是在隔离环境中运行一个进程，如果进程停止，容器就会销毁，隔离环境拥有自己的系统文件，ip地址，主机名等。</p></blockquote><h3 id="1-容器和虚拟化的区别"><a href="#1-容器和虚拟化的区别" class="headerlink" title="1 容器和虚拟化的区别"></a>1 容器和虚拟化的区别</h3><ul><li><p>KVM虚拟化：</p><ul><li><p>需要硬件的支持，需要模拟硬件，可以运行不同的操作系统，启动时间分钟级（有开机启动流程）</p><p>开机启动流程</p><p>bios开机硬件自检</p><p>根据bios设置的优先启动项boot</p><p>读取mbr&#x2F;gpt引导，读取mbr硬盘分区信息，内核加载路径</p><p>加载内核</p><p>启动第一个进程（C6：&#x2F;sbin&#x2F;init，C7：systemd）</p><p>系统初始化完成</p><p>运行服务</p></li></ul></li><li><p>容器：</p><ul><li><p>不需要硬件的支持，不需要模拟硬件，公用宿主机内核，启动时间秒级（没有开机启动流程）</p><p>容器的第一个进程直接运行服务，损耗少，启动快，性能高</p></li></ul></li></ul><h3 id="2-容器的优缺点"><a href="#2-容器的优缺点" class="headerlink" title="2 容器的优缺点"></a>2 容器的优缺点</h3><ul><li><p>优点</p><ul><li><p>与宿主机使用同一个内核，性能损耗小</p><p>不需要指令级模拟</p><p>容器可以再cpu核心的本地运行指令，不需要任何专门的解释机制</p><p>避免了准虚拟化和系统调用替换中的复杂性</p><p>轻量级隔离，在隔离的同事还提供共享机制，以实现容器与宿主机的资源共享</p></li></ul></li><li><p>缺点</p><ul><li>使用同一内核，存在安全性问题</li></ul></li></ul><h3 id="3-容器技术的发展过程"><a href="#3-容器技术的发展过程" class="headerlink" title="3 容器技术的发展过程"></a>3 容器技术的发展过程</h3><blockquote><p>chroot — lxc —- docker</p></blockquote><h3 id="4-Docker组成"><a href="#4-Docker组成" class="headerlink" title="4 Docker组成"></a>4 Docker组成</h3><p>​Docker基于Go语言开发，C&#x2F;S模式</p><ul><li>主要组件<ul><li>镜像</li><li>容器</li><li>仓库：最大的dockerhub</li><li>网络</li><li>存储</li></ul></li></ul><h2 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h2><blockquote><p>参考网站：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/</a></p></blockquote><h3 id="1-联网在线安装"><a href="#1-联网在线安装" class="headerlink" title="1 联网在线安装"></a>1 联网在线安装</h3><p>开启rpm包缓存，方便制作离线安装包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;yum.confkeepcache&#x3D;1 </code></pre></div></figure><p>如果你之前安装过 docker，请先删掉</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo yum remove docker docker-common docker-selinux docker-engine</code></pre></div></figure><p>安装一些依赖</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre></div></figure><p>根据你的发行版下载repo文件（Centos）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</code></pre></div></figure><p>把软件仓库替换为TUNA：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo sed -i &#39;s+download.docker.com+mirrors.tuna.tsinghua.edu.cn&#x2F;docker-ce+&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</code></pre></div></figure><p>最后安装:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo yum makecache fast    sudo yum install docker-ce</code></pre></div></figure><h3 id="2-无网环境下离线安装"><a href="#2-无网环境下离线安装" class="headerlink" title="2 无网环境下离线安装"></a>2 无网环境下离线安装</h3><p>搜集联网环境下下载的rpm包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">find &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7&#x2F; -name &quot;*.rpm&quot; | xargs -i mv &#123;&#125; docker_rpm&#x2F;tar -zvcf docker_rpm.tgz docker_rpm&#x2F;</code></pre></div></figure><p>拷贝到无网环境的服务器中安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -vxf docker_rpm.tgz # 解压cd docker_rpmrpm -Uvh .&#x2F;*.rpm # 安装</code></pre></div></figure><h3 id="3-启动服务并验证安装是否成功"><a href="#3-启动服务并验证安装是否成功" class="headerlink" title="3 启动服务并验证安装是否成功"></a>3 启动服务并验证安装是否成功</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动服务systemctl enable dockersystemctl start docker# 验证是否安装成功docker versiondocker info</code></pre></div></figure><h3 id="4-Docker镜像下载加速"><a href="#4-Docker镜像下载加速" class="headerlink" title="4 Docker镜像下载加速"></a>4 Docker镜像下载加速</h3><ul><li>阿里云docker镜像加速器服务</li><li>配置docker镜像加速(推荐)</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建文件vi &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123;    &quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]&#125; # 重新加载systemctl daemon-reloadsystemctl restart docker</code></pre></div></figure><h3 id="5-创建并运行一个nginx容器"><a href="#5-创建并运行一个nginx容器" class="headerlink" title="5 创建并运行一个nginx容器"></a>5 创建并运行一个nginx容器</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 80:80 nginx</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker系列(零)-Docker介绍</title>
    <link href="/2021/06/28/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E9%9B%B6-Docker%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/06/28/01_%E8%BF%90%E7%BB%B4/03-Docker/Docker%E7%B3%BB%E5%88%97-%E9%9B%B6-Docker%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、容器简介"><a href="#一、容器简介" class="headerlink" title="一、容器简介"></a>一、容器简介</h1><p>容器就是在隔离环境中运行一个进程，如果进程停止，容器就会销毁。</p><p>隔离环境拥有自己的系统文件，ip地址，主机名等。</p><h2 id="1-1-容器和虚拟化的区别"><a href="#1-1-容器和虚拟化的区别" class="headerlink" title="1.1 容器和虚拟化的区别"></a>1.1 容器和虚拟化的区别</h2><p>KVM虚拟化：</p><p>需要硬件的支持，需要模拟硬件，可以运行不同的操作系统，启动时间分钟级（有开机启动流程）</p><p>开机启动流程</p><p>bios开机硬件自检</p><p>根据bios设置的优先启动项boot</p><p>读取mbr&#x2F;gpt引导，读取mbr硬盘分区信息，内核加载路径</p><p>加载内核</p><p>启动第一个进程（C6：&#x2F;sbin&#x2F;init，C7：systemd）</p><p>系统初始化完成</p><p>运行服务</p><p>容器：</p><p>不需要硬件的支持，不需要模拟硬件，公用宿主机内核，启动时间秒级（没有开机启动流程）</p><p>容器的第一个进程直接运行服务，损耗少，启动快，性能高</p><h2 id="1-2-容器的优缺点："><a href="#1-2-容器的优缺点：" class="headerlink" title="1.2 容器的优缺点："></a>1.2 容器的优缺点：</h2><p>优点：</p><p>与宿主机使用同一个内核，性能损耗小</p><p>不需要指令级模拟</p><p>容器可以再cpu核心的本地运行指令，不需要任何专门的解释机制</p><p>避免了准虚拟化和系统调用替换中的复杂性</p><p>轻量级隔离，在隔离的同事还提供共享机制，以实现容器与宿主机的资源共享</p><p>缺点：</p><p>使用同一内核，存在安全性问题</p><h2 id="1-3-容器技术的发展过程"><a href="#1-3-容器技术的发展过程" class="headerlink" title="1.3 容器技术的发展过程"></a>1.3 容器技术的发展过程</h2><p>chroot — lxc —- docker</p><h1 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h1><p># 添加docker安装源 </p><p>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a> </p><p>查看所有仓库中docker版本，并选择特定版本安装：(此处我们查看社区版 docker-ce) yum list docker-ce –showduplicates | sort -r # 安装docker-ce yum install docker-ce -y</p><h1 id="三、Docker镜像的常用命令"><a href="#三、Docker镜像的常用命令" class="headerlink" title="三、Docker镜像的常用命令"></a>三、Docker镜像的常用命令</h1><p># 搜索镜像docker search [镜像名称]# 拉取镜像docker pull [域名镜像名称]:[版本号]例如：docker pull daocloud.io&#x2F;hzc&#x2F;alpine:3.6 # 默认拉取Lastest最新版PS: docker image pull &#x3D; docker pull# 如何查看镜像有那些版本？dockerhub网页搜索 daocloud 国内的dockhub# 镜像加速：（1）阿里云docker镜像加速器服务（2）配置docker镜像加速(推荐) vi &#x2F;etc&#x2F;docker&#x2F;daemon.json {   “registry-mirrors”:[“<a href="https://registry.docker-cn.com”]">https://registry.docker-cn.com”]</a> } systemctl daemon-reload# 上传镜像docker push [镜像名称]# 查看已有镜像docker images &#x3D; docker image ls# 导出镜像docker image save alpine:latest -o docker_alpine.tar.gz # save跟export选哪个？都是导出镜像，但是export没带版本标签，export弃用# 导入镜像docker image load -i docker_alpine.tar.gz # load跟import选哪个？都是导入镜像，load对应save，import不带版本标签，import弃用# 删除镜像docker image rm alpine:3.6# 构建镜像docker image build# 查看构建镜像用到的历史命令docker image histroy# 查看镜像的详细属性docker image inspect# 批量删除镜像docker image prune# 给镜像打标签docker image tag [镜像ID] oldboy:v1 # Docker的容器管理1、查看容器列表 docker container ls -a docker ps # 默认只查看活着的容器 docker ps -a # 查看所有容器 docker ps -a -q # 静默输出，显示所有容器的ID docker ps -a -l docker ps -a -l –no-trunc # 查看完整命令（不隐藏）# 停止容器docker container stop [容器ID] docker container kill [容器ID]# 恢复容器 docker container start 【容器ID】# 启动容器 docker run -d -p 80:80 nginx:latest run 创建并运行一个容器 -d   放在后台运行 -p 端口映射 -v 源地址(宿主机)：目标地址(容器) docker run -it –name centos6 centos:6.9 &#x2F;bin&#x2F;bash -it 分配交互式的终端 –name 制定容器的名称 &#x2F;bin&#x2F;sh 容器执行的命令，每个进程默认有初始执行命令，可以覆盖※进入容器（调试、排错）docker exec - it [容器名称&#x2F;ID] &#x2F;bin&#x2F;bash docker attach 【容器名称&#x2F;ID】 (使用同一个终端)临时退出容器：ctrl +p和ctrl + q退出# 删除容器docker container rm [容器ID] docker rm [容器ID]如何批量删除容器：docker rm <code>docker ps -a -q</code></p><p><strong>总结：</strong></p><p>docker容器内的第一个进程（初始命令）必须一直处于前台运行的状态（必须夯住），否则这个容器，就会处于退出状态。</p><p>业务在容器中运行：前台运行夯住，启动服务</p><h1 id="四、-Docker的网络访问"><a href="#四、-Docker的网络访问" class="headerlink" title="四、 Docker的网络访问"></a>四、 Docker的网络访问</h1><h2 id="4-1-容器网络访问流程"><a href="#4-1-容器网络访问流程" class="headerlink" title="4.1 容器网络访问流程"></a>4.1 容器网络访问流程</h2><p>实际上是端口映射，docker容器有自己的ip，需要靠宿主机NAT上网 </p><p> -p设置自动端口映射，在iptables中有增的Chain Docker, 也可以手动设置NAT</p><p>查看当前设置的nat：iptables -t nat -L -n</p><h2 id="4-2-容器网络访问注意事项："><a href="#4-2-容器网络访问注意事项：" class="headerlink" title="4.2 容器网络访问注意事项："></a>4.2 容器网络访问注意事项：</h2><p>sysctl -a | grep ipv4 | grep forward </p><p>查看</p><p>net.ipv4.ip_forward &#x3D; 1 # 为1时，docker容器才能上网，虚拟机挂起将使他变成0</p><p>解决方法:</p><p>1、sysctl net.ipv4.ip_forward &#x3D; 1 设置为1</p><p>2、不要挂起虚拟机，直接关机重启，docker服务在启动时会将它改为1</p><h2 id="4-3-指定映射-p-参数详解"><a href="#4-3-指定映射-p-参数详解" class="headerlink" title="4.3 指定映射(-p)参数详解"></a>4.3 指定映射(-p)参数详解</h2><p>-p hostPort:containerPort # 指定端口 -p ip:hostPort:containerPort # 指定ip+端口 -p ip::containerPort # 指定随机端口 -p 10.0.0.100:53:udp # 指定随机端口 + udp -p hostPort:containerPort -p hostPort:containerPort # 指定多个端口</p><h1 id="五、容器的数据卷挂载"><a href="#五、容器的数据卷挂载" class="headerlink" title="五、容器的数据卷挂载"></a>五、容器的数据卷挂载</h1><h2 id="5-1-临时挂载"><a href="#5-1-临时挂载" class="headerlink" title="5.1 临时挂载"></a>5.1 临时挂载</h2><p># 将&#x2F;opt&#x2F;xiaoniao目录挂载到容器的html目录 docker run -d -p 80:80 -v &#x2F;opt&#x2F;xiaoniao:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest</p><h2 id="5-2-持久化挂载"><a href="#5-2-持久化挂载" class="headerlink" title="5.2 持久化挂载"></a>5.2 持久化挂载</h2><p>容器被删除，创建的卷可以保留，可以再次挂载到新建的容器中</p><p># 创建名为oldboy的容器卷并挂载到容器html目录 docker run -d -p 80:80 -v oldboy:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest # 查看当前有哪些容器卷 docker volume ls # 查看名为oldboy的卷的信息 docker volume inspect oldboy # PS：删除容器并删除卷，无法将卷删除 docker rm -f -v [容器ID]   -v –volume</p><h1 id="六、小案例练习"><a href="#六、小案例练习" class="headerlink" title="六、小案例练习"></a>六、小案例练习</h1><p>&gt;&gt; 基于Nginx多端点的多站点 基于nginx启动一个容器，监听80和81，访问80，出现nginx默认的欢迎首页，访问81，出现小鸟页面。</p><h1 id="七、如何制作Docker镜像"><a href="#七、如何制作Docker镜像" class="headerlink" title="七、如何制作Docker镜像"></a>七、如何制作Docker镜像</h1><h2 id="7-1-启动一个基础的容器"><a href="#7-1-启动一个基础的容器" class="headerlink" title="7.1 启动一个基础的容器"></a>7.1 启动一个基础的容器</h2><p>docker run -it centos:6.9 # yum docker run -it alpine:3.9 # apk</p><h2 id="7-2-容器中安装服务"><a href="#7-2-容器中安装服务" class="headerlink" title="7.2 容器中安装服务"></a>7.2 容器中安装服务</h2><p># dns重定向 echo ‘192.168.15.84 mirrors.aliyun.com’ &gt;&gt; &#x2F;etc&#x2F;hosts # 替换源为阿里源 curl -o &#x2F;etc&#x2F;yum.repo.d&#x2F;CentOS-Base.repo <a href="https://mirrors.aliyun.com/repo/CentOS-6.repo">https://mirrors.aliyun.com/repo/CentOS-6.repo</a> # 安装并启动openssh服务 yum install openssh-server -y service opensshd restart # 修改root密码 echo ‘123456’ | passwd –stdin root 或者 echo 123456:root | chpassw</p><p>7.3 把已经安装服务的容器打包成镜像</p><p>docker contanier commit 5617e5d123432 centos6.9_ssh:v1</p><h2 id="7-4-测试镜像的功能"><a href="#7-4-测试镜像的功能" class="headerlink" title="7.4 测试镜像的功能"></a>7.4 测试镜像的功能</h2><p># 使用镜像启动一个新容器,并开启ssh服务 docker run -d -p 1022:22 centos6.9_ssh:v1 tail -f &#x2F;usr&#x2F;sbin&#x2F;sshd -D</p><h2 id="7-5-创建一个ssh-nginx双服务的镜像"><a href="#7-5-创建一个ssh-nginx双服务的镜像" class="headerlink" title="7.5 创建一个ssh + nginx双服务的镜像"></a>7.5 创建一个ssh + nginx双服务的镜像</h2><p>(1) 启动一个基础容器 docker yun -it -p 80:80 -p 1023:22 centos6.9_ssh:v1 &#x2F;bin&#x2F;bash (2) 在容器中安装服务(hosts与repo源在新容器会重新挂载) # dns重定向 echo ‘192.168.15.84 mirrors.aliyun.com’ &gt;&gt; &#x2F;etc&#x2F;hosts # 替换源为阿里源 curl -o &#x2F;etc&#x2F;yum.repo.d&#x2F;epel.repo <a href="https://mirrors.aliyun.com/repo/epel.repo">https://mirrors.aliyun.com/repo/epel.repo</a> # 安装nginx服务 yum install nginx -y (3) 把已经安装好服务的容器，提交为镜像 docker commit e6a6dsa6 centos6.9_ssh_nginx:v2 (4) 测试镜像功能 vim init.sh &gt;&gt;&gt;&gt;&gt; #!&#x2F;bin&#x2F;bash service sshd restart nginx -g ‘daemon off;’ &gt;&gt;&gt;&gt;&gt; # 启动镜像，执行脚本：开启服务，并夯住 docker run -d -p 1025:22 -p 80:80 centos6.9_ssh_nginx:v2 &#x2F;bin&#x2F;bash &#x2F;init.sh</p><h3 id="7-6-自定义容器镜像的密码"><a href="#7-6-自定义容器镜像的密码" class="headerlink" title="7.6 自定义容器镜像的密码"></a>7.6 自定义容器镜像的密码</h3><p># 修改脚本，添加密码相关的脚本行，见右图 vim init.sh # 启动容器，并附带环境变量 docker run -d -p 1025:22 -p 80:80 -e “SSH_PWD&#x3D;123456” centos6.9_ssh_nginx:v2 &#x2F;bin&#x2F;bash &#x2F;init.sh</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="7-7-作业"><a href="#7-7-作业" class="headerlink" title="7.7 作业"></a>7.7 作业</h3><p>制作基于centos6的lnmp架构的镜像，discuz论坛</p><p>怎么夯住？</p><p>启动所有需要的服务</p><p>最后tail -F (大F无论文件有没有) </p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="八、Dockfile的使用"><a href="#八、Dockfile的使用" class="headerlink" title="八、Dockfile的使用"></a>八、Dockfile的使用</h1><p>发布镜像太大了，而dockerfile只有几kb，使用dockfile文件可以构建出相同的镜像，</p><h2 id="8-1-使用dockfile自动构建镜像"><a href="#8-1-使用dockfile自动构建镜像" class="headerlink" title="8.1 使用dockfile自动构建镜像"></a>8.1 使用dockfile自动构建镜像</h2><p>自动构建镜像的步骤：</p><p>1、手动构建一遍</p><p>2、参考历史命令，编写dockerfile</p><p>3、构建镜像</p><p>dockerfile build -t centos6.9_ssh .</p><p>4、测试</p><h2 id="8-2-Dockerfile常用命令详解"><a href="#8-2-Dockerfile常用命令详解" class="headerlink" title="8.2 Dockerfile常用命令详解"></a>8.2 Dockerfile常用命令详解</h2>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（三）Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenStack学习笔记</title>
    <link href="/2021/04/12/01_%E8%BF%90%E7%BB%B4/04-%E8%99%9A%E6%8B%9F%E5%8C%96/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/04/12/01_%E8%BF%90%E7%BB%B4/04-%E8%99%9A%E6%8B%9F%E5%8C%96/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenStack笔记"><a href="#OpenStack笔记" class="headerlink" title="OpenStack笔记"></a><strong><font color=green>OpenStack笔记</font></strong></h1><p>​OpenStack实现的是云计算IAAS</p><h2 id="一、服务架构发展"><a href="#一、服务架构发展" class="headerlink" title="一、服务架构发展"></a><font color=blue>一、服务架构发展</font></h2><h3 id="1-1-MVC架构"><a href="#1-1-MVC架构" class="headerlink" title="1.1 MVC架构"></a>1.1 MVC架构</h3><p>​业务不拆分，一个服务挂，则所有的全挂</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">首页 www.jd.com&#x2F;index.html秒杀 www.jd.com&#x2F;miaosha&#x2F;index.html优惠券 www.jd.com&#x2F;juan&#x2F;index.html</code></pre></div></figure><h3 id="1-2-SOA架构（千万级）"><a href="#1-2-SOA架构（千万级）" class="headerlink" title="1.2 SOA架构（千万级）"></a>1.2 SOA架构（千万级）</h3><p>​业务拆分，每一个功能都拆分成一个独立的web服务，每个独立的web服务，都至少拥有一个集群</p><figure><div class="code-wrapper"><pre class="line-numbers language-she" data-language="she"><code class="language-she">首页 www.jd.com&#x2F;index.html秒杀 miaosha.jd.com&#x2F;index.html优惠券 juan.jd.com&#x2F;index.html</code></pre></div></figure><h3 id="1-3-微服务架构（亿级）"><a href="#1-3-微服务架构（亿级）" class="headerlink" title="1.3 微服务架构（亿级）"></a>1.3 微服务架构（亿级）</h3><p>阿里开源dubbo</p><p>Spring Boot</p><p>自动化代码上线：Jekins + gilab ci</p><p>自动化代码质量检查：sonarqube</p><h2 id="二、搭建OpenStack"><a href="#二、搭建OpenStack" class="headerlink" title="二、搭建OpenStack"></a><font color=blue>二、搭建OpenStack</font></h2><p>​本流程为手动安装M版，脚本安装可以参考</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;4367225&#x2F;blog&#x2F;4255750</code></pre></div></figure><p>OpenStack的结构介绍：</p><blockquote><p>Nova – 提供VM虚拟化支持 8774</p><p>Glance – 提供镜像 9292</p><p>Clinder – 存储支持 8776</p><p>Neutron – 网络支持 9696</p><p>Cellometer –  监控计费 </p><p>KeyStone – 登录认证</p><p>Horizon – 网页UI，dashboard</p><p>Heat – 部署编排，批量建虚拟机</p><p>Switft – 对象存储（不是传统的文件夹存放，而是用数据库记录已上传的文件信息，当有文件上传，先查询数据库中是否有该文件的md5值，如果有，则不用重新上传，给个链接就是 — 百度云盘）</p></blockquote><p><img src="/../../../img/image-20210615135957367.png" alt="image-20210615135957367"></p><h3 id="2-1-虚拟机准备"><a href="#2-1-虚拟机准备" class="headerlink" title="2.1 虚拟机准备"></a>2.1 虚拟机准备</h3><p>虚拟机规划</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 系统：CentOS7.4controller: 内存3G, CPU开启虚拟化10.0.0.11compute1: 内存1G，CPU开启虚拟化    10.0.0.31# 修改主机名，IP地址，host解析，测试ping百度</code></pre></div></figure><p>配置本地M版yum源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、资源准备mount &#x2F;dev&#x2F;cdrom &#x2F;mnt # 追加到&#x2F;etc&#x2F;rc.local,自动挂载解压openstack_rpm.tar.gz到&#x2F;opt&#x2F;repo# 2、编辑repo文件vim &#x2F;etc&#x2F;yum.repo.d&#x2F;local&#x2F;repo#### 内容[local]name&#x3D;localbaseurl&#x3D;file:&#x2F;&#x2F;&#x2F;mntgpgcheck&#x3D;0[openstack]name&#x3D;openstackbaseurl&#x3D;file:&#x2F;&#x2F;&#x2F;opt&#x2F;repogpgcheck&#x3D;0##### 3、更新yum源yum makecacheyum repolist</code></pre></div></figure><h3 id="2-2-基础服务安装"><a href="#2-2-基础服务安装" class="headerlink" title="2.2 基础服务安装"></a>2.2 基础服务安装</h3><h4 id="2-2-1-NTP时间同步"><a href="#2-2-1-NTP时间同步" class="headerlink" title="2.2.1 NTP时间同步"></a>2.2.1 NTP时间同步</h4><p>controller与阿里NTP服务器同步</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;chrony.confserver ntp6.aliyun.com # 3行allow 10.0.0.0&#x2F;24 # 24行systemctl restart chronyd</code></pre></div></figure><p>computer与controller同步</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;chrony.confserver 10.0.0.11 iburst # 3行systemctl restart chronyd</code></pre></div></figure><h4 id="2-2-2-扩展-公网安装O版OpenStack的方法介绍（跳过该步骤）"><a href="#2-2-2-扩展-公网安装O版OpenStack的方法介绍（跳过该步骤）" class="headerlink" title="2.2.2 扩展-公网安装O版OpenStack的方法介绍（跳过该步骤）"></a>2.2.2 扩展-公网安装O版OpenStack的方法介绍（跳过该步骤）</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repoyum makecacheyum list | grep openstackyum install centos-release-openstack-ocata.noarch -y # 安装O版</code></pre></div></figure><h4 id="2-2-3-安装OpenStack客户端openstack-selinux-（所有节点执行）"><a href="#2-2-3-安装OpenStack客户端openstack-selinux-（所有节点执行）" class="headerlink" title="2.2.3 安装OpenStack客户端openstack-selinux （所有节点执行）"></a>2.2.3 安装OpenStack客户端openstack-selinux （所有节点执行）</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install python-openstackclient openstack-selinux -y</code></pre></div></figure><h4 id="2-2-4-安装和配置mariadb-仅控制节点执行"><a href="#2-2-4-安装和配置mariadb-仅控制节点执行" class="headerlink" title="2.2.4 安装和配置mariadb (仅控制节点执行)"></a>2.2.4 安装和配置mariadb (仅控制节点执行)</h4><p>安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install mariadb mariadb-server python2-PyMySQL -y</code></pre></div></figure><p>配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;my.cnf.d&#x2F;openstack.cnf#----------------[mysqld]bind-address &#x3D; 10.0.0.11# 监听地址default-storage-engine &#x3D; innodb # 默认存储引擎innodb_file_per_table  # 独立表空间文件max_connections &#x3D; 4096# 最大连接数collation-server &#x3D; utf8_general_ci# 默认字符集utf8character-set-server &#x3D; utf8#-----------------# 启动服务systemctl start mariadbsystemctl enable mariadb# 数据库安全初始化,保障数据库安全性，如果不执行，同步数据库表会报错mysql_secure_installation回车 n y y y y</code></pre></div></figure><h4 id="2-2-5-消息队列配置-仅控制节点执行"><a href="#2-2-5-消息队列配置-仅控制节点执行" class="headerlink" title="2.2.5 消息队列配置(仅控制节点执行)"></a>2.2.5 消息队列配置(仅控制节点执行)</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装rabbitmqyum install rabbitmq-server -y# 启动服务systemctl start rabbitmq-serversystemctl enable rabbitmq-server# 添加用户rabbitmqctl add_user openstack RABBIT_PASS# 设置用户权限（读、写、执行）rabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;rabbitmq-plugins enable rabbitmq_management# 查看是否开启15672端口netstat -lntup# 浏览器登录rabbitmqhttp:&#x2F;&#x2F;10.0.0.11:15672默认用户名和密码：guest</code></pre></div></figure><h4 id="2-2-6-缓存系统配置memcache（仅控制节点执行）"><a href="#2-2-6-缓存系统配置memcache（仅控制节点执行）" class="headerlink" title="2.2.6 缓存系统配置memcache（仅控制节点执行）"></a>2.2.6 缓存系统配置memcache（仅控制节点执行）</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装yum install memcached python-memched -y# 配置sed -i &#39;s#127.0.0.1#10.0.0.11#g&#39; &#x2F;etc&#x2F;sysconfig&#x2F;memcached# 启动服务systemctl restart memcachedsystemctl enable memcached# 查询端口11211是否已监听，默认使用该端口</code></pre></div></figure><h3 id="2-3-安装keystone认证服务-仅控制节点执行"><a href="#2-3-安装keystone认证服务-仅控制节点执行" class="headerlink" title="2.3 安装keystone认证服务(仅控制节点执行)"></a>2.3 安装keystone认证服务(仅控制节点执行)</h3><h4 id="2-3-1-Keystone功能介绍"><a href="#2-3-1-Keystone功能介绍" class="headerlink" title="2.3.1 Keystone功能介绍"></a>2.3.1 Keystone功能介绍</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、认证管理：账户密码2、授权管理3、服务目录：跟电话本一样，keystone上可以查询到glance、nova等服务的地址端口等信息，每一个新加的服务都需要在keystone上注册</code></pre></div></figure><h4 id="2-3-2-OpenStack服务器安装的通用步骤"><a href="#2-3-2-OpenStack服务器安装的通用步骤" class="headerlink" title="2.3.2 OpenStack服务器安装的通用步骤"></a>2.3.2 OpenStack服务器安装的通用步骤</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、创库授权2、在Keystone创建用户，关联角色3、在keystone创建服务，注册api4、安装服务相关的软件包5、修改配置数据库的连接keystone认证授权信息rabbitmq连接信息其他配置6、同步数据库，创建表7、启动服务</code></pre></div></figure><h4 id="2-3-3-安装步骤"><a href="#2-3-3-安装步骤" class="headerlink" title="2.3.3 安装步骤"></a>2.3.3 安装步骤</h4><p>1、创库授权</p><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 登录mysql$ mysql -u root -p# 创建keystone数据库CREATE DATABASE keystone;# 对&#96;&#96;keystone&#96;&#96;数据库授予恰当的权限GRANT ALL PRIVILEGES ON keystone.* TO &#39;keystone&#39;@&#39;localhost&#39; \  IDENTIFIED BY &#39;KEYSTONE_DBPASS&#39;;GRANT ALL PRIVILEGES ON keystone.* TO &#39;keystone&#39;@&#39;%&#39; \  IDENTIFIED BY &#39;KEYSTONE_DBPASS&#39;;</code></pre></div></figure><p>2、安装keystone相关软件包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install openstack-keystone httpd mod_wsgi -y</code></pre></div></figure><p>3、修改配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 备份原配置文件\cp &#x2F;etc&#x2F;keystone&#x2F;keystone.conf&#123;,.bak&#125;# 去除配置文件中的空格行和注释行grep -Ev &#39;^$|#&#39; &#x2F;etc&#x2F;keystone&#x2F;keystone.conf.bak &gt; &#x2F;etc&#x2F;keystone&#x2F;keystone.conf# 安装自动配置工具yum install openstack-utils -y# 使用工具设置（也可以直接修改文件）修改项 参数 &#x3D; 值openstack-config --set &#x2F;etc&#x2F;keystone&#x2F;keystone.conf DEFAULT admin_token ADMIN_TOKENopenstack-config --set &#x2F;etc&#x2F;keystone&#x2F;keystone.conf database connection  mysql+pymysql:&#x2F;&#x2F;keystone:KEYSTONE_DBPASS@controller&#x2F;keystone # 注意hostname--controlleropenstack-config --set &#x2F;etc&#x2F;keystone&#x2F;keystone.conf token provider fernet# 校验md5sum &#x2F;etc&#x2F;keystone&#x2F;keystone.confd5acb3db852fe3f247f4f872b051b7a9 # 同步数据库su -s &#x2F;bin&#x2F;sh -c &quot;keystone-manage db_sync&quot; keystone# 查询是否生成表mysql keystone -e &quot;show tables;&quot;# 初始化fernetkeystone-manage fernet_setup --keystone-user keystone --keystone-group keystone# 验证&#x2F;etc&#x2F;keystone&#x2F;fernet-keys已创建# 配置httpdecho &quot;ServerName controller&quot; &gt;&gt; &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf# 创建wsgi配置文件vim &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;wsgi-keystone.conf###内容Listen 5000Listen 35357&lt;VirtualHost *:5000&gt;    WSGIDaemonProcess keystone-public processes&#x3D;5 threads&#x3D;1 user&#x3D;keystone group&#x3D;keystone display-name&#x3D;%&#123;GROUP&#125;    WSGIProcessGroup keystone-public    WSGIScriptAlias &#x2F; &#x2F;usr&#x2F;bin&#x2F;keystone-wsgi-public    WSGIApplicationGroup %&#123;GLOBAL&#125;    WSGIPassAuthorization On    ErrorLogFormat &quot;%&#123;cu&#125;t %M&quot;    ErrorLog &#x2F;var&#x2F;log&#x2F;httpd&#x2F;keystone-error.log    CustomLog &#x2F;var&#x2F;log&#x2F;httpd&#x2F;keystone-access.log combined    &lt;Directory &#x2F;usr&#x2F;bin&gt;        Require all granted    &lt;&#x2F;Directory&gt;&lt;&#x2F;VirtualHost&gt;&lt;VirtualHost *:35357&gt;    WSGIDaemonProcess keystone-admin processes&#x3D;5 threads&#x3D;1 user&#x3D;keystone group&#x3D;keystone display-name&#x3D;%&#123;GROUP&#125;    WSGIProcessGroup keystone-admin    WSGIScriptAlias &#x2F; &#x2F;usr&#x2F;bin&#x2F;keystone-wsgi-admin    WSGIApplicationGroup %&#123;GLOBAL&#125;    WSGIPassAuthorization On    ErrorLogFormat &quot;%&#123;cu&#125;t %M&quot;    ErrorLog &#x2F;var&#x2F;log&#x2F;httpd&#x2F;keystone-error.log    CustomLog &#x2F;var&#x2F;log&#x2F;httpd&#x2F;keystone-access.log combined    &lt;Directory &#x2F;usr&#x2F;bin&gt;        Require all granted    &lt;&#x2F;Directory&gt;&lt;&#x2F;VirtualHost&gt;# 校验md5sum &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;wsgi-keystone.conf8f051eb53577f67356ed03e4550315c2 # 启动httpdsystemctl enable httpdsystemctl start httpd# 创建服务和注册apiexport OS_TOKEN&#x3D;ADMIN_TOKENexport OS_URL&#x3D;http:&#x2F;&#x2F;controller:35357&#x2F;v3export OS_IDENTITY_API_VERSION&#x3D;3openstack service create --name keystone --description &quot;OpenStack Identity&quot; identityopenstack endpoint create --region RegionOne identity public http:&#x2F;&#x2F;controller:5000&#x2F;v3openstack endpoint create --region RegionOne identity internal http:&#x2F;&#x2F;controller:5000&#x2F;v3openstack endpoint create --region RegionOne identity admin http:&#x2F;&#x2F;controller:35357&#x2F;v3# 创建域、项目（租户）、用户和角色openstack domain create --description &quot;Default Domain&quot; defaultopenstack project create --domain default --description &quot;Admin Project&quot; adminopenstack user create --domain default --password ADMIN_PASS adminopenstack role create admin# 关联项目，用户，角色openstack role add --project admin --user admin admin# 在admin项目上，给admin用户赋予admin角色openstack project create --domain default --description &quot;Service Project&quot; service# 创建环境变量脚本export OS_PROJECT_DOMAIN_NAME&#x3D;defaultexport OS_USER_DOMAIN_NAME&#x3D;defaultexport OS_PROJECT_NAME&#x3D;adminexport OS_USERNAME&#x3D;adminexport OS_PASSWORD&#x3D;ADMIN_PASSexport OS_IMAGE_API_VERSION&#x3D;2export OS_IDENTITY_API_VERSION&#x3D;3export OS_AUTH_URL&#x3D;http:&#x2F;&#x2F;controller:35357&#x2F;v3# 作为admin用户请求认证令牌openstack token issue  # 如果不设置环境变量可以通过传入参数的方式申请openstack --os-auth-url http:&#x2F;&#x2F;controller:35357&#x2F;v3   --os-project-domain-name default --os-user-domain-name default   --os-project-name admin --os-username admin --os-password ADMIN_PASS token issue# 查看用户列表openstack user list# 查看endpoint列表openstack endpoint list</code></pre></div></figure><h3 id="2-4-安装glance镜像服务"><a href="#2-4-安装glance镜像服务" class="headerlink" title="2.4 安装glance镜像服务"></a>2.4 安装glance镜像服务</h3><p>​镜像服务 (glance) 允许用户发现、注册和获取虚拟机镜像。</p><h4 id="2-4-1-安装步骤"><a href="#2-4-1-安装步骤" class="headerlink" title="2.4.1 安装步骤"></a>2.4.1 安装步骤</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 数据库创库授权mysql &gt;&gt;CREATE DATABASE glanceGRANT ALL PRIVILEGES ON glance.* TO &#39;glance&#39;@&#39;localhost&#39; \  IDENTIFIED BY &#39;GLANCE_DBPASS&#39;;GRANT ALL PRIVILEGES ON glance.* TO &#39;glance&#39;@&#39;%&#39; \  IDENTIFIED BY &#39;GLANCE_DBPASS&#39;;   # 在keystone创建glance用户关联角色 openstack user create --domain default --password GLANCE_PASS glance openstack role add --project service --user glance admin  # 在keystone上创建服务和注册apiopenstack service create --name glance   --description &quot;OpenStack Image&quot; imageopenstack endpoint create --region RegionOne \  image public http:&#x2F;&#x2F;controller:9292openstack endpoint create --region RegionOne \  image internal http:&#x2F;&#x2F;controller:9292openstack endpoint create --region RegionOne \  image admin http:&#x2F;&#x2F;controller:9292  # 查看已创建的信息openstack role assignment listopenstack role listopenstack project listopenstack user list （要有glance用户）# mysql中验证表是否已创建[root@controller ~]# mysql keystone -e &quot;show tables;&quot; | grep userfederated_userlocal_useruseruser_group_membership[root@controller ~]# mysql keystone -e &quot;show tables;&quot; | grep projectprojectproject_endpointproject_endpoint_group# 安装服务相应软件包yum install openstack-glance -y# 修改相应的配置文件--apicp &#x2F;etc&#x2F;glance&#x2F;glance-api.conf&#123;,.bak&#125;grep &#39;^[a-Z\[]&#39; &#x2F;etc&#x2F;glance&#x2F;glance-api.conf.bak &gt; &#x2F;etc&#x2F;glance&#x2F;glance-api.confopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf database connection mysql+pymysql:&#x2F;&#x2F;glance:GLANCE_DBPASS@controller&#x2F;glanceopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken auth_uri http:&#x2F;&#x2F;controller:5000openstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken memcached_servers controller:11211openstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken auth_type passwordopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken project_name serviceopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken username glanceopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf keystone_authtoken password GLANCE_PASSopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf paste_deploy flavor keystoneopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf glance_store stores file,httpopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf glance_store default_store fileopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-api.conf glance_store filesystem_store_datadir &#x2F;var&#x2F;lib&#x2F;glance&#x2F;images&#x2F;# 修改相应的配置文件--registrycp &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf&#123;,.bak&#125;grep &#39;^[a-Z\[]&#39; &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf.bak &gt; &#x2F;etc&#x2F;glance&#x2F;glance-registry.confopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf database connection mysql+pymysql:&#x2F;&#x2F;glance:GLANCE_DBPASS@controller&#x2F;glanceopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken auth_uri http:&#x2F;&#x2F;controller:5000openstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken memcached_servers controller:11211openstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken auth_type passwordopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken project_name serviceopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken username glanceopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf keystone_authtoken password GLANCE_PASSopenstack-config --set &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf paste_deploy flavor keystone# md5值验证md5sum &#x2F;etc&#x2F;glance&#x2F;glance-api.conf3e1a4234c133eda11b413788e001cba3  &#x2F;etc&#x2F;glance&#x2F;glance-api.confmd5sum &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf46acabd81a65b924256f56fe34d90b8f  &#x2F;etc&#x2F;glance&#x2F;glance-registry.conf# 写入镜像服务数据库su -s &#x2F;bin&#x2F;sh -c &quot;glance-manage db_sync&quot; glance # 会有Warning不用在意# 验证mysql glance -e &quot;show tables;&quot;# 启动服务systemctl enable openstack-glance-api.service   openstack-glance-registry.servicesystemctl start openstack-glance-api.service   openstack-glance-registry.service</code></pre></div></figure><h4 id="2-4-2-上传镜像测试"><a href="#2-4-2-上传镜像测试" class="headerlink" title="2.4.2 上传镜像测试"></a>2.4.2 上传镜像测试</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 错误日志查看&#x2F;var&#x2F;log&#x2F;glance# 确保已获取token令牌openstack token issue# 下载测试镜像wget http:&#x2F;&#x2F;download.cirros-cloud.net&#x2F;0.3.4&#x2F;cirros-0.3.4-x86_64-disk.img# 上传测试镜像openstack image create &quot;cirros&quot; \--file cirros-0.3.4-x86_64-disk.img \--disk-format qcow2 --container-format bare \--public# 上传文件确认ls &#x2F;var&#x2F;lib&#x2F;glance&#x2F;images&#x2F; (在&#x2F;etc&#x2F;glance&#x2F;glance-api.conf中设置)mysql glance -e &quot;show tables;&quot; | grep image</code></pre></div></figure><h3 id="2-5-安装nova计算服务"><a href="#2-5-安装nova计算服务" class="headerlink" title="2.5 安装nova计算服务"></a>2.5 安装nova计算服务</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nova-api -- 接受并相应所有的计算服务请求，管理云主机生命周期nova-compute（多个）-- 真正管理虚拟机(nova-compute调用libvirt)nova-scheduler -- nova 调度器（挑选最合适的nova-compute）nova-conductor -- 帮助nova-compute连接数据库nova-network --  早期版本管理虚拟机的网络（已弃用，改用neutron，留着为了方便兼容早期版本）nova-consoleauth和nova-novncproxy -- web版的vnc来直接操作云主机novnproxy -- web版vnc客户端nova-api-metadata -- 接受来自虚拟机发送的元数据请求（配合neutron-metadata-agent实现虚拟机定制化）</code></pre></div></figure><h4 id="2-5-1-控制节点–安装步骤"><a href="#2-5-1-控制节点–安装步骤" class="headerlink" title="2.5.1 控制节点–安装步骤"></a>2.5.1 控制节点–安装步骤</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创库授权mysql &gt;&gt;CREATE DATABASE nova_api;CREATE DATABASE nova;GRANT ALL PRIVILEGES ON nova_api.* TO &#39;nova&#39;@&#39;localhost&#39; \  IDENTIFIED BY &#39;NOVA_DBPASS&#39;;GRANT ALL PRIVILEGES ON nova_api.* TO &#39;nova&#39;@&#39;%&#39; \  IDENTIFIED BY &#39;NOVA_DBPASS&#39;;GRANT ALL PRIVILEGES ON nova.* TO &#39;nova&#39;@&#39;localhost&#39; \  IDENTIFIED BY &#39;NOVA_DBPASS&#39;;GRANT ALL PRIVILEGES ON nova.* TO &#39;nova&#39;@&#39;%&#39; \  IDENTIFIED BY &#39;NOVA_DBPASS&#39;;  # 在keystone创建用户novaopenstack user create --domain default   --password NOVA_PASS nova# 给Nova用户添加admin角色openstack role add --project service --user nova admin# 在keystone上创建服务和注册apiopenstack service create --name nova   --description &quot;OpenStack Compute&quot; computeopenstack endpoint create --region RegionOne   compute public http:&#x2F;&#x2F;controller:8774&#x2F;v2.1&#x2F;%\(tenant_id\)sopenstack endpoint create --region RegionOne   compute internal http:&#x2F;&#x2F;controller:8774&#x2F;v2.1&#x2F;%\(tenant_id\)sopenstack endpoint create --region RegionOne   compute admin http:&#x2F;&#x2F;controller:8774&#x2F;v2.1&#x2F;%\(tenant_id\)s# 安装相应软件包yum install -y openstack-nova-api openstack-nova-conductor \  openstack-nova-console openstack-nova-novncproxy \  openstack-nova-scheduler  # 修改配置文件cp &#x2F;etc&#x2F;nova&#x2F;nova.conf&#123;,.bak&#125;grep -Ev &#39;^$|#&#39; &#x2F;etc&#x2F;nova&#x2F;nova.conf.bak &gt; &#x2F;etc&#x2F;nova&#x2F;nova.confopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT enabled_apis osapi_compute,metadataopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT rpc_backend rabbitopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT auth_strategy keystoneopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT my_ip 10.0.0.11openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT use_neutron Trueopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT firewall_driver nova.virt.firewall.NoopFirewallDriveropenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf api_database connection mysql+pymysql:&#x2F;&#x2F;nova:NOVA_DBPASS@controller&#x2F;nova_apiopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf database connection mysql+pymysql:&#x2F;&#x2F;nova:NOVA_DBPASS@controller&#x2F;novaopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf glance api_servers http:&#x2F;&#x2F;controller:9292openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken auth_uri http:&#x2F;&#x2F;controller:5000openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken memcached_servers controller:11211openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken auth_type passwordopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken project_name serviceopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken username novaopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken password NOVA_PASSopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_concurrency lock_path &#x2F;var&#x2F;lib&#x2F;nova&#x2F;tmpopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_messaging_rabbit rabbit_host controlleropenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_messaging_rabbit rabbit_userid openstackopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_messaging_rabbit rabbit_password RABBIT_PASSopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf vnc vncserver_listen &#39;$my_ip&#39;openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf vnc vncserver_proxyclient_address &#39;$my_ip&#39;# 校验md5sum &#x2F;etc&#x2F;nova&#x2F;nova.conf47ded61fdd1a79ab91bdb37ce59ef192  &#x2F;etc&#x2F;nova&#x2F;nova.conf# 同步数据库su -s &#x2F;bin&#x2F;sh -c &quot;nova-manage api_db sync&quot; novasu -s &#x2F;bin&#x2F;sh -c &quot;nova-manage db sync&quot; nova# 验证mysql nova_api -e &quot;show tables;&quot;mysql nova -e &quot;show tables;&quot;# 启动服务systemctl enable openstack-nova-api.service \openstack-nova-consoleauth.service openstack-nova-scheduler.service \openstack-nova-conductor.service openstack-nova-novncproxy.servicesystemctl restart openstack-nova-api.service \openstack-nova-consoleauth.service openstack-nova-scheduler.service \openstack-nova-conductor.service openstack-nova-novncproxy.service# 验证[root@controller ~]# nova service-list+----+------------------+------------+----------+---------+-------+------------+-----------------+| Id | Binary           | Host       | Zone     | Status  | State | Updated_at | Disabled Reason |+----+------------------+------------+----------+---------+-------+------------+-----------------+| 1  | nova-conductor   | controller | internal | enabled | down  | -          | -               || 4  | nova-scheduler   | controller | internal | enabled | down  | -          | -               || 5  | nova-consoleauth | controller | internal | enabled | down  | -          | -               |+----+------------------+------------+----------+---------+-------+------------+-----------------+# novncproxy 怎么检测起来没有？[root@controller ~]# netstat -lntup | grep 6080tcp        0      0 0.0.0.0:6080            0.0.0.0:*               LISTEN      8719&#x2F;python2[root@controller ~]# ps -ef | grep 8719nova       8719      1  0 21:53 ?        00:00:01 &#x2F;usr&#x2F;bin&#x2F;python2 &#x2F;usr&#x2F;bin&#x2F;nova-novncproxy --web &#x2F;usr&#x2F;share&#x2F;novnc&#x2F;</code></pre></div></figure><h4 id="2-5-1-计算节点–安装步骤"><a href="#2-5-1-计算节点–安装步骤" class="headerlink" title="2.5.1 计算节点–安装步骤"></a>2.5.1 计算节点–安装步骤</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装软件包yum install -y openstack-nova-compute openstack-utils# 修改配置文件cp &#x2F;etc&#x2F;nova&#x2F;nova.conf&#123;,.bak&#125;grep -Ev &#39;^$|#&#39; &#x2F;etc&#x2F;nova&#x2F;nova.conf.bak &gt; &#x2F;etc&#x2F;nova&#x2F;nova.confopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT enabled_apis osapi_compute,metadataopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT rpc_backend rabbitopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT auth_strategy keystoneopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT my_ip 10.0.0.31 # 注意ipopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT use_neutron Trueopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf DEFAULT firewall_driver nova.virt.firewall.NoopFirewallDriveropenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf glance api_servers http:&#x2F;&#x2F;controller:9292openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken auth_uri http:&#x2F;&#x2F;controller:5000openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken memcached_servers controller:11211openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken auth_type passwordopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken project_name serviceopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken username novaopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf keystone_authtoken password NOVA_PASSopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_concurrency lock_path &#x2F;var&#x2F;lib&#x2F;nova&#x2F;tmpopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_messaging_rabbit rabbit_host controlleropenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_messaging_rabbit rabbit_userid openstackopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf oslo_messaging_rabbit rabbit_password RABBIT_PASSopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf vnc enabled  Trueopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf vnc vncserver_listen 0.0.0.0openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf vnc vncserver_proxyclient_address &#39;$my_ip&#39;openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf vnc novncproxy_base_url http:&#x2F;&#x2F;controller:6080&#x2F;vnc_auto.html# 校验md5sum &#x2F;etc&#x2F;nova&#x2F;nova.conf45cab6030a9ab82761e9f697d6d79e14  &#x2F;etc&#x2F;nova&#x2F;nova.conf# 启动服务systemctl enable libvirtd.service openstack-nova-compute.servicesystemctl restart libvirtd.service openstack-nova-compute.service# 服务启动错误排查参考博客：https:&#x2F;&#x2F;www.codeleading.com&#x2F;article&#x2F;89785382846&#x2F;cat &#x2F;etc&#x2F;nova&#x2F;nova.conf # compute1日志查看报错 nova AccessRefused: (0, 0): (403) ACCESS_REFUSED处理步骤：在controllercat &#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;rabbit@controller.log # 发现报错AMQPLAIN login refused: user &#39;openstack&#39; - invalid credentials 无效凭证rabbitmqctl list_users # 确认是否还有openstack用户rabbitmqctl add_user openstack RABBIT_PASSrabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;systemctl restart rabbitmq-server.service # 重新创用户，并重启服务</code></pre></div></figure><h3 id="2-6-安装neutron网络服务"><a href="#2-6-安装neutron网络服务" class="headerlink" title="2.6 安装neutron网络服务"></a>2.6 安装neutron网络服务</h3><p>neutron-server – 端口9696，api接受和响应外部的网络管理请求</p><p>neutron-linuxbridge-agent –  负责创建桥接网卡</p><p>neutron-dhcp-agent – 负责分配ip</p><p>neutron-metadata-agent –  配合nova-metadata-api实现虚拟机的定制化操作</p><p>L3-agent – 实现三层网络vxlan（网络层）</p><h4 id="2-6-1-控制节点–安装步骤"><a href="#2-6-1-控制节点–安装步骤" class="headerlink" title="2.6.1 控制节点–安装步骤"></a>2.6.1 控制节点–安装步骤</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创库授权Mysql &gt;&gt;CREATE DATABASE neutron;GRANT ALL PRIVILEGES ON neutron.* TO &#39;neutron&#39;@&#39;localhost&#39; \  IDENTIFIED BY &#39;NEUTRON_DBPASS&#39;;GRANT ALL PRIVILEGES ON neutron.* TO &#39;neutron&#39;@&#39;%&#39; \  IDENTIFIED BY &#39;NEUTRON_DBPASS&#39;;  # 在keystone创建用户neutronopenstack user create --domain default   --password NEUTRON_PASS neutron# 给neutron用户添加admin角色openstack role add --project service --user neutron admin# 在keystone上创建服务和注册apiopenstack service create --name neutron   --description &quot;OpenStack Networking&quot; networkopenstack endpoint create --region RegionOne   network public http:&#x2F;&#x2F;controller:9696openstack endpoint create --region RegionOne   network internal http:&#x2F;&#x2F;controller:9696openstack endpoint create --region RegionOne   network admin http:&#x2F;&#x2F;controller:9696# 网络配置--公共网络cp &#x2F;etc&#x2F;neutron&#x2F;neutron.conf&#123;,.bak&#125;grep -Ev &quot;^$|#&quot; &#x2F;etc&#x2F;neutron&#x2F;neutron.conf.bak  &gt; &#x2F;etc&#x2F;neutron&#x2F;neutron.conf&gt;&gt;&gt;&gt;&gt;openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf database connection mysql+pymysql:&#x2F;&#x2F;neutron:NEUTRON_DBPASS@controller&#x2F;neutronopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT core_plugin ml2openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT service_pluginsopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT rpc_backend rabbitopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT auth_strategy keystoneopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT notify_nova_on_port_status_changes Trueopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT notify_nova_on_port_data_changes Trueopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_messaging_rabbit rabbit_host controlleropenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_messaging_rabbit rabbit_userid openstackopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_messaging_rabbit rabbit_password RABBIT_PASSopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken auth_uri http:&#x2F;&#x2F;controller:5000openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken memcached_servers controller:11211openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken auth_type passwordopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken project_name serviceopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken username neutronopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken password NEUTRON_PASSopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova auth_type passwordopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova region_name RegionOneopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova project_name serviceopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova username novaopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf nova password NOVA_PASSopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_concurrency lock_path &#x2F;var&#x2F;lib&#x2F;neutron&#x2F;tmp&gt;&gt;&gt;&gt;&gt;cp &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini&#123;,.bak&#125;grep -Ev &quot;^$|#&quot; &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini.bak &gt; &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini&gt;&gt;&gt;&gt;&gt;openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini ml2 type_drivers flat,vlanopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini ml2 tenant_network_typesopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini ml2 mechanism_drivers linuxbridgeopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini ml2 extension_drivers port_securityopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini ml2_type_flat flat_networks provideropenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini securitygroup enable_ipset True&gt;&gt;&gt;&gt;&gt;cp &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini&#123;,.bak&#125;grep -Ev &quot;^$|#&quot; &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini.bak &gt; &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini&gt;&gt;&gt;&gt;&gt;openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini linux_bridge physical_interface_mappings provider:ens33  # 要修改网络接口名openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini vxlan enable_vxlan Falseopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini securitygroup enable_security_group Trueopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini securitygroup firewall_driver neutron.agent.linux.iptables_firewall.IptablesFirewallDriver&gt;&gt;&gt;&gt;&gt;cp &#x2F;etc&#x2F;neutron&#x2F;dhcp_agent.ini&#123;,.bak&#125;grep -Ev &quot;^$|#&quot; &#x2F;etc&#x2F;neutron&#x2F;dhcp_agent.ini.bak &gt; &#x2F;etc&#x2F;neutron&#x2F;dhcp_agent.ini&gt;&gt;&gt;&gt;&gt;openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;dhcp_agent.ini DEFAULT interface_driver neutron.agent.linux.interface.BridgeInterfaceDriveropenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;dhcp_agent.ini DEFAULT  dhcp_driver neutron.agent.linux.dhcp.Dnsmasqopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;dhcp_agent.ini DEFAULT  enable_isolated_metadata True&gt;&gt;&gt;&gt;&gt;cp &#x2F;etc&#x2F;neutron&#x2F;metadata_agent.ini&#123;,.bak&#125;grep -Ev &quot;^$|#&quot; &#x2F;etc&#x2F;neutron&#x2F;metadata_agent.ini.bak &gt; &#x2F;etc&#x2F;neutron&#x2F;metadata_agent.ini&gt;&gt;&gt;&gt;&gt;openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;metadata_agent.ini DEFAULT nova_metadata_ip controlleropenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;metadata_agent.ini DEFAULT metadata_proxy_shared_secret METADATA_SECRET&gt;&gt;&gt;&gt;&gt;# 再次修改nova配置文件，添加neutron服务openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron url http:&#x2F;&#x2F;controller:9696openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron auth_type passwordopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron region_name RegionOneopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron project_name serviceopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron username neutronopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron password NEUTRON_PASSopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron service_metadata_proxy Trueopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron metadata_proxy_shared_secret METADATA_SECRET# 校验文件[root@controller ~]# md5sum &#x2F;etc&#x2F;nova&#x2F;nova.conf6334f359655efdbcf083b812ab94efc1  &#x2F;etc&#x2F;nova&#x2F;nova.conf# 网络服务初始化脚本需要一个超链接ln -s &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini &#x2F;etc&#x2F;neutron&#x2F;plugin.ini# 同步数据库su -s &#x2F;bin&#x2F;sh -c &quot;neutron-db-manage --config-file &#x2F;etc&#x2F;neutron&#x2F;neutron.conf \  --config-file &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;ml2_conf.ini upgrade head&quot; neutron  # 检查数据库mysql neutron -e &quot;show tables;&quot;# 重启Nova服务systemctl restart openstack-nova-api.service# 启动Neutron服务systemctl enable neutron-server.service   neutron-linuxbridge-agent.service neutron-dhcp-agent.service   neutron-metadata-agent.servicesystemctl start neutron-server.service   neutron-linuxbridge-agent.service neutron-dhcp-agent.service   neutron-metadata-agent.service# 查看服务有没有起来neutron agent-list+--------------------------------------+--------------------+------------+-------------------+-------+----------------+---------------------------+| id                                   | agent_type         | host       | availability_zone | alive | admin_state_up | binary                    |+--------------------------------------+--------------------+------------+-------------------+-------+----------------+---------------------------+| 0d68dc27-f2b8-4cae-9c30-cddd126076b4 | Linux bridge agent | controller |                   | :-)   | True           | neutron-linuxbridge-agent || 688cc47d-424d-4243-ae2b-b1c4b298a2a8 | Metadata agent     | controller |                   | :-)   | True           | neutron-metadata-agent    || c4c5e360-ee02-4b9b-a1a5-59a0d0d088b0 | DHCP agent         | controller | nova              | :-)   | True           | neutron-dhcp-agent        |+--------------------------------------+--------------------+------------+-------------------+-------+----------------+---------------------------+</code></pre></div></figure><h4 id="2-6-2-计算节点–安装步骤"><a href="#2-6-2-计算节点–安装步骤" class="headerlink" title="2.6.2 计算节点–安装步骤"></a>2.6.2 计算节点–安装步骤</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装组件yum install -y openstack-neutron-linuxbridge ebtables ipset# 网络配置--公共网络cp &#x2F;etc&#x2F;neutron&#x2F;neutron.conf&#123;,.bak&#125;grep -Ev &quot;^$|#&quot; &#x2F;etc&#x2F;neutron&#x2F;neutron.conf.bak  &gt; &#x2F;etc&#x2F;neutron&#x2F;neutron.conf&gt;&gt;&gt;&gt;&gt;&gt;openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT rpc_backend rabbitopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf DEFAULT auth_strategy keystoneopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_messaging_rabbit rabbit_host controlleropenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_messaging_rabbit rabbit_userid openstackopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_messaging_rabbit rabbit_password RABBIT_PASSopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken auth_uri http:&#x2F;&#x2F;controller:5000openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken memcached_servers controller:11211openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken auth_type passwordopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken project_name serviceopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken username neutronopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf keystone_authtoken password NEUTRON_PASSopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;neutron.conf oslo_concurrency lock_path &#x2F;var&#x2F;lib&#x2F;neutron&#x2F;tmp&gt;&gt;&gt;&gt;&gt;&gt;# md5校验md5sum &#x2F;etc&#x2F;nova&#x2F;nova.conf328cd5f0745e26a420e828b0dfc2934e  &#x2F;etc&#x2F;nova&#x2F;nova.confcp &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini&#123;,.bak&#125;grep -Ev &quot;^$|#&quot; &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini.bak &gt; &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini&gt;&gt;&gt;&gt;&gt;&gt;openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini linux_bridge physical_interface_mappings provider:ens33  # 要修改网络接口名openstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini vxlan enable_vxlan Falseopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini securitygroup enable_security_group Trueopenstack-config --set &#x2F;etc&#x2F;neutron&#x2F;plugins&#x2F;ml2&#x2F;linuxbridge_agent.ini securitygroup firewall_driver neutron.agent.linux.iptables_firewall.IptablesFirewallDriver&gt;&gt;&gt;&gt;&gt;&gt;# 再次修改nova配置文件，添加neutron配置openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron url http:&#x2F;&#x2F;controller:9696openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron auth_url http:&#x2F;&#x2F;controller:35357openstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron auth_type passwordopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron project_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron user_domain_name defaultopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron region_name RegionOneopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron project_name serviceopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron username neutronopenstack-config --set &#x2F;etc&#x2F;nova&#x2F;nova.conf neutron password NEUTRON_PASS# 重启nova服务systemctl restart openstack-nova-compute.service# 启动linuxbridge代理服务systemctl enable neutron-linuxbridge-agent.servicesystemctl restart neutron-linuxbridge-agent.service# 查看是否配置成功controller执行 &gt;&gt; neutron agent-list配置正确会多出来一个Linux bridge agent | compute1   |                   | :-)   | True # 查看计算资源openstack compute service list</code></pre></div></figure><h3 id="2-7-安装horizon-（Dashboard）web界面"><a href="#2-7-安装horizon-（Dashboard）web界面" class="headerlink" title="2.7 安装horizon （Dashboard）web界面"></a>2.7 安装horizon （Dashboard）web界面</h3><h4 id="2-7-1-安装步骤（控制节点"><a href="#2-7-1-安装步骤（控制节点" class="headerlink" title="2.7.1 安装步骤（控制节点)"></a>2.7.1 安装步骤（控制节点)</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装组件包yum install -y openstack-dashboard# 修改配置文件vim &#x2F;etc&#x2F;openstack-dashboard&#x2F;local_settings&gt;&gt;&gt;&gt;OPENSTACK_HOST &#x3D; &quot;controller&quot;ALLOWED_HOSTS &#x3D; [&#39;*&#39;, ]SESSION_ENGINE &#x3D; &#39;django.contrib.sessions.backends.cache&#39;CACHES &#x3D; &#123;    &#39;default&#39;: &#123;         &#39;BACKEND&#39;: &#39;django.core.cache.backends.memcached.MemcachedCache&#39;,         &#39;LOCATION&#39;: &#39;controller:11211&#39;,    &#125;&#125;OPENSTACK_KEYSTONE_URL &#x3D; &quot;http:&#x2F;&#x2F;%s:5000&#x2F;v3&quot; % OPENSTACK_HOSTOPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT &#x3D; TrueOPENSTACK_API_VERSIONS &#x3D; &#123;    &quot;identity&quot;: 3,    &quot;image&quot;: 2,    &quot;volume&quot;: 2,&#125;OPENSTACK_KEYSTONE_DEFAULT_DOMAIN &#x3D; &quot;default&quot;OPENSTACK_KEYSTONE_DEFAULT_ROLE &#x3D; &quot;user&quot;OPENSTACK_NEUTRON_NETWORK &#x3D; &#123;    ...    &#39;enable_router&#39;: False,    &#39;enable_quotas&#39;: False,    &#39;enable_distributed_router&#39;: False,    &#39;enable_ha_router&#39;: False,    &#39;enable_lb&#39;: False,    &#39;enable_firewall&#39;: False,    &#39;enable_vpn&#39;: False,    &#39;enable_fip_topology_check&#39;: False,&#125;TIME_ZONE &#x3D; &quot;Asia&#x2F;Shanghai&quot;&gt;&gt;&gt;&gt;# 解决不能进入页面的BUGvim &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;openstack-dashboard.conf添加一行 &gt;&gt; WSGIAppicationGroup %&#123;GLOBAL&#125;# 重启服务systemctl restart httpd.service memcached.service# 登录界面https:&#x2F;&#x2F;10.0.0.11&#x2F;dashboard域:default用户名:admin密码:ADMIN_PASS# 扩展：查看文件输入那个rpm包rpm -qf &#x2F;etc&#x2F;openstack-dashboard&#x2F;local_settings</code></pre></div></figure><h4 id="2-7-2-Dashboard报错解决"><a href="#2-7-2-Dashboard报错解决" class="headerlink" title="2.7.2 Dashboard报错解决"></a>2.7.2 Dashboard报错解决</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 问题1--Invalid service catalog service: image发生原因：openstack service list 存在两个 glance解决方法：    openstack service delete c12c125edc2041e3aaf2f250442162c6    openstack service delete 6a11431b95bc44d1bd1e9371c0faa16b # 两个glance都删掉    重复2.4.1在keystone上创建glance服务和注册api    再重启服务systemctl restart httpd.service memcached.service</code></pre></div></figure><h3 id="2-8-启动一个云主机"><a href="#2-8-启动一个云主机" class="headerlink" title="2.8 启动一个云主机"></a>2.8 启动一个云主机</h3><h3 id="2-8-1-创建步骤"><a href="#2-8-1-创建步骤" class="headerlink" title="2.8.1 创建步骤"></a>2.8.1 创建步骤</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建网络neutron net-create --shared --provider:physical_network provider \  --provider:network_type flat gs  # 在网络中创建一个子网neutron subnet-create --name gs2 \  --allocation-pool start&#x3D;10.0.0.101,end&#x3D;10.0.0.250 \  --dns-nameserver 223.5.5.5 --gateway 10.0.0.2 \  gs 10.0.0.0&#x2F;24  # 创建云主机硬件配置方案（规格）openstack flavor create --id 0 --vcpus 1 --ram 64 --disk 1 m1.nano# 创建密钥键值对ssh-keygen -q -N &quot;&quot; -f ~&#x2F;.ssh&#x2F;id_rsaopenstack keypair create --public-key ~&#x2F;.ssh&#x2F;id_rsa.pub mykey# 验证公钥的添加openstack keypair list# 添加安全组规则openstack security group rule create --proto icmp defaultopenstack security group rule create --proto tcp --dst-port 22 default# 在公有网络启动一个实例openstack flavor list # 查看可用的配置规格openstack image list # 查看可用镜像openstack network list # 查看可用网络openstack security group list # 查看已设置的安全组openstack server create --flavor 规格名&#x2F;ID --image 镜像名&#x2F;ID \  --nic net-id&#x3D;网络ID --security-group default \  --key-name mykey 实例名称示例：openstack server create --flavor m1.tiny --image cirros \--nic net-id&#x3D;cb032582-893b-414d-b78d-c89c6548612d --security-group default \--key-name mykey my-instance</code></pre></div></figure><h3 id="2-8-2-创建云主机问题解决"><a href="#2-8-2-创建云主机问题解决" class="headerlink" title="2.8.2 创建云主机问题解决"></a>2.8.2 创建云主机问题解决</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、启动云主机时，No valid host was found【计算节点中】查看云主机创建日志：&#x2F;var&#x2F;log&#x2F;nova&#x2F;nova-compute.log，里面有记录问题原因是CPU feature spec-ctrl not found修改&#x2F;usr&#x2F;share&#x2F;libvirt&#x2F;cpu_map.xml，将和spec-ctrl相关的特性删除然后重启服务systemctl restart libvirtd openstack-nova-compute参考博客：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;laolieren&#x2F;p&#x2F;solve_openstack_create_instance_error.html# 2、云主机控制台seabios -- Booting from Hard Disk错误【计算节点中】vim &#x2F;etc&#x2F;nova&#x2F;nova.conf&gt;&gt;&gt;&gt;[libvirt]virt_type &#x3D; qemucpu_mode &#x3D; none&gt;&gt;&gt;&gt;systemctl restart libvirtd openstack-nova-compute重启云主机</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>（四）虚拟化之OpenStack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
